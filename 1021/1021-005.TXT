@CAT,P    1021-005-006.,///10000
@ASG,T    TEMP.,///10000
@ELT,OI TEMP.1021-005-006,,,130163053241,000
)@@G@@**PF**@@@[,:@@@@@@@@@@@[@ 2@@@]FE /^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AB
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@AC
)@@G@@@@@@@@@@G@@@@@@@@[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@@@@@@@@@@@B@@@AD
)@@G@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@AE
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@AF
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@@@@@@@@#@@O@@@@@@@@@@@@@@@AG
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@AI
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@@@@@@@@N@@@@@@@@@@@@@@@AJ
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL
)@@G@@@@@@@@@@@@@@@@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@@@@@@@@@@@F@@@AM
)@@G@@@@@@@@@@@@@@@@@@@R@@@@@@@@@@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@RAN
)@@G@@ERSD        @@@@@@@@[@@@            @ @[@]@@@@@N@@@@W@CNT OFERAT        AO
)@@G@@@@@@@@@K[@@@            @ @#@^@@@@[V@@@@WNCPI OFCGOS        @@@@@@@@[@@@AP
)@@G@@            @ @=@ @@@@]3@@@@X,FW@ UFCGIG        @@@@@@@@[@@@            AQ
)@@G@@@ @.@ @@@@^;@@@@)-C:$A#FERRS        @@@@@C@K[@@@            @ @@@[@@@@@XAR
)@@G@@@@@@>WD<IBEFATTR        @@@@@@@@[@@@            @ @E@ @@@@BS@@@@>9N[NFPFAS
)@@G@@CGSB        @@@@@@@@[@@@            @ @Z@ @@@@^_@@@@!LGY+GLFCGRS        AT
)@@G@@@@@@@@@@[@@@            @ @P@ @@@@[L@@@@2KO6.[GGCGAB        @@@@@L@@[@@@AU
)@@G@@            @ @I@ @@@@  @@@@3-J@5[KGERSY        @@@@@@@K[@@@            AV
)@@G@@@ @G@ @@@@[)@@@@8&J$3[NGCASES       @@@@@@@@[@@@            @ @[@]@@@@@XAW
)@@G@@@@@@'AK^O[NGCGTB        @@@@@@@@[@@@            @ @Q@ @@@@[P@@@@'<F'0[YGAX
)@@G@@ERCG        @@@@@@@K[@@@            @ @A@ @@@@@;@@@@;8K%E[YGCGBB        AY
)@@G@@@@@@@@@@[@@@            @ @F@ @@@@ F@@@@/3G=[]^GCGXG        @@@@@@@@[@@@AZ
)@@G@@            @ @^@ @@@@FO@@@[["MF)]DGERSM        @@@@@@@K[@@@            BA
)@@G@@@ @ @ @@@@[#@@@[HMH^7]EGEREX        @@@@@@@K[@@@            @ @M@ @@@@[?BB
)@@G@@@@@[IPJ=3]EGCGBK        @@@@@@@@[@@@            @ @.@ @@@@CF@@@[K[I?L]FGBC
)@@G@@CGCV        @@@@@@@@[@@@            @ @V@ @@@@#J@@@[SGF-B]JGCGAS        BD
)@@G@@@@@@@@@@[@@@            @ @!@ @@@@]L@@@[VVL@\]JGCGOA        @@@@@@@@[@@@BE
)@@G@@            @ @.@ @@@@ (@@@[X?I,\]MGCGDR        @@@@@@@@[@@@            BF
)@@G@@@ @+@ @@@@BF@@@[<PD.Z]PGCGIO        @@@@@@@@[@@@            @ @[@]@@@@^FBG
)@@G@@@@@[%)C:C]UGEND   PART  FINAL MERGE(S) REQUIRED:START MRG NO.    ::INPUTBH
)@@G@@ FILES      :OUTPUT FILE             UNIT  LABEL       UNIT  LABEL      BI
)@@G@@                                    OUTPUT@USE     $ ,            @@@@@@BJ
)@@G@@@@@@@@@[@@@@@@M FD@@@@@@@[@@@@@@= E3@@[ B<@[@@@@@@% E9@@@@@@@[@@@@@@= F@BK
)@@G@@@@@@@@@[@@@@@@0 E>@@@@@@@[@@@@@@G FI@@@@@@@[@@@@@@M FL@@@@@@@[@@@@@@% FPBL
)@@G@@@@@@@@@[@@@@@@% FW@@@@@@@[@@@@@@S F<@@@@@@@[@@@@@@0 F<@@@@@@@[@@@@@@% F<BM
)@@G@@@@@@@@@[@@@@@@M FO@@@@@@@[@@@@@@G FG@@@@@@@[@@@@@@= E!@@@@@@@[@@@@@@2 F@BN
)@@G@@@@[ B<@@@@@0@B____@@B001@@^ F:'^@@88@@[@@@@@[@@@@@@@@@@@@@@@SORT ERROR CBO
)@@G@@ODE   @@@@@@@@M HC@@@@@@@@[@@[@@[ G%@/T ;7@@@@@@@@@@@@@@@@@@@]@ ;7A7J ;7BP
)@@G@@A<J ;7A$J ;7A:J ;7A\J ;7A3J ;7A7J ;7@LOG  *WARNING* A $$$$$$ NO. WAS TRUBQ
)@@G@@NCATED AT SEQ NO. $$$$$$ OF MAIN PROGRAM   OF SUBPROG $$$$$$ REAL DOUBLEBR
)@@G@@COMPLX@@@@@@A<Y H9A$Y H9A:Y H9A\Y H9A3Y H9A7Y H9R<Y H9R$Y H9R:Y H9R\Y H9BS
)@@G@@R3Y H9R7Y H9R<Z ;7R$Z ;7R:Z ;7R\Z ;7R3Z ;7R7Z ;7@]  JN@]  I2@]C I7@]^ I_BT
)@@G@@@]  JD@]A J#@]  JI@]B I:INSUFFICIENT DATA IN RECORD BEING REREAD. ILLEGABU
)@@G@@L CHARACTER IN INTEGER  INTEGER OUT OF RANGE, MAX IS +/-34359738367     BV
)@@G@@BAD CHARACTER SEQUENCE. ILLEGAL CHARACTER IN FLOATING INPUT.EXPONENT FIEBW
)@@G@@LD IS INCOMPLETE  FLOATING NUMBER IS TOO LARGE. NO T OR F IN LOGICAL INPBX
)@@G@@UT.   __"@@       @@H H+@@[@@@K[)@@@@@@@@@@@@@@F@@@@@T__"@@^__"@@L@@@@@[BY
)@@G@@@@@@@#@@@@@#@@@@@K@@@@@ @@@@@MA7Y /IA3Y /IA\Y /IA:Y /IA$Y /IA<Y /I@@@@@ BZ
)@@G@@@@@@@+@@@@@-@@@@@E@@@@@D      KG@@@@L48)@@__"@@ @[O /I@@H /I@)[@@@@-@@@@CA
)@@G@@@@@@@@@@@@@@@@@@@@@)@@@@@=@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CB
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CC
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@)[@@@@)@@@@@)@@@@@-@@@@@-@@@@@=@@@@@=@@@@@#C +*CD
)@@G@@ERROR DETECTED WHILE CLOSING FILE OF UNIT       @BRKPT                  CE
)@@G@@@@@@@@@)@@@@@@@@@@_____";_____@_^ < @_D <D@_B <M@[F <TFILE  $-$ NOT ASSICF
)@@G@@GNED  THE NTRAN UNIT $-$ IS NOT AVAILABLE FOR STANDARD I/O. DRUM FILE ASCG
)@@G@@SIGNED TO SYMBIONT UNIT       BACKSPACE WAS ENCOUNTERED FOR THE UNASSIGNCH
)@@G@@ED FILE: $-$ - IGNORED. @ASG,T      ,F    @@@@@@@@@@@K@@@@@K@@@@@C@@@@@CCI
)@@G@@@@@@@D@@@@@)@@@@@(@@@@@@@@@@@@                        /K@[HN/K@[I^R;) =#CJ
)@@G@@/K@[IRR;) =[@@@@@@@@@@@@@_C =AABNORMAL CONDITION DETECTED IN BUFFER HANDCK
)@@G@@LING  @@[@@[@@@@@@ K> Y&@@@__"@@@ Y$(C@ =L @@ =LCC) =KG8)@@H!G) =K/K@ ==CL
)@@G@@9?K =)A#K["FA#)[EU9?K =+C9K@@@N8K@@T/K@[EU'^@[D<M#Y)@@@@[ =N@@@@@LR#@ =&CM
)@@G@@/K@[GX__  =$NO PACKET SPACE AVAILABLE.    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CN
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@_@@@@@# <=      CO
)@@G@@A REWIND WAS ATTEMPTED ON A SYMBIONT DEVICE - IGNORED @]D ="_@@S@@@@[ >ECP
)@@G@@@EOF AAN ATTEMPT TO WRITE AN EOF-MARK ON CARDREADER OR PRINTER -  IGNORECQ
)@@G@@D     @]G >F@@@@@@@@@@@@@@[[N"/K@ >V@@[["U@ASG,T      ILLEGAL BUFFER LENCR
)@@G@@GTH PARAMETER ( < 1 OR > 65K WORDS ).     TOO MANY PARAMETERS IN SUBROUTCS
)@@G@@INE CALL.   EOF, EOT, PARITY ERROR, OR TRANSLATE ERROR DETECTED.  ILLEGACT
)@@G@@L UNIT NUMBER ( < 0 OR > 49 ).READ ATTEMPT AFTER WRITE OPERATION. LOGICACU
)@@G@@L UNIT IS NOT ASSIGNED. LOGICAL UNIT NOT ASSIGNED TO TAPE.  INPUT OUTPUTCV
)@@G@@[-&[Z\[=I[+Y'^@[W1/GK[V;@@^ >Y                                          CW
)@@G@@                                                                        CX
)@@G@@       ERROR DETECTED IN   IOTP   DURING         ON LUN   . __D &5@@[@@@CY
)@@G@@@]O &-@@@[X=@@@[Y\@@@@@@@@@@@@@@@@@@@@@[X=@@@[XR@@@@@@@@@@@@@@@@@@@@@@@@CZ
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DA
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DB
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DC
)@@G@@@@@@@@@@@@@@@@@@@@@[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@@@@@@@@@@@@@@@@@@@DD
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DE
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DF
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DG
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0           1           2           3     DH
)@@G@@      4           5           6           7           8           9     DI
)@@G@@      10          11          12          13          14          15    DJ
)@@G@@      16          17          18          19          20          21    DK
)@@G@@      22          23          24          25          26          27    DL
)@@G@@      28          29          30          31          32          33    DM
)@@G@@      34          35          36          37          38          39    DN
)@@G@@      40          41          42          43          44          45    DO
)@@G@@      46          47          48          49          _____"@@@@@@@@@@@@DP
)@@G@@ ERROR OCCURED WHILE CLOSING FILES AT RUN TERMINATION.@]D %MREQUESTED OPDQ
)@@G@@ERATION IS ILLEGAL ON THIS UNIT.    @BRKPT PRINT$ .                     DR
)@@G@@                                                                        DS
)@@G@@                                                                        DT
)@@G@@@@@@@@REREAD ATTEMPT BEFORE FIRST READ ON CARD READER.ATTEMPT TO READ BEDU
)@@G@@YOND END OF INPUT ON CARD READER.   @@[ %*[YR %*0@@ :#@@[ :W@BRKPT PUNCHDV
)@@G@@$ .   C,E.  C,B.  @@@@@@@@@@@@K@@[Z_C@@[Z7L@@[Z_*@@[Z_(@@[Z_D@@[Z_)@@[Z_DW
)@@G@@%@@[-G:@@[-GM@@[-DE@@[+LF@@[+N@@@@@@@@@@@@@@B>:8@@ >:;@@C>:8)@B>:8)@C>:8DX
)@@G@@)@ >:;)@C>:8)@^>:.)@^>:.^@@[)*[@@[Z: @@[)>@@@[)*D@@[)$E@@[-UF@@[+T]@@[Z:DY
)@@G@@[@@[Z!>8@^@@=8@[@@UNRECOGNISED STATUS CODE =   .LOSS OF POSITION ON TAPEDZ
)@@G@@ UNIT -- OPERATOR ANSWERED ERROR MESSAGE WITH B.NINE TRACK TAPES MUST BEEA
)@@G@@ ODD PARITY.OPERATOR DECLARED TAPE UNIT DOWN.   @@[@@@@@] :!@@[ :)@@[ ?>EB
)@@G@@@@@@@@@@@@@@C@@[+*D@@[<KK@@[<IM@@[<P(@@[<S*@@[<*E@@[<?UNRECOVERABLE ERROEC
)@@G@@R ON FASTRAND DEVICE -- STATUS CODE = XX. FILE IS INCOMPLETE OR BAD FORMED
)@@G@@AT.   @@] ?<@@[@@@@FREE @@@@@@@@@@@@@@# ?_      022674@@@ #U@@@ ]?@@@@@@EE
)@@G@@ ^Y ^H@@@ ^\@@@ !3@@@@@@@[@@@@@@@[4)@@@[49@@@[5]@@@[5]@@@@@@@@@@@@@@@@@@EF
)@@G@@@@@@@@@@@@@@@@@@@@[#S@G)]#S@G)# S@G)^ S@G) ^S@K*A^S@K*B#S@G)C S@G)D#S@G)EG
)@@G@@E#S@G)F^S@-OG^S@-OH^S@-OI]=@J*J[S@#'@@@@@@@USE       ,EXTERNALFILE .    EH
)@@G@@@@@@@@@@@@@@@@@@@@@LOG  SORT: T/R=XXX.XMS, IC=XXXXXXXX, OC=XXXXXXXX, BIAEI
)@@G@@=XXX.X@@@@@@@LOG  M1  BLOCK  SIZE :          MERGE  POWER :        .    EJ
)@@G@@@LOG  M2  BLOCK  SIZE :          MERGE  POWER :        .    @@@@@[      EK
)@@G@@ SORT LINKAGE USED AT WRONG TIME    DRUM BLOCK SIZE TOO SMALL =   @@@@@@EL
)@@G@@FASTRAND BLOCK SIZE TOO SMALL =     @@@@@@@@@@@@@@@@@@@@[@@[Z_____@_____EM
)@@G@@/K@[2%@@L ,6@@= ,9@@E ,5R$CORE      [.3 \4@@[ 0#@@@@@@PARAMETER CARD INCEN
)@@G@@ORRECTCARD TABLE OVERFLOWED   EOF CARD MISSING  @@@@@@@@S 1&@@@@@@@@@@@@EO
)@@G@@@@M 1,@@@@@@@@@@@@@@S 1%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EP
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[ 0X@@@___@@@MRGEQ
)@@G@@@@@RTA@@@RTB@@@RTC@@@DOA@@@DOB@@@NTA@@@NTB@@@NTC@@@ORT@@@ECK@@@RSZ@@@SZWER
)@@G@@@@[ \4      @@[@@[@@[@@@@@@ 2XN@@ 29N@@ 2;N@@ 2.N@@ 2_N@@ 3[N@@ 3#N@@ 3 ES
)@@G@@N@@ 3BN@@ 3DN@@ 3FN@@ 3HN@@ 3JN@@ 3LN@@ 3NN@@ 3PN@@ 3RN@@ 3TN@@ 3VN@@ 3XET
)@@G@@N@@ 3ZN@@ 3-N@@ 3<N@@ 3>N@@ 3$N@@ 3(N@@ 3:9@@ 2XXA          XB          EU
)@@G@@XC          XD          XE          XF          XG          XH          EV
)@@G@@XI          XJ          XK          XL          XM          XN          EW
)@@G@@XO          XP          XQ          XR          XS          XT          EX
)@@G@@XU          XV          XW          XX          XY          XZ          EY
)@@G@@ STOP       @#] 3\@@Q /I(1P6G13.5)  @@[[_F@@[["U@@@@@@@@@@@@@@@@@@@@@@@@EZ
)@@G@@@@@@@@T     F     @@@@@@@@@@@@@@@@@@@@@@@@@@[ /I)^@@@@)@)@@@@@[@@O@@[@@PFA
)@@G@@@@@@@@^@@@@@@@@@@@@@@@C@K^*@@@@@@@@@KB2@@@@@@@@@KE")@@@@@@@@KI$^@@@@@@@@FB
)@@G@@KL05@@@@@@@@KO.]K@@@@@@@KS&DU@@@@@@@KV\:0)@@@@@@KY;&?*@@@@@@K+>KF9@@@@@@FC
)@@G@@L#:R<:1U1+@@L=2ZFD3KL$N,M '1>J<-:>D)M$+H-6E_G=3LNC$4/$D-YUC=N(,RRQ!,899#FD
)@@G@@OE5"X'<8ZU"@O:"5-8MO:II&PH==5(FESV96UT(3<A\:?M4RZ>\2B=K@I?7N@@@@@@A$\ 5HFE
)@@G@@A:\ 5HA\\ 5HA3\ 5HA7\ 5HA<\ 5GLOCATION OF ERROR IS MARKED BY * IN FOLLOWFF
)@@G@@ING IMAGE.  @@C 5?@@[ 6,@@[ 6,@@[ 6,@@^ 54@@^ 58@@A 5/@@[ 6,@@  6]INTERNFG
)@@G@@AL TYPE AND FORMAT TYPE ARE INCOMPATIBLE. ILLEGAL OCTAL INPUT.    ILLEGAFH
)@@G@@L INTEGER INPUT.  TOO MANY DIGITS IN INTEGER INPUT.   ILLEGAL CHARACTER FI
)@@G@@IN INPUT.   @[D 6D@[C 6MILLEGAL FORMAT CHARACTERS WERE ACCEPTED AS BLANKFJ
)@@G@@S.    RECORDS EXCEEDING MAXIMUM LENGTH ARE FAULTY.    @@@@@@      @@ @@@FK
)@@G@@@@@@@@NBMSG$()    @]D 5^@[Q ;7@@[ 5H@[Q 5H??????@_D 7N@_F 67@_D 7]@_F 67FL
)@@G@@@_C 7F@_# 7WEXECUTION TERMINATED BY AN ATTEMPT TO READ PAST AN END-OF-FIFM
)@@G@@LE.   EXECUTION TERMINATED BY AN ATTEMPT TO PASS END-OF-TAPEA NON INTEGRFN
)@@G@@AL BLOCK WAS READ FROM MAGNETIC TAPEABNORMAL I/O CONDITION DETECTED - STFO
)@@G@@ATUS CODE = --    INAPPROPRIATE UNITOUTPUT SYMBIONT UNIT REFERENCED BY AFP
)@@G@@ READ  STATEMENT.  INPUTOUTPUT WRITE READ __D 7Z@@@@@@@@@@@@ SEQUENCE  NFQ
)@@G@@   LINE    N   ERROR TERMINATION IN        ROUTINE           CALLED  AT FR
)@@G@@ SEQUENCE  NUMBER         OF        ROGRAMA COMPUTED GO TO THAT WAS OUT FS
)@@G@@OF RANGE WAS DETECTED ATPVARS(...) NOT PUNCHED.  FILL IN LISTDV   @]@@@@FT
)@@G@@      IDV=1 @^@@@@      DO 320 IV=1,NVARS @#@@@@      LISTDV(IV)=0@^@@@@FU
)@@G@@      DO 310 IF=1,NF    @A@@@@      IF(IV.EQ.LISTFV(IF))GO TO 320 @[@@@@FV
)@@G@@C     @#@@@@310   CONTINUE    @C@@@@C         VARIABLE IV IS NOT A FACTOFW
)@@G@@R VARIABLE  @F@@@@C     IF VARIABLE IV IS ALPHA, DON'T ADD IT TO STRING FX
)@@G@@OF DEPVARS  @A@@@@      CALL S1GTVT(IV,TYPE,$318)     @ @@@@      IF(TYPFY
)@@G@@E.EQ.1)GO TO 319  @^@@@@318   PRINT 9318,IV     @G@@@@9318  FORMAT(1H ,'FZ
)@@G@@***** NWAY1 NOTE. VARIABLE NUMBER ',I6,' IS ALPHANUMER@C@@@@     1IC ANDGA
)@@G@@ WILL NOT BE USED AS A DEPVAR ')    @#@@@@      GO TO 320   @#@@@@319   GB
)@@G@@CONTINUE    @^@@@@      LISTDV(IV)=IDV    @#@@@@      IDV=IDV+1   @#@@@@GC
)@@G@@320   CONTINUE    @#@@@@      NDV=IDV-1   @ @@@@      IF(NDV.NE.0)GO TO GD
)@@G@@400   @^@@@@      CALL S1PCHD(2)    @#@@@@      NERR=NERR+1 @#@@@@      GE
)@@G@@PRINT 9320,E@E@@@@9320  FORMAT(4A6,'  THERE ARE NO DEPENDENT VARIABLES.'GF
)@@G@@)     @#@@@@      GO TO 400   @#@@@@330   CONTINUE    @C@@@@C           GG
)@@G@@        DEPVARS(...) WAS PUNCHED    @^@@@@      DO 340 IV=1,NVARS @#@@@@GH
)@@G@@340   LISTDV(IV)=0@]@@@@      INCR=0@]@@@@      NDV=1 @^@@@@      DO 360GI
)@@G@@ IV=1,NUM   @B@@@@      IF(OUTLST(IV+LDEPVR).NE.0)GO TO 350 @A@@@@C     GJ
)@@G@@                        SLASH @#@@@@      NDV=NDV+1   @]@@@@      INCR=0GK
)@@G@@@#@@@@      GO TO 360   @#@@@@350   CONTINUE    @ @@@@      MODE=OUTLST(GL
)@@G@@IV+LDEPVR)  @^@@@@      LISTDV(MODE)=NDV  @ @@@@      IF(ORDLEV.EQ.0)GO GM
)@@G@@TO 360@^@@@@      READDV(MODE)=INCR @#@@@@      INCR=INCR+1 @#@@@@360   GN
)@@G@@CONTINUE    @G@@@@C                 NOW CHECK FOR DUPLICATE ENTRIES IF NGO
)@@G@@OT DONE BY SYSTEM @ @@@@      IF(NUM.EQ.1)GO TO 400   @^@@@@      DO 370GP
)@@G@@ IV=2,NUM   @#@@@@      IF=IV-1     @^@@@@      DO 370 I=1,IF     @B@@@@GQ
)@@G@@      IF(OUTLST(IV+LDEPVR).EQ.0)GO TO 370 @E@@@@      IF(OUTLST(IV+LDEPVGR
)@@G@@R). NE.OUTLST(I+LDEPVR)) GO TO 370  @^@@@@      CALL S1PCHD(2)    @#@@@@GS
)@@G@@      NERR=NERR+1 @A@@@@      TEMP(1)=OUTLST(IV+LDEPVR)     @ @@@@      GT
)@@G@@PRINT 9370,E,TEMP(1)    @G@@@@9370  FORMAT(4A6,' VARIABLE',I5,' IS USED GU
)@@G@@MORE THAN ONCE FOR THE DEPVARS@^@@@@     1  CONTROL WORD')  @#@@@@370   GV
)@@G@@CONTINUE    @#@@@@400   CONTINUE    @F@@@@C         IF ORDERFAC WAS PUNCGW
)@@G@@HED, CHECK NUMBER OF LEVELS FOR EACH@A@@@@C         EACH DEPENDENT VARIAGX
)@@G@@BLE   @A@@@@      IF(ORDLEV.EQ.0)  GO TO 500    @B@@@@      IF(OUTLST(LDGY
)@@G@@EPVR).EQ.0) GO TO 500   @G@@@@C         S1ENST PRINTS A MESSAGE IF ORDERGZ
)@@G@@FAC IS PUNCHED AND NOT DEPVARS@]@@@@      IDV=1 @#@@@@      LOC=LDEPVR+1HA
)@@G@@@]@@@@      N=0   @]@@@@      IV=0  @#@@@@410   CONTINUE    @A@@@@      HB
)@@G@@IF(OUTLST(LOC).NE.0)GO TO 430 @A@@@@C                             SLASH HC
)@@G@@@#@@@@415   CONTINUE    @ @@@@      IF(N.EQ.ORDLEV)GO TO 420@^@@@@      HD
)@@G@@CALL S1PCHD(2)    @#@@@@      NERR=NERR+1 @^@@@@      PRINT 9420,E,N,IDVHE
)@@G@@@G@@@@9420  FORMAT(4A6,'  THE ORDER FACTOR HAS',I4,' LEVELS FOR DEPENDENHF
)@@G@@T VARI@#@@@@     1ABLE',I4)   @]@@@@420   N=0   @#@@@@      IDV=IDV+1   HG
)@@G@@@#@@@@      GO TO 440   @]@@@@430   N=N+1 @#@@@@440   LOC=LOC+1   @#@@@@HH
)@@G@@      IV=IV+1     @ @@@@      IF(IV-NUM)410,415,450   @#@@@@450   CONTINHI
)@@G@@UE    @#@@@@500   CONTINUE    @ @@@@C         CHECK VARIABLE TYPES@ @@[@HJ
)@@G@@      IF(NF .LE. 0) GO TO 510 @B@@[@      CALL S1STFT('S9FTYP',FW,1,NF,$HK
)@@G@@9000) @^@@[@      DO 508 I=1,NF     @]@@[@      TYPE=0@#@@[@      IV=LISHL
)@@G@@TFV(I)@ @@[@      IF(IV .EQ. 0) GO TO 505 @A@@[@      CALL S1GTVT(IV,TYPHM
)@@G@@E,$505)     @#@@[@ 505  IX(FW)=TYPE @#@@[@ 508  FW=FW+1     @#E@@@510   HN
)@@G@@CONTINUE    @^@@@@      DO 520 I=1,NVARS  @#@@@@      IV=LISTDV(I)@ @@@@HO
)@@G@@      IF(IV.EQ.0)GO TO 520    @ @@@@      CALL S1GTVT(I,TYPE,$515)@ @@@@HP
)@@G@@      IF(TYPE.EQ.1)GO TO 520  @#@@@@515   NERR=NERR+1 @^@@@@      CALL SHQ
)@@G@@1PCHD(2)    @^@@@@      PRINT 9515,E,I    @G@@@@9515  FORMAT(4A6,'   VARHR
)@@G@@IABLE NUMBER',I5,' IS USED AS A DEPENDENT VARIAB@ @@@@     1LE BUT IS NOHS
)@@G@@T NUMERIC') @#@@@@520   CONTINUE    @[@@@@C     @C@@@@C     CHECK FOR TWHT
)@@G@@ELVE FACTORS PLUS ORDERFAC    @D@@@@      IF(NF.NE.12.OR.OUTLST(LORDFC).HU
)@@G@@EQ.0)GO TO 525    @#@@@@      PRINT 9520,E@G@@@@9520  FORMAT(4A6,'   THIHV
)@@G@@RTEEN FACTORS (INCLUDING THE ORDERFACTOR) HAVE B@F@@@@     XEEN SPECIFIEHW
)@@G@@D.'/40X,'NWAY1 ALLOWS AT MOST TWELVE FACTORS' ) @#@@@@      NERR=NERR+1 HX
)@@G@@@#@@@@525   CONTINUE    @[@@[@C     @B@@[@C             CHECK AND SAVE EHY
)@@G@@MS SPECS    @[@@[@C     @B@@[@ 600  IF(OUTLST(LEMS) .EQ. 0) GO TO 700   HZ
)@@G@@@ @@[@      NMODIF=OUTLST(LEMS+1)   @#@@[@      LOC=LEMS+2  @]@@[@      IA
)@@G@@EMS=0 @A@@[@      IF(NMODIF .EQ. 0) GO TO 660   @^@@[@      DO 650 IF=1,IB
)@@G@@NMODIF@^@@[@      MODE=OUTLST(LOC)  @D@@[@      IF(MODE .LT. 1  .OR.  MOIC
)@@G@@DE .GT. 4) GO TO 660    @A@@[@      GO TO (610,660,620,630),MODE  @^@@[@ID
)@@G@@ 610  NUM=OUTLST(LOC+1) @#@@[@      LOC=LOC+2   @A@@[@      CALL TSTNUM(IE
)@@G@@NUM,BIT,$650)     @#@@[@      GO TO 640   @ @@[@ 620  NUMLOW=OUTLST(LOC+IF
)@@G@@1)    @ @@[@      NUMHGH=OUTLST(LOC+2)    @#@@[@      LOC=LOC+3   @C@@[@IG
)@@G@@      IF(NUMHGH .GT. NUMLOW+12) NUMHGH=NUMLOW+12@ @@[@      DO 625 NUM=NIH
)@@G@@UMLOW,NUMHGH@A@@[@      CALL TSTNUM(NUM,BIT,$625)     @B@@[@      IF(ANDII
)@@G@@(BIT,EMS) .NE. 0) GO TO 645   @^@@[@      EMS=OR(EMS,BIT)   @#@@[@ 625  IJ
)@@G@@CONTINUE    @#@@[@      GO TO 650   @#@@[@ 630  LOC=LOC+3   @B@@[@      IK
)@@G@@CALL TSTNAM(OUTLST(LOC-2),BIT,$650) @B@@[@ 640  IF(AND(BIT,EMS) .NE. 0) IL
)@@G@@GO TO 645   @^@@[@      EMS=OR(EMS,BIT)   @#@@[@      GO TO 650   @#@@[@IM
)@@G@@ 645  CALL ERROR  @#@@[@      PRINT 9645,E@G@@[@ 9645 FORMAT(3A6,A3,'A FIN
)@@G@@ACTOR IS SPECIFIED MORE THAN ONCE WITH EMS')    @#@@[@ 650  CONTINUE    IO
)@@G@@@B@@[@ 660  CALL S1STFT('EMS',FW,1,1,$9000)     @#@@[@      IX(FW)=EMS  IP
)@@G@@@[@@[@C     @C@@[@C             CHECK AND SAVE ZEROTERMS SPECS    @[@@[@IQ
)@@G@@C     @ @@[@ 700  NMODIF=OUTLST(LZEROT)   @A@@[@      IF(NMODIF .EQ. 0) IR
)@@G@@GO TO 790   @#@@[@      LOC=LZEROT+1@#@@[@      ZEROT=0     @#@@[@      IS
)@@G@@NZEROT=0    @^@@[@      DO 750 I=1,NMODIF @^@@[@      MODE=OUTLST(LOC)  IT
)@@G@@@#@@[@      LOC=LOC+1   @D@@[@      IF(MODE .LT. 1  .OR.  MODE .GT. 5) GIU
)@@G@@O TO 760    @B@@[@      GO TO (710,760,760,720,750), MODE   @^@@[@ 710  IV
)@@G@@NUM=OUTLST(LOC)   @#@@[@      LOC=LOC+1   @A@@[@      CALL TSTNUM(NUM,BIIW
)@@G@@T,$740)     @#@@[@      GO TO 730   @#@@[@ 720  LOC=LOC+2   @B@@[@      IX
)@@G@@CALL TSTNAM(OUTLST(LOC-2),BIT,$740) @B@@[@ 730  IF(AND(BIT,ZEROT) .EQ. 0IY
)@@G@@) GO TO 738 @#@@[@      CALL ERROR  @#@@[@      PRINT 9735,E@E@@[@ 9735 IZ
)@@G@@FORMAT(3A6,A3,'A ZEROTERM IS IMPROPERLY SPECIFIED')   @ @@[@ 738  ZEROT=JA
)@@G@@OR(BIT,ZEROT)     @A@@[@ 740  IF(I .EQ. NMODIF) GO TO 745   @B@@[@      JB
)@@G@@IF(OUTLST(LOC) .EQ. 5) GO TO 750    @A@@[@ 745  OUTLST(LZEROT+NZEROT)=ZEJC
)@@G@@ROT   @^@@[@      NZEROT=NZEROT+1   @#@@[@      ZEROT=0     @#@@[@ 750  JD
)@@G@@CONTINUE    @A@@[@ 760  IF(NZEROT .LT. 2) GO TO 780   @^@@[@      DO 770JE
)@@G@@ I=2,NZEROT @ @@[@      ZEROT=OUTLST(LZEROT+I-2)@A@@[@      IF(ZEROT .EQJF
)@@G@@. 0) GO TO 770    @ @@[@      DO 765 NZT=I,NZEROT     @D@@[@      IF(OUTJG
)@@G@@LST(LZEROT+NZT-1) .NE. ZEROT) GO TO 765   @#@@[@      CALL ERROR  @#@@[@JH
)@@G@@      PRINT 9765,E@G@@[@ 9765 FORMAT(3A6,A3,'THE SAME ZEROTERM IS SPECIFJI
)@@G@@IED MORE THAN ONCE')    @#@@[@      GO TO 780   @#@@[@ 765  CONTINUE    JJ
)@@G@@@#@@[@ 770  CONTINUE    @A@@[@ 780  IF(NZEROT .EQ. 0) GO TO 790   @C@@[@JK
)@@G@@      CALL S1STFT('ZEROTM',FW,1,NZEROT,$9000)   @#@@[@      LOC=LZEROT  JL
)@@G@@@^@@[@      DO 785 I=1,NZEROT @^@@[@      IX(FW)=OUTLST(LOC)@#@@[@      JM
)@@G@@LOC=LOC+1   @#@@[@ 785  FW=FW+1     @#@@[@ 790  CONTINUE    @[@@@@C     JN
)@@G@@@E@@@@C                   STORE INFORMATION IN TAGGED STORAGE     @^@@@@JO
)@@G@@      NTAG=NVARS+34     @A@@@@      IF(ORDLEV.NE.0)NTAG=NTAG+NVARS@C@@@@JP
)@@G@@      CALL S1STFT('S9INFO',FW,1,NTAG,$9000)     @#@@@@      IX(FW)=NF   JQ
)@@G@@@#@@@@      NCELLS=1    @ @@@@      NFLEVS(NF+1)=ORDLEV     @^@@@@      JR
)@@G@@IX(FW+1)=ORDLEV   @^@@@@      IX(FW+2)=ORDNAM(1)@^@@@@      IX(FW+3)=ORDJS
)@@G@@NAM(2)@#@@@@      IX(FW+4)=NDV@^@@@@      IX(FW+5)=NPEEL    @^@@@@      JT
)@@G@@IX(FW+6)=NBADRC   @^@@@@      IX(FW+7)=NOMISS   @^@@@@      DO 910 I=1,1JU
)@@G@@2     @C@@@@      IF(NFLEVS(I).NE.0)NCELLS=NCELLS*NFLEVS(I) @ @@@@      JV
)@@G@@IX(FW+9+I)=NFLEVS(I)    @ @@@@      IX(FW+21+I)=LISTFV(I)   @#@@@@910   JW
)@@G@@CONTINUE    @^@@@@      IX(FW+8)=NCELLS   @^@@@@      DO 920 I=1,NVARS  JX
)@@G@@@ @@@@      IX(FW+33+I)=LISTDV(I)   @#@@@@920   CONTINUE    @ @@@@      JY
)@@G@@IF(ORDLEV.EQ.0)GO TO 940@E@@@@C                   READDV IS NOT STORED IJZ
)@@G@@F IT IS NOT NEEDED@^@@@@      DO 930 I=1,NVARS  @A@@@@      IX(FW+NVARS+KA
)@@G@@33+I)=READDV(I)   @#@@@@930   CONTINUE    @#@@@@940   CONTINUE    @#@@@@KB
)@@G@@      IV=NF+12    @^@@@@      DO 950 I=1,NF     @^@@@@950   IV=IV+NFLEVSKC
)@@G@@(I)   @B@@@@      CALL S1STFT('S9IDST',FW,1,IV,$9000) @^@@@@      DO 960KD
)@@G@@ I=1,12     @#@@@@960   IX(FW+I-1)=0@[@@@@C     @]@@@@      RETURN@[@@@@KE
)@@G@@C     @[@@@@C     @#@@@@9000  CONTINUE    @G@@@@C         TAGGED STORAGEKF
)@@G@@ OVERFLOW DETECTED BY SYSTEM, WHICH PRINTS MESS @]@@[@      RETURN@[@@[@KG
)@@G@@C     @[@@[@C     @C@@[@C        LOCAL SUBROUTINE FOR ERROR HANDLING    KH
)@@G@@@[@@[@C     @^@@[@      SUBROUTINE ERROR  @^@@[@      CALL S1PCHD(1)    KI
)@@G@@@#@@[@      NERR=NERR+1 @]@@[@      RETURN@[@@[@C     @[@@[@C     @D@@[@KJ
)@@G@@C        LOCAL SUBROUTINE TO TEST A FACTOR NUMBER     @[@@[@C     @B@@[@KK
)@@G@@      SUBROUTINE TSTNUM(FNUM,FACTOR,$)    @ @@[@      IF(NF .GT. 0) GO TKL
)@@G@@O 2100@A@@[@      IF(ORDLEV .EQ. 0) RETURN 3    @#@@[@ 2000 CALL ERROR  KM
)@@G@@@^@@[@      PRINT 2050,E,FNUM @F@@[@ 2050 FORMAT(3A6,A3,I8,' IS NOT THE KN
)@@G@@NUMBER OF A FACTOR VARIABLE') @#@@[@      RETURN 3    @^@@[@ 2100 DO 220KO
)@@G@@0 IF=1,NF   @B@@[@      IF(FNUM .NE. LISTFV(IF)) GO TO 2200 @^@@[@      KP
)@@G@@FACTOR=8**(NF-IF) @B@@[@      IF(ORDLEV .NE. 0) FACTOR=FACTOR*8   @]@@[@KQ
)@@G@@      RETURN@#@@[@ 2200 CONTINUE    @#@@[@      GO TO 2000  @[@@[@C     KR
)@@G@@@[@@[@C     @C@@[@C        LOCAL SUBROUTINE TO TEST FACTOR NAME   @[@@[@KS
)@@G@@C     @B@@[@      SUBROUTINE TSTNAM(FNAME,FACTOR,$)   @^@@[@      DIMENSKT
)@@G@@ION FNAME(2)@ @@[@      IF(NF .EQ. 0) GO TO 3300@A@@[@      CALL S1CKVN(KU
)@@G@@FNAME,FNUMB,$3300)@^@@[@      DO 3200 IF=1,NF   @B@@[@      IF(FNUMB .NEKV
)@@G@@. LISTFV(IF)) GO TO 3200@^@@[@      FACTOR=8**(NF-IF) @B@@[@      IF(ORDKW
)@@G@@LEV .NE. 0) FACTOR=FACTOR*8   @]@@[@      RETURN@#@@[@ 3200 CONTINUE    KX
)@@G@@@#@@[@ 3250 CALL ERROR  @^@@[@      PRINT 3275,E,FNAME@E@@[@ 3275 FORMATKY
)@@G@@(3A6,A4,A6,A2,' IS NOT THE NAME OF A FACTOR')   @#@@[@      RETURN 3    KZ
)@@G@@@A@@[@ 3300 IF(ORDLEV .EQ. 0) GO TO 3250  @C@@[@      IF(FNAME(1) .NE. OLA
)@@G@@RDNAM(1)) GO TO 3250    @C@@[@      IF(FNAME(2) .NE. ORDNAM(2)) GO TO 32LB
)@@G@@50    @#@@[@      FACTOR=1    @]@@[@      RETURN@]@@@@      END   ___+1)LC
)@@G@@=ORDLEV     @^@@@@      *[S@@@*SDFF*@^@@@@      SUBROUTINE S9CCP  @ @@@@LD
)@@G@@      IMPLICIT INTEGER(A-Z)   @^@@[@      DIMENSION NVEC(6) @^[@@@      LE
)@@G@@PARAMETER OP=23   @^@@@@      PARAMETER AP=16   @^@@@@      PARAMETER CPLF
)@@G@@=18   @^@@@@      PARAMETER DP=19   @ @@@@      DIMENSION CCTABL(130)/  LG
)@@G@@@C@@@@     1   'INPUT       ',1,0,0,-1,0,0, 1,0,0,1,0,@D@@@@     2    'ILH
)@@G@@/FORMAT    ',2,0,0,-1,0,0, 2,3,0,0,-2,    @C@@@@     3   'INCHECKS    ',LI
)@@G@@3,0,0, 0,0,0, 3,0,0,0,0,@C@@@@     4   'VNAMES      ',3,0,0, 0,0,0, 4,0,LJ
)@@G@@0,0,0,@D@@@@     5   'TRANSFRM    ',5,0,0, 0,0,0, 5,0,0,0,-1,     @C@@@@LK
)@@G@@     6   'TITLE       ',6,0,0, 0,0,0, 6,5,0,0,0,@C@@@@     7   'ANALYSISLL
)@@G@@    ',7,0,0,-1,0,0,AP,0,0,0,0,@C@@@@     8   'CODE        ',8,0,0, 0,0,0LM
)@@G@@,CP,0,0,0,0,@C@@@@     9   'DESIGN      ',8,0,0, 0,0,0,DP,0,0,0,0,@C@@@@LN
)@@G@@     *   'OUTPUT      ',9,0,0, 0,0,0,OP,0,0,0,0/@^@@@@      COMMON COM(2LO
)@@G@@)     @#@@@@      INCLUDE CCI @^@@@@      PARAMETER NCW=10  @^@@@@C*****LP
)@@G@@*************     @[@@@@C     @D@@@@C       NWAY1 CONTROL CARD PROCESSORLQ
)@@G@@ PRIMARY ROUTINE. @[@@@@C     @^@@@@C******************     @[@@@@C     LR
)@@G@@@A@@@@C       S9CCP SYMBOL USAGE SUMMARY  @[@@@@C     @^@@@@C***********LS
)@@G@@*******     @[@@@@C     @G@@@@C       AP -       PARAMETER VARIABLE, PROLT
)@@G@@CESSOR NUMBER OF PROCESSOR    @C@@@@C                  FOR NWAY1'S ANALYLU
)@@G@@SIS CARD.   @F@@@@C       CCI -      FORTRAN PROC, WHICH DEFINES COMMON LV
)@@G@@BLOCK S1CCI @F@@@@C       CCTABL -   DIMENSIONED(130), CONTROL CARD TABLLW
)@@G@@E FO S1CCFS,@F@@@@C                  CONTAINING NAMES AND NUMBERS OF CONLX
)@@G@@TROL CARD   @D@@@@C                  PROCESSORS AND PARAMETER FOR THEM  LY
)@@G@@@B@@@@C       COM -      BLANK COMMON ARRAY.    @G@@@@C       CP -      LZ
)@@G@@ PROCESSOR NUMBER OF CODE CONTROL CARD PROCESSOR,     @B@@@@C           MA
)@@G@@       PARAMETER VARIABLE.    @F@@@@C       DP -       PARAMETER VARIABLMB
)@@G@@E, PROCESSOR NUMBER OF DESIGN @B@@@@C                  CONTROL CARD PROCMC
)@@G@@ESSOR.@A@@@@C       I -        DO-LOOP INDEX.   @F@@@@C       ICOD -    MD
)@@G@@ POINTER TO TAG S9CODE IN BLANK COMMON ARRAY.   @B@@@@C       IDUMY -   ME
)@@G@@ DUMMY VARIAVLE, =0     @G@@@@C       IFLAG -    FLAG, =1 IF FOUND NONZEMF
)@@G@@RO BIT IN THE CODE WORD YET.  @C@@@@C       INFO -     POINTER TO THE TAMG
)@@G@@G S9INFO.   @G@@@@C       ISHIFT -   NUMBER TO MULTIPLY BY TO LEFT SHIFTMH
)@@G@@ CODE WORDS SO    @C@@@@C                  THAT THEY ARE LEFT JUSTIFIED.MI
)@@G@@@G@@@@C       ISTOR -    NUMBER OF WORDS OF STORAGE REQUIRED BY INTERACTMJ
)@@G@@ION   @ @@@@C                  STORAGE.   @C@@@@C       ITEST -    VALUEMK
)@@G@@ OF TAG TEST, OR ZERO.  @D@@@@C       J -        DO-LOOP INDEX THROUGH TML
)@@G@@HE FACTORS. @B@@@@C       K -        TEMPORARY VARIABLE.    @D@@@@C     MM
)@@G@@  M -        DO-LOOP INDEX THROUGH CODE WORDS.  @G@@@@C       NCCERR -  MN
)@@G@@ IN COMMON BLOCK S1CCI, NUMBER OF CONTROL CARD ERRORS.@G@@@@C       NCW MO
)@@G@@-      NUMBER OF CONTROL CARD TYPES IN TABLE, PARAMETER VAR.@G@@@@C     MP
)@@G@@  NDIM -     NUMBER OF DIMENSIONED CELLS IN THE ANALYSIS, =COM(   @ @@@@MQ
)@@G@@C                  INFO+8).   @C@@@@C       NEL -      NUMBER OF ELEMENTMR
)@@G@@S IN TAG.   @E@@@@C       NF -       NUMBER OF FACTORS INCLUDING ANY ORDMS
)@@G@@ERFAC.@G@@@@C       NSTOR -    TOTAL AMOUNT OF STORAGE NEEDED BY ANALYSIMT
)@@G@@S PART AND  @A@@@@C                  ALL OF NWAY1.    @G@@@@C       NSTOMU
)@@G@@RR -   TOTAL AMOUNT OF STORAGE NEEDED FOR READ PHASE, THAT  @G@@@@C     MV
)@@G@@             IS SPACE FOR NSTOR1 PLUS SPACE FOR DOUBLE PRECISION  @A@@@@MW
)@@G@@C                  SUMS OF SQUARES. @G@@@@C       NSTOR1 -   AMOUNT OF SMX
)@@G@@TORAGE USED BY FACTOR LEVELS, SUMS MATRIX,@G@@@@C                  COUNTMY
)@@G@@S MATRIX, AND MATRIX OF NUMBER OF ZERO CELLS IN @E@@@@C                 MZ
)@@G@@ THE ANALYSIS OF EACH DEPENDENT VARIABLE. @G@@@@C                  ( ANDNA
)@@G@@ TOTAL SUMS OF SQUARES AND CORRECTED SUMS OF    @E@@@@C                 NB
)@@G@@ SQUARES AFTER ITS USE IN THE READ PHASE.)@G@@@@C       NSTOR2 -   SPACENC
)@@G@@ FOR INC, NDF, DIV LSQ AND LBA ARRAYS + 1*NUMBER@A@@@@C                 ND
)@@G@@ OF CODE WORDS.   @F@@@@C       NSTOR3 -   SPACE NEEDED IN MEANS PHASE FNE
)@@G@@OR SCRATCH ARRAYS.@C@@@@C       NV -       NUMBER OF INPUT VARIABLES.   NF
)@@G@@@G@@@@C       NVEC -     DIMENSIONED(2) VECTOR OF NUMBERS OF WORDS NEEDENG
)@@G@@D FOR @G@@@@C                  SCRATCH ARRAYS IN THE ANALYSIS PHASE. USENH
)@@G@@D TO ALLOCAT@G@@@@C                  COMSTO.  NVEC(1)= SPACE FOR INPUT ANI
)@@G@@RRAY FROM S1INOB. @E@@@@C                  NVEC(2)=NSTOR FOR ALL OTHER SNJ
)@@G@@CRATCH.     @D@@@@C       NWE -      NUMBER OF WORDS PER ELEMENT OF TAG.NK
)@@G@@@G@@@@C       OP -       PARAMETER VARIABLE, OUTPUT CARD PROCESSOR'S PRONL
)@@G@@CESSOR@B@@@@C                  NUMBER FOR S1CCPD.     @F@@@@C       S1CCNM
)@@G@@FS -   FIRST 16 PROCESSOR, HANDLES CONTROL CARDS.     @G@@@@C           NN
)@@G@@       RETURNS CONTROL AFTER BEGINDATA CARD HAD BEEN READ,  @C@@@@C     NO
)@@G@@             OR ENDOFFILE ENCOUNTERED.    @C@@@@C       S1GTAG -   RETRINP
)@@G@@EVE POINTERS TO TAG.    @B@@@@C       S1GVAL -   RETRIEVE VALUE OF TAG. NQ
)@@G@@@F@@@@C       S1STOR -   PASS REQUIREMENTS FOR LARGE SCRATCH ARRAYS INTONR
)@@G@@@G@@@@C                  SYSTEM ROUTINES, SO THAT TAG COMSTO CAN BE ALLONS
)@@G@@CATED @G@@@@C       S9DNPF -   NWAY1 DESIGN CARD PROCESSOR, CALLED HERE NT
)@@G@@TO CREATE   @G@@@@C                  CODE WORDS FOR A FULLY CROSSED DESINU
)@@G@@GN IF NO CODE OR  @C@@@@C                  DESIGN CARD IN THE DECK.     NV
)@@G@@@[@@@@C     @^@@@@C******************     @[@@@@C     @D@@@@C       NWAYNW
)@@G@@1 USE OF TAGGED STORAGE IN ALL ROUTINES.  @[@@@@C     @^@@@@C***********NX
)@@G@@*******     @[@@@@C     @G@@@@C       'CELLVA' - IS CREATED BY S1ENST IFNY
)@@G@@ CELLVAR IS ON THE OUTPUT CARD@[@@@@C     @G@@@@C       'CROSSD' - IS CRNZ
)@@G@@EATED BY S1ENST IF CROSSDFIXDF APPEARS ON ANALYS@^@@@@C                 OA
)@@G@@ CARD.@G@@@@C       'NSTOR' -  IS CREATED BY S9OUTP WITH THE NUMBER OF WOB
)@@G@@ORDS OF     @F@@@@C                  STORAGE NEEDED IN MATRICES FOR MEANOC
)@@G@@S TABLES.   @G@@@@C       'NVARS' -  IS RETRIEVED FOR THE NUMBER OF INPUOD
)@@G@@T VARIABLES DEFINE@G@@@@C                  THIS IS REALLY THE NUMBER OF OE
)@@G@@TRANSFORMED VARIABLES   @B@@@@C                  AFTER TRANSFORMATIONS. OF
)@@G@@@G@@@@C       'ONEWAY' - IS CREATED BY S1ENST IF ONEWAYMEANS APPEARS ON OG
)@@G@@THE   @A@@@@C                  OUTPUT CARD.     @G@@@@C       'OPMEAN' -OH
)@@G@@ IS CREATED BY S9OUTP TO HOLD THE MODIFIER LISTS OF   @C@@@@C           OI
)@@G@@       M OR MEANS CONTROL WORDS.    @G@@@@C       'POOL' -   IS CREATED OJ
)@@G@@BY S1ENST IF THE POOL CONTROL WORD APPEARS@C@@@@C                  AND COK
)@@G@@ONTAINS ITS MODIFIER.   @G@@@@C       'S9CODE' - IS CREATED BY S9CODP OROL
)@@G@@ S9DNPF WITH THE CODE WORDS   @F@@@@C                  THAT SPECIFY WHATOM
)@@G@@ TO PRINT INTHE ANOVA TABLE.  @G@@@@C       'S9ICOD' - IS CREATED BY S9DON
)@@G@@NPF TO HOLD AN ARRAY CALLED IVEC.   @G@@@@C       'S9INFO' - IS CREATED OO
)@@G@@BY S9ANPF WITH INFORMATION ON THE ANALYSIS@C@@@@C                  SUMMAOP
)@@G@@RY OF USE OF S9INFO     @A@@@@C                  WORD:   USE:     @D@@@@OQ
)@@G@@C                  0) NUMBER OF FACTOR VARIABLES.     @G@@@@C           OR
)@@G@@       1) =0 IF NO ORDERFAC, =NUMBER OF LEVELS IF ORDERFAC  @D@@@@C     OS
)@@G@@             2) NAME OF ORDERFAC, IF ANY, WORD 1@D@@@@C                 OT
)@@G@@ 3) NAME OF ORDERFAC, IF ANY, WORD 2@D@@@@C                  4) NUMBER OOU
)@@G@@F DEPENDENT VARIABLES.  @A@@@@C                  5) NPEEL, =0     @A@@@@OV
)@@G@@C                  6) NBADRC, =0    @F@@@@C                  7) =0 IF -0OW
)@@G@@ IS MISSING DATA, =1 IF -0 IS =0    @D@@@@C                  8) NUMBER OOX
)@@G@@F CELLS IN THE ANALYSIS.@F@@@@C                  9) NUMBER OF WORDS OF SOY
)@@G@@TORAGE IN IX ALLOCATED. @G@@@@C                  10-21) NUMBER OF LEVELSOZ
)@@G@@ LEGAL FOR EACH OF 12 FACTORS.@G@@@@C                  22-33) LISTFV = IPA
)@@G@@NPUT VARIABLE NUMBERS OF FACTORS.   @G@@@@C                  34-34+NVARSPB
)@@G@@) - LISTDV- NUMBER OF DEPENDENT VARIABLE  @G@@@@C                       PC
)@@G@@                 FOR THIS VARIABLE OR ZERO IF   @D@@@@C                 PD
)@@G@@                       NOT A DEPVAR.@G@@@@C                  34+NVARS-34PE
)@@G@@+2*NVARS) - ALLOCATED ONLY IF ORDERFAC    @G@@@@C                       PF
)@@G@@            SPECIFIED. READDV, NUMBER OF THIS   @G@@@@C                 PG
)@@G@@                  VARIABLE AS A LEVEL OF ORDERFAC.    @G@@@@C       'TESPH
)@@G@@T' -   IS RETRIEVED TO TELL WHETHER DIAGNOSTIC OUTPUT IS TO @G@@@@C     PI
)@@G@@             BE PRINTED.  CREATED IN SZEROS IF TEST OR SYSTES     @G@@@@PJ
)@@G@@C                  SPECIFIED ON BEGINPROG CARD, TEST IS A ONE WORD LONG PK
)@@G@@@F@@@@C                  TAG THAT IS =1 IF TEST SPECIFIED, =2 IF SYSTES PL
)@@G@@@G@@@@C                  SPECIFIED. NWAY1 DOEN'T CHANGE ITS ACTIONS BASEPM
)@@G@@D ON  @F@@@@C                  WHICH IS PRESENT ONLY IF EITHER IS PRESENPN
)@@G@@T.    @G@@@@C       'TWOWAY' - IS CREATED BY S1ENST IF CONTROL WORD TWOWPO
)@@G@@AYMEANS     @C@@@@C                  APPEARS ON THE OUTPUTCARD.   @G@@@@PP
)@@G@@C       'VNAMES' - IS RETRIEVED TO GET THE FACTORS VARIABLE NAMES IF THEPQ
)@@G@@@A@@@@C                  THEY HAVE SUCH.  @^@@@@C******************     PR
)@@G@@@[@@@@C     @B@@@@C       NWAY1 DISK I/O USAGE SUMMARY.     @[@@@@C     PS
)@@G@@@^@@@@C******************     @[@@@@C     @G@@@@C       UNIT -1 -  IS USPT
)@@G@@ED BY THE STATJOB SYSTEM TO BUFFER BCDTAPE IF   @C@@@@C                 PU
)@@G@@ PADDING CHECKING REQUIRES IT.@G@@@@C       UNIT 0 -   IS USED BY STATJOPV
)@@G@@B SYSTEM TO WRITE ADD FILE AND TAGS @E@@@@C                  OUT ON DISKPW
)@@G@@ TO PASS TO ANALYSIS PHASE.   @A@@@@C       UNIT 1 -   USED BY NWAY1    PX
)@@G@@@F@@@@C                  IN THE ANALYSIS PHASE TO HOLD SINGLE PRECISION PY
)@@G@@@G@@@@C                  VARIANCES THAT MUST BE SAVED FROM READ PHASE TOPZ
)@@G@@ THE  @A@@@@C                  MEANS PHASE.     @G@@@@C       UNIT 2 -  QA
)@@G@@ IS USED TO HOLD THE LABELS FOR THE ANOVA TABLE. THE  @G@@@@C           QB
)@@G@@       FORMAT OF THIS FILE IS AS FOLLOWS. THE FIRST WORD OF @G@@@@C     QC
)@@G@@             EACH ENTRY IS THE NUMBER OF WORDS IN THE ENTRY. THE  @G@@@@QD
)@@G@@C                  SUBSEQUENT N WORDS ARE WHAT TO PRINT ON A LINE OF THEQE
)@@G@@@B@@@@C                  TABLE, IN FIELDATA.    @[@@@@C     @^@@@@C*****QF
)@@G@@*************     @A@@@@      CALL S1CCFS(CCTABL,NCW,0,0)   @C@@@@      QG
)@@G@@CALL S1GTAG('S9INFO',INFO,NWE,NEL,$100)   @#@@@@        ITEST=0   @B@@@@QH
)@@G@@        CALL S1GVAL('TEST',ITEST,$10,$10) @#@@@@10      CONTINUE  @#@@@@QI
)@@G@@      GO TO 110   @^@@@@100   NCCERR=NCCERR+1   @C@@@@110   CALL S1GTAG(QJ
)@@G@@'S9CODE',ICOD,NWE,NEL,$120)   @#@@@@      GO TO 125   @ @@@@120   IF(NCCQK
)@@G@@ERR.GT.0)GO TO 125@#@@@@      IDUMY=0     @D@@@@      CALL S9DNPF(IDUMY,QL
)@@G@@IDUMY,IDUMY,IDUMY,NCCERR)     @#@@@@125   CONTINUE    @]@@[@      NEL=0 QM
)@@G@@@C@@@@      CALL S1GTAG('S9CODE',ICOD,NWE,NEL,$160)   @A@@@@C     DETERMQN
)@@G@@INE TOTAL STORAGE FOR   @^@@@@C          A.  READ     @^@@@@C          BQO
)@@G@@. ANALYSIS  @^@@@@C          C. MEANS     @#@@@@C     READ STORAGE@B@@@@QP
)@@G@@      CALL S1GVAL('NVARS',NV,$400,$400)   @#@@@@      NF=COM(INFO)@A@@@@QQ
)@@G@@      IF(COM(INFO+1).GT.0)NF=NF+1   @#@@@@      NSTOR1=NF   @B@@@@      QR
)@@G@@CALL S1GVAL('TEST',ITEST,$128,$128) @#@@@@128   CONTINUE    @^@@@@      QS
)@@G@@DO 130 I=1,NF     @A@@@@130   NSTOR1=NSTOR1+COM(INFO+9+I)   @#@@@@      QT
)@@G@@NSTID=NSTOR1@^@@@@      NDIM=COM(INFO+8)  @ @@@@      IF(NDIM.LT.4)NDIM=QU
)@@G@@4     @B@@@@      NSTOR1=NSTOR1+(1+3*NDIM)*COM(INFO+4)@B@@@@      NSTORRQV
)@@G@@=NSTOR1+2*NDIM*(COM(INFO+4)+2)@A@@@@      IF(ITEST.NE.0)PRINT 135,NSTORRQW
)@@G@@@E@@@@135   FORMAT('0 STORAGE REQUIRED FOR READ PHASE= ',I21)     @^@@@@QX
)@@G@@C     ANALYSIS STORAGE  @A@@@@      NSTOR1=NSTOR1+4*COM(INFO+4)   @#@@@@QY
)@@G@@      NSTOR=0     @^@@@@      ISHIFT=8**(12-NF) @^@@@@      DO 145 M=1,NQZ
)@@G@@EL    @ @@@@      K=COM(ICOD-1+M)*ISHIFT  @]@@@@      K=K*4 @#@@@@      RA
)@@G@@IFLAG=0     @#@@@@      ISTOR=1     @^@@@@      DO 140 J=1,NF     @A@@@@RB
)@@G@@      IF(FLD(0,1,K).EQ.0)GO TO 137  @ @@@@      IF(IFLAG.EQ.0)GO TO 140 RC
)@@G@@@A@@@@      ISTOR=ISTOR*COM(INFO+9+J)     @#@@@@      GO TO 140   @#@@@@RD
)@@G@@137   IFLAG=1     @]@@@@140   K=K*8 @ @@@@145   NSTOR=NSTOR+2*ISTOR+5   RE
)@@G@@@^@@@@      NSTOR=NSTOR+NEL   @^@@@@      NSTOR2=NEL*(NF+5) @A@@@@      RF
)@@G@@NSTOR=NSTOR2+NSTOR1+NSTOR     @A@@@@      IF(ITEST.NE.0)PRINT 150,NSTOR RG
)@@G@@@E@@@@150   FORMAT('0 STORAGE REQUIRED FOR ANALYSIS PHASE= ',I17) @^@@@@RH
)@@G@@C     MEANS STORAGE     @#@@@@      NSTOR3=0    @C@@@@      CALL S1GVAL(RI
)@@G@@'NSTOR',NSTOR3,$160,$160)     @B@@@@      NSTOR3=NDIM+5*NSTOR3+NSTOR2+NSRJ
)@@G@@TOR1  @#@@@@      IDATSB=0    @C@@@@      CALL S1GVAL('DATSUB',IDATSB,$1RK
)@@G@@52,$152)    @C@@@@ 152  IF(IDATSB .NE. 0) NSTOR3=NSTOR3+3*NDIM    @A@@@@RL
)@@G@@      IF(ITEST.NE.0)PRINT 155,NSTOR3@D@@@@C ONE MORE WORD FOR MORE STORARM
)@@G@@GE IN ALALYSIS NOW.     @^@@@@        NSTOR3=NSTOR3+1 @E@@@@155   FORMATRN
)@@G@@('0 STORAGE REQUIRED FOR MEANS PHASE= ',I20)    @B@@@@160   IF(NSTOR3.GTRO
)@@G@@.NSTOR)NSTOR=NSTOR3     @B@@@@      IF(NSTORR.GT.NSTOR)NSTOR=NSTORR     RP
)@@G@@@#@@@@      NVEC(1)=NV  @^@@@@      NVEC(2)=NSTID     @^@@@@      NVEC(3RQ
)@@G@@)=NSTID     @^@@@@      NVEC(4)=NSTOR     @#@@[@      EMSCOR=0    @B@@[@RR
)@@G@@      CALL S1GTAG('EMS',DUM,DUM,DUM,$200) @ @@[@      EMSCOR=NEL*(NEL+1)RS
)@@G@@/2    @^@@[@ 200  NVEC(5)=EMSCOR    @^@@[@      NVEC(6)=EMSCOR    @ @@[@RT
)@@G@@      CALL S1STOR(6,NVEC)     @^[@@@      COM(INFO+9)=NSTOR @#@@@@400   RU
)@@G@@CONTINUE    @]@@@@      RETURN@[@@@@C     @]@@@@      END   ___   GO TO RV
)@@G@@125   @ @@@@120   IF(NCC*[S@@@*SDFF*@^@@@@      SUBROUTINE S1IDCK @ @@@@RW
)@@G@@      IMPLICIT INTEGER (A-Z)  @[@@@@C     @G@@@@C        SUBROUTINE TO TRX
)@@G@@EST IDVAR SPECIFIED ON THE INPUT CONTROL CARD.  @[@@@@C     @^@@@@      RY
)@@G@@INCLUDE CCI,LIST  @[@@@@C     @#@@@@      COMMON X(1) @[@@@@C     @B@@@@RZ
)@@G@@      CALL S1GTAG('IDVAR',FW,NWE,NEL,$100)@A@@@@      IF(X(FW) .EQ. 4) GSA
)@@G@@O TO 30     @A@@@@      IF(X(FW) .NE. 1) GO TO 100    @#@@@@      VI=X(FSB
)@@G@@W+1)  @ @@@@      CALL S1CKVI(VI,$20)     @#@@@@      GO TO 50    @B@@@@SC
)@@G@@ 20   CALL S1MSG4(366,VI,'IDVAR','      ')@^@@@@ 25   NCCERR=NCCERR+1   SD
)@@G@@@#@@@@      GO TO 100   @A@@@@ 30   CALL S1CKVN(X(FW+1),VI,$40)   @#@@@@SE
)@@G@@      GO TO 50    @E@@@@ 40   CALL S1MSG5(367,X(FW+1),X(FW+2),'IDVAR',' SF
)@@G@@     ')     @#@@@@      GO TO 25    @#@@[@ 50   X(FW)=VI*2  @A[@@@      SG
)@@G@@CALL S1GTVT(VI,VTYP,$100)     @A@@[@      IF(VTYP .EQ. 1) X(FW)=X(FW)+1 SH
)@@G@@@]A@@@ 100  RETURN@]@@@@      END   ___@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SI
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SJ
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@*[@@@@*SDFF*@C@@@@      SUBROUTINE S11CCV(NUMVARSK
)@@G@@,IFLD,NCARD,NERR) @A@@@@      DIMENSION IFLD(11),IFLDS(12)  @#@@@@      SL
)@@G@@COMMON X(1) @ @@@@      IMPLICIT INTEGER(A-Z)   @^@@@@      DATA NOVARL/SM
)@@G@@0/    @[@@@@C     @D@@[@C        THIS SUBROUTINE PROCESSES THE VLABEL CASN
)@@G@@RD    @[[@@@C     @ @@@@      IF(NOVARL.NE.0)  GO TO 2@B@@@@      CALL SSO
)@@G@@1STFT('NOVARL',LVARL,1,1,$999)@A@@@@    2 IF(NCARD.EQ.1)   GO TO 10     SP
)@@G@@@#@@@@      NERR=NERR+1 @^@@[@      CALL S1PCHD(1)    @#@@@@      PRINT SQ
)@@G@@5     @G@@[@ 5    FORMAT(' ***** PICT1 ERROR.  CONTINUATION CARDS ARE NOSR
)@@G@@T ALLOWED FO@ @@[@     -R THE VLABEL CARD')     @E#@@@   10 IF(NOVARL.EQSS
)@@G@@.0)   CALL S1IODR(2,'REWIND',0,AREA,LEND) @ @@[@      IF(NUMVAR .EQ. 0) ST
)@@G@@RETURN@ @@[@      CALL S1CKVI(NUMVAR,$800)@^@@@@      IFLDS(1)=NUMVAR   SU
)@@G@@@#@@@@      DO 15 I=1,11@^@@@@   15 IFLDS(I+1)=IFLD(I)@B@@@@      CALL SSV
)@@G@@1IODR(2,'WRITE',12,IFLDS,LEND)@^@@@@      NOVARL=NOVARL+1   @^@@@@      SW
)@@G@@X(LVARL)=NOVARL   @]@@@@      RETURN@#@@[@ 800  NERR=NERR+1 @^@@[@      SX
)@@G@@CALL S1PCHD(1)    @^@@[@      PRINT 810,NUMVAR  @G@@[@ 810  FORMAT(' ***SY
)@@G@@** PICT1 ERROR.  THERE IS NO VARIABLE NUMBER',I8)     @]@@[@      RETURNSZ
)@@G@@@#@@@@  999 PRINT 998   @D@@@@  998 FORMAT('0***** LACK OF SPACE IN BLANTA
)@@G@@K COMMON')  @]@@@@      RETURN@]@@@@      END   ___@@@@@@@@@@@@@@@@@@@@@TB
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TC
)@@G@@*[S@@@*SDFF*@E@@@@      SUBROUTINE S17HST(NCARD,IFLD,SCR,SCR1,LSCR,NERR,TD
)@@G@@$)    @D@@@@      DIMENSION IFLD(2),SCR(2),TABLE(60),CTYPE(2)     @A@@@@TE
)@@G@@      DIMENSION NAME(2),FLGARR(100) @C@@@@      DIMENSION WADDR(100),INTTF
)@@G@@MAX(100),ADDR(100)@^@@@@      INCLUDE CCI,LIST  @#@@@@      COMMON  X(2)TG
)@@G@@@C@@@@      INTEGER ADDR,WADDR,SCR, CONST,FLGARR,TABLE@B@@@@      EQUIVATH
)@@G@@LENCE (IMIN,VMIN),(IMAX,VMAX) @A@@@@      DIMENSION ADDR1(100),SCR1(600)TI
)@@G@@@G@@@@      EQUIVALENCE (BASE1,NBASE),   (ADDR(1),ADDR1(1)),(STOR1,MSTORTJ
)@@G@@)     @#@@@@      LOGICAL OTF @E@@@@      DATA CTYPE(1)/4HHIST/,ISTAN/30TK
)@@G@@/,MAXST/ 700/,CONST/10/ @ @@@@      DATA (TABLE(I),I=1,60)/ @E@@@@     *TL
)@@G@@7HNODIST ,-2,6,1,105   ,0,31,-999999999,999999999,    @E@@@@     *7HNORMTM
)@@G@@AL ,-2,6, 701,105   ,0,31,-999999999,999999999, @E@@@@     *7HBETA   ,-2TN
)@@G@@,6,1401,105   ,0,31,-999999999,999999999, @E@@@@     *7HGAMMA  ,-2,6,210TO
)@@G@@1,105   ,0,31,-999999999,999999999, @E@@@@     *7HPOISSON,-2,6,2801,105 TP
)@@G@@  ,0,31,-999999999,999999999, @D@@@@     *7HALPHA  ,-2,0,3501,105   ,1,-TQ
)@@G@@1,1,999999999/    @]@@@@      HELP=0@]@@@@      NERR=0@#@@@@      NBASE=TR
)@@G@@1     @#@@@@      ITEST=0     @B@@@@      CALL S1GVAL('TEST',ITEST,$10,$TS
)@@G@@10)   @#@@@@   10 NVARS1=NVARS@A@@@@      IF(NTVARS.NE.0)NVARS1=NTVARS  TT
)@@G@@@A@@@@      IF(NVARS1.LE.100)GO TO 15     @^@@@@      CALL S1PCHD(2)    TU
)@@G@@@^@@@@      PRINT 9999,NVARS1 @G@@@@9999  FORMAT('0*****UNISTAT1 ERROR. TV
)@@G@@A MAXIMUM OF 100 VARIABLES IS ALLOWE@ @@@@     *D. NO. OF VARS=',I5)    TW
)@@G@@@#@@@@      NERR=NERR+1 @#@@@@      NVARS1=100  @#@@@@15    CONTINUE    TX
)@@G@@@E@@@@      CALL S1ENDC(CTYPE,IFLD,NCARD,SCR,LSCR,LEND,NERR1,$997)@^@@@@TY
)@@G@@      NERR=NERR+NERR1   @ @@@@      IBEG=MAX(LEND+1,601)    @^@@@@      TZ
)@@G@@LLSCR=LSCR-IBEG+1 @F@@@@      CALL S1ENST(CTYPE,SCR,LEND,TABLE,6,0,SCR(IUA
)@@G@@BEG),LLSCR,TSTOR, @]@@@@     *NERR1)@^@@@@      NERR=NERR+NERR1   @^@@@@UB
)@@G@@      DO 20 J=1,NVARS1  @#@@@@      ADDR(J)=0   @#@@@@      WADDR(J)=0  UC
)@@G@@@#@@@@   20 INTMAX(J)=0 @[@@@@C     @G@@@@C        FLAG IN FLGARR IS SETUD
)@@G@@ TO 1 FOR ALPHANUMERIC,SET TO 0 FOR NUM.  @#@@@@C        VARIABLES@[@@@@UE
)@@G@@C     @^@@@@      DO 25 J=1,NVARS1  @^@@[@      CALL S1CKVI(J,$26)@ @@[@UF
)@@G@@      CALL S1GTVT(J,ITYPE,$26)@^[@@@      FLGARR(J)=ITYPE-1 @#@@@@   25 UG
)@@G@@CONTINUE    @#@@[@26    CONTINUE    @[@@@@C     @C@@@@C        IF OTF OPUH
)@@G@@TION NOT USED OTF IS TRUE     @#@@@@      OTF=.TRUE.  @B@@@@      CALL SUI
)@@G@@1GVAL('OTF',IDUM,$30,$30)     @#@@@@      OTF=.FALSE. @[@@@@C     @E@@@@UJ
)@@G@@C        LOOP TO SEARCH FOR ALL CONTROL WORDS EXCEPT ALPHA  @A@@@@C     UK
)@@G@@   I IS DISTRIBUTION TYPE     @[@@@@C     @#@@@@   30 II=IBEG     @#@@@@UL
)@@G@@      DO 200 I=1,5@[@@@@C     @D@@@@C        J IS NUMBER OF REPETITIONS UM
)@@G@@OF A CONTROL WORD @[@@@@C     @#@@@@      J=SCR(II)   @ @@@@      IF(J.EUN
)@@G@@Q.0) GO TO 185    @#@@@@   35 JBEG=II+3   @#@@@@      DO 180 K=1,J@#@@@@UO
)@@G@@      JJ=JBEG     @[@@@@C     @C@@@@C        LOOP ON REPETITIONS OF A COUP
)@@G@@NTROL WORD  @[@@@@C     @]@@@@      NMOD=0@^@@@@      NMODF=SCR(JJ-1)   UQ
)@@G@@@[@@@@C     @D@@@@C        NMODF IS EQUAL TO NUMBER OF MODIFIERS FOUND  UR
)@@G@@@[@@@@C     @D@@@@C        FIND OUT WHICH INTERVAL TYPE IS SPECIFIED    US
)@@G@@@[@@@@C     @ @@@@      IF(NMODF.NE.0) GO TO 50 @B@@@@      IF(.NOT.OTF UT
)@@G@@.AND. I.NE.5) CALL ERR1 @ @@@@      DO 40 IVAR =1,NVARS1    @A@@@@      UU
)@@G@@IF(FLGARR(IVAR).NE.0) GO TO 40@#@@@@      INNUM=ISTAN @#@@@@      INTYPEUV
)@@G@@=1    @#@@@@      CALL PUTVAR @#@@@@   40 CONTINUE    @#@@@@      GO TO UW
)@@G@@170   @A@@@@   50 IF(NMODF.EQ.NMOD) GO TO 70    @#@@@@      IDUM=SCR(JJ)UX
)@@G@@@#@@@@      NMOD=NMOD+1 @ @@@@      IF(IDUM.NE.1) GO TO 60  @#@@@@      UY
)@@G@@JJ=JJ+2     @#@@@@      GO TO 50    @ @@@@   60 IF(IDUM.NE.3) GO TO 65  UZ
)@@G@@@#@@@@      JJ=JJ+3     @#@@@@      GO TO 50    @ @@@@   65 IF(IDUM.NE.4VA
)@@G@@) GO TO 68  @#@@@@      JJ=JJ+3     @#@@@@      GO TO 50    @ @@@@   68 VB
)@@G@@IF(IDUM.NE.5) GO TO 997 @ @@@@   70 IF(NMODF-NMOD-1) ,80,75 @B@@@@      VC
)@@G@@IF(.NOT.OTF .AND. I.NE.5) CALL ERR1 @#@@@@      INNUM=ISTAN @#@@@@      VD
)@@G@@INTYPE=1    @#@@@@      GO TO 100   @#@@@@   75 INTYPE=3    @A@@@@      VE
)@@G@@IF(SCR(JJ+3).NE.5) GO TO 71   @ @@@@      IF(NMODF-NMOD-4) ,76    @#@@@@VF
)@@G@@   71 NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      PRINT 1000  VG
)@@G@@@#@@@@      GO TO 185   @^@@@@   76 IMIN=SCR(JJ+5)    @^@@@@      IMAX=SVH
)@@G@@CR(JJ+7)    @A@@@@      IF(SCR(JJ+4).EQ.1) VMIN=IMIN  @A@@@@      IF(SCRVI
)@@G@@(JJ+6).EQ.1) VMAX=IMAX  @ @@@@      IF(VMIN-VMAX)90,,79     @#@@@@      VJ
)@@G@@NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      PRINT 530   @G@@@@VK
)@@G@@  530 FORMAT('0*****UNISTAT1 ERROR.MINIMUM AND MAXIMUM SPECIFIED ON HISTVL
)@@G@@@A@@@@     * CARD SHOULD NOT BE EQUAL.')  @#@@@@  79  DUM=VMIN    @#@@@@VM
)@@G@@      VMIN=VMAX   @#@@@@      VMAX=DUM    @#@@@@      GO TO 90    @#@@@@VN
)@@G@@   80 INTYPE=2    @B@@@@      IF(.NOT.OTF .AND. I.NE.5) CALL ERR1 @^@@@@VO
)@@G@@   90 INNUM=SCR(JJ+2)   @[@@@@C     @A@@@@C        NOW STORE ALL INFORMAVP
)@@G@@TION  @[@@@@C     @#@@@@  100 JJ=JBEG     @]@@@@      NMOD=0@A@@@@  110 VQ
)@@G@@IF(NMOD.EQ.NMODF) GO TO 170   @#@@@@      IDUM=SCR(JJ)@#@@@@      NMOD=NVR
)@@G@@MOD+1 @ @@@@      IF(IDUM.NE.1) GO TO 120 @^@@@@      IVAR=SCR(JJ+1)    VS
)@@G@@@#@@@@      JJ=JJ+2     @C@@@@111   IF(IVAR.GT.0.AND.IVAR.LE.100)GO TO 1VT
)@@G@@16    @#@@@@  115 CALL ERR2   @#@@@@      GO TO 110   @B@@@@  116 IF(FLGVU
)@@G@@ARR(IVAR).EQ.0) GO TO 117     @#@@@@      CALL ERR3   @#@@@@      GO TO VV
)@@G@@110   @#@@@@  117 CALL PUTVAR @#@@@@      GO TO 110   @ @@@@  120 IF(IDUVW
)@@G@@M.NE.3) GO TO 150 @^@@@@      IN1=SCR(JJ+1)     @^@@@@      IN2=SCR(JJ+2VX
)@@G@@)     @#@@@@      JJ=JJ+3     @B@@@@      IF(IN1.GT.0.AND.IN2.LE.100)GO VY
)@@G@@TO 121@^@@@@      CALL S1PCHD(2)    @^@@@@      PRINT 9998,IN1,IN2@G@@@@VZ
)@@G@@9998  FORMAT('0*****UNISTAT1 ERROR. THE MODIFIER',I4,'-',I4,' REFERS TO WA
)@@G@@@D@@@@     *A VARIABLE NUMBER OUTSIDE THE RANGE 1-100')     @#@@@@      WB
)@@G@@NERR=NERR+1 @#@@@@      GO TO 110   @#@@@@121   CONTINUE    @ @@@@      WC
)@@G@@DO 140 IVAR=IN1,IN2     @B@@@@  135 IF(FLGARR(IVAR).EQ.0) GO TO 136     WD
)@@G@@@#@@@@      CALL ERR3   @#@@@@      GO TO 140   @#@@@@  136 CALL PUTVAR WE
)@@G@@@#@@@@  140 CONTINUE    @#@@@@      GO TO 110   @ @@@@  150 IF(IDUM.NE.4WF
)@@G@@) GO TO 160 @^@@@@      NAME(1)=SCR(JJ+1) @^@@@@      NAME(2)=SCR(JJ+2) WG
)@@G@@@#@@@@      JJ=JJ+3     @A@@@@      CALL S1CKVN(NAME,IVAR,$154)   @#@@@@WH
)@@G@@      GO TO 111   @#@@@@  154 NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    WI
)@@G@@@^@@@@      PRINT 570,NAME    @#@@@@      GO TO 110   @ @@@@  160 IF(IDUWJ
)@@G@@M.NE.5) GO TO 165 @#@@@@      JJ=JJ+3     @ @@@@      IF(INTYPE.EQ.3) JJWK
)@@G@@=JJ+5 @#@@@@      GO TO 170   @#@@@@  165 NERR=NERR+1 @^@@@@      CALL SWL
)@@G@@1PCHD(2)    @#@@@@      PRINT 1000  @#@@@@  170 JBEG=JJ+2   @#@@@@  180 WM
)@@G@@CONTINUE    @#@@@@  185 II=II+MAXST @#@@@@  200 CONTINUE    @[@@@@C     WN
)@@G@@@B@@@@C        PROCESSING OF ALPHA CONTROL WORD @A@@@@C        J IS NUMBWO
)@@G@@ER OF REPETITIONS @[@@@@C     @#@@@@      J=SCR(II)   @ @@@@      IF(J.EWP
)@@G@@Q.0) GO TO 245    @#@@@@      JJ=II+1     @#@@@@      DO 240 K=1,J@^@@@@WQ
)@@G@@      NMODF=SCR(JJ)     @#@@@@      JJ=JJ+1     @^@@@@  220 DO 230 KK=1,WR
)@@G@@NMODF @#@@@@      IVAR=SCR(JJ)@B@@@@      IF(FLGARR(IVAR).EQ.0) GO TO 63WS
)@@G@@0     @#@@@@      CALL PUTALP @#@@@@  229 JJ=JJ+1     @#@@@@  230 CONTINWT
)@@G@@UE    @#@@@@  240 CONTINUE    @^@@@@  245 NBASE=NBASE-1     @^@@@@      WU
)@@G@@NW=NBASE+NVARS1   @B@@@@      CALL S1STFT('HIST',IDUM,1,NW,$997)  @[@@@@WV
)@@G@@C     @F@@@@C        ADDR1 IS STILL INTEGER ALTHOUGH STORED IN REAL ARRAWW
)@@G@@Y     @F@@@@C        SCR1 IS REAL, MIN AND MAX ARE SO ALWAYS STORED AS RWX
)@@G@@EAL   @[@@@@C     @^@@@@      DO 300 I=1,NVARS1 @^@@@@      X(IDUM)=ADDRWY
)@@G@@1(I)  @#@@@@      IDUM=IDUM+1 @#@@@@  300 CONTINUE    @^@@@@      DO 320WZ
)@@G@@ I=1,NBASE  @^@@@@      X(IDUM)=SCR1(I)   @#@@@@      IDUM=IDUM+1 @#@@@@XA
)@@G@@  320 CONTINUE    @#@@@@      MSTOR=0     @ @@@@      IF(.NOT.OTF) GO TOXB
)@@G@@ 360  @^@@@@      DO 340 I=1,NVARS1 @^@@@@      IDUM=INTMAX(I)    @A@@@@XC
)@@G@@      IF(IDUM.GT.MSTOR) MSTOR=IDUM  @#@@@@  340 CONTINUE    @#@@@@      XD
)@@G@@GO TO 380   @^@@@@  360 DO 365 I=1,NVARS1 @ @@@@      MSTOR=MSTOR+INTMAXXE
)@@G@@(I)   @#@@@@  365 CONTINUE    @B@@@@  380 CALL S1STFT('MSTOR',IDUM,1,2,$XF
)@@G@@997)  @[@@@@C     @C@@@@C        STOR1 AND BASE1 CONTAIN INTEGER VALUES XG
)@@G@@@[@@@@C     @^@@@@      X(IDUM)=STOR1     @^@@@@      X(IDUM+1)=BASE1   XH
)@@G@@@ @@@@      IF(ITEST.EQ.0) RETURN   @A@@@@      PRINT 321,(ADDR(I),I=1,NXI
)@@G@@VARS1)@A@@@@      PRINT 321,(SCR(I),I=1,NBASE)  @ @@@@      PRINT 341,MSXJ
)@@G@@TOR,NBASE   @ @@@@  321 FORMAT((10(1X,O12)))    @^@@@@  341 FORMAT(10I12XK
)@@G@@)     @]@@@@      RETURN@G@@@@  570 FORMAT('0*****UNISTAT1 ERROR. ',2A6,XL
)@@G@@' IS NOT A VARIABLE NAME.')   @#@@@@  630 NERR=NERR+1 @^@@@@      CALL SXM
)@@G@@1PCHD(2)    @^@@@@      PRINT 650,IVAR    @G@@@@  650 FORMAT('0*****UNISXN
)@@G@@TAT1 ERROR. VARIABLE NO.',I3,' IS NOT AN ALPHANU@F@@@@     *MERIC VARIABXO
)@@G@@LE BUT APPEARED IN ALPHA LIST ON HIST CARD.')   @#@@@@      GO TO 229   XP
)@@G@@@^@@@@997     NERR=NERR+1     @ @@@@        CALL S1SERR('S17HST') @G@@@@XQ
)@@G@@ 1000 FORMAT('0*****UNISTAT1 ERROR.SLASHES ON HIST CARD DO NOT MATCH.') XR
)@@G@@@#@@@@      RETURN 7    @^@@@@      SUBROUTINE ERR1   @#@@@@      NERR=NXS
)@@G@@ERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      PRINT 510   @G@@@@  510 XT
)@@G@@FORMAT('0*****UNISTAT1 ERROR. USING OTF OPTION MIN AND MAX MUST BE@A@@@@XU
)@@G@@     * SPECIFIED ON HIST CARD.')    @]@@@@      RETURN@^@@@@      SUBROUXV
)@@G@@TINE ERR2   @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @^@@@@XW
)@@G@@      PRINT 540,IVAR    @G@@@@  540 FORMAT('0*****UNISTAT1 ERROR.VALUE 'XX
)@@G@@,I10,' IS NOT VARIABLE NUMBER.@]@@@@     *')    @]@@@@      RETURN@^@@@@XY
)@@G@@      SUBROUTINE ERR3   @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(XZ
)@@G@@2)    @^@@@@      ID2 =(I-1)*10+1   @#@@@@      ID1=ID2 +1  @C@@@@      YA
)@@G@@PRINT 610,IVAR,TABLE(ID2 ),TABLE(ID1)     @G@@@@  610 FORMAT('0*****UNISYB
)@@G@@TAT1 ERROR.VARIABLE NO.',I3,' IS NOT A NUMERIC V@F@@@@     *ARIABLE BUT YC
)@@G@@APPEARED IN ',A6,A1, ' LIST ON HIST CARD.')     @]@@@@      RETURN@[@@@@YD
)@@G@@C     @ @@@@C        INTERNAL SUBROUTINE  @[@@@@C     @^@@@@      SUBROUYE
)@@G@@TINE PUTVAR @A@@@@ 2000 IF(ADDR(IVAR).EQ.0) GO TO 2010@^@@@@      INDEX=YF
)@@G@@WADDR(IVAR) @A@@@@      FLD(18,18,SCR1(INDEX))=NBASE  @^@@@@ 2005 FLD(0,YG
)@@G@@6, HELP)=I  @ @@@@      FLD(6,6, HELP)=INTYPE   @C@@@@      IF(INTYPE.EQYH
)@@G@@.1 .AND. I.EQ.5) INNUM=38     @A@@@@      IF(INNUM.EQ.0) GO TO 2012     YI
)@@G@@@A@@@@      IF(INNUM.GT.38)GO TO 2015     @ @@@@      FLD(12,6, HELP)=INYJ
)@@G@@NUM   @^@@@@      SCR1(NBASE)=HELP  @^@@@@      WADDR(IVAR)=NBASE @C@@@@YK
)@@G@@      INTMAX(IVAR)=INTMAX(IVAR)+CONST+INNUM+1   @^@@@@      NBASE=NBASE+YL
)@@G@@1     @ @@@@      IF(INTYPE.NE.3) RETURN  @ @@@@      IF(I.NE.5) GO TO 2YM
)@@G@@007   @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      YN
)@@G@@PRINT 2006  @G@@@@ 2006 FORMAT('0*****UNISTAT1 ERROR. MIN AND MAX SHOULDYO
)@@G@@ NOT BE SPECIFIED @A@@@@     *WITH POISSON CONTROL WORD.')  @^@@@@ 2007 YP
)@@G@@SCR1(NBASE)=VMIN  @^@@@@      SCR1(NBASE+1)=VMAX@^@@@@      NBASE=NBASE+YQ
)@@G@@2     @]@@@@      RETURN@^@@@@ 2010 ADDR(IVAR)=NBASE  @#@@@@      GO TO YR
)@@G@@2005  @#@@@@ 2012 NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      YS
)@@G@@PRINT 2013  @G@@@@ 2013 FORMAT('0*****UNISTAT1 ERROR. NUMBER OF INTERVALYT
)@@G@@S SPECIFIED SHOULD@^@@@@     * NOT BE ZERO.')   @]@@@@      RETURN@#@@@@YU
)@@G@@2015  NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      PRINT 2016  YV
)@@G@@@G@@@@2016  FORMAT('0*****UNISTAT1 ERROR. NUMBER OF INTERVALS SPECIFIED YW
)@@G@@SHOULD@^@@@@     X NOT EXCEED 38 .')@]@@@@      RETURN@[@@@@C     @ @@@@YX
)@@G@@C        INTERNAL SUBROUTINE  @[@@@@C     @^@@@@      SUBROUTINE PUTALP YY
)@@G@@@A@@@@      IF(ADDR(IVAR).NE.0) GO TO 3030@^@@@@ 3020 ADDR(IVAR)=NBASE  YZ
)@@G@@@^@@@@      SCR1(NBASE)=0     @ @@@@      FLD(0,6,SCR1(NBASE))=6  @^@@@@ZA
)@@G@@      NBASE=NBASE+1     @]@@@@ 3030 RETURN@]@@@@      END   ___     CALLZB
)@@G@@ S1SERR('S17HST') @G@@@@ 1000 FORMAT('0*****UNISTAT1 ERROR.SLASHES ON HIZC
)@@G@@ST CARD DO NOT MATCH.') *[S@@@*SDFF*@D@@@@      SUBROUTINE S82CMP(CN,CARZD
)@@G@@D,NC,SCR,LSCR,NERR,$)   @ @@@@      IMPLICIT INTEGER (A-Z)  @ @@@@      ZE
)@@G@@DIMENSION CARD(1),SCR(1)@[@@@@C     @B@@@@C        ONEWAY2 COMPARE CARD ZF
)@@G@@PROCESSOR.  @[@@@@C     @G@@@@C        COMPARE SPECIFICATIONS ARE WRITTEZG
)@@G@@N ON UNIT 6, AS FOLLOWS -     @ @@@@C             1.  MODEL NUMBER@B@@@@ZH
)@@G@@C             2.  NUMBER OF SIMPLE EFFECTS@E@@@@C             3.  POINTEZI
)@@G@@R TO FIRST SIMPLE EFFECTS SPECS     @D@@@@C             4.  NUMBER OF TTZJ
)@@G@@ESTS WITH MODIFIERS     @D@@@@C             5.  NUMBER OF TTESTS WITHOUTZK
)@@G@@ MODIFIERS  @C@@@@C             6.  POINTER TO FIRST TTESTS SPECS @A@@@@ZL
)@@G@@C             7.  NUMBER OF CONTRAST@D@@@@C             8.  POINTER TO FZM
)@@G@@IRST CONTRAST SPECS     @A@@@@C             9.  NON-ZERO IF POLYS @B@@@@ZN
)@@G@@C            10.  Q SPECIFIED WITH POLYS  @E@@@@C            11.  NUMBERZO
)@@G@@ OF R-VALUES SPECIFIED WITH POLYS   @B@@@@C            12.  POINTER TO FZP
)@@G@@IRST R-VALUE@B@@@@C            13.  NON-ZERO IF POOLERROR   @B@@@@C     ZQ
)@@G@@       14.  NUMBER OF CI MODIFIERS  @ @@@@C            15.  CI PERCENT  ZR
)@@G@@@A@@@@C            16.  NUMBER OF ORTHOCON@D@@@@C            17.  POINTEZS
)@@G@@R TO FIRST ORTHOCON SPECS     @A@@@@C            18.  NUMBER OF RANGE   ZT
)@@G@@@C@@@@C            19.  POINTER TO FIRST RANGE SPECS  @D@@@@C           ZU
)@@G@@ 19.5 TOTAL NUMBER OF REMAINING SPECS     @G@@@@C            20.  SIMPLEZV
)@@G@@ EFFECTS SPECS - EACH BEGINS WITH THE NUMBER OF @G@@@@C                 ZW
)@@G@@ ENTRIES AND CONSISTS OF INTEGERS AND 0 FOR SLASH     @G@@@@C           ZX
)@@G@@ 21.  TTESTS SPECS - EACH CONSISTS OF    # IN GROUP1, FLAG  @G@@@@C     ZY
)@@G@@             FOR AVERAGE GROUP1, # IN GROUP2, FLAG FOR AVERAGE    @F@@@@ZZ
)@@G@@C                  GROUP2, THE CELL NUMBERS FOR GROUP1 AND GROUP2 @G@@@@AA
)@@G@@C            22.  CONTRASTS SPECS  - EACH BEGINS WITH THE NUMBER OF     AB
)@@G@@@D@@@@C                  ENTRIES AND CONSISTS OF REAL VALUES@A@@@@C     AC
)@@G@@       23.  POLYS SPACINGS    @G@@@@C            24.  ORTHOG SPECS - EACAD
)@@G@@H BEGINS WITH THE NUMBER OF ENTRIES @F@@@@C                  AND CONSISTAE
)@@G@@S OF INTEGER POINTERS TO CONTRASTS  @ @@@@C            25.  RANGE VALUESAF
)@@G@@@[@@@@C     @[@@@@C     @[@@@@C     @[@@@@C     @A@@@@      COMMON /S82BAG
)@@G@@LK/ LCCT,LCCN,    @D@@@@     -   NSCALE,SCALNO(400),SCALTP(400),SCALEN(4AH
)@@G@@00),  @A@@@@     -   VARSCL(500),VARLIM,VAROVF, @ @@@@     -   MDATA,NWHAI
)@@G@@EAD,NSCOUT, @ @@@@     -   NMODEL,NWMODL,NCOORD,@B@@@@     -   MODNO,NFAAJ
)@@G@@CT,NCELL,NDEPV,NDVGRP,  @ @@@@     -   NTABS,NDVTOT,NGRTOT, @ @@@@     -AK
)@@G@@   HISTAT,MMCOR,NHISTS, @A@@@@     -   DATSAV,CDSAV(5),DVSAV(30), @A@@@@AL
)@@G@@     -   BAVAR,BABUF,OSIZEM,OSIZEC, @B@@@@     -   TA(400),TB(400),TC(40AM
)@@G@@0),TW(400)  @[@@@@C     @^@@@@      COMMON BLCOM(2)   @[@@@@C     @ @@@@AN
)@@G@@      DIMENSION CWSPEC(76)    @^@@@@      DATA CWSPEC /     @D@@@@     1AO
)@@G@@   12HSIMEFF       ,-2,0,1,100,1,21,1,1000,     @D@@[@     2   12HTTESTSAP
)@@G@@       ,-2,0,451,100,0,29,1,1000,   @F@@[@     3   12HCONTRAST     ,-2,0AQ
)@@G@@,1801,200,1,3,-999999999,999999999, @F]@@@     4   12HPOLYS        ,2,0,AR
)@@G@@901,300,0,19,-999999999,999999999,  @C@@@@     5   12HCI           ,2,0,AS
)@@G@@1201,2,1,11,0,100,@B@@@@     6   12HPOOLERROR    ,2,0,1210,0,     @D@@@@AT
)@@G@@     7   12HORTHOCON     ,-3,3,1212,100,2,1,1,100,    @E@@[@     8   12HAU
)@@G@@RANGE        ,2,0,1501,295,1,3,0,999999999/     @[[@@@C     @[@@@@C     AV
)@@G@@@ @@@@      DIMENSION SVSPEC(19)    @^@@@@      DIMENSION INFO(2) @#@@@@AW
)@@G@@      REAL RVAL   @ @@@@      EQUIVALENCE (IVAL,RVAL) @[@@@@C     @^@@@@AX
)@@G@@C             INITIALIZE@[@@@@C     @]@@@@      NERR=0@^@@@@      SVSPECAY
)@@G@@(1)=MODNO   @#@@@@      FACMES=0    @[@@@@C     @B@@@@C             DECOAZ
)@@G@@DE AND CHECK THE CARD   @[@@@@C     @#@@[@      LAST=2400   @#@@[@      BA
)@@G@@LS=LAST+1   @G@@[@      CALL S1ENDC('COMPARE',CARD,NC,SCR(LS),LSCR-LAST,BB
)@@G@@LEND,NE,$999)     @#]@@@      NERR=NERR+NE@]@@@@      L=LS  @B@@[@ 50   BC
)@@G@@IF(L .GT. LAST + LEND) GO TO 80     @#[@@@      TYP=SCR(L)  @]@@@@      BD
)@@G@@L=L+1 @ @@@@      IF(TYP .GT. 0) GO TO 60 @B@@@@      IF(SCR(L) .NE. 'SIBE
)@@G@@MPLE') GO TO 65   @G@@@@      IF(SCR(L+1) .NE. 'FFECTS'  .AND.  SCR(L+1)BF
)@@G@@ .NE. 'FFECT') GO TO 65 @^@@@@      SCR(L)='SIMEFF'   @^@@@@      SCR(L+BG
)@@G@@1)='      ' @#@@@@      GO TO 65    @ @@@@ 60   IF(TYP .GT. 5) GO TO 80 BH
)@@G@@@A@@@@      GO TO (70,70,65,65,50), TYP   @]@@@@ 65   L=L+1 @]@@@@ 70   BI
)@@G@@L=L+1 @#@@@@      GO TO 50    @#@@@@ 80   CONTINUE    @G@@[@      CALL SBJ
)@@G@@1ENST('COMPARE',SCR(LAST+1),LEND,CWSPEC,8,0,SCR(1),LAST,    @#[@@@     -BK
)@@G@@   DUM,NE)  @#@@@@      NERR=NERR+NE@E@@[@      IF(SCR(449) .NE. 0  .OR.BL
)@@G@@  SCR(450) .NE. 0) GO TO 90   @E@@[@      IF(SCR(899) .NE. 0  .OR.  SCR(BM
)@@G@@900) .NE. 0) GO TO 90   @F@@[@      IF(SCR(2399) .EQ. 0  .AND.  SCR(2400BN
)@@G@@) .EQ. 0) GO TO 100     @#@@[@ 90   CALL ERROR  @#@@[@      PRINT 9095  BO
)@@G@@@G@@[@ 9095 FORMAT(' ***** ONEWAY2 ERROR.  THERE ARE TOO MANY SIMEFF, TTBP
)@@G@@EST, O@G@@[@     -R CONTRAST SPECIFICATIONS FOR ONE SET OF COMPARE CARDSBQ
)@@G@@.'/25X,     @G@@[@     -'REWRITE THE PROGRAM SO THE SPECIFICATIONS ARE DBR
)@@G@@IVIDED BETWEEN SEV@A@@[@     -ERAL SETS OF COMPARE CARDS.') @]@@[@      BS
)@@G@@RETURN@[@@@@C     @B@@@@C             CHECK SIMPLEFFECTS SPECS    @[@@@@BT
)@@G@@C     @#@@@@ 100  NCW=SCR(1)  @]@@@@      L=2   @^@@@@      SVSPEC(2)=NCBU
)@@G@@W     @^@@[@      SVSPEC(3)=LS-LAST @ [@@@      IF(NCW .EQ. 0) GO TO 200BV
)@@G@@@#@@@@      CELERR=0    @#@@@@      TWOERR=0    @#@@@@      CALL MULGRP BW
)@@G@@@^@@@@      DO 180 I=1,NCW    @#@@@@      NMOD=SCR(L) @]@@@@      L=L+1 BX
)@@G@@@A@@@@      IF(NMOD .EQ. 0) GO TO 180     @#@@@@      LSAVE=LS    @#@@@@BY
)@@G@@      LS=LS+1     @]@@@@      LOW=LS@^@@@@      DO 150 J=1,NMOD   @#@@@@BZ
)@@G@@      CALL NEXTMD @ @@@@      IF(TYP .EQ. 1) GO TO 120@ @@@@      IF(TYPCA
)@@G@@ .EQ. 3) GO TO 130@^@@@@      CALL STORE(0,$999)@#@@@@      GO TO 150   CB
)@@G@@@A@@@@ 120  IF(NCELL .GT. 0) GO TO 125    @ @@@@ 122  CALL STORE(INFO(1)CC
)@@G@@,$999)@#@@@@      GO TO 150   @B@@@@ 125  IF(INFO(1) .LE. NCELL) GO TO 1CD
)@@G@@22    @A@@@@ 127  IF(CELERR .NE. 0) GO TO 150   @#@@@@      CELERR=1    CE
)@@G@@@#@@@@      CALL ERROR  @A@@@@      PRINT 9130,CWSPEC(1),CWSPEC(2)@G@@@@CF
)@@G@@ 9130 FORMAT(' ***** ONEWAY2 ERROR.  A CELL NUMBER SPECIFIED WITH ',2A6,CG
)@@G@@@C@@@@     -' IS GREATER THAN THE NUMBER OF CELLS')   @#@@@@      GO TO CH
)@@G@@150   @#@@@@ 130  KA=INFO(1)  @#@@@@      KB=INFO(2)  @C@@@@      IF(KA CI
)@@G@@.GT. KB  .OR.  KA .LE. 0) GO TO 150 @^@@@@      DO 140 K=KA,KB    @D@@@@CJ
)@@G@@      IF(NCELL .GT. 0  .AND.  K .GT. NCELL) GO TO 127 @^@@@@ 140  CALL SCK
)@@G@@TORE(K,$999)@#@@@@ 150  CONTINUE    @^@@@@      SCR(LSAVE)=LS-LOW @A@@@@CL
)@@G@@      IF(TWOERR .NE. 0) GO TO 180   @A@@@@      CALL TSTREP(LOW,LS-1,$16CM
)@@G@@0)    @#@@@@      GO TO 180   @#@@@@ 160  TWOERR=1    @#@@@@      CALL ECN
)@@G@@RROR  @A@@@@      PRINT 9160,CWSPEC(1),CWSPEC(2)@G@@@@ 9160 FORMAT(' ***CO
)@@G@@** ONEWAY2 ERROR.  A CELL IS SPECIFIED MORE THAN ONCE @A@@@@     -WITH ACP
)@@G@@ ',2A6,' CONTROL WORD') @#@@@@ 180  CONTINUE    @[@@@@C     @C@@@@C     CQ
)@@G@@        BEGIN LOOP TO CHECK TTESTS SPECS  @[@@@@C     @#@@[@ 200  NCW=SCCR
)@@G@@R(451)@]@@[@      L=452 @#]@@@      TTESTA=0    @ @@@@      IF(NCW .EQ. CS
)@@G@@0) GO TO 290@#@@@@      MODERR=0    @#@@@@      CELERR=0    @#@@@@      CT
)@@G@@TWOERR=0    @^@@[@      SVSPEC(6)=LS-LAST @^[@@@      DO 285 I=1,NCW    CU
)@@G@@@^@@@@      NMOD=SCR(L+1)     @]@@@@      L=L+2 @A@@@@      IF(NMOD .GT.CV
)@@G@@ 0) GO TO 215     @^@@@@      TTESTA=TTESTA+1   @A@@@@      IF(TTESTA .NCW
)@@G@@E. 2) GO TO 280   @#@@@@      CALL ERROR  @#@@@@      PRINT 9210  @G@@@@CX
)@@G@@ 9210 FORMAT(' ***** ONEWAY2 ERROR.  TTESTS IS SPECIFIED MORE THAN ONCE CY
)@@G@@@ @@@@     -WITHOUT MODIFIERS')     @#@@@@      GO TO 280   @]@@@@ 215  CZ
)@@G@@NG1=0 @]@@@@      AV1=0 @]@@@@      NG2=0 @]@@@@      AV2=0 @#@@@@      DA
)@@G@@LSAVE=LS    @#@@@@      LS=LS+4     @]@@@@      LOW=LS@[@@@@C     @A@@@@DB
)@@G@@C             CHECK BEFORE THE /    @[@@@@C     @#@@@@      CALL NEXTMD DC
)@@G@@@#@@@@      NMOD=NMOD-1 @ @@@@      IF(TYP .NE. 4) GO TO 230@A@@@@      DD
)@@G@@IF(INFO(1) .NE. 'A') GO TO 220@]@@@@      AV1=1 @A@@@@      IF(NMOD .EQ.DE
)@@G@@ 0) GO TO 225     @#@@@@      CALL NEXTMD @#@@@@      NMOD=NMOD-1 @#@@@@DF
)@@G@@      GO TO 230   @A@@@@ 220  CALL TESTAN(INFO,KEMP,$225)   @]@@@@      DG
)@@G@@AV1=1 @]@@@@      TYP=1 @#@@@@      INFO(1)=KEMP@#@@@@      GO TO 230   DH
)@@G@@@A@@@@ 225  IF(MODERR .NE. 0) GO TO 228   @#@@@@      MODERR=1    @#@@@@DI
)@@G@@      CALL ERROR  @#@@@@      PRINT 9225  @G@@@@ 9225 FORMAT(' ***** ONEDJ
)@@G@@WAY2 ERROR.  ONE OR MORE MODIFIERS OF TTESTS ARE@D@@@@     - OUT OF SEQUDK
)@@G@@ENCE OR ARE IMPROPERLY SPECIFIED')  @A@@@@ 228  IF(NMOD .EQ. 0) GO TO 28DL
)@@G@@0     @^@@@@      DO 229 K=1,NMOD   @#@@@@ 229  CALL NEXTMD @#@@@@      DM
)@@G@@GO TO 280   @ @@@@ 230  IF(TYP .EQ. 1) GO TO 235@ @@@@      IF(TYP .EQ. DN
)@@G@@3) GO TO 240@ @@@@      IF(TYP .NE. 5) GO TO 225@#@@@@      GO TO 250   DO
)@@G@@@E@@@@ 235  IF(NCELL .GT. 0  .AND.  INFO(1) .GT. NCELL) GO TO 237 @ @@@@DP
)@@G@@      CALL STORE(INFO(1),$999)@#@@@@      NG1=NG1+1   @#@@@@      GO TO DQ
)@@G@@248   @A@@@@ 237  IF(CELERR .NE. 0) GO TO 248   @#@@@@      CELERR=1    DR
)@@G@@@#@@@@      CALL ERROR  @B@@@@      PRINT 9130,CWSPEC(11),CWSPEC(12)    DS
)@@G@@@#@@@@      GO TO 248   @#@@@@ 240  KA=INFO(1)  @#@@@@      KB=INFO(2)  DT
)@@G@@@C@@@@      IF(KA .GT. KB  .OR.  KA .LE. 0) GO TO 248 @^@@@@      DO 245DU
)@@G@@ K=KA,KB    @D@@@@      IF(NCELL .GT. 0  .AND.  K .GT. NCELL) GO TO 237 DV
)@@G@@@#@@@@      NG1=NG1+1   @^@@@@ 245  CALL STORE(K,$999)@A@@@@ 248  IF(NMODW
)@@G@@D .EQ. 0) GO TO 225     @#@@@@      CALL NEXTMD @#@@@@      NMOD=NMOD-1 DX
)@@G@@@#@@@@      GO TO 230   @[@@@@C     @A@@@@C             CHECK AFTER THE DY
)@@G@@/     @[@@@@C     @A@@@@ 250  IF(NMOD .EQ. 0) GO TO 225     @#@@@@      DZ
)@@G@@CALL NEXTMD @#@@@@      NMOD=NMOD-1 @ @@@@      IF(TYP .NE. 4) GO TO 260EA
)@@G@@@A@@@@      IF(INFO(1) .EQ. 'A') GO TO 251@A@@@@      CALL TESTAN(INFO,KEB
)@@G@@EMP,$252)   @]@@@@      AV2=1 @]@@@@      TYP=1 @#@@@@      INFO(1)=KEMPEC
)@@G@@@#@@@@      GO TO 260   @]@@@@ 251  AV2=1 @A@@@@      IF(NMOD .EQ. 0) GOED
)@@G@@ TO 225     @#@@@@      CALL NEXTMD @#@@@@      NMOD=NMOD-1 @ @@@@      EE
)@@G@@IF(TYP .NE. 4) GO TO 260@B@@@@      IF(INFO(1) .NE. 'OTHER') GO TO 225  EF
)@@G@@@B@@@@ 252  IF(INFO(1) .NE. 'AOTHER') GO TO 254 @B@@@@      IF(INFO(2) .EG
)@@G@@NE. '      ') GO TO 225 @]@@@@      AV2=1 @^@@@@      INFO(1)='OTHER'   EH
)@@G@@@B@@@@ 254  IF(INFO(1) .NE. 'OTHER') GO TO 225  @A@@@@      IF(NMOD .NE.EI
)@@G@@ 0) GO TO 225     @A@@@@      IF(NCELL .EQ. 0) GO TO 280    @#@@@@      EJ
)@@G@@LUP=LS-1    @^@@@@      DO 258 K=1,NCELL  @A@@@@      IF(LUP .LT. LOW) GEK
)@@G@@O TO 256    @^@@@@      DO 255 J=LOW,LUP  @A@@@@      IF(K .EQ. SCR(J)) EL
)@@G@@GO TO 258   @#@@@@ 255  CONTINUE    @#@@@@ 256  NG2=NG2+1   @^@@@@      EM
)@@G@@CALL STORE(K,$999)@#@@@@ 258  CONTINUE    @ @@@@      IF(NG2 .NE. 0) GO EN
)@@G@@TO 280@#@@@@      CALL ERROR  @#@@@@      PRINT 9260  @G@@@@ 9260 FORMATEO
)@@G@@(' ***** ONEWAY2 ERROR.  OTHER IS USED WITH TTESTS BUT ALL C@C@@@@     -EP
)@@G@@ELLS ARE SPECIFIED IN THE FIRST LIST')    @#@@@@      GO TO 280   @ @@@@EQ
)@@G@@ 260  IF(TYP .EQ. 3) GO TO 265@ @@@@      IF(TYP .NE. 1) GO TO 225@E@@@@ER
)@@G@@      IF(NCELL .GT. 0  .AND.  INFO(1) .GT. NCELL) GO TO 262 @ @@@@      ES
)@@G@@CALL STORE(INFO(1),$999)@#@@@@      NG2=NG2+1   @#@@@@      GO TO 270   ET
)@@G@@@A@@@@ 262  IF(CELERR .NE. 0) GO TO 270   @#@@@@      CELERR=1    @#@@@@EU
)@@G@@      CALL ERROR  @B@@@@      PRINT 9130,CWSPEC(11),CWSPEC(12)    @#@@@@EV
)@@G@@      GO TO 270   @#@@@@ 265  KA=INFO(1)  @#@@@@      KB=INFO(2)  @C@@@@EW
)@@G@@      IF(KA .GT. KB  .OR.  KA .LE. 0) GO TO 270 @^@@@@      DO 268 K=KA,EX
)@@G@@KB    @D@@@@      IF(NCELL .GT. 0  .AND.  K .GT. NCELL) GO TO 262 @#@@@@EY
)@@G@@      NG2=NG2+1   @^@@@@ 268  CALL STORE(K,$999)@A@@@@ 270  IF(NMOD .EQ.EZ
)@@G@@ 0) GO TO 275     @#@@@@      CALL NEXTMD @#@@@@      NMOD=NMOD-1 @#@@@@FA
)@@G@@      GO TO 260   @E@@@@C             CHECK FOR DUPLICATES AND END TTESTFB
)@@G@@S LOOPS     @[@@@@C     @[@@@@C     @A@@@@ 275  IF(TWOERR .NE. 0) GO TO FC
)@@G@@280   @A@@@@      CALL TSTREP(LOW,LS-1,$276)    @#@@@@      GO TO 280   FD
)@@G@@@#@@@@ 276  TWOERR=1    @#@@@@      CALL ERROR  @B@@@@      PRINT 9160,CFE
)@@G@@WSPEC(11),CWSPEC(12)    @^@@@@ 280  SCR(LSAVE)=NG1    @^@@@@      SCR(LSFF
)@@G@@AVE+1)=AV1  @^@@@@      SCR(LSAVE+2)=NG2  @^@@@@      SCR(LSAVE+3)=AV2  FG
)@@G@@@#@@@@ 285  CONTINUE    @^@@@@ 290  NCW=NCW-TTESTA    @^@@@@      SVSPECFH
)@@G@@(4)=NCW     @^@@@@      SVSPEC(5)=TTESTA  @A@@@@      IF(NCW .GT. 0) CALFI
)@@G@@L MULGRP    @[@@@@C     @A@@@@C             CHECK CONTRAST SPECS  @[@@@@FJ
)@@G@@C     @^@@[@ 300  NCW=SCR(1801)     @]@@[@      L=1802@^]@@@      SVSPECFK
)@@G@@(7)=NCW     @ @@@@      IF(NCW .EQ. 0) GO TO 400@^@@[@      SVSPEC(8)=LSFL
)@@G@@-LAST @#[@@@      MODERR=0    @#@@@@      ZERERR=0    @#@@@@      CALL MFM
)@@G@@ULGRP @^@@@@      DO 380 I=1,NCW    @#@@@@      NMOD=SCR(L) @]@@@@      FN
)@@G@@L=L+1 @#@@@@      LSAVE=LS    @#@@@@      LS=LS+1     @A@@@@      IF(MODFO
)@@G@@ERR .NE. 0) GO TO 330   @A@@@@      IF(NCELL .EQ. 0) GO TO 330    @A@@@@FP
)@@G@@      IF(NMOD .EQ. NCELL) GO TO 330 @#@@@@      MODERR=1    @#@@@@      FQ
)@@G@@CALL ERROR  @#@@@@      PRINT 9320  @G@@@@ 9320 FORMAT(' ***** ONEWAY2 EFR
)@@G@@RROR.  THE NUMBER OF WEIGHTS SPECIFIED WIT@D@@@@     -H CONTRASTS DOES NFS
)@@G@@OT MATCH THE NUMBER OF CELLS')@A@@@@ 330  IF(NMOD .EQ. 0) GO TO 370     FT
)@@G@@@#@@@@      NONZER=0    @^@@@@      DO 360 J=1,NMOD   @#@@@@      CALL NFU
)@@G@@EXTMD @#@@@@      IVAL=INFO(1)@A@@@@      IF(TYP .EQ. 1) RVAL=INFO(1)   FV
)@@G@@@B@@@@      IF(RVAL .NE. 0) NONZER=NONZER+1     @ @@@@      CALL STORE(IFW
)@@G@@VAL,$999)   @#@@@@ 360  CONTINUE    @D@@@@      IF(ZERERR .NE. 0  .OR.  FX
)@@G@@NONZER .GE. 2) GO TO 370@#@@@@      ZERERR=1    @#@@@@      CALL ERROR  FY
)@@G@@@#@@@@      PRINT 9365  @G@@@@ 9365 FORMAT(' ***** ONEWAY2 ERROR.  A CONFZ
)@@G@@TRAST DOES NOT HAVE AT LEAST T@ @@@@     -WO NON-ZERO WEIGHTS')   @ @@@@GA
)@@G@@ 370  SCR(LSAVE)=LS-LSAVE-1   @#@@@@ 380  CONTINUE    @[@@@@C     @A@@@@GB
)@@G@@C             CHECK POLYS SPECS     @[@@@@C     @#@@@@ 400  NCW=SCR(901)GC
)@@G@@@^@@@@      SVSPEC(9)=NCW     @ @@@@      IF(NCW .EQ. 0) GO TO 500@#@@@@GD
)@@G@@      CALL MULGRP @^@@@@      NMOD=SCR(902)     @]@@@@      L=903 @A@@@@GE
)@@G@@      IF(NMOD .GT. 0) GO TO 420     @#@@@@      SVSPEC(10)=0@#@@@@      GF
)@@G@@GO TO 500   @#@@@@ 420  CALL NEXTMD @#@@@@      NMOD=NMOD-1 @ @@@@      GG
)@@G@@IF(TYP .EQ. 1) GO TO 430@#@@@@ 425  CALL ERROR  @#@@@@      PRINT 9425  GH
)@@G@@@G@@@@ 9425 FORMAT(' ***** ONEWAY2 ERROR.  THE FIRST MODIFIER OF POLYS MGI
)@@G@@UST BE@E@@@@     - AN INTEGER BETWEEN ZERO AND THE NUMBER OF CELLS')    GJ
)@@G@@@#@@@@      GO TO 435   @A@@@@ 430  IF(INFO(1) .LE. 0) GO TO 425  @E@@@@GK
)@@G@@      IF(NCELL .GT. 0  .AND.  INFO(1) .GE. NCELL) GO TO 425 @^@@@@      GL
)@@G@@SVSPEC(10)=INFO(1)@#@@@@      SVSPEC(11)=0@A@@@@ 435  IF(NMOD .EQ. 0) GOGM
)@@G@@ TO 500     @#@@@@      CALL NEXTMD @#@@@@      NMOD=NMOD-1 @ @@@@      GN
)@@G@@IF(TYP .EQ. 5) GO TO 440@#@@@@      CALL ERROR  @#@@@@      PRINT 9435  GO
)@@G@@@G@@@@ 9435 FORMAT(' ***** ONEWAY2 ERROR.  THE FIRST MODIFIER OF POLYS MGP
)@@G@@UST BE@ @@@@     - FOLLOWED BY / OR )')   @#@@@@      GO TO 500   @A@@@@GQ
)@@G@@ 440  IF(NMOD .GT. 0) GO TO 450     @#@@@@ 445  CALL ERROR  @#@@@@      GR
)@@G@@PRINT 9445  @G@@@@ 9445 FORMAT(' ***** ONEWAY2 ERROR.  THE NUMBER OF GROGS
)@@G@@UP SPACINGS SPECIF@E@@@@     -IED WITH POLYS DOES NOT MATCH THE NUMBER OGT
)@@G@@F CELLS')   @#@@@@      GO TO 500   @A@@@@ 450  IF(NCELL .EQ. 0) GO TO 4GU
)@@G@@60    @A@@@@      IF(NMOD .NE. NCELL) GO TO 445 @^@@@@ 460  SVSPEC(11)=NGV
)@@G@@MOD   @^@@[@      SVSPEC(12)=LS-LAST@A[@@@      IF(NMOD .EQ. 0) GO TO 50GW
)@@G@@0     @^@@@@      DO 480 J=1,NMOD   @#@@@@      CALL NEXTMD @ @@@@      GX
)@@G@@IF(TYP .NE. 5) GO TO 470@#@@@@      CALL ERROR  @#@@@@      PRINT 9460  GY
)@@G@@@G@@@@ 9460 FORMAT(' ***** ONEWAY2 ERROR.  A / IS USED INCORRECTLY WITH GZ
)@@G@@POLYS'@]@@@@     -)     @#@@@@      GO TO 500   @#@@@@ 470  IVAL=INFO(1)HA
)@@G@@@A@@@@      IF(TYP .EQ. 1) RVAL=INFO(1)   @ @@@@      CALL STORE(IVAL,$9HB
)@@G@@99)   @#@@@@ 480  CONTINUE    @[@@@@C     @ @@@@C             CHECK CI SHC
)@@G@@PECS  @[@@@@C     @^@@@@ 500  NMOD=SCR(1201)    @^@@@@      SVSPEC(14)=NHD
)@@G@@MOD   @A@@@@      IF(NMOD .EQ. 0) GO TO 550     @E@@[@      IF(SCR(451) HE
)@@G@@.NE. 0  .OR.  SCR(1801) .NE. 0) GO TO 505 @A[@@@      IF(SCR(901) .NE. 0HF
)@@G@@) GO TO 505 @#@@@@      CALL ERROR  @#@@@@      PRINT 9500  @G@@@@ 9500 HG
)@@G@@FORMAT(' ***** ONEWAY2 ERROR.  CI CANNOT BE USED UNLESS TTESTS, CO@A@@@@HH
)@@G@@     -NTRAST, OR POLYS IS USED')    @]@@@@ 505  L=1202@#@@@@      CALL NHI
)@@G@@EXTMD @ @@@@      IF(TYP .GT. 2) GO TO 510@#@@@@      IVAL=INFO(1)@A@@@@HJ
)@@G@@      IF(TYP .EQ. 1) RVAL=INFO(1)   @D@@@@      IF(RVAL .LE. 0  .OR.  RVHK
)@@G@@AL .GE. 100) GO TO 510  @^@@@@      SVSPEC(15)=IVAL   @#@@@@      GO TO HL
)@@G@@520   @#@@@@ 510  CALL ERROR  @#@@@@      PRINT 9510  @G@@@@ 9510 FORMATHM
)@@G@@(' ***** ONEWAY2 ERROR.  CI PERCENT IS IMPROPERLY SPECIFIED @A@@@@     -HN
)@@G@@OR IS NOT BETWEEN 0 AND 100') @A@@@@ 520  IF(NMOD .EQ. 1) GO TO 550     HO
)@@G@@@#@@@@      CALL NEXTMD @ @@@@      IF(TYP .NE. 4) GO TO 530@B@@@@      HP
)@@G@@IF(INFO(1) .NE. 'SCHEFF') GO TO 530 @A@@@@      IF(INFO(2) .EQ. 'E') GO HQ
)@@G@@TO 550@#@@@@ 530  CALL ERROR  @#@@@@      PRINT 9530  @G@@@@ 9530 FORMATHR
)@@G@@(' ***** ONEWAY2 ERROR.  SECOND MODIFIER OF CI, IF USED, MUS@^@@@@     -HS
)@@G@@T BE SCHEFFE')    @[@@@@C     @A@@@@C             CHECK POOLERROR USE   HT
)@@G@@@[@@@@C     @ @@@@ 550  SVSPEC(13)=SCR(1210)    @B@@@@      IF(SVSPEC(13HU
)@@G@@) .EQ. 0) GO TO 600     @E@@@@      IF(SVSPEC(9) .NE. 0  .OR.  SCR(1212)HV
)@@G@@ .NE. 0) GO TO 600@#@@@@      CALL ERROR  @#@@@@      PRINT 9560  @G@@@@HW
)@@G@@ 9560 FORMAT(' ***** ONEWAY2 ERROR.  POOLERROR CANNOT BE USED UNLESS POLHX
)@@G@@@A@@@@     -YS OR ORTHOCON IS ALSO USED') @[@@@@C     @A@@@@C           HY
)@@G@@  CHECK ORTHOCON SPECS  @[@@@@C     @^@@@@ 600  NCW=SCR(1212)     @]@@@@HZ
)@@G@@      L=1213@^@@@@      SVSPEC(16)=NCW    @^@@[@      SVSPEC(17)=LS-LASTIA
)@@G@@@ [@@@      IF(NCW .EQ. 0) GO TO 700@#@@@@      CELERR=0    @#@@@@      IB
)@@G@@TWOERR=0    @#@@@@      MODERR=0    @^@@@@      NCON=SVSPEC(7)    @^@@@@IC
)@@G@@      DO 680 I=1,NCW    @#@@@@      NMOD=SCR(L) @]@@@@      L=L+1 @#@@@@ID
)@@G@@      LSAVE=LS    @#@@@@      LS=LS+1     @]@@@@      LOW=LS@A@@@@      IE
)@@G@@IF(NMOD .EQ. 0) GO TO 645     @A@@@@      IF(NCELL .EQ. 0) GO TO 610    IF
)@@G@@@A@@@@      IF(NMOD .LT. NCELL) GO TO 610 @A@@@@      IF(MODERR .NE. 0) IG
)@@G@@GO TO 610   @#@@@@      MODERR=1    @#@@@@      CALL ERROR  @#@@@@      IH
)@@G@@PRINT 9605  @G@@@@ 9605 FORMAT(' ***** ONEWAY2 ERROR.  THE NUMBER OF CONII
)@@G@@TRASTS SPECIFIED W@E@@@@     -ITH ORTHOCON MUST BE LESS THAN THE NUMBER IJ
)@@G@@OF CELLS')  @^@@@@ 610  DO 640 J=1,NMOD   @#@@@@      KEMP=SCR(L) @]@@@@IK
)@@G@@      L=L+1 @A@@@@      IF(NCON .EQ. 0) GO TO 620     @A@@@@      IF(KEMIL
)@@G@@P .LE. NCON) GO TO 620  @A@@@@      IF(CELERR .NE. 0) GO TO 620   @#@@@@IM
)@@G@@      CELERR=1    @#@@@@      CALL ERROR  @#@@@@      PRINT 9610  @G@@@@IN
)@@G@@ 9610 FORMAT(' ***** ONEWAY2 ERROR.  A NUMBER SPECIFIED WITH ORTHOCON EXIO
)@@G@@@B@@@@     -CEEDS THE NUMBER OF CONTRASTS')     @ @@@@ 620  CALL STORE(KIP
)@@G@@EMP,$999)   @#@@@@ 640  CONTINUE    @ @@@@ 645  SCR(LSAVE)=LS-LSAVE-1   IQ
)@@G@@@A@@@@      IF(TWOERR .NE. 0) GO TO 680   @A@@@@      CALL TSTREP(LOW,LSIR
)@@G@@-1,$650)    @#@@@@      GO TO 680   @#@@@@ 650  TWOERR=1    @#@@@@      IS
)@@G@@CALL ERROR  @#@@@@      PRINT 9650  @G@@@@ 9650 FORMAT(' ***** ONEWAY2 EIT
)@@G@@RROR.  THE SAME CONTRAST IS SPECIFIED MORE@C@@@@     - ONCE WITH AN ORTHIU
)@@G@@OCON CONTROL WORD')     @#@@@@ 680  CONTINUE    @[@@@@C     @A@@@@C     IV
)@@G@@        CHECK RANGE SPECS     @[@@@@C     @^@@@@ 700  NMOD=SCR(1501)    IW
)@@G@@@^@@@@      SVSPEC(18)=NMOD   @A@@@@      IF(NMOD .EQ. 0) GO TO 800     IX
)@@G@@@#@@@@      CALL MULGRP @^@@[@      SVSPEC(19)=LS-LAST@A[@@@      IF(NCEIY
)@@G@@LL .EQ. 0) GO TO 720    @A@@@@      IF(NMOD .LT. NCELL) GO TO 720 @#@@@@IZ
)@@G@@      CALL ERROR  @#@@@@      PRINT 9715  @G@@@@ 9715 FORMAT(' ***** ONEJA
)@@G@@WAY2 ERROR.  THE NUMBER OF MODIFIERS OF RANGE IS@B@@@@     - NOT LESS THJB
)@@G@@AN THE NUMBER OF CELLS')@]@@@@ 720  L=1502@A@@@@      IF(NMOD .EQ. 0) GOJC
)@@G@@ TO 800     @^@@@@      DO 760 J=1,NMOD   @#@@@@      CALL NEXTMD @#@@@@JD
)@@G@@      IVAL=INFO(1)@A@@@@      IF(TYP .EQ. 1) RVAL=INFO(1)   @A@@@@ 740  JE
)@@G@@IF(RVAL .GT. 0) GO TO 750     @#@@@@      CALL ERROR  @#@@@@      PRINT JF
)@@G@@9745  @G@@@@ 9745 FORMAT(' ***** ONEWAY2 ERROR.  A MODIFIER OF RANGE IS JG
)@@G@@NEGATIVE OR @]@@@@     -ZERO')@#@@@@      GO TO 800   @ @@@@ 750  CALL SJH
)@@G@@TORE(IVAL,$999)   @#@@@@ 760  CONTINUE    @[@@@@C     @C@@@@C           JI
)@@G@@  SAVE SPECS ON FILE 6 IF NO ERRORS @[@@@@C     @ @@@@ 800  IF(NERR .NE.JJ
)@@G@@ 0) RETURN  @B@@@@      CALL S1IODR(6,'WRITE',19,SVSPEC,DUM)@#@@@@      JK
)@@G@@MAXCON=0    @B@@@@      IF(SVSPEC(9) .NE. 0) MAXCON=NCELL   @C@@@@      JL
)@@G@@IF(SVSPEC(7) .GT. MAXCON) MAXCON=SVSPEC(7)@ @@@@      MAXCON=MAXCON*NCELJM
)@@G@@L     @B@@@@      IF(MAXCON .GT. OSIZEM) OSIZEM=MAXCON@^@@[@      NOUT=LJN
)@@G@@S-(LAST+1)  @B[@@@      IF(NOUT .GT. OSIZEC) OSIZEC=NOUT    @B@@@@      JO
)@@G@@CALL S1IODR(6,'WRITE',1,NOUT,DUM)   @A@@@@      IF(NOUT .EQ. 0) GO TO 81JP
)@@G@@0     @D@@[@      CALL S1IODR(6,'WRITE',NOUT,SCR(LAST+1),DUM)     @C[@@@JQ
)@@G@@ 810  CALL S1GTAG('NWCOMP',FW,DUM,DUM,$820)     @ @@@@      BLCOM(FW)=BLJR
)@@G@@COM(FW)+1   @]@@@@      RETURN@B@@@@ 820  CALL S1STFT('NWCOMP',FW,1,1,$9JS
)@@G@@99)   @#@@@@      BLCOM(FW)=1 @]@@@@      RETURN@[@@@@C     @[@@@@C     JT
)@@G@@@#@@@@ 999  PRINT 9999  @C@@@@ 9999 FORMAT(' ***** SYSTEM ERROR IN S82CMJU
)@@G@@P')   @#@@@@      RETURN 7    @[@@@@C     @[@@@@C     @C@@@@C        LOCJV
)@@G@@AL SUBROUTINE FOR ERROR HANDLING    @[@@@@C     @^@@@@      SUBROUTINE EJW
)@@G@@RROR  @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(1)    @]@@@@      JX
)@@G@@RETURN@[@@@@C     @[@@@@C     @D@@@@C        LOCAL SUBROUTINE FOR TESTINJY
)@@G@@G MULTIPLE GROUPS @[@@@@C     @^@@@@      SUBROUTINE MULGRP @ @@@@      JZ
)@@G@@IF(NFACT .LE. 1) RETURN @ @@@@      IF(FACMES .NE. 0) RETURN@#@@@@      KA
)@@G@@FACMES=1    @#@@@@      CALL ERROR  @#@@@@      PRINT 9105  @G@@@@ 9105 KB
)@@G@@FORMAT(' ***** IF GROUPS IS REPEATED ON THE MODEL CARD, ONLY TTEST@F@@@@KC
)@@G@@     -S WITHOUT MODIFIERS AND CI CAN BE USED ON THE COMPARE CARD')@]@@@@KD
)@@G@@      RETURN@[@@@@C     @[@@@@C     @C@@@@C        LOCAL SUBROUTINE TO SKE
)@@G@@TORE IN SPECS LIST@[@@@@C     @A@@@@      SUBROUTINE STORE(STODAT,$)    KF
)@@G@@@A@@@@      IF(LS .GE. LSCR) RETURN 2     @^@@@@      SCR(LS)=STODAT    KG
)@@G@@@#@@@@      LS=LS+1     @]@@@@      RETURN@[@@@@C     @[@@@@C     @C@@@@KH
)@@G@@C        LOCAL SUBROUTINE TO GET NEXT MODIFIER  @[@@@@C     @^@@@@      KI
)@@G@@SUBROUTINE NEXTMD @#@@@@      TYP=SCR(L)  @]@@@@      L=L+1 @^@@@@      KJ
)@@G@@INFO(1)=SCR(L)    @^@@@@      INFO(2)=SCR(L+1)  @B@@@@      GO TO (1200,KK
)@@G@@1200,1100,1100,1300),TYP@]@@@@ 1100 L=L+1 @]@@@@ 1200 L=L+1 @]@@@@ 1300 KL
)@@G@@RETURN@[@@@@C     @[@@@@C     @F@@@@C        LOCAL SUBROUTINE TO TEST FOKM
)@@G@@R A REPEATED SPECIFICATION    @[@@@@C     @A@@@@      SUBROUTINE TSTREP(KN
)@@G@@JA,JB,$)    @^@@@@      DO 1600 J=JA,JB   @#@@@@      KLOW=J+1    @ @@@@KO
)@@G@@      IF(KLOW .GE. JB) RETURN @#@@@@      KEMP=SCR(J) @A@@@@      IF(KEMKP
)@@G@@P .EQ. 0) GO TO 1600    @^@@@@      DO 1500 K=KLOW,JB @A@@@@      IF(KEMKQ
)@@G@@P .EQ. SCR(K)) RETURN 3 @#@@@@ 1500 CONTINUE    @#@@@@ 1600 CONTINUE    KR
)@@G@@@]@@@@      RETURN@[@@@@C     @[@@@@C     @E@@@@C        LOCAL SUBROUTINKS
)@@G@@E TO DECODE 'A' FOLLOWED BY INTEGER @[@@@@C     @A@@@@      SUBROUTINE TKT
)@@G@@ESTAN(FLD,VALUE,$)@^@@@@      DIMENSION FLD(2)  @ @@@@      CALL S1PRFT(KU
)@@G@@FLD(1),1,CH)@ @@@@      IF(CH .NE. 'A') RETURN 3@B@@@@      IF(FLD(2) .NKV
)@@G@@E. '      ') RETURN 3   @^@@@@      DO 2000 IK=2,6    @A@@@@      CALL SKW
)@@G@@1PRFT(FLD(1),IK,CH)     @A@@@@      IF(CH .EQ. ' ') GO TO 2100    @A@@@@KX
)@@G@@      IF(S1SPCT(CH) .NE. 2) RETURN 3@#@@@@ 2000 CONTINUE    @]@@@@      KY
)@@G@@IK=7  @A@@@@ 2100 CALL S1PRST(FLD(1),1,' ')     @A@@@@      CALL S1VLU(FKZ
)@@G@@LD,IK-1,VALUE)    @]@@@@      RETURN@]@@@@      END   ___   @A@@@@      LA
)@@G@@IF(NOUT .EQ. 0) GO TO 810     @D@@[@      CALL S*[S@@@*SDFF*@G@@@@      LB
)@@G@@SUBROUTINE S82CP2(CCERR,NVAR,CPDUMP,SCR,LSCR,$,NARLEN,ARRLEN)     @ @@@@LC
)@@G@@      IMPLICIT INTEGER (A-Z)  @^@@@@      DIMENSION SCR(1)  @ @@@@      LD
)@@G@@DIMENSION ARRLEN(1)     @[@@@@C     @E@@@@C             ONEWAY2 CONTROL LE
)@@G@@PROCESSING ROUTINE CALLED     @D@@@@C             AFTER ALL CONTROL CARDLF
)@@G@@S HAVE BEEN READ  @E@@@@C             AND PROCESSED BY ROUTINES FOR EACHLG
)@@G@@ CONTROL    @C@@@@C             CARD TYPE AND SPECIFICATIONS HAVE @F@@@@LH
)@@G@@C             BEEN SAVED IN COMMON /S82BLK/ AND ON SCRATCH UNITS. @[@@@@LI
)@@G@@C     @[@@@@C     @D@@@@C             IF ERRORS WERE DETECTED DURING CONLJ
)@@G@@TROL  @C@@@@C             CARD PROCESSING (CCERR .NE. 0) ---@B@@@@C     LK
)@@G@@             S22SC2 IS NOT CALLED   @D@@@@C             IF THERE WERE NOLL
)@@G@@ ERRORS IN THE RUN --   @D@@@@C                  ROUTINE S22SC2 IS CALLELM
)@@G@@D TO PREPARE@D@@@@C                  SCALES AND LABELS FOR THE EXECUTIONLN
)@@G@@@C@@@@C                  PHASE.  ADDITIONAL STORAGE   @D@@@@C           LO
)@@G@@       REQUIREMENTS INFORMATION IS ALSO   @D@@@@C                  OBTAILP
)@@G@@NED BY S22SC2.  AFTER RETURN  @C@@@@C                  FROM S22SC2, FINALQ
)@@G@@L EXECUTION @B@@@@C                  PREPARATIONS ARE MADE. @[@@@@C     LR
)@@G@@@[@@@@C     @[@@@@C     @A@@@@      COMMON /S82BLK/ LCCT,LCCN,    @D@@@@LS
)@@G@@     -   NSCALE,SCALNO(400),SCALTP(400),SCALEN(400),  @A@@@@     -   VARLT
)@@G@@SCL(500),VARLIM,VAROVF, @ @@@@     -   MDATA,NWHEAD,NSCOUT, @ @@@@     -LU
)@@G@@   NMODEL,NWMODL,NCOORD,@B@@@@     -   MODNO,NFACT,NCELL,NDEPV,NDVGRP,  LV
)@@G@@@ @@@@     -   NTABS,NDVTOT,NGRTOT, @ @@@@     -   HISTAT,MMCOR,NHISTS, LW
)@@G@@@A@@@@     -   DATSAV,CDSAV(5),DVSAV(30), @A@@@@     -   BAVAR,BABUF,OSILX
)@@G@@ZEM,OSIZEC, @B@@@@     -   TA(400),TB(400),TC(400),TW(400)  @[@@@@C     LY
)@@G@@@C@@@@      DIMENSION CDVAR(150),CDSCL(150),CDLEN(150)@A@@@@      EQUIVALZ
)@@G@@LENCE (CDVAR(1),TA(1))  @A@@@@      EQUIVALENCE (CDSCL(1),TA(201))@A@@@@MA
)@@G@@      EQUIVALENCE (CDLEN(1),TB(1))  @[@@@@C     @ @@@@      DIMENSION SAMB
)@@G@@VPAR(10)    @^@@@@      DATA NSVPAR /10/  @[@@@@C     @#@@@@      COMMONMC
)@@G@@ X(1) @[@@@@C     @[@@@@C     @E@@@@C             INITIALIZE PAGE HEADINMD
)@@G@@G IF DUMP REQUESTED     @[@@@@C     @A@@@@      IF(CPDUMP .EQ. 0) GO TO ME
)@@G@@50    @G@@@@      CALL S1PCHH('(1H0,25X,33HADDITIONAL  ONEWAY2 CONTROL DMF
)@@G@@UMPS)',2)   @[@@@@C     @C@@@@C             INITIALIZE BUFFER FOR S22UNIMG
)@@G@@T     @[@@@@C     @^@@@@ 50   LST=LSCR-2000     @A@@@@      IF(LST .LT. MH
)@@G@@1000) GO TO 70    @B@@@@      CALL S22IOD(SCR(LST+1),2000,$70)    @#@@@@MI
)@@G@@      GO TO 100   @#@@@@ 70   PRINT 75    @C@@@@ 75   FORMAT('0***** BUFMJ
)@@G@@FER TROUBLE IN S82CP2') @#@@@@ 80   RETURN 6    @[@@@@C     @D@@@@C     MK
)@@G@@        SET UP SCALNO VECTOR OF SCALES USED     @[@@@@C     @]@@@@ 100  ML
)@@G@@NIN=0 @^@@@@      DO 105 I=1,300    @#@@@@ 105  TW(I)=TB(I) @A@@@@      MM
)@@G@@IF(NCOORD .EQ. 0) GO TO 140   @A@@@@      IF(NSCALE .EQ. 0) GO TO 112   MN
)@@G@@@^@@@@      DO 110 I=1,NSCALE @A@@@@      SCALEN(I)=AND(SCALEN(I),1023) MO
)@@G@@@#@@@@ 110  TC(I)=0     @^@@@@ 112  DO 120 J=1,NCOORD @#@@@@      JS=CDSMP
)@@G@@CL(J) @ @@@@      IF(JS .LE. 0) GO TO 115 @ @@@@      TC(JS)=OR(TC(JS),2MQ
)@@G@@)     @C@@@@      IF(TW(J+150) .NE. 0) TC(JS)=OR(TC(JS),1)  @ @@@@      MR
)@@G@@CDLEN(J)=SCALEN(JS)     @#@@@@      GO TO 120   @^@@@@ 115  CDLEN(J)=-JSMS
)@@G@@/8 + 1@#@@@@ 120  CONTINUE    @A@@@@      IF(NSCALE .EQ. 0) GO TO 140   MT
)@@G@@@^@@@@      DO 130 I=1,NSCALE @A@@@@      IF(TC(I) .EQ. 0) GO TO 130    MU
)@@G@@@#@@@@      NIN=NIN+1   @A@@@@      SCALNO(NIN)=SCALNO(I)*4+TC(I) @#@@@@MV
)@@G@@      TC(I)=NIN   @#@@@@ 130  CONTINUE    @A@@@@      IF(NIN .EQ. NSCALEMW
)@@G@@) GO TO 140 @^@@@@      DO 135 J=1,NCOORD @#@@@@      I=CDSCL(J)  @ @@@@MX
)@@G@@      IF(I .LE. 0) GO TO 135  @^@@@@      CDSCL(J)=TC(I)    @#@@@@ 135  MY
)@@G@@CONTINUE    @#@@@@ 140  NSCALE=NIN  @[@@@@C     @B@@@@C             COMPMZ
)@@G@@UTE SUMMATION AREA SIZE @[@@@@C     @#@@@@      ACCTOT=0    @#@@@@      NA
)@@G@@HISTOT=0    @#@@@@      HISMAX=0    @#@@@@      CLSMAX=0    @A@@@@      NB
)@@G@@IF(NCOORD .EQ. 0) GO TO 150   @^@@@@      DO 145 J=1,NCOORD @^@@@@      NC
)@@G@@ROWS=CDLEN(J)     @ @@@@      NCLASS=AND(TW(J+150),63)@^@@@@      HCORE=ND
)@@G@@TW(J+150)/64@^@@@@      HSIZE=ROWS*NCLASS @B@@@@      IF(HSIZE .GT. HISMNE
)@@G@@AX) HISMAX=HSIZE  @B@@@@      IF(NCLASS .GT. CLSMAX) CLSMAX=NCLASS@ @@@@NF
)@@G@@      HISTOT=HISTOT+ROWS*HCORE@ @@@@ 145  ACCTOT=ACCTOT+ROWS*TW(J)@[@@@@NG
)@@G@@C     @B@@@@C             DUMP PARAMETERS IF SELECTED @[@@@@C     @A@@@@NH
)@@G@@ 150  IF(CPDUMP .EQ. 0) GO TO 200   @A@@@@      IF(NCOORD .EQ. 0) GO TO NI
)@@G@@190   @^@@@@      CALL S1PCHD(3)    @#@@@@      PRINT 160   @D@@@@ 160  NJ
)@@G@@FORMAT(/'0COORDINATES - I  VAR   SCALE   LEN')  @^@@@@      DO 170 I=1,NNK
)@@G@@COORD @^@@@@      CALL S1PCHD(1)    @C@@@@      PRINT 165,I,CDVAR(I),CDSNL
)@@G@@CL(I),CDLEN(I)    @ @@@@ 165  FORMAT(10X,I6,I5,2I7)   @#@@@@ 170  CONTINNM
)@@G@@UE    @A@@@@ 175  IF(NSCALE .EQ. 0) GO TO 190   @^@@@@      CALL S1PCHD(NN
)@@G@@3)    @#@@@@      PRINT 177   @D@@@@ 177  FORMAT(/'0SCALES USED - J   NONO
)@@G@@.   LAB6   LAB4') @^@@@@      DO 185 J=1,NSCALE @^@@@@      CALL S1PCHD(NP
)@@G@@1)    @^@@@@      TMP=SCALNO(J)     @^@@@@      LAB6=AND(TMP,1)   @^@@@@NQ
)@@G@@      LAB4=AND(TMP,2)/2 @#@@@@      TMP=TMP/4   @A@@@@      PRINT 180,J,NR
)@@G@@TMP,LAB6,LAB4     @^@@@@ 180  FORMAT(10X,4I6)   @#@@@@ 185  CONTINUE    NS
)@@G@@@^@@@@ 190  CALL S1PCHD(3)    @#@@@@      PRINT 195   @B@@@@ 195  FORMATNT
)@@G@@(/'0MISCELLANEOUS PARAMETERS')@A@@@@      CALL PLV('NCOORD',NCOORD)     NU
)@@G@@@A@@@@      CALL PLV('NSCALE',NSCALE)     @ @@@@      CALL PLV('NTABS',NNV
)@@G@@TABS) @A@@@@      CALL PLV('ACCTOT',ACCTOT)     @ @@@@      CALL PLV('NVNW
)@@G@@AR',NVAR)   @A@@@@      CALL PLV('NMODEL',NMODEL)     @A@@@@      CALL PNX
)@@G@@LV('NWMODL',NWMODL)     @A@@@@      CALL PLV('NDVTOT',NDVTOT)     @A@@@@NY
)@@G@@      CALL PLV('NGRTOT',NGRTOT)     @A@@@@      CALL PLV('HISTAT',HISTATNZ
)@@G@@)     @A@@@@      CALL PLV('HISTOT',HISTOT)     @ @@@@      CALL PLV('MMOA
)@@G@@COR',MMCOR) @A@@@@      CALL PLV('NHISTS',NHISTS)     @A@@@@      CALL POB
)@@G@@LV('DATSAV',DATSAV)     @A@@@@      CALL PLV('HISMAX',HISMAX)     @A@@@@OC
)@@G@@      CALL PLV('CLSMAX',CLSMAX)     @ @@@@      CALL PLV('BAVAR',BAVAR) OD
)@@G@@@ @@@@      CALL PLV('BABUF',BABUF) @A@@@@      CALL PLV('OSIZEM',OSIZEMOE
)@@G@@)     @A@@@@      CALL PLV('OSIZEC',OSIZEC)     @A@@@@ 200  IF(CCERR .NEOF
)@@G@@. 0) GO TO 310    @[@@@@C     @C@@@@C             CALL S22SC2 TO PROCESSOG
)@@G@@ SCALES     @[@@@@C     @E@@@@ 300  CALL S22SC2(NSCOUT,SCALNO,NSCALE,CATOH
)@@G@@WTS,SCLTOT,LABTOT,@B@@@@     -   VARSCL,SCALEN,TC,TW,SCR,LST,$80) @A@@@@OI
)@@G@@      IF(NSCALE .EQ. 0) GO TO 310   @B@@@@      CALL S22DWR(SCALNO,NSCALOJ
)@@G@@E,$510)     @A@@@@ 310  IF(CPDUMP .EQ. 0) GO TO 350   @A@@@@      CALL POK
)@@G@@LV('CATWTS',CATWTS)     @A@@@@      CALL PLV('SCLTOT',SCLTOT)     @A@@@@OL
)@@G@@      CALL PLV('LABTOT',LABTOT)     @[@@@@C     @D@@@@C             PREPOM
)@@G@@ARE POINTER VECTORS FOR SAVING DATA @[@@@@C     @A@@@@ 350  IF(CCERR .NEON
)@@G@@. 0) GO TO 360    @A@@@@      CALL S22DWR(HISTAT,1,$510)    @A@@@@      OO
)@@G@@CALL S22DWR(DATSAV,1,$510)    @A@@@@ 360  IF(DATSAV .EQ. 0) GO TO 400   OP
)@@G@@@#@@@@      NCDSAV=0    @^@@@@      DO 370 I=1,NCOORD @A@@@@      CALL TOQ
)@@G@@STBIT(CDSAV,I,$370)     @^@@@@      NCDSAV=NCDSAV+1   @^@@@@      TB(200OR
)@@G@@+NCDSAV)=I  @#@@@@ 370  CONTINUE    @D@@@@      IF(CPDUMP .NE. 0) CALL POS
)@@G@@LV('NCDSAV',NCDSAV)     @A@@@@      IF(CCERR .NE. 0) GO TO 375    @A@@@@OT
)@@G@@      CALL S22DWR(NCDSAV,1,$510)    @B@@@@      CALL S22DWR(TB(201),NCDSOU
)@@G@@AV,$510)    @#@@@@ 375  NDVSAV=0    @^@@@@      DO 380 I=1,NVAR   @A@@@@OV
)@@G@@      CALL TSTBIT(DVSAV,I,$380)     @^@@@@      NDVSAV=NDVSAV+1   @^@@@@OW
)@@G@@      TB(200+NDVSAV)=I  @#@@@@ 380  CONTINUE    @C@@@@      CALL S1GTAG(OX
)@@G@@'IDVAR',IDFW,DUM,DUM,$390)    @^@@@@      NDVSAV=NDVSAV+1   @ @@[@      OY
)@@G@@TB(200+NDVSAV)=X(IDFW)/2@#[@@@ 390  CONTINUE    @D@@@@      IF(CPDUMP .NOZ
)@@G@@E. 0) CALL PLV('NDVSAV',NDVSAV)     @A@@@@      IF(CCERR .NE. 0) GO TO 4PA
)@@G@@00    @A@@@@      CALL S22DWR(NDVSAV,1,$510)    @B@@@@      CALL S22DWR(PB
)@@G@@TB(201),NDVSAV,$510)    @[@@@@C     @F@@@@C             COMPUTE ARRAY LEPC
)@@G@@NGTHS REQUIRED FOR ANALYSIS PHASE   @[@@@@C     @]@@@@ 400  NALL=0@#@@@@PD
)@@G@@      ALLTOT=0    @#@@@@      ENTMAX=0    @A@@@@      IF(NCOORD .EQ. 0) PE
)@@G@@GO TO 420   @^@@@@      DO 410 I=1,NCOORD @C@@@@      IF(CDLEN(I) .GT. EPF
)@@G@@NTMAX) ENTMAX=CDLEN(I)  @A@@@@      IF(CDSCL(I) .GE. 0) GO TO 410 @#@@@@PG
)@@G@@      NALL=NALL+1 @ @@@@      ALLTOT=ALLTOT+CDLEN(I)+5@#@@@@ 410  CONTINPH
)@@G@@UE    @A@@@@ 420  IF(CPDUMP .EQ. 0) GO TO 430   @ @@@@      CALL PLV('NAPI
)@@G@@LL',NALL)   @A@@@@      CALL PLV('ALLTOT',ALLTOT)     @A@@@@      CALL PPJ
)@@G@@LV('ENTMAX',ENTMAX)     @#@@@@ 430  SCR(1)=NVAR @#@@@@      DO 435 I=2,6PK
)@@G@@@^@@@@ 435  SCR(I)=NCOORD     @^@@@@      DO 440 I=7,14     @^@@@@ 440  PL
)@@G@@SCR(I)=NSCALE     @^@@@@      SCR(15)=SCLTOT    @#@@@@      SCR(16)=NALLPM
)@@G@@@^@@@@      SCR(17)=3*NALL    @^@@@@      SCR(18)=ALLTOT    @^@@@@      PN
)@@G@@SCR(19)=2*ALLTOT  @ @@@@      SCR(20)=NSCALE+LABTOT   @^@@@@      DO 442PO
)@@G@@ I=21,24    @^@@@@ 442  SCR(I)=NMODEL     @^@@@@      SCR(25)=5*NMODEL  PP
)@@G@@@^@@@@      SCR(26)=4*NMODEL  @^@@@@      SCR(27)=NTABS     @^@@@@      PQ
)@@G@@SCR(28)=NTABS     @^@@@@      SCR(29)=NDVTOT    @^@@@@      SCR(30)=NGRTPR
)@@G@@OT    @D@@@@      SCR(31)=20*ENTMAX + 4*CLSMAX + HISMAX + 2*OSIZEM@C@@@@PS
)@@G@@      IF(HISTAT .NE. 0) SCR(31)=SCR(31)+6*ENTMAX@^@@@@      SCR(32)=2*NHPT
)@@G@@ISTS  @^@@@@      SCR(33)=2*NHISTS  @^@@@@      SCR(34)=HISTOT    @^@@@@PU
)@@G@@      DO 445 I=35,39    @^@@@@ 445  SCR(I)=ACCTOT     @A@@@@      IF(MDAPV
)@@G@@TA .EQ. 0) SCR(36)=0    @^@@@@      SCR(40)=2*ACCTOT  @A@@@@      IF(DATPW
)@@G@@SAV .NE. 0) GO TO 455   @ @@@@      SCR(41)=2000-6*ACCTOT   @A@@@@      PX
)@@G@@IF(SCR(41) .LT. 0) SCR(41)=0  @#@@@@      GO TO 460   @A@@@@ 455  SCR(41PY
)@@G@@)=4000+2*(NCDSAV+NDVSAV)@D@@@@      IF(6*ACCTOT .LT. 2000) SCR(40)=2000-PZ
)@@G@@4*ACCTOT    @^@@@@ 460  SCR(42)=3*BAVAR   @#@@@@      SCR(43)=0   @A@@@@QA
)@@G@@      IF(BAVAR .NE. 0) SCR(43)=14   @^@@@@      SCR(44)=BABUF     @#@@@@QB
)@@G@@      SCR(45)=0   @^@@@@      SCR(46)=OSIZEC    @#@@@@      SCR(47)=100 QC
)@@G@@@#@@@@      NARRAY=47   @A@@@@      IF(CPDUMP .EQ. 0) GO TO 480   @^@@@@QD
)@@G@@      CALL S1PCHD(3)    @#@@@@      PRINT 465   @D@@@@ 465  FORMAT(/'0STQE
)@@G@@ORAGE VECTORS REQUIRED - I    LEN') @^@@@@      DO 475 I=1,NARRAY @^@@@@QF
)@@G@@      CALL S1PCHD(1)    @^@@@@      PRINT 470,I,SCR(I)@^@@@@ 470  FORMATQG
)@@G@@(25X,I4,I7) @#@@@@ 475  CONTINUE    @^@@@@ 480  DO 485 I=1,NARRAY @^@@@@QH
)@@G@@ 485  ARRLEN(I)=SCR(I)  @^@@@@      NARLEN=NARRAY     @[@@@@C     @C@@@@QI
)@@G@@C             SAVE PARAMETERS AND CLOSE S22UNIT @[@@@@C     @ @@@@      QJ
)@@G@@IF(CCERR .NE. 0) RETURN @A@@@@      CALL S22DWR(CDVAR,NCOORD,$510)@#@@@@QK
)@@G@@      GO TO 520   @#@@@@ 510  PRINT 515   @C@@@@ 515  FORMAT('0***** I/OQL
)@@G@@ TROUBLE IN S82CP2')    @#@@@@      RETURN 6    @A@@@@ 520  CALL S22DWR(QM
)@@G@@CDSCL,NCOORD,$510)@A@@@@      CALL S22DWR(CDLEN,NCOORD,$510)@A@@@@      QN
)@@G@@IF(NALL .EQ. 0) GO TO 530     @]@@@@      K=0   @^@@@@      DO 525 I=1,NQO
)@@G@@COORD @A@@@@      IF(CDSCL(I) .GE. 0) GO TO 525 @]@@@@      K=K+1 @#@@@@QP
)@@G@@      SCR(K)=2    @B@@@@      CALL S1GTVT(CDVAR(I),SCR(K),$525)   @#@@@@QQ
)@@G@@ 525  CONTINUE    @A@@@@      CALL S22DWR(SCR,NALL,$510)    @^@@@@ 530  QR
)@@G@@CALL S22DEF($510) @^@@@@      SAVPAR(1)=NCOORD  @^@@@@      SAVPAR(2)=NSQS
)@@G@@CALE  @^@@@@      SAVPAR(3)=NALL    @^@@@@      SAVPAR(4)=NMODEL  @^@@@@QT
)@@G@@      SAVPAR(5)=CATWTS  @^@@@@      SAVPAR(6)=NWMODL  @^@@@@      SAVPARQU
)@@G@@(7)=MDATA   @^@@@@      SAVPAR(8)=ENTMAX  @^@@@@      SAVPAR(9)=ACCTOT  QV
)@@G@@@^@@@@      SAVPAR(10)=NWHEAD @C@@@@      CALL S1STFT('S22PAR',FW,1,NSVPQW
)@@G@@AR,$580)    @^@@@@      DO 550 I=1,NSVPAR @^@@@@      X(FW)=SAVPAR(I)   QX
)@@G@@@#@@@@ 550  FW=FW+1     @]@@@@      RETURN@#@@@@ 580  PRINT 585   @E@@@@QY
)@@G@@ 585  FORMAT('0***** TROUBLE SAVING PARAMETERS IN S22CP2')  @#@@@@      QZ
)@@G@@RETURN 6    @[@@@@C     @D@@@@C             LOCAL SUBROUTINE TO PRINT LARA
)@@G@@BELLED VALUE@[@@@@C     @ @@@@      SUBROUTINE PLV(LB,VL)   @^@@@@      RB
)@@G@@CALL S1PCHD(1)    @^@@@@      PRINT 1010,LB,VL  @ @@@@ 1010 FORMAT(2X,A6RC
)@@G@@,3H = ,I6)  @]@@@@      RETURN@[@@@@C     @D@@@@C             LOCAL ROUTRD
)@@G@@INE TO ESTIMATE SCALE STORAGE @C@@@@C             REQUIREMENTS IF S22SC2RE
)@@G@@ NOT CALLED @[@@@@C     @^@@@@      SUBROUTINE ESTSCL @ @@@@      IMPLICRF
)@@G@@IT INTEGER (A-Z)  @#@@@@      CATWTS=1    @#@@@@      SCLTOT=0    @#@@@@RG
)@@G@@      LABTOT=0    @ @@@@      IF(NSCALE .EQ. 0) RETURN@ @@@@      DO 202RH
)@@G@@0 II=1,NSCALE     @B@@@@      IF(SCALTP(II) .LT. 0) GO TO 2020    @ @@@@RI
)@@G@@      XA=AND(SCALTP(II),7)    @ @@@@      IF(XA .GT. 4) GO TO 2020@^@@@@RJ
)@@G@@      SLL=SCALEN(II)*2  @^@@@@      SCLTOT=SCLTOT+SLL @B@@@@      IF(XA RK
)@@G@@.LE. 2) SCLTOT=SCLTOT+SLL     @ @@@@      LABTOT=LABTOT+5*SLL     @#@@@@RL
)@@G@@ 2020 CONTINUE    @]@@@@      RETURN@[@@@@C     @[@@@@C     @D@@@@C     RM
)@@G@@   LOCAL SUBROUTINE TO TEST BIT IN A VECTOR     @[@@@@C     @B@@@@      RN
)@@G@@SUBROUTINE TSTBIT(BVEC,INDEX,$)     @ @@@@      IMPLICIT INTEGER (A-Z)  RO
)@@G@@@^@@@@      DIMENSION BVEC(1) @^@@@@      IW=(INDEX-1)/36   @^@@@@      RP
)@@G@@IBIT=INDEX-36*IW-1@C@@@@      IF(FLD(IBIT,1,BVEC(IW+1)) .EQ. 0) RETURN 3RQ
)@@G@@@]@@@@      RETURN@]@@@@      END   ___HD(1)    @^@@@@      PRINT 470,I,RR
)@@G@@SCR(I)@^@@@@ 470  FORMAT*[S@@@*SDFF*@D@@@@      SUBROUTINE S82MOD(CN,CARRS
)@@G@@D,NC,SCR,LSCR,NERR,$)   @ @@@@      IMPLICIT INTEGER (A-Z)  @ @@@@      RT
)@@G@@DIMENSION CARD(1),SCR(1)@[@@@@C     @B@@@@C        ONEWAY2 MODEL CARD PRRU
)@@G@@OCESSOR.    @[@@@@C     @[@@@@C     @E@@@@C        MODEL CARD NUMBER CN RV
)@@G@@(STORED IN VECTOR CARD) IS    @F@@@@C        DECODED AND CHECKED.  VALIDRW
)@@G@@ SPECIFICATIONS ARE SAVED IN  @B@@@@C        COMMON /S82BLK/ AS FOLLOWS RX
)@@G@@-     @E@@@@C             NMODEL - TOTAL NUMBER OF MODEL CARDS PROCESSEDRY
)@@G@@@D@@@@C             NWMODL - NUMBER OF MODELS WITH NO ERRORS@D@@@@C     RZ
)@@G@@        NCOORD - NUMBER OF DISTINCT COORDINATES @D@@@@C             CDVASA
)@@G@@R (IN TA) - COORDINATE VARIABLES    @C@@@@C             CDSCL (IN TA) - SB
)@@G@@COORDINATES SCALES@D@@@@C             MODNO - NUMBER OF THE CURRENT MODESC
)@@G@@L     @C@@@@C             NFACT - NUMBER OF FACTOR VARIABLES@E@@@@C     SD
)@@G@@        NCELL - NUMBER OF PRIMARY CELLS IN THE MODEL  @D@@@@C           SE
)@@G@@  NDEPV - NUMBER OF DEPENDENT VARIABLES   @E@@@@C             NDVGRP - NSF
)@@G@@UMBER OF DEPENDENT VARIABLE GROUPS  @E@@@@C             NTABS - TOTAL NOSG
)@@G@@. OF FACTOR VAR. IN ALL MODELS@E@@@@C             NDVTOT - TOTAL NO. OF SH
)@@G@@DEP. VAR. IN ALL MODELS @F@@@@C             NGRTOT - TOTAL NO. OF DEP. VSI
)@@G@@AR. GROUPS IN ALL MODELS@C@@@@C             HISTAT - NON-ZERO IF HISTOGRSJ
)@@G@@AMS   @G@@@@C             MMCOR - TOTAL NO. OF DEP. VAR. GROUPS WITH HISSK
)@@G@@TOGRAMS     @E@@@@C             NHISTS - TOTAL NO. OF HISTOGRAMS TO PRINSL
)@@G@@T     @E@@@@C             DATSAV - SET NON-ZERO IF DATA TO BE SAVED     SM
)@@G@@@E@@@@C             CDSAV - BIT FLAGS FOR COORDINATES TO BE SAVED @E@@@@SN
)@@G@@C             DVSAV - BIT FLAGS FOR DEP. VAR. TO BE SAVED   @E@@@@C     SO
)@@G@@        BAVAR - MAX. NUMBER OF VARIABLES FOR BANKRES  @D@@@@C           SP
)@@G@@  BABUF - MAX. BUFFER SIZE FOR BANKRES    @G@@@@C             OSIZEM - MSQ
)@@G@@AX. LENGTH OF OUTPUT SPECS WRITTEN ON UNIT 5    @E@@@@C             TC -SR
)@@G@@ VECTOR OF DEPENDENT VARIABLE NUMBERS     @E@@@@C             TW - VECTOSS
)@@G@@R OF DEPENDENT VAR. GROUP SIZES     @[@@@@C     @E@@@@C        IF THERE ST
)@@G@@ARE NO ERRORS ON THE CARD ,  THE FOLLOWING@C@@@@C        INFORMATION IS SU
)@@G@@WRITTEN ON UNIT 3 -     @B@@@@C             MODNO,NFACT,NDEPV,NDVGRP    SV
)@@G@@@C@@@@C             HIST (NON-ZERO IF HISTOGRAMS)     @D@@@@C           SW
)@@G@@  NCLASS, HMIN, HMAX (ONLY IF HIST .NE. 0)@C@@@@C             COORDINATESX
)@@G@@ NUMBERS (NFACT OF THEM)@E@@@@C             DEPENDENT VARIABLE NUMBERS (SY
)@@G@@NDEPV OF THEM)    @D@@@@C             DEPVAR GROUP SIZES (NDVGRP OF THEMSZ
)@@G@@)     @[@@@@C     @D@@@@C        OUTPUT SPECIFICATIONS ARE WRITTEN ON UNTA
)@@G@@IT 5. @[@@@@C     @[@@@@C     @[@@@@C     @[@@@@C     @A@@@@      COMMONTB
)@@G@@ /S82BLK/ LCCT,LCCN,    @D@@@@     -   NSCALE,SCALNO(400),SCALTP(400),SCTC
)@@G@@ALEN(400),  @A@@@@     -   VARSCL(500),VARLIM,VAROVF, @ @@@@     -   MDATD
)@@G@@TA,NWHEAD,NSCOUT, @ @@@@     -   NMODEL,NWMODL,NCOORD,@B@@@@     -   MODTE
)@@G@@NO,NFACT,NCELL,NDEPV,NDVGRP,  @ @@@@     -   NTABS,NDVTOT,NGRTOT, @ @@@@TF
)@@G@@     -   HISTAT,MMCOR,NHISTS, @A@@@@     -   DATSAV,CDSAV(5),DVSAV(30), TG
)@@G@@@A@@@@     -   BAVAR,BABUF,OSIZEM,OSIZEC, @B@@@@     -   TA(400),TB(400)TH
)@@G@@,TC(400),TW(400)  @[@@@@C     @[@@@@C     @ @@[@      DIMENSION CWSPEC(1TI
)@@G@@04)   @^[@@@      DATA CWSPEC /     @C@@@@     1   12HGROUPS      ,-1,0,TJ
)@@G@@1001,2,1,9,1,1000,@C@@@@     2   12HDEPVARS     ,2,0,1,400,1,-1,0,0,    TK
)@@G@@@C@@@@     3   12HREPVARS     ,2,0,501,400,1,-2,0,0,  @A@@@@     4   12HTL
)@@G@@NOANOVA     ,2,0,1401,0,@A@@@@     5   12HREFFECTS    ,2,0,1402,0,@F@@@@TM
)@@G@@     6   12HHIST        ,2,0,1403,4,0,19,-999999999,999999999,    @A@@@@TN
)@@G@@     7   12HASSOC       ,2,0,1430,0,@C@@@@     8   12HHOMVAR      ,2,0,1TO
)@@G@@431,10,1,8,0,0,   @D@@@@     9   12HRESID       ,2,0,1460,3,0,9,1,999999TP
)@@G@@999,  @C@@@@     -   12HBANKRES     ,4,3,1480,1,0,8,0,0,    @A@@[@     1TQ
)@@G@@   12HNODSTAT     ,2,0,1490,0,@C@@[@     2   12HLABELVAR    ,2,0,1495,1,TR
)@@G@@1,-1,0,0/   @[[@@@C     @[@@@@C     @^@@@@      DATA NHV /10/     @B@@@@TS
)@@G@@      DIMENSION HMV(10),HMCL(2,10),HMC(10)@G@@@@      DATA HMCL /'BARTLETT
)@@G@@TT','COCHRAN','FMAX   ','BKB    ','BKBLOG ',    @F@@@@     -   'JACKKNIFTU
)@@G@@E','LEVENEZ','LEVENEM','LEVENES','BA       '/   @E@@@@      DATA HMC /'BTV
)@@G@@','C','F','K',' ','J','LZ','LM','LS',' '/ @[@@@@C     @ @@@@      DIMENSTW
)@@G@@ION MODNUM(50)    @^@@@@      DATA MODLIM /50/  @[@@@@C     @E@@@@      TX
)@@G@@DIMENSION CDVAR(150),CDSCL(150),FVAR(50),FSCL(50)     @A@@@@      DATA CTY
)@@G@@DLIM /150/ FACLIM /50/  @D@@@@      EQUIVALENCE (CDVAR(1),TA(1)), (FVAR(TZ
)@@G@@1),TA(151)) @E@@@@      EQUIVALENCE (CDSCL(1),TA(201)), (FSCL(1),TA(351)UA
)@@G@@)     @B@@@@      DIMENSION CDCORA(150),CDCORH(150)   @E@@@@      EQUIVAUB
)@@G@@LENCE (CDCORA(1),TB(1)), (CDCORH(1),TB(151))    @[@@@@C     @^@@@@      UC
)@@G@@DIMENSION INFO(2) @^@@@@      REAL HMIN,HMAX    @#@@@@      REAL RVAL   UD
)@@G@@@ @@@@      EQUIVALENCE (IVAL,RVAL) @^@@@@      DIMENSION SPEC(12)@#@@@@UE
)@@G@@      COMMON BC(1)@[@@@@C     @[@@@@C     @^@@@@C             INITIALIZEUF
)@@G@@@[@@@@C     @]@@@@      NERR=0@[@@@@C     @C@@@@C             CHECK MODEUG
)@@G@@L NUMBER FOR DUPLICATE  @[@@@@C     @#@@@@      MODNO=CN    @A@@@@      UH
)@@G@@IF(NMODEL .EQ. 0) GO TO 80    @B@@@@      IF(NMODEL .GT. MODLIM) GO TO 1UI
)@@G@@00    @^@@@@      DO 55 I=1,NMODEL  @B@@@@      IF(MODNO .EQ. MODNUM(I))UJ
)@@G@@ GO TO 60   @#@@@@ 55   CONTINUE    @#@@@@      GO TO 80    @A@@@@ 60   UK
)@@G@@NCN=MOD(MODNO*100+1,10000)    @#@@@@      GO TO 70    @#@@@@ 65   NCN=NCUL
)@@G@@N+1   @^@@@@ 70   DO 75 I=1,NMODEL  @B@@@@      IF(NCN .EQ. MODNUM(I)) GUM
)@@G@@O TO 65     @#@@@@ 75   CONTINUE    @^@@@@      CALL S1PCHD(1)    @ @@@@UN
)@@G@@      PRINT 9705,MODNO,NCN    @G@@@@ 9705 FORMAT(' MODEL',I6,' ALREADY SUO
)@@G@@PECIFIED.  THIS MODEL RENUMBERED'I6)@#@@@@      MODNO=NCN   @^@@@@ 80   UP
)@@G@@NMODEL=NMODEL+1   @B@@@@      IF(NMODEL .GT. MODLIM) GO TO 100    @ @@@@UQ
)@@G@@      MODNUM(NMODEL)=MODNO    @[@@@@C     @B@@@@C             DECODE ANDUR
)@@G@@ CHECK THE CARD   @[@@@@C     @F@@@@ 100  CALL S1ENDC(12HMODEL        ,CUS
)@@G@@ARD,NC,SCR,LSCR,LEND,NE,$999) @#@@@@      NERR=NERR+NE@#@@@@      BS=LENUT
)@@G@@D     @^@@@@      LSTOR=LSCR-LEND   @A@@@@      IF(LSTOR .LT. 1500) GO TUU
)@@G@@O 999 @G@@[@      CALL S1ENST(12HMODEL       ,SCR,LEND,CWSPEC,12,0,SCR(BUV
)@@G@@S+1),LSTOR, @#[@@@     -   DUMMY,NE)@#@@@@      NERR=NERR+NE@[@@@@C     UW
)@@G@@@D@@@@C             BEGIN LOOP TO CHECK AND SAVE GROUP SPECS@[@@@@C     UX
)@@G@@@#@@@@ 150  L=BS+1001   @#@@@@      NFACT=SCR(L)@#@@@@      NCELL=0     UY
)@@G@@@A@@@@      IF(NFACT .EQ. 0) GO TO 300    @B@@@@      IF(NFACT .LE. FACLUZ
)@@G@@IM) GO TO 160     @#@@@@      CALL ERROR  @^@@@@      PRINT 9150,FACLIM VA
)@@G@@@G@@@@ 9150 FORMAT(' ***** ONEWAY2 ERROR.  LIMIT OF',I5,' GROUPS CONTROLVB
)@@G@@ WORDS@#@@@@     - EXCEEDED') @#@@@@      NFACT=FACLIM@#@@@@ 160  LUP=NFVC
)@@G@@ACT*8 @^@@@@      DO 165 I=1,LUP    @]@@@@      L=L+1 @#@@@@ 165  TW(I)=VD
)@@G@@SCR(L)@]@@@@      L=1   @^@@@@      DO 280 I=1,NFACT  @#@@@@      FVAR(IVE
)@@G@@)=0   @#@@@@      FSCL(I)=0   @#@@@@      NMODIF=TW(L)@]@@@@      L=L+1 VF
)@@G@@@A@@@@      IF(NMODIF .EQ. 0) GO TO 280   @[@@@@C     @B@@@@C           VG
)@@G@@  CHECK VARIABLE SPECIFICATION@[@@@@C     @A@@@@      IF(TW(L) .EQ. 4) GVH
)@@G@@O TO 180    @#@@@@      VI=TW(L+1)  @]@@@@      L=L+2 @ @@@@      CALL SVI
)@@G@@1CKVI(VI,$170)    @#@@@@      GO TO 200   @C@@@@ 170  CALL S1MSG4(366,VIVJ
)@@G@@,'GROUPS','      ')     @#@@@@      NERR=NERR+1 @#@@@@      GO TO 195   VK
)@@G@@@A@@@@ 180  CALL S1CKVN(TW(L+1),VI,$190)  @]@@@@      L=L+3 @#@@@@      VL
)@@G@@GO TO 200   @E@@@@ 190  CALL S1MSG5(367,TW(L+1),TW(L+2),'GROUPS','      VM
)@@G@@')    @#@@@@      NERR=NERR+1 @]@@@@      L=L+3 @]@@@@ 195  VI=0  @#@@@@VN
)@@G@@ 200  FVAR(I)=VI  @A@@@@      IF(NMODIF .GT. 1) GO TO 220   @ @@@@      VO
)@@G@@IF(VI .EQ. 0) GO TO 280 @#@@@@      KVS=(VI+1)/2@ @@@@      KVSB=(VI-2*KVP
)@@G@@VS+1)*16+1  @A@@@@      TEMP=FLD(KVSB,16,VARSCL(KVS)) @A@@@@      IF(TEMVQ
)@@G@@P .NE. 0) GO TO 210     @#@@@@      CALL ERROR  @^@@@@      PRINT 9205,VVR
)@@G@@I     @G@@@@ 9205 FORMAT(' ***** ONEWAY2 ERROR.  SCALE HAS NOT BEEN DEFIVS
)@@G@@NED FOR GROU@^@@@@     -PS VARIABLE',I4)  @#@@@@      GO TO 280   @^@@@@VT
)@@G@@ 210  SCAL=TEMP-20000   @#@@@@      GO TO 275   @[@@@@C     @A@@@@C     VU
)@@G@@        CHECK SECOND MODIFIER @[@@@@C     @A@@@@ 220  IF(TW(L) .EQ. 4) GVV
)@@G@@O TO 230    @]@@@@      L=L+2 @#@@@@ 225  CALL ERROR  @#@@@@      PRINT VW
)@@G@@9225  @G@@@@ 9225 FORMAT(' ***** ONEWAY2 ERROR.  SECOND MODIFIER OF GROUVX
)@@G@@PS IS NOT IN@D@@@@     - ONE OF THESE FORMS -  SCALE S, ALL K, XALL K') VY
)@@G@@@#@@@@      GO TO 280   @#@@@@ 230  TEMP=TW(L+1)@]@@@@      L=L+3 @ @@@@VZ
)@@G@@      CALL S1PRFT(TEMP,1,CHAR)@ @@@@      CALL S1PRST(TEMP,6,' ') @A@@@@WA
)@@G@@      IF(CHAR .EQ. 'S') GO TO 234   @ @@@@      CALL S1PRST(TEMP,5,' ') WB
)@@G@@@A@@@@      IF(CHAR .EQ. 'X') GO TO 232   @A@@@@      IF(CHAR .NE. 'A') WC
)@@G@@GO TO 225   @ @@@@      CALL S1PRST(TEMP,4,' ') @A@@@@      IF(TEMP .NE.WD
)@@G@@ 'ALL') GO TO 225 @]@@@@      NA=4  @#@@@@      GO TO 235   @A@@@@ 232  WE
)@@G@@IF(TEMP .NE. 'XALL') GO TO 225@]@@@@      NA=5  @#@@@@      GO TO 235   WF
)@@G@@@B@@@@ 234  IF(TEMP .NE. 'SCALE') GO TO 225     @]@@@@      NA=6  @]@@@@WG
)@@G@@ 235  SCH=0 @^@@@@      DO 238 J=NA,12    @A@@@@      CALL S1PRFT(TW(L-2WH
)@@G@@),J,CHAR)   @A@@@@      IF(CHAR .EQ. ' ') GO TO 240   @B@@@@      IF(S1SWI
)@@G@@PCT(CHAR) .NE. 2) GO TO 225   @#@@@@      SCH=SCH+1   @A@@@@ 238  CALL SWJ
)@@G@@1PRST(INFO,SCH,CHAR)    @ @@@@ 240  IF(SCH .EQ. 0) GO TO 225@ @@@@      WK
)@@G@@CALL S1VLU(INFO,SCH,SK) @ @@@@      IF(NA .EQ. 6) GO TO 250 @D@@@@      WL
)@@G@@IF(SK .GT. 1  .AND.  SK .LE. 1000) GO TO 245    @#@@@@      CALL ERROR  WM
)@@G@@@#@@@@      PRINT 9240  @G@@@@ 9240 FORMAT(' ***** ONEWAY2 ERROR.  K MUSWN
)@@G@@T EXCEED 1 AND NOT EXCEED 1000@ @@@@     - WHEN ALL K IS USED')   @]@@@@WO
)@@G@@      SK=1  @#@@@@ 245  SCAL=-8*SK  @A@@@@      IF(NA .EQ. 5) SCAL=-(8*SWP
)@@G@@K+1)  @#@@@@      GO TO 275   @[@@@@C     @B@@@@C             SECOND MODWQ
)@@G@@IFIER IS SCALE S  @[@@@@C     @A@@@@ 250  IF(NSCALE .EQ. 0) GO TO 258   WR
)@@G@@@^@@@@      DO 255 J=1,NSCALE @B@@@@      IF(SK .NE. SCALNO(J)) GO TO 25WS
)@@G@@5     @]@@@@      SCAL=J@#@@@@      GO TO 260   @#@@@@ 255  CONTINUE    WT
)@@G@@@#@@@@ 258  CALL ERROR  @^@@@@      PRINT 9260,SK     @G@@@@ 9260 FORMATWU
)@@G@@(' ***** ONEWAY2 ERROR.  SCALE',I6,' HAS NOT BEEN DEFINED') @]@@@@      WV
)@@G@@SCAL=0@#@@@@      GO TO 275   @^@@@@ 260  JS=SCALTP(SCAL)   @ @@@@      WW
)@@G@@IF(JS .GE. 0) GO TO 261 @#@@@@      SCAL=-JS    @#@@@@      GO TO 260   WX
)@@G@@@#@@@@ 261  WX=JS/8     @^@@@@      STYPE=AND(JS,7)   @A@@@@      IF(STYWY
)@@G@@PE .NE. 6) GO TO 263    @]@@@@ 262  SK=WX @^@@@@      IF(SK .EQ. 0) SK=1WZ
)@@G@@@#@@@@      GO TO 245   @A@@@@ 263  IF(STYPE .NE. 7) GO TO 265    @]@@@@XA
)@@G@@      NA=5  @#@@@@      GO TO 262   @D@@@@ 265  IF(STYPE .EQ. 0  .OR.  VXB
)@@G@@I .EQ. 0) GO TO 275     @A@@@@      CALL S1GTVT(VI,VTYP,$275)     @A@@@@XC
)@@G@@      IF(VTYP .EQ. 2) GO TO 267     @A@@@@      IF(STYPE .GE. 2) GO TO 2XD
)@@G@@75    @#@@@@      CALL ERROR  @^@@@@      PRINT 9265,SK,VI  @G@@@@ 9265 XE
)@@G@@FORMAT(' ***** ONEWAY2 ERROR.  SCALE',I6,' IS A DISCRETE SCALE BUT@A@@@@XF
)@@G@@     - VARIABLE',I4,' IS NUMERIC')  @#@@@@      GO TO 275   @A@@@@ 267  XG
)@@G@@IF(STYPE .EQ. 1) GO TO 270    @#@@@@      CALL ERROR  @^@@@@      PRINT XH
)@@G@@9267,SK,VI  @G@@@@ 9267 FORMAT(' ***** ONEWAY2 ERROR.  SCALE',I6,' IS A XI
)@@G@@RANGE SCALE BUT VA@A@@@@     -RIABLE',I4,' IS ALPHANUMERIC')@#@@@@      XJ
)@@G@@GO TO 275   @ @@@@ 270  IF(WX .EQ. 0) GO TO 275 @ @@@@      CALL S1GTVW(XK
)@@G@@VI,WID,$275)@A@@@@      IF(WID .GE. WX) GO TO 275     @#@@@@      CALL EXL
)@@G@@RROR  @^@@@@      PRINT 9270,VI,SK  @G@@@@ 9270 FORMAT(' ***** ONEWAY2 EXM
)@@G@@RROR.  FIELD WIDTH OF VARIABLE',I4,' IS LE@E@@@@     -SS THAN THE MAXIMUXN
)@@G@@M SCALE VALUE WIDTH OF SCALE',I6)   @#@@@@ 275  FSCL(I)=SCAL@ @@@@      XO
)@@G@@IF(SCAL)276,280,277     @#@@@@ 276  SK=-SCAL/8  @#@@@@      GO TO 278   XP
)@@G@@@ @@@@ 277  SK=SCALEN(SCAL)/1024    @A@@@@      IF(SK .EQ. 0) SK=SCALEN(XQ
)@@G@@SCAL) @A@@@@ 278  IF(SK .GT. NCELL) NCELL=SK    @#@@@@ 280  CONTINUE    XR
)@@G@@@[@@@@C     @A@@@@C             CHECK REPVAR SPECS    @[@@@@C     @#@@@@XS
)@@G@@ 300  NDEPV=0     @#@@@@      NDVGRP=0    @#@@@@      L=BS+501    @#@@@@XT
)@@G@@      NDVS=SCR(L) @]@@@@      LS=0  @A@@@@      IF(NDVS .EQ. 0) GO TO 32XU
)@@G@@5     @]@@@@      L=L+1 @#@@@@      GSIZE=0     @^@@@@      DO 320 I=1,NXV
)@@G@@DVS   @#@@@@      NEXT=SCR(L) @A@@@@      IF(NEXT .EQ. 0) GO TO 310     XW
)@@G@@@A@@@@      CALL S1GTVT(NEXT,VTYP,$305)   @A@@@@      IF(VTYP .NE. 2) GOXX
)@@G@@ TO 305     @#@@@@      CALL ERROR  @^@@@@      PRINT 9305,NEXT   @G@@@@XY
)@@G@@ 9305 FORMAT(' ***** ONEWAY2 ERROR.  DEPENDENT VARIABLE',I4,' IS ALPHANUXZ
)@@G@@@#@@@@     -MERIC')     @^@@@@ 305  NDEPV=NDEPV+1     @A@@@@      IF(NDEYA
)@@G@@PV .GT. 400) GO TO 395  @^@@@@      GSIZE=GSIZE+1     @#@@@@      LS=LS+YB
)@@G@@1     @#@@@@      TC(LS)=NEXT @#@@@@      GO TO 320   @^@@@@ 310  NDVGRPYC
)@@G@@=NDVGRP+1   @^@@@@      TW(NDVGRP)=GSIZE  @#@@@@      GSIZE=0     @]@@@@YD
)@@G@@ 320  L=L+1 @^@@@@      NDVGRP=NDVGRP+1   @^@@@@      TW(NDVGRP)=GSIZE  YE
)@@G@@@[@@@@C     @A@@@@C             CHECK DEPVARS SPECS   @[@@@@C     @]@@@@YF
)@@G@@ 325  L=BS+1@#@@@@      NDVS=SCR(L) @#@@@@      NREPV=NDEPV @A@@@@      YG
)@@G@@IF(NDVS .EQ. 0) GO TO 345     @]@@@@      L=L+1 @^@@@@      DO 340 I=1,NYH
)@@G@@DVS   @#@@@@      NEXT=SCR(L) @]@@@@      L=L+1 @A@@@@      CALL S1GTVT(YI
)@@G@@NEXT,VTYP,$330)   @A@@@@      IF(VTYP .NE. 2) GO TO 330     @#@@@@      YJ
)@@G@@CALL ERROR  @^@@@@      PRINT 9305, NEXT  @^@@@@ 330  NDEPV=NDEPV+1     YK
)@@G@@@A@@@@      IF(NDEPV .GT. 400) GO TO 395  @#@@@@      LS=LS+1     @#@@@@YL
)@@G@@      TC(LS)=NEXT @^@@@@      NDVGRP=NDVGRP+1   @#@@@@      TW(NDVGRP)=1YM
)@@G@@@A@@@@      IF(NREPV .EQ. 0) GO TO 340    @^@@@@      DO 335 J=1,NREPV  YN
)@@G@@@A@@@@      IF(NEXT .NE. TC(J)) GO TO 335 @#@@@@      CALL ERROR  @^@@@@YO
)@@G@@      PRINT 9335, NEXT  @G@@@@ 9335 FORMAT(' ***** ONEWAY2 ERROR.  DEPVAYP
)@@G@@RS VARIABLE',I4,' IS ALSO SPEC@ @@@@     -IFIED WITH REPVARS')    @#@@@@YQ
)@@G@@      GO TO 340   @#@@@@ 335  CONTINUE    @#@@@@ 340  CONTINUE    @A@@@@YR
)@@G@@ 345  IF(NDEPV .NE. 0) GO TO 400    @[@@@@C     @D@@@@C             CREAYS
)@@G@@TE DEPVARS LIST IF NONE SPECIFIED   @[@@@@C     @#@@@@ 350  NVARS=0     YT
)@@G@@@B@@@@      CALL S1GVAL('NVARS',NVARS,$360,$360)@#@@@@ 360  NTVARS=0    YU
)@@G@@@C@@@@      CALL S1GVAL('NTVARS',NTVARS,$370,$370)    @A@@@@ 370  IF(NTVYV
)@@G@@ARS .NE. 0) NVARS=NTVARS@A@@@@      IF(NVARS .EQ. 0) GO TO 400    @^@@@@YW
)@@G@@      DO 390 I=1,NVARS  @ @@@@      CALL S1GTVT(I,VTYP,$380)@A@@@@      YX
)@@G@@IF(VTYP .EQ. 2) GO TO 390     @A@@@@ 380  IF(NFACT .EQ. 0) GO TO 387    YY
)@@G@@@^@@@@      DO 385 J=1,NFACT  @A@@@@      IF(I .EQ. FVAR(J)) GO TO 390  YZ
)@@G@@@#@@@@ 385  CONTINUE    @^@@@@ 387  NDEPV=NDEPV+1     @A@@@@      IF(NDEZA
)@@G@@PV .GT. 400) GO TO 395  @#@@@@      TC(NDEPV)=I @^@@@@      NDVGRP=NDVGRZB
)@@G@@P+1   @#@@@@      TW(NDVGRP)=1@#@@@@ 390  CONTINUE    @#@@@@      GO TO ZC
)@@G@@400   @#@@@@ 395  CALL ERROR  @#@@@@      PRINT 9395  @G@@@@ 9395 FORMATZD
)@@G@@(' ***** ONEWAY2 ERROR.  MAXIMUM OF 400 DEPENDENT VARIABLES @#@@@@     -ZE
)@@G@@EXCEEDED')  @[@@@@C     @ @@@@C             CHECK HIST SPECS@[@@@@C     ZF
)@@G@@@#@@@@ 400  L=BS+1403   @]@@@@      HIST=0@#@@@@      HCORE=0     @#@@@@ZG
)@@G@@      NCLASS=0    @A@@@@      IF(SCR(L) .EQ. 0) GO TO 450   @]@@@@      ZH
)@@G@@HIST=1@#@@@@      MINMAX=2    @]@@@@      HMIN=0@]@@@@      HMAX=0@#@@@@ZI
)@@G@@      NCLASS=24   @^@@@@      NMODIF=SCR(L+1)   @A@@@@      IF(NMODIF .EZJ
)@@G@@Q. 0) GO TO 440   @]@@@@      HIST=2@]@@@@      L=L+2 @A@@@@      IF(SCRZK
)@@G@@(L) .EQ. 1) GO TO 410   @#@@@@ 405  CALL ERROR  @#@@@@      PRINT 9405  ZL
)@@G@@@G@@@@ 9405 FORMAT(' ***** ONEWAY2 ERROR.  HIST IS NOT IN ONE OF THESE FZM
)@@G@@ORMS -@B@@@@     -  HIST, HIST(N), HIST(N,MIN,MAX)')  @#@@@@      GO TO ZN
)@@G@@450   @^@@@@ 410  NCLASS=SCR(L+1)   @]@@@@      L=L+2 @E@@@@      IF(NCLZO
)@@G@@ASS .GE. 5  .AND.  NCLASS .LE. 40) GO TO 415    @#@@@@      CALL ERROR  ZP
)@@G@@@#@@@@      PRINT 9410  @G@@@@ 9410 FORMAT(' ***** ONEWAY2 ERROR.  NUMBEZQ
)@@G@@R OF INTERVALS SPECIFIED WITH @B@@@@     -HIST MUST BE BETWEEN 5 AND 40'ZR
)@@G@@)     @A@@@@      IF(NCLASS .GT. 40) NCLASS=40  @A@@@@      IF(NCLASS .LZS
)@@G@@T. 5) NCLASS=5    @A@@@@ 415  IF(NMODIF .EQ. 1) GO TO 440   @A@@@@      ZT
)@@G@@IF(NMODIF .EQ. 3) GO TO 418   @A@@@@      IF(NMODIF .NE. 4) GO TO 405   ZU
)@@G@@@A@@@@      IF(SCR(L) .NE. 5) GO TO 405   @]@@@@      L=L+1 @ @@@@ 418  ZV
)@@G@@IF(SCR(L)-2)420,422,405 @^@@@@ 420  HMIN=SCR(L+1)     @#@@@@      GO TO ZW
)@@G@@425   @^@@@@ 422  IVAL=SCR(L+1)     @#@@@@      HMIN=RVAL   @]@@@@ 425  ZX
)@@G@@L=L+2 @ @@@@      IF(SCR(L)-2)430,432,405 @^@@@@ 430  HMAX=SCR(L+1)     ZY
)@@G@@@#@@@@      GO TO 435   @^@@@@ 432  IVAL=SCR(L+1)     @#@@@@      HMAX=RZZ
)@@G@@VAL   @#@@@@ 435  MINMAX=1    @A@@@@      IF(HMIN .LT. HMAX) GO TO 440  AA
)@@G@@@#@@@@      CALL ERROR  @#@@@@      PRINT 9440  @G@@@@ 9440 FORMAT(' ***AB
)@@G@@** ONEWAY2 ERROR.  HIST MINIMUM VALUE IS NOT LESS THAN@^@@@@     - MAXIMAC
)@@G@@UM VALUE')  @ @@@@ 440  HISTAT=OR(HISTAT,MINMAX)@A@@@@      NHISTS=NHISTAD
)@@G@@S+NFACT*NDVGRP    @^@@@@      HCORE=(NCLASS+1)/2@A@@@@      IF(HCORE .EQAE
)@@G@@. 0) HCORE=12     @^@@@@      HCORE=HCORE*NDVGRP@[@@@@C     @A@@@@C     AF
)@@G@@        CHECK HOMVAR SPECS    @[@@@@C     @#@@@@ 450  L=BS+1431   @^@@@@AG
)@@G@@      DO 455 I=1,NHV    @#@@@@ 455  HMV(I)=0    @^@@@@      NMODIF=SCR(LAH
)@@G@@)     @A@@@@      IF(NMODIF .EQ. 0) GO TO 475   @]@@@@      L=L+1 @^@@@@AI
)@@G@@      DO 470 J=1,NMODIF @#@@@@      TEMP=SCR(L) @]@@@@      L=L+2 @^@@@@AJ
)@@G@@      DO 460 I=1,NHV    @A@@@@      IF(TEMP .EQ. HMC(I)) GO TO 458@B@@@@AK
)@@G@@      IF(TEMP .NE. HMCL(1,I)) GO TO 460   @C@@@@      IF(SCR(L-1) .NE. HAL
)@@G@@MCL(2,I)) GO TO 460     @]@@@@ 458  II=I  @#@@@@      GO TO 465   @#@@@@AM
)@@G@@ 460  CONTINUE    @#@@@@      CALL ERROR  @A@@@@      PRINT 9460,SCR(L-2AN
)@@G@@),SCR(L-1)  @G@@@@ 9460 FORMAT(' ***** ONEWAY2 ERROR.  THE CODE ',2A6,' AO
)@@G@@CANNOT BE USED WIT@#@@@@     -H HOMVAR')  @#@@@@      GO TO 470   @A@@@@AP
)@@G@@ 465  IF(HMV(II) .EQ. 0) GO TO 468  @#@@@@      CALL ERROR  @#@@@@      AQ
)@@G@@PRINT 9465  @G@@@@ 9465 FORMAT(' ***** ONEWAY2 ERROR.  THE SAME MODIFIERAR
)@@G@@ OF HOMVAR IS SPEC@ @@@@     -IFIED MORE THAN ONCE')  @#@@@@ 468  HMV(IIAS
)@@G@@)=1   @#@@@@ 470  CONTINUE    @[@@@@C     @A@@@@C             CHECK BANKAT
)@@G@@RES SPECS   @[@@@@C     @#@@@@ 475  L=BS+1480   @]@@@@      NADD=0@A@@@@AU
)@@G@@      IF(SCR(L) .EQ. 0) GO TO 500   @A@@@@      IF(NFACT .LE. 1) GO TO 4AV
)@@G@@80    @#@@@@      CALL ERROR  @#@@@@      PRINT 9475  @G@@@@ 9475 FORMATAW
)@@G@@(' ***** ONEWAY2 ERROR.  BANKRES CANNOT BE SPECIFIED IF GROU@A@@@@     -AX
)@@G@@PS IS USED MORE THAN ONCE')   @#@@@@ 480  NADD=NDEPV  @ @@@@      IF(NADAY
)@@G@@D .EQ. 0) NADD=1  @^@@@@      NMODIF=SCR(L+1)   @A@@@@      IF(NMODIF .EAZ
)@@G@@Q. 0) GO TO 486   @^@@@@      INFO(1)=SCR(L+2)  @^@@@@      INFO(2)=SCR(BA
)@@G@@L+3)  @#@@@@      DO 482 I=1,9@ @@@@      CALL S1PRFT(INFO,I,CHAR)@A@@@@BB
)@@G@@      IF(CHAR .NE. ' ') GO TO 482   @]@@@@      NCH=I @#@@@@      GO TO BC
)@@G@@490   @#@@@@ 482  CONTINUE    @#@@@@ 484  CALL ERROR  @#@@@@      PRINT BD
)@@G@@9484  @G@@@@ 9484 FORMAT(' ***** VARIABLE NAME SPECIFIED WITH BANKRES HABE
)@@G@@S TOO MANY C@#@@@@     -HARACTERS') @#@@@@      GO TO 500   @C@@@@ 486  BF
)@@G@@CALL S1GTAG('VNAMES',FW,DUM,DUM,$500)     @C@@@@      CALL S1GTAG('INAMEBG
)@@G@@S',FW,DUM,DUM,$490)     @]@@@@ 490  LS=1  @]@@@@      NSUF=1@^@@@@      BH
)@@G@@DO 495 I=1,NADD   @A@@@@      IF(NMODIF .NE. 0) GO TO 492   @A@@@@      BI
)@@G@@IF(NDEPV .EQ. 0) GO TO 491    @A@@@@      IF(TC(I) .LE. 0) GO TO 495    BJ
)@@G@@@^@@@@      L=FW+(TC(I)-1)*2  @B@@@@      IF(BC(L) .EQ. '      ') GO TO BK
)@@G@@491   @^@@@@      INFO(1)='R     '  @^@@@@      INFO(2)='      '  @A@@@@BL
)@@G@@      CALL S1TCHS(BC(L),1,INFO,2,7) @#@@@@      GO TO 493   @^@@@@ 491  BM
)@@G@@INFO(1)='AVR   '  @^@@@@      INFO(2)='      '  @]@@@@      NCH=4 @A@@@@BN
)@@G@@ 492  IF(NADD .EQ. 1) GO TO 493     @A@@@@      CALL S1ENCI(NSUF,TEMP,6,BO
)@@G@@6,1)  @#@@@@      NSUF=NSUF+1 @^@@@@      CALL S1ENCB(KL)   @A@@@@      BP
)@@G@@IF(NCH+KL .GT. 9) GO TO 484   @B@@@@      CALL S1TCHS(TEMP,7-KL,INFO,NCHBQ
)@@G@@,KL)  @#@@@@ 493  SCR(LS)=0   @A@@@@      IF(I .GT. 1) SCR(LS)='SKPERR' BR
)@@G@@@D@@@@      CALL S1CKBN('BANKRES',INFO,1,SCR(LS),BUFSIZ,NE) @#@@@@      BS
)@@G@@NERR=NERR+NE@^@@@@      SCR(LS+1)=INFO(1) @^@@@@      SCR(LS+2)=INFO(2) BT
)@@G@@@#@@@@      LS=LS+3     @B@@@@      IF(BUFSIZ .GT. BABUF) BABUF=BUFSIZ  BU
)@@G@@@#@@@@ 495  CONTINUE    @A@@@@      IF(BAVAR .LT. NADD) BAVAR=NADD@[@@@@BV
)@@G@@C     @C@@[@C             CHECK LABELVAR AND RESID SPECS    @[[@@@C     BW
)@@G@@@#@@@@ 500  RPRINT=0    @#@@@@      RPUNCH=0    @#@@@@      RFILE=0     BX
)@@G@@@ @@[@      LABELV=SCR(BS+1495)     @A@@[@      IF(LABELV .EQ. 0) GO TO BY
)@@G@@505   @A@@[@      CALL S1GTVT(LABELV,TYP,$502)  @^@@[@ 502  LABELV=LABELBZ
)@@G@@V*2   @A@@[@      IF(TYP .EQ. 1) LABELV=LABELV+1@#@@[@ 505  L=BS+1460   CA
)@@G@@@A[@@@      IF(SCR(L) .EQ. 0) GO TO 550   @^@@@@      NMODIF=SCR(L+1)   CB
)@@G@@@]@@@@      L=L+2 @A@@@@      IF(NMODIF .NE. 0) GO TO 510   @#@@@@      CC
)@@G@@RPRINT=1    @#@@@@      GO TO 550   @^@@@@ 510  DO 540 J=1,NMODIF @#@@@@CD
)@@G@@      VAL=SCR(L+1)@A@@@@      IF(VAL .NE. 'PRINT') GO TO 520@A@@@@      CE
)@@G@@IF(RPRINT .EQ. 0) GO TO 515   @#@@@@ 512  CALL ERROR  @^@@@@      PRINT CF
)@@G@@9515,VAL    @G@@@@ 9515 FORMAT(' ***** ONEWAY2 ERROR.  ',A5,' IS SPECIFICG
)@@G@@ED MORE THAN ONCE @#@@@@     -WITH RESID')@#@@@@ 515  RPRINT=1    @#@@@@CH
)@@G@@      GO TO 540   @A@@@@ 520  IF(VAL .NE. 'PUNCH') GO TO 525@A@@@@      CI
)@@G@@IF(RPUNCH .NE. 0) GO TO 512   @#@@@@      RPUNCH=1    @#@@@@      GO TO CJ
)@@G@@540   @A@@@@ 525  CALL S1UFOT(SCR(L),2,TEMP,NE) @#@@@@      NERR=NERR+NECK
)@@G@@@ @@@@      CALL S1UFT2(LUNDEV)     @A@@@@      IF(LUNDEV .NE. 2) GO TO CL
)@@G@@528   @D@@@@      IF(NDVGRP .LE. 1  .AND.  NFACT .LE. 1) GO TO 528@#@@@@CM
)@@G@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(2)    @#@@@@      PRINT 9525  CN
)@@G@@@G@@@@ 9525 FORMAT(' ***** ONEWAY2 ERROR.  RESID OUTPUT FILE CAN NOT BE CO
)@@G@@ON MAS@G@@@@     -S STORAGE IF THERE ARE MULTIPLE DEPENDENT VARIABLES,'/CP
)@@G@@20X,'REPLICA@A@@@@     -TE SETS, OR GROUPS VARIABLES')@#@@@@ 528  CONTINCQ
)@@G@@UE    @A@@@@      IF(RFILE .EQ. 0) GO TO 530    @#@@@@      VAL='FILE'  CR
)@@G@@@#@@@@      GO TO 512   @#@@@@ 530  RFILE=TEMP  @]@@@@ 540  L=L+3 @[@@@@CS
)@@G@@C     @B@@@@C             UPDATE COORDINATE LISTS     @[@@@@C     @A@@@@CT
)@@G@@ 550  IF(NFACT .EQ. 0) GO TO 600    @^@@@@      DO 590 I=1,NFACT  @#@@@@CU
)@@G@@      VI=FVAR(I)  @ @@@@      IF(VI .EQ. 0) GO TO 590 @#@@@@      SCAL=FCV
)@@G@@SCL(I)@A@@@@      IF(SCAL .EQ. 0) GO TO 590     @A@@@@      IF(NCOORD .ECW
)@@G@@Q. 0) GO TO 575   @^@@@@      DO 570 J=1,NCOORD @A@@@@      IF(VI .NE. CCX
)@@G@@DVAR(J)) GO TO 570@A@@@@      IF(SCAL .LT. 0) GO TO 560     @B@@@@      CY
)@@G@@IF(SCAL .NE. CDSCL(J)) GO TO 570    @#@@@@ 555  FVAR(I)=J   @A@@@@      CZ
)@@G@@CDCORA(J)=CDCORA(J)+NDVGRP    @ @@@@      NCLAS2=AND(CDCORH(J),63)@A@@@@DA
)@@G@@      CDCORH(J)=CDCORH(J)-NCLAS2    @A@@@@      CDCORH(J)=CDCORH(J)+HCORDB
)@@G@@E*64  @C@@@@      CDCORH(J)=CDCORH(J)+MAX0(NCLASS,NCLAS2)   @#@@@@      DC
)@@G@@GO TO 590   @A@@@@ 560  IF(CDSCL(J) .GE. 0) GO TO 570 @#@@@@      TEMP=-DD
)@@G@@SCAL  @^@@@@      XALL=AND(TEMP,1)  @#@@@@      ALLK=TEMP/8 @^@@@@      DE
)@@G@@TEMP=-CDSCL(J)    @^@@@@      XALL2=AND(TEMP,1) @#@@@@      ALLK2=TEMP/8DF
)@@G@@@B@@@@      IF(XALL + XALL2 .EQ. 1) GO TO 570   @A@@@@      IF(ALLK .GT.DG
)@@G@@ ALLK2) ALLK2=ALLK@A@@@@      CDSCL(J)=-(8*ALLK2+XALL2)     @#@@@@      DH
)@@G@@GO TO 555   @#@@@@ 570  CONTINUE    @^@@@@ 575  NCOORD=NCOORD+1   @B@@@@DI
)@@G@@      IF(NCOORD .LE. CDLIM) GO TO 580     @#@@@@      CALL ERROR  @^@@@@DJ
)@@G@@      PRINT 9575,CDLIM  @G@@@@ 9575 FORMAT(' ***** ONEWAY2 ERROR.  LIMITDK
)@@G@@ OF ',I4,' COORDINATE SCALES E@#@@@@     -XCEEDED')   @#@@@@      NCOORDDL
)@@G@@=1    @^@@@@ 580  CDVAR(NCOORD)=VI  @^@@@@      CDSCL(NCOORD)=SCAL@^@@@@DM
)@@G@@      FVAR(I)=NCOORD    @ @@@@      CDCORA(NCOORD)=NDVGRP   @A@@@@      DN
)@@G@@CDCORH(NCOORD)=HCORE*64+NCLASS@#@@@@ 590  CONTINUE    @A@@@@      IF(NFADO
)@@G@@CT .EQ. 1) GO TO 600    @^@@@@      DO 598 I=2,NFACT  @^@@@@      TEMP=FDP
)@@G@@VAR(I-1)    @A@@@@      IF(TEMP .EQ. 0) GO TO 598     @^@@@@      DO 595DQ
)@@G@@ J=I,NFACT  @B@@@@      IF(FVAR(J) .NE. TEMP) GO TO 595     @#@@@@      DR
)@@G@@CALL ERROR  @#@@@@      PRINT 9595  @G@@@@ 9595 FORMAT(' ***** ONEWAY2 EDS
)@@G@@RROR.  THE SAME VARIABLE WITH THE SAME SCA@E@@@@     -LE IS USED IN MOREDT
)@@G@@ THAN ONE GROUPS SPECIFICATION')    @#@@@@      GO TO 600   @#@@@@ 595  DU
)@@G@@CONTINUE    @#@@@@ 598  CONTINUE    @[@@@@C     @C@@@@C             SET DV
)@@G@@FLAGS FOR DATA TO BE SAVED    @[@@@@C     @D@@@@ 600  IF(HIST .EQ. 0  .ODW
)@@G@@R.  MINMAX .EQ. 1) GO TO 602  @C@@@@      CALL S1GTAG('STJBIN',FW,DUM,DUDX
)@@G@@M,$605)     @C@@@@      CALL S1GTAG('TVTYPE',FW,DUM,DUM,$602)     @#@@@@DY
)@@G@@      GO TO 605   @^@@@@ 602  DO 603 I=4,10     @A@@@@      IF(HMV(I) .NDZ
)@@G@@E. 0) GO TO 605   @#@@@@ 603  CONTINUE    @A@@@@      IF(NADD .NE. 0) GOEA
)@@G@@ TO 605     @F@@@@      IF(RPRINT .NE. 0  .OR.  RPUNCH .NE. 0  .OR. RFILEB
)@@G@@E .NE. 0)   @#@@@@     -   GO TO 605@#@@@@      GO TO 650   @#@@@@ 605  EC
)@@G@@DATSAV=1    @A@@@@      IF(NFACT .EQ. 0) GO TO 620    @^@@@@      DO 610ED
)@@G@@ I=1,NFACT  @A@@@@      CALL SETBIT(CDSAV,FVAR(I))    @#@@@@ 610  CONTINEE
)@@G@@UE    @A@@@@ 620  IF(NDEPV .EQ. 0) GO TO 640    @^@@@@      DO 630 I=1,NEF
)@@G@@DEPV  @ @@@@      CALL SETBIT(DVSAV,TC(I))@#@@@@ 630  CONTINUE    @A@@[@EG
)@@G@@ 640  CALL SETBIT(DVSAV,LABELV/2)   @[[@@@C     @D@@@@C             SAVEEH
)@@G@@ OUTPUT SPECS ON FILE 5 IF NO ERRORS@[@@@@C     @ @@@@ 650  IF(NERR .NE.EI
)@@G@@ 0) RETURN  @^@@@@      SPEC(1)='MODEL'   @^@@@@      SPEC(2)=MODNO     EJ
)@@G@@@C@@@@      SPEC(3)=SCR(BS+1401)*2 + SCR(BS+1490)     @ @@@@      SPEC(4EK
)@@G@@)=SCR(BS+1402)    @ @@@@      SPEC(5)=SCR(BS+1430)    @^@@@@      SPEC(6EL
)@@G@@)=RPRINT    @^@@@@      SPEC(7)=RPUNCH    @^@@@@      SPEC(8)=RFILE     EM
)@@G@@@^@@[@      SPEC(9)=LABELV    @#[@@@      SPEC(10)=0  @#@@@@      SPEC(1EN
)@@G@@1)=0  @^@@@@      SPEC(12)=NADD     @B@@@@      CALL S1IODR(5,'WRITE',12EO
)@@G@@,SPEC,DUMMY)@B@@@@      CALL S1IODR(5,'WRITE',NHV,HMV,DUMMY)@F@@@@      EP
)@@G@@IF(NADD .NE. 0) CALL S1IODR(5,'WRITE',3*NADD,SCR,DUMMY)     @[@@@@C     EQ
)@@G@@@C@@@@C             SAVE PROCESSING SPECS ON FILE 3   @[@@@@C     @^@@@@ER
)@@G@@      NWMODL=NWMODL+1   @B@@@@      CALL S1IODR(3,'WRITE',1,MODNO,DUMMY)ES
)@@G@@@B@@@@      CALL S1IODR(3,'WRITE',1,NFACT,DUMMY)@B@@@@      CALL S1IODR(ET
)@@G@@3,'WRITE',1,NDEPV,DUMMY)@C@@@@      CALL S1IODR(3,'WRITE',1,NDVGRP,DUMMYEU
)@@G@@)     @B@@@@      CALL S1IODR(3,'WRITE',1,HIST,DUMMY) @A@@@@      IF(HISEV
)@@G@@T .EQ. 0) GO TO 810     @ @@@@      IF(HIST .EQ. 1) NCLASS=0@C@@@@      EW
)@@G@@CALL S1IODR(3,'WRITE',1,NCLASS,DUMMY)     @B@@@@      CALL S1IODR(3,'WRIEX
)@@G@@TE',1,HMIN,DUMMY) @B@@@@      CALL S1IODR(3,'WRITE',1,HMAX,DUMMY) @#@@@@EY
)@@G@@ 810  CONTINUE    @^@@@@      NTABS=NTABS+NFACT @ @@@@      NDVTOT=NDVTOEZ
)@@G@@T+NDEPV     @ @@@@      NGRTOT=NGRTOT+NDVGRP    @C@@@@      CALL S1IODR(FA
)@@G@@3,'WRITE',NFACT,FVAR,DUMMY)   @C@@@@      CALL S1IODR(3,'WRITE',NDEPV,TCFB
)@@G@@,DUMMY)     @C@@@@      CALL S1IODR(3,'WRITE',NDVGRP,TW,DUMMY)    @]@@@@FC
)@@G@@      RETURN@[@@@@C     @[@@@@C     @#@@@@ 999  PRINT 9999  @C@@@@ 9999 FD
)@@G@@FORMAT(' ***** SYSTEM ERROR IN S82MOD')   @#@@@@      RETURN 7    @[@@@@FE
)@@G@@C     @[@@@@C     @C@@@@C        LOCAL SUBROUTINE FOR ERROR HANDLING    FF
)@@G@@@[@@@@C     @^@@@@      SUBROUTINE ERROR  @#@@@@      NERR=NERR+1 @^@@@@FG
)@@G@@      CALL S1PCHD(1)    @]@@@@      RETURN@[@@@@C     @[@@@@C     @C@@@@FH
)@@G@@C        LOCAL SUBROUTINE TO SET BIT IN A VECTOR@[@@@@C     @A@@@@      FI
)@@G@@SUBROUTINE SETBIT(BVEC,INDEX) @ @@@@      IMPLICIT INTEGER (A-Z)  @^@@@@FJ
)@@G@@      DIMENSION BVEC(1) @ @@@@      IF(INDEX .LE. 0) RETURN @^@@@@      FK
)@@G@@IW=(INDEX-1)/36   @^@@@@      IBIT=INDEX-36*IW-1@ @@@@      FLD(IBIT,1,BFL
)@@G@@VEC(IW+1))=1@]@@@@      RETURN@]@@@@      END   ___RPRINT .NE. 0  .OR.  FM
)@@G@@RPUNCH .NE. 0  .OR. RFILE .NE. 0)   @#@@@@     -*[S@@@*SDFF*@I@@@@      FN
)@@G@@SUBROUTINE S9DNPF(IMAGES,NCARDS,SCR,LSCR,NERR)                    STJ001FO
)@@G@@00    @I@@@@C                                                           FP
)@@G@@            STJ00200    @I@@@@C  IF NCARDS .EQ. 0, S9DNPF GENERATES CODEFQ
)@@G@@ WORDS FOR COMPLETELY CROSSED STJ00300    @I@@@@C    DESIGN (RECOGNIZINGFR
)@@G@@ POOL IF SET IN TAGGED STORAGE PRIOR TO CALL)   STJ00400    @I@@@@C     FS
)@@G@@                                                                  STJ005FT
)@@G@@00    @I@@@@      IMPLICIT INTEGER (A-Z)                                FU
)@@G@@            STJ00600    @I@@@@      COMMON X(2)                         FV
)@@G@@                              STJ00700    @I@@@@      DIMENSION IMAGES(2FW
)@@G@@),SCR(2),TABLE(30),NESTS(12,12)                 STJ00800    @I@@@@      FX
)@@G@@DIMENSION NAME1(2),NAME2(2)                                       STJ009FY
)@@G@@00    @I@@@@      DIMENSION JERR(12),JNAME(2,12),JFAC(12),TAGSCR(10)    FZ
)@@G@@            STJ01000    @I@@@@      DIMENSION MASK(12),B(12),C(325),D(32GA
)@@G@@5),E(325),NBITS(325),JJ(13)   STJ01100    @B@@@@      DIMENSION IVEC(325GB
)@@G@@),IN(6),OUT(6)    @B@@@@      DIMENSION LABEL(132),PLABEL(132)    @B@@@@GC
)@@G@@      EQUIVALENCE (LABEL(1),PLABEL(1))    @I@@@@      DATA (TABLE(I),I=1GD
)@@G@@,30)/                                           STJ01300    @I@@@@     *GE
)@@G@@12HNEST        ,-2,0,1,11,1,9,1,200,                              STJ014GF
)@@G@@00    @I@@@@     *12HWITHIN      ,-2,0,301,11,1,9,1,200,                GG
)@@G@@            STJ01500    @I@@@@     *12HPOOL        ,2,0,0,1,1,1,1,11/   GH
)@@G@@                              STJ01600    @I@@@@      DIMENSION CCTYPE(2GI
)@@G@@)                                               STJ01700    @I@@@@      GJ
)@@G@@DATA (CCTYPE(I),I=1,2)/12HDESIGN      /                           STJ018GK
)@@G@@00    @G@@@@        DATA COMMA,STAR,BLANK,WITHIN,NAME/2H ,,2H *,1H ,6HWIGL
)@@G@@THIN,0/     @^@@@@C******************     @[@@@@C     @G@@@@C       THISGM
)@@G@@ ROUTINE PROCESSES NWAY1 DESIGN CARDS OR GENERATES A FULLY  @D@@@@C     GN
)@@G@@  CROSSED DESIGN IF NO DESIGN CARD WAS PRESENT. @[@@@@C     @^@@@@C*****GO
)@@G@@*************     @[@@@@C     @A@@@@C       S9DNPF SYMBOL USAGE SUMMARY GP
)@@G@@@[@@@@C     @^@@@@C******************     @E@@@@C       B -        DIMENGQ
)@@G@@SIONED(12), NESTING INDICATORS.     @[@@@@C     @^@@@@C       BLANK -   GR
)@@G@@ =6H  @I@@@@C       C          DIMENSIONED(325), CODE WORD ARRAY. BIT SEGS
)@@G@@T FOR FACTOR IF THESE AR@D@@@@C                  WITHIN SOMETHING, OR NOGT
)@@G@@ WITHINS.   @[@@@@C     @C@@@@C       CCTYPE -   DIMENSIONED(2), =12HDESGU
)@@G@@IGN   @^@@@@C       COMMA -    =2H ,@I@@@@C       D -        DIMENSIONEDGV
)@@G@@(325), CODE WORD ARRAY. BIT SET FOR FACTOR IF C'S FACT@A@@@@C           GW
)@@G@@       ARE WITHIN D'S.  @#@@@@C       DCODE -   @[@@@@C     @A@@@@C     GX
)@@G@@  DUM -      DUMMY VARIABLE.  @G@@@@C       E -        DIMENSIONED(325),GY
)@@G@@ CODE WORD ARRAY THAT IS PASSED TO  @G@@@@C                  THE ANALYSIGZ
)@@G@@S PHASE.  EACH FACTOR HAS 3 BITS, FACTOR  @G@@@@C                  ONE GHA
)@@G@@ETTING THE LOW ORDER BITS.  ONLY THE LOWEST     @F@@@@C                 HB
)@@G@@ ORDER BIT IS USED, AND IT IS ONE IF THAT FACTOR@D@@@@C                 HC
)@@G@@ IS INVOLVED IN THIS INTERACTION.   @C@@@@C       EMAX -     MAXIMUM VALHD
)@@G@@UE IN THE E ARRAY.@B@@@@C       FW -       FIRST WORD OF TAG.     @B@@@@HE
)@@G@@C       I -        TEMPORARY VARIABLE.    @C@@@@C       ICKWD -    CODE HF
)@@G@@WORD WITH ALL BITS ON.  @A@@@@C       IDUM -     DUMMY VARIABLE.  @A@@@@HG
)@@G@@C       IFACT -    FACTOR NUMBER.   @B@@@@C       II -       TEMPORARY VHH
)@@G@@ARIABLE.    @F@@@@C       IMAGES -   FORMAL PARAMETER, DIMENSIONED(2), CHI
)@@G@@ARD IMAGES  @G@@@@C                  OF DESIGN CARD TO BE PROCESSED OR ZHJ
)@@G@@ERO IF FULLY CROSS@G@@@@C                  CROSSED DESIGN IS TO BE GENERHK
)@@G@@ATED AS THE DEFAULT.    @ @@@@C       IMAX -     MAXIMUM I. @G@@@@C     HL
)@@G@@  IN -       DIEMNSIONED(6), USED IN BUILDING LABELS FROM CODEWORD@B@@@@HM
)@@G@@C                  FOR STORING CHARACTERS.@F@@@@C       INEST -    COUNTHN
)@@G@@ OF THE NUMBER OF NEST CONTROL WORDS.     @G@@@@C       INICE -    USED HO
)@@G@@TO SET UP NICE OUTPUT, =2HST,2HND OR 2HRD OR 2HT@E@@@@C                 HP
)@@G@@ 2HTH DEPENDING ON NUMBER TO BE PRINTED.  @H@@@@C       ISW -      SWITCHQ
)@@G@@H, =0 OR 1, IF ONE WE NEED A * OR , BEFORE NEXT ENTRY.@C@@@@C       IVECHR
)@@G@@ -     DIMENSIONED(325), =0 OR 1.   @G@@@@C       IWITHN -   NUMBER OF WHS
)@@G@@ITHIN CONTROL WORDS ON THE DESIGN CARD.   @B@@@@C       I1 -       TEMPOHT
)@@G@@RARY VARIABLE.    @B@@@@C       I2 -       TEMPORARY VARIABLE.    @B@@@@HU
)@@G@@C       J --       TEMPORARY VARIABLE.    @G@@@@C       JERR -     DIMENHV
)@@G@@SIONED(12), NUMBER OF ERRORS IN MODIFIER LIST.  @G@@@@C       JFAC -    HW
)@@G@@ DIMENSIONED(12) FACTOR NUMBERS FROM THE WITHIN LIST  @G@@@@C       JFACHX
)@@G@@T -    FACTOR NUMBER RETURNED BY S9GTFC FROM WITHIN LIST.   @E@@@@C     HY
)@@G@@  JJ -       DIMENSIONED(13), TEMPORARY VARIABLE.     @G@@@@C       JNAMHZ
)@@G@@E -    DIMENSIONED(2,12) NAMES OF THE FACTOR VARIABLES IN   @A@@@@C     IA
)@@G@@             A WITHIN LIST.   @H@@@@C       JSW -      SWITCH. 1= IF THIIB
)@@G@@S WAS LAST WORD OF THE LABEL, 0 OTHERWISE.@B@@@@C       J1 -       TEMPOIC
)@@G@@RARY VARIABLE.    @B@@@@C       J2 -       TEMPORARY VARIABLE.    @B@@@@ID
)@@G@@C       K -        TEMPORARY VARIABLE.    @F@@@@C       KNF -      NUMBEIE
)@@G@@R OF FACTORS, INCLUDING ANY ORDERFAC.     @G@@@@C       LABEL -    DIMENIF
)@@G@@SIONED(132), EQUIVALENT TO PLABEL. SPACE FOR    @A@@@@C                 IG
)@@G@@ LABEL BUILDING.  @A@@@@C       LCHAR -    LAST CHARACTER.  @G@@@@C     IH
)@@G@@  LEND -     STATUS FROM S1IODR OR THE LENGTH OF CRACKED STRING   @A@@@@II
)@@G@@C                  FROM S1ENST.     @G@@@@C       LINFO -    POINTER TO IJ
)@@G@@TAG S9INFO IN BLANK COMMON ARRAY, EQUIV.  @ @@@@C                  LOCS9IK
)@@G@@.     @G@@@@C       LMAX -     MAXIMUM NUMBER OF WORDS THAT S1ENDC CAN UIL
)@@G@@SE IN THE   @A@@@@C                  SCRATCH ARRAY.   @E@@@@C       LOC IM
)@@G@@-      LOCATION OF VNAME IN BLANK COMMON ARRAY. @E@@@@C       LOCS9 -   IN
)@@G@@ EQUIV. LINFO - POINTER TO TAG S9INFO.    @D@@@@C       LOOP -     FROM IO
)@@G@@1 TO KNF, A POINTER INTO JJ.  @D@@@@C       LSCR -     FORMAL PARAMETER,IP
)@@G@@ LENGTH OF SCR.   @B@@@@C       LTOP -     TEMPORARY VARIABLE.    @G@@@@IQ
)@@G@@C       MASK -     DIMENSIONED(12), BITS SET IN FACTORS POSITION IN EACHIR
)@@G@@@^@@@@C                  CELL.@F@@@@C       NAME -     POINTER TO TAG 'VIS
)@@G@@ANMES' IN BLANK COMMON ARRAY. @E@@@@C       NAME1 -    DIMENSIONED(2), NIT
)@@G@@AME OF THE NEST FACTOR. @F@@@@C       NAME2 -    DIMENSIONED(2), NAME OFIU
)@@G@@ THE WITHIN FACTOR.     @G@@@@C       NB -       DIMENSIONED(325) NUMBERIV
)@@G@@ OF BITS SET IN CODE WORDS.   @F@@@@C                  THUS, NUMBER OF FIW
)@@G@@ACTORS IN THIS CODE WORD.     @D@@@@C       NBITS -    NUMBER OF BITS SEIX
)@@G@@T IN THE CODEWORD.@F@@@@C       NBMIN -    MINIMUM NUMBER OF BITS SET INIY
)@@G@@ ANY CODE WORD.   @A@@@@C                  USED IN THE SORT.@E@@@@C     IZ
)@@G@@  NCARDS -   NUMBER OF CARDS IN A SET OF DESIGN CARDS.@D@@@@C       NCW JA
)@@G@@-      NUMBER OF CODE WORDS GENERATED.    @^@@@@C       NCW1 -     NCW-1JB
)@@G@@@^@@@@C       NCW2 -     NCW+2@F@@@@C       NERR -     FORMAL PARAMETER JC
)@@G@@NUMBER OF CONTROL CARD ERRS   @G@@@@C       NERR1 -    NUMBER OF CONTROLJD
)@@G@@ CARD ERRORS FOUND BY SUBSIDIARY    @ @@@@C                  ROUTINE.   JE
)@@G@@@F@@@@C       NERR2 -    NUMBER OF CONTROL CARD ERRORS FOUND BY S9GTFC. JF
)@@G@@@C@@@@C       NERR3 -    TEMPORARY NUMBER OF ERRORS.  @C@@@@C       NERRJG
)@@G@@4 -    TEMPORARY NUMBER OF ERRORS.  @G@@@@C       NESTS -    DIMENSIONEDJH
)@@G@@(12,12), (N,M) IF FACTOR N IS WITHIN M.   @C@@@@C       NF -       NUMBEJI
)@@G@@R OF FACTOR VARIABLES.  @E@@@@C       NPOOL -    VALUE OF MODIFIER TO POJJ
)@@G@@OL CONTROL WORD.  @C@@@@C       NUMNST -   DO-LOOP PARAMETER ON NEST.   JK
)@@G@@@G@@@@C       OUT -      DIMENSIONED(6), USED TO HOLD ONE WORD FULL OF CJL
)@@G@@HARACT@A@@@@C       OUTP -     POINTER TO OUT.  @G@@@@C       PLABEL -  JM
)@@G@@ DIMENSIONED(132), EQUIV. LABEL, PLACE TO BUILD PACKED@ @@@@C           JN
)@@G@@       LABEL.     @D@@@@C       POINT -    POINTER TO THE LABEL BEING BUJO
)@@G@@ILT.  @C@@@@C       PP -       POINTER TO PACKED LABEL.     @G@@@@C     JP
)@@G@@  SCR -      FORMAL PARAMETER, DIMENSIONED(2), SCRATCH ARRAY.     @^@@@@JQ
)@@G@@C       STAR -     =2H *@C@@@@C       S1ENDC -   CRACKS CARD INTO TOKENSJR
)@@G@@.     @G@@@@C       S1ENST -   CHECKS TOKENS FOR LEGALITY AND FURTHER CRJS
)@@G@@ACKS THE    @^@@@@C                  CARD.@C@@@@C       S1GTAG -   RETRIJT
)@@G@@EVES POINTERS TO A TAG. @C@@@@C       S1GVAL -   RETRIEVES THE VALUE OF JU
)@@G@@A TAG.@A@@@@C       S1IODR -   DOES DISK I/O    @F@@@@C       S1SERR -  JV
)@@G@@ ROUTINE TO PRINT STATJOB SYSTEM ERROR MESSAGE. @E@@@@C       S1STFT -  JW
)@@G@@ CREATES TAGS AND ALLOCATES THEIR STORAGE.@G@@@@C       S9GTFC -   RETURJX
)@@G@@NS A FACTOR NUMBER AND ITS NAME FROM WITHIN OR N@ @@@@C                 JY
)@@G@@ NEST WORD. @G@@@@C       TABLE -    DIMENSIONED(30) SPECIFIES NAMES ANDJZ
)@@G@@ TYPES OF CONTROL @E@@@@C                  WORDS ALLOWED ON DESIGN CARD KA
)@@G@@FOR S1ENST. @F@@@@C       TAGSCR -   DIMENSIONED(10), PASED TO S1ENST ASKB
)@@G@@ SCRATCH.   @B@@@@C       TEMP -     TEMPORARY VARIABLE.    @E@@@@C     KC
)@@G@@  TEST -     ZERO OR THE VALUE OF THE TAG 'TEST'.     @B@@@@C       TOP KD
)@@G@@-      TEMPORARY VARIABLE.    @D@@@@C       VARNO -    INPUT VARIABLE FOKE
)@@G@@R THE FACTOR.     @ @@@@C       WITHIN -   =6HWITHIN  @D@@@@C       X - KF
)@@G@@       DIMENSIONED(2) BLANK COMMON ARRAY. @B@@@@C       XC -       TEMPOKG
)@@G@@RARY VARIABLE.    @B@@@@C       XD -       TEMPORARY VARIABLE.    @[@@@@KH
)@@G@@C     @^@@@@C******************     @[@@@@C     @C@@@@C       S9DNPF TAGKI
)@@G@@GED STORAGE USAGE SUMMARY.    @[@@@@C     @^@@@@C******************     KJ
)@@G@@@[@@@@C     @G@@@@C       'CROSSD'   IS RETRIEVED TO DIAGNOSE ERROR THATKK
)@@G@@ NESTED DESIGN IS @F@@@@C                  NOT FULLY CROSSED, AND CAN'T KL
)@@G@@BE CROSSEDFIXDF.  @G@@@@C       'POOL'     IS RETRIEVED TO GET THE VALUEKM
)@@G@@ OF MODIFIER OF THIS    @ @@@@C                  CODE WORD. @G@@@@C     KN
)@@G@@  'S9CODE'   IS RETRIEVED TO PREVENT THE USE OF BOTH DESIGN AND   @G@@@@KO
)@@G@@C                  CODE CONTROL CARDS. ALSO CREATED TO HOLD THE CODE    KP
)@@G@@@ @@@@C                  WORDS.     @C@@@@C       'S9ICOD'   IS CREATED KQ
)@@G@@TO HOLD IVEC.     @D@@@@C       'S9INFO'   RETRIEVED FOR FACTOR INFORMATKR
)@@G@@ION.  @G@@@@C       'TEST' -   IS RETRIEVED TO DECIDE WHETHER TO PRINT DKS
)@@G@@IAGNOSTIC   @ @@@@C                  OUTPUT.    @F@@@@C       'VNAMES'  KT
)@@G@@ IS RETRIEVED TO GET FACTORS VARIABLE NAMES.    @[@@@@C     @^@@@@C*****KU
)@@G@@*************     @[@@@@C     @A@@@@C       S9DNPF DISK I/O USAGE SUMARYKV
)@@G@@@[@@@@C     @^@@@@C******************     @[@@@@C     @G@@@@C       UNITKW
)@@G@@ 2     IS WRITTEN WITH LABELS FOR TH( ANOVA TABLE IN RECORDS@F@@@@C     KX
)@@G@@             OF THE FORM: WORD 1= NUMBER OF FOLLOWINF WORDS,@D@@@@C     KY
)@@G@@             WORDS 2 TO N+1 LABEL IN FIELDATA.  @D@@@@C       UNIT 2    KZ
)@@G@@ IS ENDFILED AND REWOUND AT THE END.@[@@@@C     @^@@@@C*****************LA
)@@G@@*     @[@@@@C     @ @@@@C       SET IVEC TO ZERO.     @[@@@@C     @^@@@@LB
)@@G@@C******************     @I@@@@      DO 5 I=1,325                        LC
)@@G@@                              STJ01900    @I@@@@5     IVEC(I)=0         LD
)@@G@@                                                STJ02000    @^@@@@C*****LE
)@@G@@*************     @[@@@@C     @ @@@@C       SET NESTS TO ZERO.    @[@@@@LF
)@@G@@C     @I@@@@      DO 10  I=1,12                                         LG
)@@G@@            STJ02100    @I@@@@      DO 10 J=1,12                        LH
)@@G@@                              STJ02200    @I@@@@      NESTS(I,J)=0      LI
)@@G@@                                                STJ02300    @I@@@@   10 LJ
)@@G@@CONTINUE                                                          STJ024LK
)@@G@@00    @I@@@@      LOCS9=0                                               LL
)@@G@@            STJ02500    @I@@@@      NF=0                                LM
)@@G@@                              STJ02600    @^@@@@C******************     LN
)@@G@@@^@@@@C******************     @[@@@@C     @A@@@@C       GET THE NUMBER OLO
)@@G@@F FACTORS.  @[@@@@C     @^@@@@C******************     @I@@@@      CALL SLP
)@@G@@1GTAG('S9INFO',LOCS9,DUM,DUM,$20)                           STJ02700    LQ
)@@G@@@I@@@@      NF=X(LOCS9)                                                 LR
)@@G@@      STJ02800    @I@@@@   20 IF (NF.NE.0) TABLE(30)=NF                 LS
)@@G@@                        STJ02900    @D@@@@      IF(X(LOCS9+1) .NE. 0) TALT
)@@G@@BLE(30)=TABLE(30)+1     @#@@@@      INEST=0     @I@@@@      IF (NCARDS.ELU
)@@G@@Q.0) GO TO 170                                        STJ03000    @I@@@@LV
)@@G@@      IF(LSCR.LT.1000) GO TO 999                                        LW
)@@G@@STJ03200    @I@@@@      LMAX=LSCR-600                                   LX
)@@G@@                  STJ03300    @I@@@@      CALL S1ENDC(CCTYPE,IMAGES,NCARLY
)@@G@@DS,SCR(601),LMAX,LEND,NERR1,$999)   STJ03500    @I@@@@      NERR=NERR+NELZ
)@@G@@RR1                                                   STJ03600    @I@@@@MA
)@@G@@      IF (NERR1.GT.0) GO TO 900                                         MB
)@@G@@STJ03700    @I@@@@      J=600                                           MC
)@@G@@                  STJ03800    @I@@@@      IWITHN=0                      MD
)@@G@@                                    STJ03900    @I@@@@      LTOP=600+LENME
)@@G@@D                                                     STJ04100    @I@@@@MF
)@@G@@   30 J=J+1                                                             MG
)@@G@@STJ04200    @I@@@@      IF (J.GT.LTOP) GO TO 60                         MH
)@@G@@                  STJ04300    @I@@@@      IF(SCR(J).NE.0) GO TO 30      MI
)@@G@@                                    STJ04400    @I@@@@      J=J+1       MJ
)@@G@@                                                      STJ04500    @I@@@@MK
)@@G@@      IF (SCR(J).EQ.6HNEST  ) GO TO 40                                  ML
)@@G@@STJ04600    @I@@@@      IF (SCR(J).EQ.6HWITHIN) GO TO 50                MM
)@@G@@                  STJ04700    @I@@@@      GO TO 30                      MN
)@@G@@                                    STJ04800    @I@@@@   40 INEST=INEST+MO
)@@G@@1                                                     STJ04900    @I@@@@MP
)@@G@@      GO TO 30                                                          MQ
)@@G@@STJ05000    @I@@@@   50 IWITHN=IWITHN+1                                 MR
)@@G@@                  STJ05100    @I@@@@      IF (IWITHN.EQ.INEST) GO TO 30 MS
)@@G@@                                    STJ05200    @I@@@@   55 NERR=NERR+1 MT
)@@G@@                                                      STJ05300    @I@@@@MU
)@@G@@      INICE=6HTH                                                        MV
)@@G@@STJ05400    @I@@@@      IF (IWITHN.EQ.1) INICE=6HST                     MW
)@@G@@                  STJ05500    @I@@@@      IF (IWITHN.EQ.2) INICE=6HND   MX
)@@G@@                                    STJ05600    @I@@@@      IF (IWITHN.EMY
)@@G@@Q.3) INICE=6HRD                                       STJ05700    @I@@@@MZ
)@@G@@      CALL S1PCHD(1)                                                    NA
)@@G@@STJ05800    @I@@@@      PRINT 57,IWITHN,INICE                           NB
)@@G@@                  STJ05900    @I@@@@   57 FORMAT(' ***** NWAY1 ERROR. NENC
)@@G@@ST()WITHIN() SYNTAX ERROR DETECTED ASTJ06000    @I@@@@     *T ',I2,A2,' ND
)@@G@@OCCURRANCE OF THE CONTROL WORD WITHIN.')              STJ06100    @I@@@@NE
)@@G@@      GO TO 900                                                         NF
)@@G@@STJ06200    @I@@@@   60 IF (INEST.NE.IWITHN) GO TO 55                   NG
)@@G@@                  STJ06300    @I@@@@      IF (NF.EQ.0) GO TO 900        NH
)@@G@@                                    STJ06400    @I@@@@      CALL S1ENST(NI
)@@G@@CCTYPE,SCR(601),LEND,TABLE,3,0,SCR(1),600,TAGSCR,     STJ06500    @I@@@@NJ
)@@G@@     *NERR1)                                                            NK
)@@G@@STJ06600    @I@@@@      NERR=NERR+NERR1                                 NL
)@@G@@                  STJ06700    @B@@@@      CALL S1GTAG('POOL',DUM,DUM,DUMNM
)@@G@@,$65) @B@@@@      CALL S1GTAG('EMS',DUM,DUM,DUM,$64)  @#@@@@ 62   NERR=NNN
)@@G@@ERR+1 @^@@@@      CALL S1PCHD(1)    @#@@@@      PRINT 63    @G@@@@ 63   NO
)@@G@@FORMAT(' ***** NWAY1 ERROR.  POOL CANNOT BE USED IF EMS OR ZEROTER@A@@@@NP
)@@G@@     -MS IS ON THE ANALYSIS CARD')  @#@@@@      GO TO 65    @C@@@@ 64   NQ
)@@G@@CALL S1GTAG('ZEROTM',DUM,DUM,DUM,$65)     @#@@@@      GO TO 62    @#@@@@NR
)@@G@@ 65   CONTINUE    @I@@@@      IF (NERR1.NE.0) GO TO 900                 NS
)@@G@@                        STJ06800    @I@@@@C                             NT
)@@G@@                                          STJ06900    @I@@@@C****BUILD NNU
)@@G@@ESTS TABLE - NESTS(I,J)=1 IF NEST(I)WITHIN(J)               STJ07000    NV
)@@G@@@I@@@@      NERR4=0                                                     NW
)@@G@@      STJ07100    @I@@@@      J1=1                                      NX
)@@G@@                        STJ07200    @I@@@@      J2=301                  NY
)@@G@@                                          STJ07300    @I@@@@      IF(SCRNZ
)@@G@@(J1).NE.INEST) GO TO 999                                    STJ07500    OA
)@@G@@@I@@@@      IF(SCR(J2).NE.IWITHN) GO TO 999                             OB
)@@G@@      STJ07700    @I@@@@      J1=J1+1                                   OC
)@@G@@                        STJ07800    @I@@@@      J2=J2+1                 OD
)@@G@@                                          STJ07900    @I@@@@      IF(INEOE
)@@G@@ST.LT.1) GO TO 170                                          STJ08000    OF
)@@G@@@I@@@@C                                                                 OG
)@@G@@      STJ08100    @F@@@@C     CHECK FOR PRESENCE OF CROSSDFIXDF-IF PRESEOH
)@@G@@NT, PRINT WARNING @C@@@@      CALL S1GTAG('CROSSD',IDUM,DUM,DUM,$73)    OI
)@@G@@@#@@@@      PRINT 72    @G@@@@72    FORMAT('*****NWAY1 NOTE---THE F-RATIOJ
)@@G@@OS GIVEN AS OUTPUT APPLY ONLY @G@@@@     XTO A COMPLETELY CROSSED DESIGNOK
)@@G@@.'/17X,' THIS DESIGN INCLUDES NESTIN@E@@@@     XG. F-RATIOS WILL NOT BE OL
)@@G@@INCLUDED IN THE OUTPUT.')     @#@@@@      X(IDUM)=0   @#@@@@73    CONTINOM
)@@G@@UE    @I@@@@C****LOOP ON NO. NEST()WITHIN() SPECIFICATIONS              ON
)@@G@@            STJ08200    @I@@@@C                                         OO
)@@G@@                              STJ08300    @I@@@@      DO 160 NUMNST=1,INOP
)@@G@@EST                                             STJ08400    @I@@@@      OQ
)@@G@@I1=SCR(J1)                                                        STJ085OR
)@@G@@00    @I@@@@      J1=J1+1                                               OS
)@@G@@            STJ08600    @I@@@@      I2=SCR(J2)                          OT
)@@G@@                              STJ08700    @I@@@@      J2=J2+1           OU
)@@G@@                                                STJ08800    @I@@@@C     OV
)@@G@@                                                                  STJ089OW
)@@G@@00    @I@@@@C****LOOP ON NO. MODIFIERS OF NEST()                        OX
)@@G@@            STJ09000    @I@@@@C                                         OY
)@@G@@                              STJ09100    @I@@@@      DO 150 I=1,I1     OZ
)@@G@@                                                STJ09200    @I@@@@      PA
)@@G@@CALL S9GTFC(SCR,J1,IFACT,NAME1,NERR1)                             STJ093PB
)@@G@@00    @I@@@@C ABOVE CALL RETRIEVES FACTOR NUMBER IN IFACT,AND           PC
)@@G@@            STJ09400    @I@@@@C  RESETS J1 TO NEXT MODE IN LIST OF NEST PD
)@@G@@MODIFIERS.                    STJ09500    @I@@@@      IF (NERR1.EQ.0) GOPE
)@@G@@ TO 110                                         STJ09600    @I@@@@      PF
)@@G@@NERR4=NERR4+1                                                     STJ097PG
)@@G@@00    @I@@@@      CALL S1PCHD(1)                                        PH
)@@G@@            STJ09800    @I@@@@      PRINT 105,I,NUMNST                  PI
)@@G@@                              STJ09900    @I@@@@  105 FORMAT(' ***** NWAPJ
)@@G@@Y1 ERROR. MODIFIER ',I2,' OF NEST() SPECIFICATIOSTJ10000    @I@@@@     *PK
)@@G@@N ',I2,' IS NOT A FACTOR VARIABLE.')                              STJ101PL
)@@G@@00    @I@@@@  110 CONTINUE                                              PM
)@@G@@            STJ10200    @I@@@@C                                         PN
)@@G@@                              STJ10300    @I@@@@C****LOOP ON NO. MODIFIEPO
)@@G@@RS OF WITHIN()                                  STJ10400    @I@@@@C     PP
)@@G@@                                                                  STJ105PQ
)@@G@@00    @I@@@@      DO 140 J=1,I2                                         PR
)@@G@@            STJ10600    @I@@@@      IF(I.GT.1) GO TO 120                PS
)@@G@@                              STJ10700    @I@@@@      CALL S9GTFC(SCR,J2PT
)@@G@@,JFACT,NAME2,NERR2)                             STJ10800    @I@@@@C  ABOPU
)@@G@@VE CALL RETRIEVS FACTOR NUMBER IN JFACT, AND                      STJ109PV
)@@G@@00    @I@@@@C  RESETS J2 TO NEXT MODE WORD IN LIST OF WITHIN MODIFIERS. PW
)@@G@@            STJ11000    @I@@@@      JERR(J)=NERR2                       PX
)@@G@@                              STJ11100    @I@@@@      JFAC(J)=JFACT     PY
)@@G@@                                                STJ11200    @I@@@@      PZ
)@@G@@JNAME(1,J)=NAME2(1)                                               STJ113QA
)@@G@@00    @I@@@@      JNAME(2,J)=NAME2(2)                                   QB
)@@G@@            STJ11400    @I@@@@      IF (NERR2.EQ.0) GO TO 120           QC
)@@G@@                              STJ11500    @I@@@@      NERR4=NERR4+1     QD
)@@G@@                                                STJ11600    @I@@@@      QE
)@@G@@CALL S1PCHD(1)                                                    STJ117QF
)@@G@@00    @I@@@@      PRINT 115,J,NUMNST                                    QG
)@@G@@            STJ11800    @I@@@@  115 FORMAT(' ***** NWAY1 ERROR. MODIFIERQH
)@@G@@ ',I2,' OF WITHIN() SPECIFICATSTJ11900    @I@@@@     *ION ',I2,' IS NOT QI
)@@G@@A FACTOR VARIABLE.')                            STJ12000    @I@@@@      QJ
)@@G@@GO TO 140                                                         STJ121QK
)@@G@@00    @I@@@@  120 IF (NERR1.NE.0) GO TO 140                             QL
)@@G@@            STJ12200    @I@@@@      IF (JERR(J).NE.0) GO TO 140         QM
)@@G@@                              STJ12300    @I@@@@      JFACT=JFAC(J)     QN
)@@G@@                                                STJ12400    @I@@@@      QO
)@@G@@NAME2(1)=JNAME(1,J)                                               STJ125QP
)@@G@@00    @I@@@@      NAME2(2)=JNAME(2,J)                                   QQ
)@@G@@            STJ12600    @I@@@@      NERR3=0                             QR
)@@G@@                              STJ12700    @I@@@@      IF (NESTS(IFACT,JFQS
)@@G@@ACT).EQ.0) GO TO 125                            STJ12800    @I@@@@      QT
)@@G@@NERR3=NERR3+1                                                     STJ129QU
)@@G@@00    @I@@@@      CALL S1PCHD(2)                                        QV
)@@G@@            STJ13000    @I@@@@      PRINT 122,NAME1,NAME2,NUMNST        QW
)@@G@@                              STJ13100    @I@@@@  122 FORMAT(' ***** NWAQX
)@@G@@Y1 ERROR. FACTOR VARIABLE ',A6,A2,' IS NESTED WISTJ13200    @I@@@@     *QY
)@@G@@THIN FACTOR VARIABLE ',A6,A2,' IN MORE THAN ONE '/20X,'NEST()WITHISTJ133QZ
)@@G@@00    @I@@@@     *N() SPECIFICATION.  ERROR DETECTED IN SPECIFICATION ',RA
)@@G@@I2)         STJ13400    @I@@@@  125 IF (NESTS(JFACT,IFACT).EQ.0) GO TO 1RB
)@@G@@30                            STJ13500    @I@@@@      NERR3=NERR3+1     RC
)@@G@@                                                STJ13600    @I@@@@      RD
)@@G@@CALL S1PCHD(2)                                                    STJ137RE
)@@G@@00    @I@@@@      PRINT 127,NAME1,NAME2,NUMNST                          RF
)@@G@@            STJ13800    @I@@@@  127 FORMAT(' ***** NWAY1 ERROR. FACTOR VRG
)@@G@@ARIABLE ',A6,A2,' IS NESTED WISTJ13900    @I@@@@     *THIN FACTOR VARIABRH
)@@G@@LE ',A6,A2,' IN NEST()WITHIN() SPECIFICATION ', STJ14000    @I@@@@     *RI
)@@G@@I2/19X,' AND VICE-VERSA IN A PREVIOUS SPECIFICATION.')            STJ141RJ
)@@G@@00    @I@@@@  130 IF (IFACT.NE.JFACT) GO TO 135                         RK
)@@G@@            STJ14200    @I@@@@      NERR3=NERR3+1                       RL
)@@G@@                              STJ14300    @I@@@@      CALL S1PCHD(1)    RM
)@@G@@                                                STJ14400    @I@@@@      RN
)@@G@@PRINT 132,NAME1,NUMNST                                            STJ145RO
)@@G@@00    @I@@@@  132 FORMAT(' ***** NWAY1 ERROR. FACTOR VARIABLE ',A6,A2,' RP
)@@G@@APPEARS IN BSTJ14600    @I@@@@     *OTH LISTS OF NEST()WITHIN() SPECIFICRQ
)@@G@@ATION ',I2)                   STJ14700    @I@@@@  135 NERR4=NERR4+NERR3 RR
)@@G@@                                                STJ14800    @I@@@@      RS
)@@G@@IF (NERR3.NE.0) GO TO 140                                         STJ149RT
)@@G@@00    @I@@@@      NESTS(IFACT,JFACT)=1                                  RU
)@@G@@            STJ15000    @I@@@@  140 CONTINUE                            RV
)@@G@@                              STJ15100    @I@@@@  150 CONTINUE          RW
)@@G@@                                                STJ15200    @I@@@@  160 RX
)@@G@@CONTINUE                                                          STJ153RY
)@@G@@00    @I@@@@      NERR=NERR+NERR4                                       RZ
)@@G@@            STJ15400    @D@@@@      CALL S1GTAG('ZEROTM',LZEROT,DUM,NZERSA
)@@G@@OT,$168)    @]@@@@      KNF=NF@B@@@@      IF(X(LOCS9+1) .NE. 0) KNF=KNF+SB
)@@G@@1     @ @@@@      IF(KNF .LT. 1) GO TO 168@ @@@@      DO 166 NZT=1,NZEROSC
)@@G@@T     @^@@@@      ZEROT=X(LZEROT)   @^@@@@      LZEROT=LZEROT+1   @#@@[@SD
)@@G@@      K=8**(KNF-1)@^[@@@      DO 165 I=2,KNF    @B@@@@      IF(AND(K,ZERSE
)@@G@@OT) .EQ. 0) GO TO 165   @]@@[@      KK=K/8@^[@@@      DO 164 J=I,KNF    SF
)@@G@@@B@@@@      IF(AND(KK,ZEROT) .EQ. 0) GO TO 164  @G@@@@      IF(NESTS(I-1SG
)@@G@@,J) .EQ. 0  .AND.  NESTS(J,I-1) .EQ. 0) GO TO 164     @ @@@@      CALL GSH
)@@G@@ETNAM(I-1,NAME1)  @ @@@@      CALL GETNAM(J,NAME2)    @#@@@@      NERR=NSI
)@@G@@ERR+1 @^@@@@      CALL S1PCHD(2)    @ @@@@      PRINT 162,NAME1,NAME2   SJ
)@@G@@@G@@@@ 162  FORMAT(' ***** NWAY1 ERROR.  THE INTERACTION ',A6,A2,'*',A6,SK
)@@G@@A2,' I@G@@@@     -S SPECIFIED WITH ZEROTERMS ON THE ANALYSIS CARD,'/23X,SL
)@@G@@'BUT ONE FAC@B@@@@     -TOR IS NESTED WITHIN THE OTHER')    @#@@[@ 164  SM
)@@G@@KK=KK/8     @]@@[@ 165  K=K/8 @#]@@@ 166  CONTINUE    @#@@@@ 168  CONTINSN
)@@G@@UE    @I@@@@      IF (NERR4.NE.0) GO TO 900                             SO
)@@G@@            STJ15500    @I@@@@C                                         SP
)@@G@@                              STJ15700    @I@@@@C****INITIALIZATION PRIOSQ
)@@G@@R TO GENERATE CODE WORDS...                     STJ15800    @I@@@@C     SR
)@@G@@                                                                  STJ159SS
)@@G@@00    @I@@@@  170 CONTINUE                                              ST
)@@G@@            STJ16000    @I@@@@      KNF=NF                              SU
)@@G@@                              STJ16100    @I@@@@      IF(X(LOCS9+1).NE.0SV
)@@G@@) KNF=KNF+1                                     STJ16200    @I@@@@      SW
)@@G@@IF (KNF.LT.1) GO TO 900                                           STJ163SX
)@@G@@00    @A@@@@      IF(INEST .EQ. 0) GO TO 174    @C@@@@      CALL S1STFT(SY
)@@G@@'S9NEST',LNEST,1,KNF*KNF,$999)@^@@@@C****ENSURE TRANSITIVITY@#@@@@      SZ
)@@G@@IMPLY=0     @^@@@@      DO 1735 I=1,KNF   @^@@@@ 171  DO 173 J=1,KNF    TA
)@@G@@@B@@@@      IF(NESTS(I,J) .EQ. 0) GO TO 173     @^@@@@      DO 172 IJ=1,TB
)@@G@@KNF   @B@@@@      IF(NESTS(J,IJ) .EQ. 0) GO TO 172    @B@@@@      IF(NESTC
)@@G@@TS(I,IJ) .NE. 0) GO TO 172    @ @@@@      IF(I .EQ. IJ) GO TO 172 @^@@@@TD
)@@G@@      NESTS(I,IJ)=1     @#@@@@      IMPLY=1     @ @@@@      CALL GETNAM(TE
)@@G@@I,NAME1)    @ @@@@      CALL GETNAM(IJ,NAME2)   @^@@@@      CALL S1PCHD(TF
)@@G@@1)    @ @@@@      PRINT 1705,NAME1,NAME2  @G@@@@ 1705 FORMAT(' NOTE.  NETG
)@@G@@ST(',A6,A2,') WITHIN (',A6,A2,') IS IMPLIED AND @A@@@@     -IS USED IN TTH
)@@G@@HE ANALYSIS.')    @#@@@@      GO TO 171   @#@@@@ 172  CONTINUE    @#@@@@TI
)@@G@@ 173  CONTINUE    @#@@@@ 1735 CONTINUE    @A@@@@      IF(IMPLY .EQ. 0) GTJ
)@@G@@O TO 1739   @^@@@@      DO 1738 I=2,KNF   @^@@@@      DO 1737 J=I,KNF   TK
)@@G@@@G@@@@      IF(NESTS(I-1,J) .EQ. 0  .OR.  NESTS(J,I-1) .EQ. 0) GO TO 173TL
)@@G@@7     @ @@@@      CALL GETNAM(I-1,NAME1)  @ @@@@      CALL GETNAM(J,NAMETM
)@@G@@2)    @^@@@@      CALL S1PCHD(1)    @^@@@@      NERR4=NERR4+1     @ @@@@TN
)@@G@@      PRINT 1736,NAME1,NAME2  @G@@@@ 1736 FORMAT(' ***** NWAY1 ERROR.  FTO
)@@G@@ACTOR VARIABLE ',A6,A2,' IS NESTED W@D@@@@     -ITHIN FACTOR VARIABLE ',TP
)@@G@@A6,A2,' AND VICE-VERSA')@#@@@@ 1737 CONTINUE    @#@@@@ 1738 CONTINUE    TQ
)@@G@@@^@@@@      NERR=NERR+NERR4   @A@@@@      IF(NERR4 .NE. 0) GO TO 900    TR
)@@G@@@#@@@@ 1739 CONTINUE    @B@@@@      CALL S9GTST(KNF,NESTS,SCR,LSCR,$999)TS
)@@G@@@#@@@@ 174  CONTINUE    @I@@@@C****GENERATE MASKS                       TT
)@@G@@                              STJ16400    @I@@@@      K=1               TU
)@@G@@                                                STJ16500    @I@@@@      TV
)@@G@@DO 175 I=1,KNF                                                    STJ166TW
)@@G@@00    @I@@@@      J=KNF-I+1                                             TX
)@@G@@            STJ16700    @I@@@@      MASK(J)=K                           TY
)@@G@@                              STJ16800    @I@@@@      K=K*8             TZ
)@@G@@                                                STJ16900    @I@@@@  175 UA
)@@G@@CONTINUE                                                          STJ170UB
)@@G@@00    @I@@@@C****GENERATE (B(I),I=1,KNF)                                UC
)@@G@@            STJ17100    @I@@@@      DO 190 I=1,KNF                      UD
)@@G@@                              STJ17200    @I@@@@      B(I)=0            UE
)@@G@@                                                STJ17300    @I@@@@      UF
)@@G@@DO 185 J=1,KNF                                                    STJ174UG
)@@G@@00    @I@@@@      IF (NESTS(I,J).NE.0) B(I)=B(I)+MASK(J)                UH
)@@G@@            STJ17500    @A@@@@      IF(INEST .EQ. 0) GO TO 185    @ @@@@UI
)@@G@@      X(LNEST)=NESTS(I,J)     @^@@@@      LNEST=LNEST+1     @I@@@@  185 UJ
)@@G@@CONTINUE                                                          STJ176UK
)@@G@@00    @I@@@@  190 CONTINUE                                              UL
)@@G@@            STJ17700    @I@@@@C                                         UM
)@@G@@                              STJ17800    @I@@@@C****GENERATE CODE WORDSUN
)@@G@@                                                STJ17900    @I@@@@C     UO
)@@G@@                                                                  STJ180UP
)@@G@@00    @I@@@@      NPOOL=0                                               UQ
)@@G@@            STJ18100    @I@@@@      CALL S1GVAL('POOL',NPOOL,$198,$198) UR
)@@G@@                              STJ18200    @I@@@@198   ICKWD=0           US
)@@G@@                                                STJ18300    @I@@@@      UT
)@@G@@DO 199 I=1,KNF                                                    STJ184UU
)@@G@@00    @I@@@@199   ICKWD=ICKWD*8+1                                       UV
)@@G@@            STJ18500    @I@@@@      NCW=1                               UW
)@@G@@                              STJ18600    @I@@@@      LOOP=0            UX
)@@G@@                                                STJ18700    @I@@@@  200 UY
)@@G@@LOOP=LOOP+1                                                       STJ188UZ
)@@G@@00    @I@@@@      IF(LOOP.GT.KNF)GO TO 282                              VA
)@@G@@            STJ18900    @I@@@@      DO 205 I=1,LOOP                     VB
)@@G@@                              STJ19000    @I@@@@  205 JJ(I)=I           VC
)@@G@@                                                STJ19100    @I@@@@      VD
)@@G@@JJ(LOOP+1)=KNF+1                                                  STJ192VE
)@@G@@00    @I@@@@      GO TO 240                                             VF
)@@G@@            STJ19300    @I@@@@  225 DO 230 I=1,LOOP                     VG
)@@G@@                              STJ19400    @I@@@@      JJ(I)=JJ(I)+1     VH
)@@G@@                                                STJ19500    @I@@@@      VI
)@@G@@IF (JJ(I).LT.JJ(I+1)) GO TO 240                                   STJ196VJ
)@@G@@00    @I@@@@  230 JJ(I)=I                                               VK
)@@G@@            STJ19700    @I@@@@      GO TO 200                           VL
)@@G@@                              STJ19800    @I@@@@  240 XC=0              VM
)@@G@@                                                STJ19900    @I@@@@      VN
)@@G@@IF(NPOOL.EQ.0)GO TO 249                                           STJ200VO
)@@G@@00    @I@@@@      IF(LOOP.LT.NPOOL)GO TO 249                            VP
)@@G@@            STJ20100    @I@@@@      C(NCW)=ICKWD                        VQ
)@@G@@                              STJ20200    @I@@@@      E(NCW)=ICKWD      VR
)@@G@@                                                STJ20300    @I@@@@      VS
)@@G@@NBITS(NCW)=KNF                                                    STJ204VT
)@@G@@00    @I@@@@      NCW=NCW+1                                             VU
)@@G@@            STJ20500    @I@@@@      GO TO 282                           VV
)@@G@@                              STJ20600    @I@@@@249   DO 250 I=1 ,LOOP  VW
)@@G@@                                                STJ20700    @I@@@@      VX
)@@G@@K=JJ(I)                                                           STJ208VY
)@@G@@00    @I@@@@  250 XC=XC+MASK(K)                                         VZ
)@@G@@            STJ20900    @I@@@@      XD=0                                WA
)@@G@@                              STJ21000    @I@@@@      DO 260 I=1,LOOP   WB
)@@G@@                                                STJ21100    @I@@@@      WC
)@@G@@K=JJ(I)                                                           STJ212WD
)@@G@@00    @I@@@@  260 XD=OR(XD,B(K))                                        WE
)@@G@@            STJ21300    @I@@@@      IF (AND(XC,XD).NE.0) GO TO 225      WF
)@@G@@                              STJ21400    @I@@@@      IF (NCW.GT.300) GOWG
)@@G@@ TO 450                                         STJ21500    @I@@@@      WH
)@@G@@C(NCW)=XC                                                         STJ216WI
)@@G@@00    @I@@@@      D(NCW)=XD                                             WJ
)@@G@@            STJ21700    @I@@@@      E(NCW)=OR(XC,XD)                    WK
)@@G@@                              STJ21800    @I@@@@      NB=0              WL
)@@G@@                                                STJ21900    @I@@@@      WM
)@@G@@DO 270 I=1,KNF                                                    STJ220WN
)@@G@@00    @I@@@@      IF (AND(E(NCW),MASK(I)).NE.0) NB=NB+1                 WO
)@@G@@            STJ22100    @I@@@@  270 CONTINUE                            WP
)@@G@@                              STJ22200    @I@@@@      NBITS(NCW)=NB     WQ
)@@G@@                                                STJ22300    @I@@@@      WR
)@@G@@NCW=NCW+1                                                         STJ224WS
)@@G@@00    @I@@@@      GO TO 225                                             WT
)@@G@@            STJ22500    @I@@@@282   IF(NPOOL.EQ.0)GO TO 300             WU
)@@G@@                              STJ22600    @I@@@@C     CHECK FOR PRESENCEWV
)@@G@@ OF REQUIRED DUMMY CODE WORD.                   STJ22700    @I@@@@C     WW
)@@G@@IF NOT FOUND, ADD TO END OF ARRAY E AND CHANGE IVEC(NCW).         STJ228WX
)@@G@@00    @I@@@@C     LATER SORT WILL PUT E(NCW) WHERE IT SHOULD BE.        WY
)@@G@@            STJ22900    @I@@@@      TOP=NCW-2                           WZ
)@@G@@                              STJ23000    @I@@@@      DO 290 I=1,TOP    XA
)@@G@@                                                STJ23100    @I@@@@      XB
)@@G@@DCODE=E(I)                                                        STJ232XC
)@@G@@00    @I@@@@      ISW=0                                                 XD
)@@G@@            STJ23300    @I@@@@      DO 284 J=1,KNF                      XE
)@@G@@                              STJ23400    @I@@@@      IF(AND(E(I),MASK(JXF
)@@G@@)).EQ.0)GO TO 284                               STJ23500    @I@@@@      XG
)@@G@@IF(B(J).EQ.0)GO TO 284                                            STJ236XH
)@@G@@00    @I@@@@C      FACTOR J IS PRESENT AND IS NESTED WITHIN SOMETHING   XI
)@@G@@            STJ23700    @I@@@@      ISW=1                               XJ
)@@G@@                              STJ23800    @I@@@@      DCODE=AND(DCODE,COXK
)@@G@@MPL(MASK(J)))                                   STJ23900    @I@@@@284   XL
)@@G@@CONTINUE                                                          STJ240XM
)@@G@@00    @I@@@@      IF(DCODE.EQ.0)GO TO 290                               XN
)@@G@@            STJ24100    @I@@@@      IF(ISW.NE.1) GO TO 290              XO
)@@G@@                              STJ24200    @I@@@@      DO 286 J=1,TOP    XP
)@@G@@                                                STJ24300    @I@@@@286   XQ
)@@G@@IF(DCODE.EQ.E(J))GO TO 290                                        STJ244XR
)@@G@@00    @I@@@@      E(NCW)=DCODE                                          XS
)@@G@@            STJ24500    @I@@@@      IVEC(NCW)=1                         XT
)@@G@@                              STJ24600    @I@@@@      NB=0              XU
)@@G@@                                                STJ24700    @I@@@@      XV
)@@G@@DO 288 J=1,KNF                                                    STJ248XW
)@@G@@00    @I@@@@      IF(AND(E(NCW),MASK(J)).NE.0)NB=NB+1                   XX
)@@G@@            STJ24900    @I@@@@288   CONTINUE                            XY
)@@G@@                              STJ25000    @I@@@@      NBITS(NCW)=NB     XZ
)@@G@@                                                STJ25100    @I@@@@      YA
)@@G@@NCW=NCW+1                                                         STJ252YB
)@@G@@00    @I@@@@290   CONTINUE                                              YC
)@@G@@            STJ25300    @I@@@@C     FOLLOWING SORT MUST ALSO INCLUDE IVEYD
)@@G@@C                             STJ25400    @I@@@@C                       YE
)@@G@@                                                STJ25500    @I@@@@C****SYF
)@@G@@HUFFLE NBITS, C, D, E IN INCREASING ORDER OF VECTOR NBITS AND     STJ256YG
)@@G@@00    @I@@@@C****DECREASING ORDER OF VECTOR E.                          YH
)@@G@@            STJ25700    @I@@@@C                                         YI
)@@G@@                              STJ25800    @^@@@@C******************     YJ
)@@G@@@[@@@@C     @F@@@@C       TECHNIQUE IS SEARCH FOR THE SMALLEST AND PUT IYK
)@@G@@T FIRST.    @[@@@@C     @^@@@@C******************     @I@@@@  300 NCW=NCYL
)@@G@@W-1                                                         STJ25900    YM
)@@G@@@I@@@@      IF (NCW.LT.2) GO TO 355                                     YN
)@@G@@      STJ26000    @I@@@@      NCW1=NCW-1                                YO
)@@G@@                        STJ26100    @I@@@@      DO 350 I=1,NCW1         YP
)@@G@@                                          STJ26200    @I@@@@      IMAX=IYQ
)@@G@@                                                            STJ26300    YR
)@@G@@@I@@@@      NBMIN=NBITS(I)                                              YS
)@@G@@      STJ26400    @I@@@@      EMAX=E(I)                                 YT
)@@G@@                        STJ26500    @I@@@@      II=I+1                  YU
)@@G@@                                          STJ26600    @I@@@@      DO 310YV
)@@G@@ J=II,NCW                                                   STJ26700    YW
)@@G@@@I@@@@      IF (NBITS(J).GT.NBMIN) GO TO 310                            YX
)@@G@@      STJ26800    @I@@@@      IF (NBITS(J).LT.NBMIN) GO TO 305          YY
)@@G@@                        STJ26900    @I@@@@      IF (E(J).LT.EMAX) GO TO YZ
)@@G@@310                                       STJ27000    @I@@@@  305 IMAX=JZA
)@@G@@                                                            STJ27100    ZB
)@@G@@@I@@@@      NBMIN=NBITS(J)                                              ZC
)@@G@@      STJ27200    @I@@@@      EMAX=E(J)                                 ZD
)@@G@@                        STJ27300    @I@@@@  310 CONTINUE                ZE
)@@G@@                                          STJ27400    @I@@@@      IF (IMZF
)@@G@@AX.EQ.I) GO TO 350                                          STJ27500    ZG
)@@G@@@I@@@@      TEMP=NBITS(IMAX)                                            ZH
)@@G@@      STJ27600    @I@@@@      NBITS(IMAX)=NBITS(I)                      ZI
)@@G@@                        STJ27700    @I@@@@      NBITS(I)=TEMP           ZJ
)@@G@@                                          STJ27800    @I@@@@      TEMP=CZK
)@@G@@(IMAX)                                                      STJ27900    ZL
)@@G@@@I@@@@      C(IMAX)=C(I)                                                ZM
)@@G@@      STJ28000    @I@@@@      C(I)=TEMP                                 ZN
)@@G@@                        STJ28100    @I@@@@      TEMP=D(IMAX)            ZO
)@@G@@                                          STJ28200    @I@@@@      D(IMAXZP
)@@G@@)=D(I)                                                      STJ28300    ZQ
)@@G@@@I@@@@      D(I)=TEMP                                                   ZR
)@@G@@      STJ28400    @I@@@@      TEMP=E(IMAX)                              ZS
)@@G@@                        STJ28500    @I@@@@      E(IMAX)=E(I)            ZT
)@@G@@                                          STJ28600    @I@@@@      E(I)=TZU
)@@G@@EMP                                                         STJ28700    ZV
)@@G@@@I@@@@      TEMP=IVEC(IMAX)                                             ZW
)@@G@@      STJ28800    @I@@@@      IVEC(IMAX)=IVEC(I)                        ZX
)@@G@@                        STJ28900    @I@@@@      IVEC(I)=TEMP            ZY
)@@G@@                                          STJ29000    @I@@@@  350 CONTINZZ
)@@G@@UE                                                          STJ29100    AA
)@@G@@@I@@@@  355 CONTINUE                                                    AB
)@@G@@      STJ29200    @I@@@@C                                               AC
)@@G@@                        STJ29300    @I@@@@C****STORE CONTROL WORDS      AD
)@@G@@                                          STJ29400    @I@@@@C           AE
)@@G@@                                                            STJ29500    AF
)@@G@@@I@@@@      CALL S1GTAG('S9CODE',DUM,DUM,DUM,$400)                      AG
)@@G@@      STJ29600    @I@@@@      NERR=NERR+1                               AH
)@@G@@                        STJ29700    @I@@@@      CALL S1PCHD(1)          AI
)@@G@@                                          STJ29800    @I@@@@      PRINT AJ
)@@G@@360                                                         STJ29900    AK
)@@G@@@I@@@@      GO TO 900                                                   AL
)@@G@@      STJ30000    @I@@@@  360 FORMAT(' ***** NWAY1 ERROR. DESIGN CARD MAAM
)@@G@@Y NOT BE USED HERE.')   STJ30100    @I@@@@  400 NCW2=NCW+2              AN
)@@G@@                                          STJ30200    @I@@@@      CALL SAO
)@@G@@1STFT('S9CODE',FW,1,NCW2,$999)                              STJ30400    AP
)@@G@@@I@@@@C****STORE FIRST WORD = 0                                         AQ
)@@G@@      STJ30500    @I@@@@      X(FW)=0                                   AR
)@@G@@                        STJ30600    @I@@@@C****STORE SECOND WORD = ALL OAS
)@@G@@NES                                       STJ30700    @I@@@@      FW=FW+AT
)@@G@@1                                                           STJ30800    AU
)@@G@@@I@@@@      X(FW)=0                                                     AV
)@@G@@      STJ30900    @I@@@@      DO 405 I=1,KNF                            AW
)@@G@@                        STJ31000    @I@@@@      X(FW)=X(FW)+MASK(I)     AX
)@@G@@                                          STJ31100    @I@@@@  405 CONTINAY
)@@G@@UE                                                          STJ31200    AZ
)@@G@@@I@@@@      IF (NCW.LT.1) GO TO 415                                     BA
)@@G@@      STJ31300    @I@@@@C****STORE GENERATED CODE WORDS                 BB
)@@G@@                        STJ31400    @I@@@@      DO 410 I=1,NCW          BC
)@@G@@                                          STJ31500    @I@@@@      FW=FW+BD
)@@G@@1                                                           STJ31600    BE
)@@G@@@I@@@@      X(FW)=E(I)                                                  BF
)@@G@@      STJ31700    @I@@@@  410 CONTINUE                                  BG
)@@G@@                        STJ31800    @I@@@@  415 CONTINUE                BH
)@@G@@                                          STJ31900    @I@@@@C     STORE BI
)@@G@@VECTOR IVEC                                                 STJ32000    BJ
)@@G@@@I@@@@CC     NOTE THAT X(FW+2)=IVEC(1)                                  BK
)@@G@@      STJ32100    @I@@@@      CALL S1STFT('S9ICOD',FW,1,NCW2,$999)      BL
)@@G@@                        STJ32200    @I@@@@      X(FW)=0                 BM
)@@G@@                                          STJ32300    @I@@@@      FW=FW+BN
)@@G@@1                                                           STJ32400    BO
)@@G@@@I@@@@      X(FW)=0                                                     BP
)@@G@@      STJ32500    @I@@@@      DO 417 I=1,NCW                            BQ
)@@G@@                        STJ32600    @I@@@@      FW=FW+1                 BR
)@@G@@                                          STJ32700    @I@@@@417   X(FW)=BS
)@@G@@IVEC(I)                                                     STJ32800    BT
)@@G@@@I@@@@C                                                                 BU
)@@G@@      STJ32900    @B@@@@C      GENERATE LABELS FOR EACH CODE WORD @E@@@@BV
)@@G@@C      USE SCRATCH FILE ( NUMBER 2 ) FOR CODE WORD LABELS   @#@@@@      BW
)@@G@@LINFO=LOCS9 @C@@@@      CALL S1GTAG('VNAMES',NAME,DUM,DUM,$5021)  @ @@@@BX
)@@G@@502   IF(X(NAME).EQ.0)NAME=0  @#@@@@5021    CONTINUE  @]@@@@      EMS=0 BY
)@@G@@@B@@@@      CALL S1GTAG('EMS',DUM,DUM,DUM,$5070)@]@@@@      EMS=1 @G@@@@BZ
)@@G@@      DIMENSION CODES(13) /'A','B','C','D','E','F','G','H','Q','R','S', CA
)@@G@@@#@@@@     -   'T','X'/ @ @@@@      DIMENSION ABCODE(12)    @]@@@@      CB
)@@G@@NEXT=0@^@@@@      DO 5050 J=1,KNF   @ @@@@      VARNO=X(LOCS9+21+J)     CC
)@@G@@@A@@@@      IF(VARNO .NE. 0) GO TO 5030   @A@@@@      CALL S1PRFT(X(LINFCD
)@@G@@O+2),1,CHAR)@#@@@@      GO TO 5035  @A@@@@ 5030 IF(NAME .EQ. 0) GO TO 50CE
)@@G@@45    @ @@@@      LOC=NAME+2*(VARNO-1)    @B@@@@      IF(X(LOC) .EQ. BLACF
)@@G@@NK) GO TO 5045    @A@@@@      CALL S1PRFT(X(LOC),1,CHAR)    @ @@@@ 5035 CG
)@@G@@IF(J .EQ. 1) GO TO 5040 @^@@@@      DO 5038 I=2,J     @B@@@@      IF(ABCCH
)@@G@@ODE(I-1) .EQ. CHAR) GO TO 5045@#@@@@ 5038 CONTINUE    @^@@@@ 5040 ABCODECI
)@@G@@(J)=CHAR    @#@@@@      GO TO 5050  @#@@@@ 5045 NEXT=NEXT+1 @^@@@@      CJ
)@@G@@CHAR=CODES(NEXT)  @#@@@@      GO TO 5035  @#@@@@ 5050 CONTINUE    @#@@@@CK
)@@G@@      WICODE='W'  @^@@@@ 5055 DO 5060 J=1,KNF   @B@@@@      IF(ABCODE(J)CL
)@@G@@ .NE. WICODE) GO TO 5060@#@@@@      NEXT=NEXT+1 @^@@@@      WICODE=CODESCM
)@@G@@(NEXT)@#@@@@      GO TO 5055  @#@@@@ 5060 CONTINUE    @#@@@@      PECODECN
)@@G@@='P'  @^@@@@ 5062 DO 5065 J=1,KNF   @B@@@@      IF(ABCODE(J) .NE. PECODECO
)@@G@@) GO TO 5065@#@@@@      NEXT=NEXT+1 @^@@@@      PECODE=CODES(NEXT)@#@@@@CP
)@@G@@      GO TO 5062  @#@@@@ 5065 CONTINUE    @C@@@@      CALL S1STFT('S9ABRCQ
)@@G@@V',FW,2,NCW+1,$999)     @#@@@@      X(FW)=WICODE@^@@@@      X(FW+1)=PECOCR
)@@G@@DE    @#@@@@      FW=FW+2     @#@@@@ 5070 MAXPP=0     @ @@@@      DIMENSCS
)@@G@@ION ABBREV(2)     @^@@@@      DO 580  I=1,NCW   @#@@@@        POINT=2   CT
)@@G@@@B@@@@      IF(NPOOL.EQ.0.OR.I.NE.NCW)GO TO 508 @ @@@@      LABEL(POINT)CU
)@@G@@='RESIDU'   @ @@@@      LABEL(POINT+1)='AL    ' @^@@@@      POINT=POINT+CV
)@@G@@2     @#@@@@      GO TO 519   @]@@@@508   ISW=0 @^@@@@      ABBREV(1)=' CW
)@@G@@     '@^@@@@      ABBREV(2)='      '@]@@@@      IABR=0@^@@@@      DO 510CX
)@@G@@ J=1,KNF    @B@@@@      IF(AND(C(I),MASK(J)).EQ.0) GO TO 510@#@@@@      CY
)@@G@@IABR=IABR+1 @B@@@@      CALL S1PRST(ABBREV,IABR,ABCODE(J))  @ @@@@      CZ
)@@G@@VARNO=X(LOCS9+21+J)     @ @@@@      IF(VARNO.NE.0)GO TO 569 @ @@@@      DA
)@@G@@IF(ISW.EQ.0)GO TO 560   @^@@@@      LABEL(POINT)=STAR @^@@@@      POINT=DB
)@@G@@POINT+1     @[@@@@C     @#@@@@C       ORDERFAC  @[@@@@C     @ @@@@560   DC
)@@G@@LABEL(POINT)=X(LINFO+2) @A@@@@      LABEL(POINT+1)=X(LINFO+3)     @^@@@@DD
)@@G@@      POINT=POINT+2     @]@@@@      ISW=1 @#@@@@      GO TO 510   @[@@@@DE
)@@G@@C     @^@@@@C       GOT VNAMES?     @[@@@@C     @ @@@@569   IF(NAME.EQ.0DF
)@@G@@)GO TO 504  @ @@@@      LOC=NAME+2*(VARNO-1)    @[@@@@C     @B@@@@C     DG
)@@G@@  YES, GOT ONE FOR THIS VARIABLE?   @ @@@@C       YES, NEED A STAR?     DH
)@@G@@@[@@@@C     @A@@@@      IF(X(LOC).EQ.BLANK)GO TO 504  @ @@@@      IF(ISWDI
)@@G@@.EQ.0)GO TO 503   @[@@@@C     @^@@@@C       YES PUT ONE IN. @[@@@@C     DJ
)@@G@@@^@@@@      LABEL(POINT)=STAR @^@@@@      POINT=POINT+1     @[@@@@C     DK
)@@G@@@A@@@@C       PUT IN HTE VARIABLE NAME.   @[@@@@C     @ @@@@503   LABEL(DL
)@@G@@POINT)=X(LOC)     @ @@@@      LABEL(POINT+1)=X(LOC+1) @^@@@@      POINT=DM
)@@G@@POINT+2     @]@@@@      ISW=1 @#@@@@      GO TO 510   @ @@@@504   IF(ISWDN
)@@G@@.EQ.0)GO TO 505   @^@@@@      LABEL(POINT)=STAR @^@@@@      POINT=POINT+DO
)@@G@@1     @A@@@@505   ENCODE(LABEL(POINT),506)VARNO @#@@@@506   FORMAT(I6)  DP
)@@G@@@^@@@@      POINT=POINT+1     @]@@@@      ISW=1 @#@@@@510   CONTINUE    DQ
)@@G@@@A@@@@      IF(EMS .EQ. 0) GO TO 5107     @^@@@@      X(FW)=ABBREV(1)   DR
)@@G@@@^@@@@      X(FW+1)=ABBREV(2) @#@@@@      FW=FW+2     @^@@@@C***********DS
)@@G@@*******     @[@@@@C     @F@@@@C       DONE WITH LABEL UPTO WITHIN PUT INDT
)@@G@@ THE WITHIN CLAUSES     @[@@@@C     @^@@@@C******************     @ @@@@DU
)@@G@@ 5107 IF(D(I).EQ.0)GO TO 519  @^@@@@      LABEL(POINT)=BLANK@ @@@@      DV
)@@G@@LABEL(POINT+1)=WITHIN   @ @@@@      LABEL(POINT+2)=BLANK    @^@@@@      DW
)@@G@@POINT=POINT+3     @]@@@@      ISW=0 @^@@@@      DO 520 J=1,KNF    @B@@@@DX
)@@G@@      IF(AND(D(I),MASK(J)).EQ.0) GO TO 520@ @@@@      VARNO=X(LOCS9+21+JDY
)@@G@@)     @ @@@@      IF(VARNO.NE.0)GO TO 579 @ @@@@      IF(ISW.EQ.0)GO TO DZ
)@@G@@570   @^@@@@      LABEL(POINT)=COMMA@^@@@@      POINT=POINT+1     @ @@@@EA
)@@G@@570   LABEL(POINT)=X(LINFO+2) @A@@@@      LABEL(POINT+1)=X(LINFO+3)     EB
)@@G@@@^@@@@      POINT=POINT+2     @]@@@@      ISW=1 @#@@@@      GO TO 520   EC
)@@G@@@ @@@@579   IF(NAME.EQ.0) GO TO 514 @ @@@@      LOC=NAME+2*(VARNO-1)    ED
)@@G@@@A@@@@      IF(X(LOC).EQ.BLANK)GO TO 514  @ @@@@      IF(ISW.EQ.0)GO TO EE
)@@G@@513   @^@@@@      LABEL(POINT)=COMMA@^@@@@      POINT=POINT+1     @ @@@@EF
)@@G@@513   LABEL(POINT)=X(LOC)     @ @@@@      LABEL(POINT+1)=X(LOC+1) @^@@@@EG
)@@G@@      POINT=POINT+2     @]@@@@      ISW=1 @#@@@@      GO TO 520   @ @@@@EH
)@@G@@514   IF(ISW.EQ.0)GO TO 515   @^@@@@      LABEL(POINT)=COMMA@^@@@@      EI
)@@G@@POINT=POINT+1     @A@@@@515   ENCODE(LABEL(POINT),506)VARNO @^@@@@      EJ
)@@G@@POINT=POINT+1     @]@@@@      ISW=1 @#@@@@520   CONTINUE    @^@@@@519   EK
)@@G@@POINT=POINT-1     @^@@@@C******************     @[@@@@C     @A@@@@C     EL
)@@G@@LABEL FOR THIS CODE WORD DONE.@^@@@@C     PACK OUT BLANKS   @[@@@@C     EM
)@@G@@@^@@@@C******************     @#@@@@      LCHAR=5     @^@@@@C***********EN
)@@G@@*******     @[@@@@C     @ @@@@C       J GOES FROM 2 TO POINT@[@@@@C     EO
)@@G@@@^@@@@C******************     @]@@@@        J=2 @]@@@@        PP=2@C@@@@EP
)@@G@@C     PP IS THE LOCATION OF THE OUTPUT STRING   @]@@@@      OUTP=1@ @@@@EQ
)@@G@@521   IN(1)=FLD( 0,6,LABEL(J))@ @@@@      IN(2)=FLD( 6,6,LABEL(J))@ @@@@ER
)@@G@@      IN(3)=FLD(12,6,LABEL(J))@ @@@@      IN(4)=FLD(18,6,LABEL(J))@ @@@@ES
)@@G@@      IN(5)=FLD(24,6,LABEL(J))@ @@@@      IN(6)=FLD(30,6,LABEL(J))@]@@@@ET
)@@G@@      K=1   @ @@@@522   IF(IN(K).EQ.5)GO TO 525 @[@@@@C     @ @@@@C     EU
)@@G@@  NON-BLANK CHARACTER   @[@@@@C     @^@@@@      OUT(OUTP)=IN(K)   @#@@@@EV
)@@G@@      LCHAR=IN(K) @#@@@@      OUTP=OUTP+1 @#@@@@      GO TO 530   @ @@@@EW
)@@G@@525   IF(LCHAR.EQ.5)GO TO 530 @[@@@@C     @ @@@@C       FIRST BLANK CHAREX
)@@G@@ACTER.@[@@@@C     @^@@@@      OUT(OUTP)=IN(K)   @#@@@@      LCHAR=IN(K) EY
)@@G@@@#@@@@      OUTP=OUTP+1 @#@@@@530   CONTINUE    @ @@@@      IF(OUTP.LE.6EZ
)@@G@@)GO TO 538  @^@@@@      PLABEL(PP)=BLANK  @]@@@@      JSW=0 @A@@@@531   FA
)@@G@@FLD(30,6,PLABEL(PP))=OUT(6)   @A@@@@532   FLD(24,6,PLABEL(PP))=OUT(5)   FB
)@@G@@@A@@@@533   FLD(18,6,PLABEL(PP))=OUT(4)   @A@@@@534   FLD(12,6,PLABEL(PPFC
)@@G@@))=OUT(3)   @A@@@@535   FLD( 6,6,PLABEL(PP))=OUT(2)   @A@@@@536   FLD( 0FD
)@@G@@,6,PLABEL(PP))=OUT(1)   @ @@@@      IF(JSW.NE.0)GO TO 545   @#@@@@      FE
)@@G@@PP=PP+1     @]@@@@      OUTP=1@]@@@@538   K=K+1 @ @@@@      IF(K.LE.6)GOFF
)@@G@@ TO 522     @]@@@@      J=J+1 @ @@@@      IF(J.LE.POINT)GO TO 521 @[@@@@FG
)@@G@@C     @B@@@@C     J IS .GT. POINT... FINISHED ARRAY   @C@@@@C     IF OUTFH
)@@G@@P.GT.1 SAVE FRACTION OF NEXT WORD   @[@@@@C     @ @@@@      IF(OUTP.NE.1FI
)@@G@@)GO TO 540  @#@@@@      PP=PP-1     @#@@@@      GO TO 545   @#@@@@540   FJ
)@@G@@OUTP=OUTP-1 @^@@@@      PLABEL(PP)=BLANK  @]@@@@      JSW=1 @B@@@@      FK
)@@G@@GO TO (536,535,534,533,532,531),OUTP@#@@@@545   CONTINUE    @^@@@@C*****FL
)@@G@@*************     @[@@@@C     @D@@@@C      FINISHED PACKING STRING FOR TFM
)@@G@@HIS CODE WORD.    @D@@@@C     CHECK IF LAST WORD OF PACKED STRING IS BLAFN
)@@G@@NK.   @^@@@@C     IF SO, DROP IT    @[@@@@C     @^@@@@C*****************FO
)@@G@@*     @A@@@@      IF(PLABEL(PP).EQ.BLANK)PP=PP-1@F@@@@C     PRECEDE THE FP
)@@G@@STRING BY A COUNT OF THE LENGTH OF THE STRING   @^@@@@        PLABEL(1)=FQ
)@@G@@PP-1  @A@@@@      IF(PP .GT. MAXPP) MAXPP=PP    @E@@@@C     STORE LABEL FR
)@@G@@+ LENGTH FOR THIS CODE WORD INTO FILE 2   @C@@@@      CALL S1IODR(2,'WRIFS
)@@G@@TE',PP,PLABEL(1),LEND)  @#@@@@580   CONTINUE    @D@@@@C     ENDFILE AND FT
)@@G@@REWIND TO DRAIN FILE 2  'S BUFFER   @C@@@@      CALL S1IODR(2,'ENDFIL',DFU
)@@G@@UM,PLABEL(1),LEND)@C@@@@      CALL S1IODR(2,'REWIND',DUM,PLABEL(1),LEND)FV
)@@G@@@B@@@@      CALL S1STFT('S9MXPP',FW,1,1,$999)   @^@@@@      X(FW)=MAXPP-FW
)@@G@@1     @^@@@@C******************     @[@@@@C     @H@@@@C       DONE WITH FX
)@@G@@WORK, NOW PRINT SUMMARY OF WHAT WAS GENERATED IF TESTING    @[@@@@C     FY
)@@G@@@^@@@@C******************     @I@@@@C                                   FZ
)@@G@@                                    STJ33100    @I@@@@      TEST=0      GA
)@@G@@                                                      STJ33200    @I@@@@GB
)@@G@@      CALL S1GVAL('TEST',TEST,$420,$420)                                GC
)@@G@@STJ33300    @I@@@@  420 CONTINUE                                        GD
)@@G@@                  STJ33400    @I@@@@      IF (TEST.EQ.0) GO TO 500      GE
)@@G@@                                    STJ33500    @I@@@@      PRINT 425   GF
)@@G@@                                                      STJ33600    @I@@@@GG
)@@G@@  425 FORMAT('0    MASKS       VECTOR B       MATRIX OF NESTS')         GH
)@@G@@STJ33700    @I@@@@      DO 430 I=1,KNF                                  GI
)@@G@@                  STJ33800    @I@@@@  430 PRINT 435,MASK(I),B(I),(NESTS(GJ
)@@G@@I,J),J=1,KNF)                       STJ33900    @I@@@@  435 FORMAT(1X,O1GK
)@@G@@2,2X,O12,3X,12I3)                                     STJ34000    @I@@@@GL
)@@G@@      IF (NCW.LT.1) GO TO 442                                           GM
)@@G@@STJ34100    @I@@@@      PRINT 437                                       GN
)@@G@@                  STJ34200    @I@@@@  437 FORMAT('0   I      C(I)       GO
)@@G@@   D(I)          E(I)        NBITS(ISTJ34300    @I@@@@     *)')         GP
)@@G@@                                                      STJ34400    @I@@@@GQ
)@@G@@      DO 440 I=1,NCW                                                    GR
)@@G@@STJ34500    @I@@@@  440 PRINT 445,I,C(I),D(I),E(I),NBITS(I)             GS
)@@G@@                  STJ34600    @I@@@@  442 CONTINUE                      GT
)@@G@@                                    STJ34700    @I@@@@  445 FORMAT(I5,3(GU
)@@G@@2X,O12),I5)                                           STJ34800    @I@@@@GV
)@@G@@      GO TO 500                                                         GW
)@@G@@STJ34900    @I@@@@C****                                                 GX
)@@G@@                  STJ35000    @I@@@@C****ERROR...TOO MANY CODE WORDS GENGY
)@@G@@ERATED...                           STJ35100    @I@@@@  450 NERR=NERR+1 GZ
)@@G@@                                                      STJ35200    @I@@@@HA
)@@G@@      CALL S1PCHD(1)                                                    HB
)@@G@@STJ35300    @I@@@@      PRINT 455                                       HC
)@@G@@                  STJ35400    @I@@@@  455 FORMAT(' ***** NWAY1 ERROR. COHD
)@@G@@DE WORD TABLE EXCEEDED.')           STJ35500    @I@@@@  500 CONTINUE    HE
)@@G@@                                                      STJ35600    @I@@@@HF
)@@G@@  900 RETURN                                                            HG
)@@G@@STJ35700    @ @@@@999    CALL S1SERR('S9DNPF')  @]@@@@      RETURN@[@@@@HH
)@@G@@C     @[@@@@C     @C@@@@C        LOCAL SUBROUTINE TO GET FACTOR NAME    HI
)@@G@@@[@@@@C     @A@@@@      SUBROUTINE GETNAM(FIND,FNAME) @^@@@@      DIMENSHJ
)@@G@@ION FNAME(2)@ @@@@      VARNO=X(LOCS9+21+FIND)  @A@@@@      IF(VARNO .NEHK
)@@G@@. 0) GO TO 5000   @ @@@@      FNAME(1)=X(LOCS9+2)     @ @@@@      FNAME(HL
)@@G@@2)=X(LOCS9+3)     @]@@@@      RETURN@C@@@@ 5000 CALL S1GTAG('VNAMES',NAMHM
)@@G@@E,DUM,DUM,$5100)  @A@@@@      IF(X(NAME) .EQ. 0) GO TO 5100 @ @@@@      HN
)@@G@@NAME=NAME+2*(VARNO-1)   @B@@@@      IF(X(NAME) .EQ. '      ') GO TO 5100HO
)@@G@@@^@@@@      FNAME(1)=X(NAME)  @^@@@@      FNAME(2)=X(NAME+1)@]@@@@      HP
)@@G@@RETURN@ @@@@ 5100 ENCODE(FNAME,5200) VARNO@^@@@@ 5200 FORMAT(I4,4X)     HQ
)@@G@@@]@@@@      RETURN@I@@@@      END                                       HR
)@@G@@                        STJ36200    ___    MASKS       VECTOR B       MAHS
)@@G@@TRIX OF NESTS')         STJ33700    @I@@@@      DO 430 I=1,KNF          HT
)@@G@@                                          STJ338*[S@@@*SDFF*@G@@@@      HU
)@@G@@SUBROUTINE S1CCIN(IFLD,NCARD,SCR,LSCR,COP,MLE,NEWCW,LCWSP,CWSP,   @A@@@@HV
)@@G@@     -   NVARS,NCR,COPIN,NERR,$)    @ @@@@      IMPLICIT INTEGER (A-Z)  HW
)@@G@@@C@@@@      DIMENSION IFLD(1), SCR(LSCR), CWSP(LCWSP) @D@@@@      COMMONHX
)@@G@@/S1CCI/DUMEE1(8),PROGNM(2),DUMEE2(12)     @[@@@@C     @[@@@@C     @D@@@@HY
)@@G@@C             MULTIVARIATE *INPUT* CARD PROCESSOR     @[@@@@C     @[@@@@HZ
)@@G@@C     @[@@@@C     @#@@@@      COMMON X(1) @ @@@@      DIMENSION CWSPEC(2IA
)@@G@@00)   @A@@@@        DATA (CWSPEC(I),I=1,110)/   @A@@@@     1 12HSTJBANK IB
)@@G@@    ,2,0,14,0,    @C@@@@     2  12HNCR          ,4,12,2,1,1,1,1,2000,   IC
)@@G@@@ @@@@     312HCOP         ,2,0,3,0,@A@@@@     412HMLE          ,2,0,0,0ID
)@@G@@,     @A@@@@     512HBCDTAPE      ,4, 6,0,0,    @A@@@@     612HSDFFILE  IE
)@@G@@    ,4, 5,0,0,    @C@@@@     712HCHARS        ,2,0,0,1,1,1,16,15000,    IF
)@@G@@@B@@@@     812HREELS        ,2,0,0,1,1,1,1,10,  @C@@@@     912HLABELREC IG
)@@G@@   ,3,5,0,2,2,1,1,34000000000,@C@@@@     *12HBLOCKED     ,3,5,  4,2,1,9,IH
)@@G@@0,2000,     @D@@@@     1 12HNOBS        ,2,0,15,1,1,5,1,O377777777777,  II
)@@G@@@B@@@@     2 12HNLR         ,4,2,2,1,1,1,1,2000,@B@@@@     3 12HNVARS   IJ
)@@G@@    ,6,1,1,1,1,1,1,2000,@]@@@@     4 /    @[@@@@C     @ @@@@      DIMENSIK
)@@G@@ION TSTOR(100)    @^@@@@      DIMENSION STOR(17)@^@@@@C*****************IL
)@@G@@*     @[@@@@C     @G@@@@C       S1CCIN HANDLES THE INPUT CARDS OF ALL STIM
)@@G@@ATJOB PROGRAMS EXCEPT   @G@@@@C       ONEWAY1 AND COLFREQ1. IT ACCEPTS AIN
)@@G@@ LIST OF CONTROL WORDS FOR    @G@@@@C       EACH PROGRAM, THAT ARE DIFFEIO
)@@G@@RENT FROM, AND IN ADDITION TO, THE  @^@@@@C       STANDARD LIST   @[@@@@IP
)@@G@@C     @^@@@@C******************     @[@@@@C     @G@@@@C       S1CCIN    IQ
)@@G@@ SYMBOL USAGE SUMMARY ALL VARIABLES ARE INTEGERS.     @[@@@@C     @^@@@@IR
)@@G@@C******************     @[@@@@C     @D@@@@C       CHAR       TEMPORARY SIS
)@@G@@TORAGE FOR A CHARACTER. @E@@@@C       CHARS      VALUE OF 'CHARS' CONTROIT
)@@G@@L WORD OR 80.     @F@@@@C       COP        FORMAL PARAMETER, =0 IF COP LIU
)@@G@@EGAL CONTROL WORD.@A@@@@C                  OTHERWISE _0.    @G@@@@C     IV
)@@G@@  COPIN      FORMAL PARAMETER, SET =1 IF COP PRESENT ON CARD,     @B@@@@IW
)@@G@@C                  =0 IF NOT PRESENT.     @G@@@@C       CWSP       FORMAIX
)@@G@@L PARAMETER, DIMENSIONED (LCWSP), ARRAY OF UP   @E@@@@C                 IY
)@@G@@ TO 96 WORDS TO ADD TO THE CONTROL WORD   @A@@@@C                  SPECIIZ
)@@G@@FICATIONS.  @F@@@@C       CWSPEC     DIMENSIONED (200), ARRAY PASSED TO JA
)@@G@@S1ENST WITH @C@@@@C                  CONTROL WORD SPECIFICATIONS. @G@@@@JB
)@@G@@C       IFLD       FORMAL PARAMETER, THE CARD IMAGES OF THE INPUT CARD. JC
)@@G@@@B@@@@C       FW         FIRST WORD OF TAG.     @B@@@@C       I         JD
)@@G@@ TEMPORARY VARIABLE.    @B@@@@C       J          POINTER INTO CCSPEC.   JE
)@@G@@@C@@@@C       LBLK       POINTER TO TAG 'BLOCKE'.     @F@@@@C       LCARJF
)@@G@@DS     NUMBER OF WORDS TO CREATE IN TAG 'LCARDS'.     @G@@@@C       LCWSJG
)@@G@@P      FORMAL PARAMETER, NUMBER OF WORDS IN CWSP. MUST NOT  @B@@@@C     JH
)@@G@@             BE GREATER THAN 96.    @G@@@@C       LEND       NUMBER OF WJI
)@@G@@ORDS OF CRACKED INFORMATION OUTPUT BY     @ @@@@C                  S1ENDJJ
)@@G@@C.    @G@@@@C       LSCR       FORMAL PARAMETER, NUMBER OF WORDS IN ARRAJK
)@@G@@Y SCR, USED @A@@@@C                  FOR SCRATCH.     @G@@@@C       MLE JL
)@@G@@       FORMAL PARAMETER, =0 IF MLE NOT A LEGAL CONTROL WORD,@A@@@@C     JM
)@@G@@             _0 IF MLE LEGAL. @G@@@@C       N          SET TO VALUE TO PJN
)@@G@@UT IN TAG 'INROUT', =1, CARDS, =2,  @A@@@@C                  SDF, =3, BCJO
)@@G@@D.    @G@@@@C       NCARD      FORMAL PARAMETER, NUMBER OF CARDS OF INPUJP
)@@G@@T CARD.     @G@@@@C       NCR        FORMAL PARAMETER, VALUE OF CONTROL JQ
)@@G@@WORD NCR OR NLR.  @C@@@@C       NCW        NUMBER OF CONTROL WORDS LEGALJR
)@@G@@@E@@@@C       NE         NUMBER OF ERRORS DETECTED IN SUBROUTINE. @G@@@@JS
)@@G@@C       NERR       FORMAL PARAMETER, NUMBER OF ERRORS ON INPUT CARD.    JT
)@@G@@@G@@@@C       NEWCW      DORMAL PARAMETER, NUMBER OF NEW CONTROL WORDS BJU
)@@G@@EING  @ @@@@C                  SUPPLIED.  @A@@@@C       NN         DUMMYJV
)@@G@@ VARIABLE.  @D@@@@C       NVALS      NUMBER OF VALUES SPECIFIED TO NOBS.JW
)@@G@@@F@@@@C       NVARS      FORMAL PARAMETER, VALUE OF NVARS CONTROL WORD. JX
)@@G@@@G@@@@C       SCR        FORMAL PARAMETER, DIMENSIONED (LSCR), SCRATCH AJY
)@@G@@RRAY. @G@@@@C       STOR       DIMENSIONED (LL), PLACE FOR S1ENST TO PLAJZ
)@@G@@CE SOME     @A@@@@C                  OUTPUT VALUES.   @E@@@@C       S1ENKA
)@@G@@DC     ROUTINE TO CRACK THE CARD INTO TOKENS.   @G@@@@C       S1ENST    KB
)@@G@@ ROUTINE TO TAKE OUTPUT OF S1ENST AND CHECK IT FOR    @G@@@@C           KC
)@@G@@       LEGAL CONSTRUCTS AND PUT VALUES INTO TAGGED STORAGE  @A@@@@C     KD
)@@G@@             OR ARRAY STOR.   @E@@@@C       S1GTAG     ROUTINE TO RETRIEKE
)@@G@@VE POINTED TO A TAG.    @D@@@@C       S1GVAL     ROUTINE TO RETRIEVE VALKF
)@@G@@UE OF A TAG.@F@@@@C       S1PRFT     ROUTINE TO FETCH A CHARACTER FROM OKG
)@@G@@N ARRAY.    @F@@@@C       S1PRST     ROUTINE TO STORE A CHARACTER INTO AKH
)@@G@@N ARRAY.    @F@@@@C       S1SERR     ROUTINE TO PRINT STATJOB SYSTEM ERRKI
)@@G@@OR MESSAGE. @F@@@@C       S1STFT     ROUTINE TO CREATE A TAG AND ALLOCATKJ
)@@G@@E STORAGE   @A@@@@C                  IMMEDIATELY.     @G@@@@C       S1STKK
)@@G@@RS     ROUTINE TO CREATE A TAG AND RESERVE STORAGE FOR IT IN@B@@@@C     KL
)@@G@@             THE ANALYSIS PHASE.    @G@@@@C       TEMP       WORD USED TKM
)@@G@@O TEST FOR ONLY ONE CHARACTER IN MODIFIER @ @@@@C                  OF BLKN
)@@G@@OCKED.@G@@@@C       TSTOR      DIMENSIONED (100), ARRAY USED AS SCRATCH KO
)@@G@@SPACE IN    @ @@@@C                  S1ENST.    @D@@@@C       WORDS     KP
)@@G@@ NUMBER OF WORDS PER LOGICAL RECORD.@B@@@@C       X          BLANK COMMOKQ
)@@G@@N ARRAY     @[@@@@C     @^@@@@C******************     @[@@@@C     @C@@@@KR
)@@G@@C       S1CCIN     TAGGED STORAGE USAGE SUMMARY @[@@@@C     @^@@@@C*****KS
)@@G@@*************     @[@@@@C     @G@@@@C       'MLE'      WILL BE CREATED BKT
)@@G@@Y S1ENST IF MLE IS PRESENT ON THE   @A@@@@C                  CONTROL CARKU
)@@G@@D     @G@@@@C       'BCDTAP'   WILL BE CREATED BY S1ENST IF 'BCDTAP' IS KV
)@@G@@PRESENT ON  @G@@@@C                  THE CONTROL CARD AND IS RETRIEVED TKW
)@@G@@O DETERMINE INPUT @B@@@@C                  ROUTINE (TAG 'INROUT') @F@@@@KX
)@@G@@C       'SDFFIL'   WILL BE CREATED BY S1ENST IF SDFFILE IS ON THE @G@@@@KY
)@@G@@C                  CONTROL CARD AND IS RETRIEVED TO DETERMINE THE INPUT KZ
)@@G@@@G@@@@C       'CHARS'    IS CREATED TO CONTAIN THE NUMBER OF CHARACTERS LA
)@@G@@PER   @B@@@@C                  ROUTINE (TAG 'INROUT') @D@@@@C           LB
)@@G@@       LOGICAL RECORD. DEFAULTED TO 80.   @G@@@@C       'REELS'    MAY BLC
)@@G@@E CREATED BY S1ENST TO CONTAIN THE NUMBER OF    @F@@@@C                 LD
)@@G@@ REELS OF TAPE COMPRISING THE INPUT FILE. ONLY  @F@@@@C                 LE
)@@G@@ CREATED IF REELS IS PRESENT ON THE CONTROL CARD@G@@@@C       'LABELR'  LF
)@@G@@ WILL BE CREATED BY S1ENST IF LABELREC IS PRESENT ON  @E@@@@C           LG
)@@G@@       THE CONTROL CARD TO CONTAIN ITS MODIFIER.@F@@@@C       'NVARS'   LH
)@@G@@ IS RETRIEVED TO SET IT FROM THE CONTROL CARD.  @G@@@@C       'NOBS' IS LI
)@@G@@CREATED IF NOBS WAS PRESENT TO CONTAIN THE MODIFIERS. @F@@@@C           LJ
)@@G@@       HAS LENGTH OF ONE OR TWO, TWO IF TWO MODIFIERS.@E@@@@C       'LCALK
)@@G@@RDS'   IS RESERVED TO HOLD A LOGICAL RECORD.    @F@@@@C       'INROUT'  LL
)@@G@@ IS RETRIEVED AND SET TO =1 IF CARD INPUT, =2 IF@B@@@@C                 LM
)@@G@@ SDFFILE =3 IF BCDTAPE. @F@@@@C       'BLOCKE'   IS CREATED IF BLOCKED CLN
)@@G@@ONTROL WORD WAS PRESENT.@G@@@@C       'PADDIN'   IS CREATED TO HOLD THE LO
)@@G@@PAD CHARACTER IF PRESENT IN   @B@@@@C                  BLOCKED CONTROL WLP
)@@G@@ORD.  @[@@@@C     @^@@@@C******************     @[@@@@C     @]@@@@      LQ
)@@G@@NERR=0@[@@@@C     @B@@@@C             SET UP CONTROL WORD SPECS   @[@@@@LR
)@@G@@C     @B@@@@      IF(PROGNM(1).NE.'ROTATE')GO TO 40   @ @@@@      CWSPECLS
)@@G@@(101)=6HFACTMA    @^@@@@      CWSPEC(102)=6HT   @^@@@@      CWSPEC(105)=LT
)@@G@@11    @^@@@@      CWSPEC(106)=2     @^@@@@      CWSPEC(107)=2     @^@@@@LU
)@@G@@      CWSPEC(110)=400   @#@@@@40    CONTINUE    @ @@@@      CWSPEC(17)=6LV
)@@G@@HCOP777     @B@@@@      IF(COP .NE. 0) CWSPEC(17)=6HCOP     @ @@@@      LW
)@@G@@CWSPEC(23)=6HMLE777     @A@@@@      IF (MLE.NE.0) CWSPEC(23)=6HMLE@#@@@@LX
)@@G@@        NCW=13    @#@@@@        J=111     @A@@@@      IF(NEWCW .EQ. 0) GLY
)@@G@@O TO 100    @^@@@@      NCW=NCW+NEWCW     @^@@@@      DO 50 I=1,LCWSP   LZ
)@@G@@@^@@@@      CWSPEC(J)=CWSP(I) @]@@@@ 50   J=J+1 @[@@@@C     @ @@@@C     MA
)@@G@@        CALL S1ENDC     @[@@@@C     @F@@@@ 100  CALL S1ENDC(8HINPUT   ,IMB
)@@G@@FLD,NCARD,SCR,LSCR,LEND,NE,$120)    @#@@@@      NERR=NERR+NE@#@@@@      MC
)@@G@@GO TO 150   @#@@@@ 120  RETURN 14   @[@@@@C     @ @@@@C             CALLMD
)@@G@@ S1ENST     @[@@@@C     @G@@@@  150 CALL S1ENST(8HINPUT   ,SCR,LEND,CWSPME
)@@G@@EC,NCW,0,STOR,17,TSTOR,NE)    @#@@@@      NERR=NERR+NE@A@@@@        IF(SMF
)@@G@@TOR(14).EQ.0) GO TO 141 @E@@@@        CALL S1CCSJ(STOR,TSTOR,SCR,LSCR,NEMG
)@@G@@RR,CWSP,NEWCW)    @E@@@@      IF(PROGNM(1).EQ.'ROTATE') CALL S1CTAG('VNAMH
)@@G@@MES','NULL')@#@@@@141     CONTINUE  @B@@@@      IF(PROGNM(1).EQ.'ROTATE'MI
)@@G@@)GO TO 151  @^@@@@      NVARS=STOR(1)     @#@@@@      GO TO 152   @#@@@@MJ
)@@G@@  151 CONTINUE    @#@@@@      NV=STOR(11) @#@@@@      NF=STOR(12) @^@@@@MK
)@@G@@      IF(NV.EQ.0)NV=400 @^@@@@      IF(NF.EQ.0)NF=400 @A@@@@      CALL SML
)@@G@@1STFT('NV',LNV,1,1,$999)@A@@@@      CALL S1STFT('NF',LNF,1,1,$999)@#@@@@MM
)@@G@@      X(LNV)=NV   @#@@@@      X(LNF)=NF   @#@@@@      NVARS=NF    @ @@@@MN
)@@G@@      IF(NF.LE.NV)GO TO 152   @#@@@@      NERR=NERR+1 @^@@@@      CALL SMO
)@@G@@1PCHD(2)    @#@@@@      PRINT 1530  @G@@@@1530  FORMAT('0*****FIRST PARAMP
)@@G@@METER OF CONTROL WORD FACTMAT (VARIABLES) @E@@@@     *MUST NOT BE SMALLEMQ
)@@G@@R THAN SECOND PARAMETER (FACTORS).')@#@@@@  152 CONTINUE    @#@@@@      MR
)@@G@@NCR=STOR(2) @^@@@@      COPIN=STOR(3)     @B@@@@      CALL S1GTAG('NVARSMS
)@@G@@',FW,N,N,$999)    @#@@@@      X(FW)=NVARS @A@@@@      IF( STOR(15) .EQ. MT
)@@G@@0) GO TO 153@#@@@@      NVALS = 1   @A@@@@      IF( STOR(15) .EQ. 3) NVAMU
)@@G@@LS = 2@C@@@@      CALL S1STFT('NOBS', FW, NVALS, 1, $999)   @^@@@@      MV
)@@G@@X(FW) = STOR(16)  @B@@@@      IF( NVALS .EQ. 2) X(FW+1) = STOR(17)@#@@@@MW
)@@G@@153   CONTINUE    @ @@@@      IF(NVARS .LE. 0) NVARS=0@ @@@@      IF(NCRMX
)@@G@@ .LE. 0) NCR=1    @#@@@@      CHARS=80    @C@@[@      CALL S1GTAG('CHARSMY
)@@G@@',LCH,DUM,DUM,$154)     @#@@[@      CHARS=X(LCH)@C@@[@      CALL S1GTAG(MZ
)@@G@@'SDFFIL',DUM,DUM,DUM,$1541)   @A]@@@      IF(CHARS.LE.378) GO TO 155    NA
)@@G@@@^@@@@      CALL S1PCHD(1)    @#@@@@      NERR=NERR+1 @#@@@@      PRINT NB
)@@G@@995   @#@@@@      GO TO 155   @B@@@@154   CALL S1STFT('CHARS',FW,1,1,$99NC
)@@G@@9)    @#@@@@      X(FW)=80    @#@@[@      GO TO 155   @C@@[@1541  CALL SND
)@@G@@1GVAL('BCDTAP',DUM,$1542,$1542)     @#@@[@      GO TO 155   @^@@[@1542  NE
)@@G@@CALL S1PCHD(1)    @#@@[@      PRINT 998   @#@@[@      CHARS=80    @#@@[@NF
)@@G@@      X(LCH)=80   @^@@@@155   WORDS=CHARS/6     @B@@@@      IF (WORDS*6.NG
)@@G@@NE.CHARS) WORDS=WORDS+1 @B@@@@      CALL S1STFT('WORDS',FW,1,1,$999)    NH
)@@G@@@#@@@@      X(FW)=WORDS @^@@@@      LCARDS=NCR*WORDS+1@A@@@@      IF( CONI
)@@G@@PIN .NE. 0) LCARDS = 14 @A@@@@      IF(PROGNM(1).NE.'ROTATE')     @C@@@@NJ
)@@G@@     *CALL S1STRS('LCARDS', 1, LCARDS, $999)    @B@@@@      CALL S1GTAG(NK
)@@G@@'INROUT',FW,N,N,$999)   @]@@@@      N=1   @B@@@@      CALL S1GVAL('BCDTANL
)@@G@@P',NN,$158,$158)  @]@@@@      N=3   @A@@@@      IF(STOR(  4).EQ.0) GO TONM
)@@G@@ 160  @A@@@@      IF (STOR(  5).EQ.1) GO TO 156 @#@@@@      NERR=NERR+1 NN
)@@G@@@^@@@@      CALL S1PCHD(1)    @#@@@@      PRINT 997   @#@@@@      GO TO NO
)@@G@@160   @B@@@@  156 CALL S1STFT('BLOCKE',LBLK,1,1,$999) @^@@@@      X(LBLKNP
)@@G@@)=STOR(  6) @A@@@@      IF(STOR(  4).EQ.1) GO TO 160  @B@@@@      CALL SNQ
)@@G@@1STFT('PADDIN',LBLK,1,1,$999) @A@@@@      IF (STOR(  7).EQ.1) GO TO 1572NR
)@@G@@@C@@@@      IF (STOR(8  ).EQ.'BLANK') STOR(  8)=1H    @^@@@@      TEMP=SNS
)@@G@@TOR(  8)    @ @@@@      CALL S1PRST(TEMP,1,1H ) @B@@@@      IF(TEMP.EQ.6NT
)@@G@@H      ) GO TO 1571     @#@@@@  157 NERR=NERR+1 @^@@@@      CALL S1PCHD(NU
)@@G@@1)    @#@@@@      PRINT 996   @#@@@@      GO TO 160   @^@@@@ 1571 X(LBLKNV
)@@G@@)=STOR(  8) @#@@@@      GO TO 160   @A@@@@ 1572 IF(STOR(  8).GT.9) GO TONW
)@@G@@ 157  @ @@@@      STOR(  8)=STOR(  8)+48  @A@@@@      CALL S1PRFT(STOR( NX
)@@G@@ 8),6,CHAR) @#@@@@      X(LBLK)=CHAR@#@@@@      GO TO 160   @B@@@@158   NY
)@@G@@CALL S1GVAL('SDFFIL',NN,$160,$160)  @]@@@@      N=2   @#@@@@160     CONTNZ
)@@G@@INUE  @A@@@@        IF(STOR(14).EQ.0) GO TO 161 @]@@@@        N=4 @#@@@@OA
)@@G@@161     CONTINUE  @#@@@@        X(FW)=N   @]@@@@      RETURN@G@@@@  995 OB
)@@G@@FORMAT(' ***** CHARS MUST NOT EXCEED 378 FOR SDFFILE INPUT.')     @G@@@@OC
)@@G@@  996 FORMAT(' ***** SECOND PARAMETER OF CONTROL WORD BLOCKED MUST BE A OD
)@@G@@@G@@@@     *SINGLE LETTER OR NUMERAL OR THE WORD BLANK TO SPECIFY PADDINOE
)@@G@@G CHAR@#@@@@     *ACTER.')    @G@@@@  997 FORMAT(' ***** FIRST PARAMETEROF
)@@G@@ OF THE CONTROL WORD BLOCKED MUST BE@D@@@@     * THE BLOCKING FACTOR FOROG
)@@G@@ BCD TAPE RECORDS.')    @G@@[@998   FORMAT(' ***** THE CHARS CONTROL WOROH
)@@G@@D WILL BE IGNORED; CHARS CAN O@C@@[@     *NLY BE USED WITH SDFFILE OR BCOI
)@@G@@DTAPE.')    @ @@@@999     CALL S1SERR('S1CCIN.')@]@@@@      END   ___@[@OJ
)@@G@@      CALL S1GTAG('CHARS',LCH,DUM,DUM,$154)     @#@@[@      CHARS=X(LCH)OK
)@@G@@@C@@[@      CALL S1GTAG(*[S@@@*SDFF*@E@@@@      SUBROUTINE S1GLST(FMT,FMOL
)@@G@@TLEN,NVARS,LIST,RECWTH,NREC,$)@[@@@@C     @H@@@@C        FMT IS THE NAMEOM
)@@G@@ OF AN ARRAY WHICH CONTAINS A STRING OF CHARACTERS    @H@@@@C         WHON
)@@G@@ICH ARE THE FORTRAN FORMAT TO BE CRACKED.  THE FORMAT MUST START  @G@@@@OO
)@@G@@C         IN THE FIRST (LEFTHAND MOST) CHARACTER POSITION OF THE ARRAY. OP
)@@G@@@[@@@@C     @G@@@@C        FMTLEN IS THE NUMBER OF CHARACTERS IN THE FOROQ
)@@G@@MAT.  THE FORMAT  @H@@@@C         MUST BEGIN WITH A LEFT PARENTHESIS BUTOR
)@@G@@ OTHERWISE BLANKS ARE IGNORED.@[@@@@C     @H@@@@C        NVARS IS THE NUOS
)@@G@@MBER OF VARIABLES FOR WHICH THIS FORMAT IS TO BE USED.@[@@@@C     @H@@@@OT
)@@G@@C        LIST IS AN ARRAY DIMENSIONED AT 2 BY NVARS.  UPON RETURN FROM TOU
)@@G@@HIS   @C@@@@C         ROUTINE, LIST IS LEFT AS FOLLOWS...   @F@@@@C  FLDOV
)@@G@@( 0,18,LIST(1,I))=RECORD NUMBER CONTAINING THE I'TH VARIABLE@I@@@@C  FLDOW
)@@G@@(18,18,LIST(1,I))=COLUMN NUMBER THE I'TH VARIABLE BEGINS IN IN THAT RECOOX
)@@G@@RD    @H@@@@C  FLD( 0,18,LIST(2,I))=COLUMN NUMBER THE I'TH VARIABLE ENDSOY
)@@G@@ IN IN THAT RECORD@G@@@@C  FLD(18, 6,LIST(2,I))=INTEGER INDICATING THE TOZ
)@@G@@YPE OF FIELD SPECIFIED  @C@@@@C         IF THE FIELD TYPE IS D,E,F, OR GPA
)@@G@@ THEN @H@@@@C  FLD(24, 6,LIST(2,I))=D WIDTH SPECIFIED FOR THE FIELD (I.EPB
)@@G@@. 5 IN E13,5)     @E@@@@C  FLD(30, 6,LIST(2,I))=SCALE FACTOR SPECIFIED FPC
)@@G@@OR THE FIELD@[@@@@C     @H@@@@C        RECWTH IS AN ARRAY DIMENSIONED ATPD
)@@G@@ LEAST TO NREC.  UPON RETURN FROM   @H@@@@C         THIS ROUTINE, RECWTHPE
)@@G@@(I) WILL CONTAIN THE MINIMUM NUMBER OF COLUMNS  @E@@@@C         REQUIREDPF
)@@G@@ BY THIS FORMAT TO BE IN RECORD NUMBER I. @[@@@@C     @H@@@@C        NREPG
)@@G@@C IS AN INTEGER VARIABLE WHICH AT ENTRY GIVES THE MAXIMUM NUMBER  @G@@@@PH
)@@G@@C         OF RECORDS TO BE ALLOWED FROM THE FORMAT.  IF MORE RECORDS AREPI
)@@G@@@H@@@@C         SPECIFIED, AN ERROR IS INDICATED AND THE ERROR RETURN TAPJ
)@@G@@KEN.  UPON  @H@@@@C         RETURN, THIS VARIABLE WILL CONTAIN THE NUMBEPK
)@@G@@R OF RECORDS REQUIRED   @D@@@@C         BY THE FORMAT FOR INPUTTING NVARPL
)@@G@@S VARIABLES.@[@@@@C     @H@@@@C        THE SEVENTH ARGUMENT IS AN ERROR PM
)@@G@@RETURN, TAKEN WHEN ANY TYPE OF ERROR@G@@@@C         IS DETECTED.  PRIOR PN
)@@G@@TO RETURN, AN ERROR MESSAGE OF THE FORM...@F@@@@C             ***** FORMPO
)@@G@@AT ERROR - (...ERROR TYPE...) ON CARD XX  @D@@@@C                  (CARDPP
)@@G@@ IMAGE WITH ASTERISK POINTER) @H@@@@C         WILL BE PRINTED.  (THE CARPQ
)@@G@@D IMAGE WILL NOT BE PRINTED IF THE ERROR  @A@@@@C         IS  A PARENTHEPR
)@@G@@SIS ERROR.) @H@@@@C         MOST TYPES OF ERRORS ARE DETECTED BY THE ACTPS
)@@G@@UAL FORMAT CRACKING     @G@@@@C         ROUTINE, S1SFMT, AND ARE DESCRIBPT
)@@G@@ED IN CONNECTION WITH IT.  TWO@H@@@@C         ERROR TYPES ARE DETECTED IPU
)@@G@@N THIS ROUTINE.  ONE IS THE SPECIFICATION @H@@@@C         BY THE FORMAT PV
)@@G@@OF MORE THAN NREC RECORDS AS DESCRIBED ABOVE.  THIS   @H@@@@C         REPW
)@@G@@SULTS IN THE DIAGNOSTIC 'TOO MANY RECORS' BEING PRINTED.  THE     @H@@@@PX
)@@G@@C         OTHER IS INDICATED BY THE DIAGNOSTIC, 'EXTRA FORMAT', AND INDIPY
)@@G@@CATES @G@@@@C         THAT THE FORMAT HAS MORE SPECIFICATONS THAN REQUIRPZ
)@@G@@ED FOR NVARS@H@@@@C         VARIABLES.  THE ROUTINE DETECTS THIS IF NO RQA
)@@G@@IGHT PARENTHESIS ENDING @G@@@@C         AN UNLIMITED GROUP IS ENCOUNTEREQB
)@@G@@D.  FOR EXAMPLE, THE FORMAT   @H@@@@C         (5F4.1,3E15.6) WOULD RESULQC
)@@G@@T IN THIS DIAGNOSTIC IF NVARS WERE LESS   @#@@@@C         THAN 8. @[@@@@QD
)@@G@@C     @ @@@@        PARAMETER MAXTYP=13   @ @@@@      IMPLICIT INTEGER (QE
)@@G@@A-Z)  @E@@@@      DIMENSION FMT(2),LIST(2,NVARS),RECWTH(2),ERRMES(3)    QF
)@@G@@@A@@@@      DIMENSION HLDFMT(12)/12*1H /  @[@@@@C     @A@@@@C        INIQG
)@@G@@TIALIZE FORMAT CRACKER  @[@@@@C     @ @@@@      CALL S1SFMT(FMT,FMTLEN) QH
)@@G@@@#@@@@      MAXREC=NREC @]@@@@      NREC=1@#@@@@      PSCAL=0     @]@@@@QI
)@@G@@      COL=0 @#@@@@      COLMAX=0    @#@@@@      K=NVARS+1   @^@@@@      QJ
)@@G@@ASSIGN 331 TO JUMP@[@@@@C     @D@@@@C        GO GET SPECIFICATIONS ONE FQK
)@@G@@IELD AT A TIME    @[@@@@C     @#@@@@      DO 32 I=1,K @D@@@@ 31   CALL SQL
)@@G@@1SPEC(FLDTYP,FLDWTH,DWIDTH,PSCALE,ERRMES) @A@@@@      IF(FLDTYP.LE.MAXTYQM
)@@G@@P) GO TO 316@^@@@@        F=FLDTYP-MAXTYP @B@@@@      GO TO (311,312,313QN
)@@G@@,314,315,900),F   @[@@@@C     @#@@@@C        X FIELD  @[@@@@C     @ @@@@QO
)@@G@@ 311  CALL ADDCOL(FLDWTH)     @#@@@@      GO TO 31    @[@@@@C     @#@@@@QP
)@@G@@C        T FIELD  @[@@@@C     @#@@@@ 312  COL=FLDWTH-1@A@@@@      IF(COLQQ
)@@G@@.GT.COLMAX) COLMAX=COL  @#@@@@      GO TO 31    @[@@@@C     @^@@@@C     QR
)@@G@@   HOLERITH FIELD @[@@@@C     @ @@@@ 313  CALL ADDCOL(FLDWTH)     @#@@@@QS
)@@G@@      GO TO 31    @[@@@@C     @#@@@@C        SLASH    @[@@@@C     @ @@@@QT
)@@G@@ 314  RECWTH(NREC)=COLMAX     @#@@@@      COLMAX=0    @]@@@@      COL=0 QU
)@@G@@@#@@@@      NREC=NREC+1 @A@@@@      IF(NREC.LE.MAXREC) GO TO 31   @#@@@@QV
)@@G@@      FLDWTH=17   @#@@@@      NREC=NREC-1 @A@@@@      CALL ERR('NRECS > QW
)@@G@@NLR  ')     @#@@@@      RETURN 7    @[@@@@C     @A@@@@C        ) ENDING QX
)@@G@@UNLIMITED GROUP   @[@@@@C     @ @@@@ 315  IF(I.EQ.K) GO TO 34     @^@@@@QY
)@@G@@      ASSIGN 34 TO JUMP @#@@@@      GO TO 314   @[@@@@C     @^@@@@C     QZ
)@@G@@   ALL OTHERS     @[@@@@C     @ @@@@ 316  IF(I.EQ.K) GO TO 33     @ @@@@RA
)@@G@@      FLD(0,18,LIST(1,I))=NREC@A@@@@      FLD(18,18,LIST(1,I))=COL+1    RB
)@@G@@@A@@@@      FLD(0,18,LIST(2,I))=COL+FLDWTH@ @@@@      CALL ADDCOL(FLDWTHRC
)@@G@@)     @A@@@@      FLD(18,6,LIST(2,I))=FLDTYP    @ @@@@      IF(FLDTYP.GTRD
)@@G@@.4) GO TO 32@A@@@@      FLD(24,6,LIST(2,I))=DWIDTH    @B@@@@      IF(PSCRE
)@@G@@ALE.NE.-999) PSCAL=PSCALE     @A@@@@      FLD(30,6,LIST(2,I))=PSCAL     RF
)@@G@@@#@@@@ 32   CONTINUE    @#@@@@ 33   GO TO JUMP  @[@@@@C     @A@@@@C     RG
)@@G@@   NEVER USED ALL OF FORMAT   @[@@@@C     @#@@@@ 331  FLDWTH=18   @A@@@@RH
)@@G@@        IF(NVARS.EQ.0) GO TO 901    @A@@@@      CALL ERR('EXTRA FORMAT  RI
)@@G@@')    @#@@@@      GO TO 901   @[@@@@C     @^@@@@C        NORMAL RETURN  RJ
)@@G@@@[@@@@C     @ @@@@ 34   RECWTH(NREC)=COLMAX     @]@@@@      RETURN@[@@@@RK
)@@G@@C     @ @@@@C        ERRORS COME HERE     @[@@@@C     @^@@@@ 900  CALL ERL
)@@G@@RR(ERRMES)  @ @@@@ 901  RECWTH(NREC)=COLMAX     @#@@@@      RETURN 7    RM
)@@G@@@[@@@@C     @D@@@@C        ADDS N COLUMNS TO CURRENT COLUMN COUNTER     RN
)@@G@@@[@@@@C     @ @@@@      SUBROUTINE ADDCOL(N)    @#@@@@      COL=COL+N   RO
)@@G@@@A@@@@      IF(COL.GT.COLMAX) COLMAX=COL  @]@@@@      RETURN@[@@@@C     RP
)@@G@@@A@@@@C        HANDLES ERROR MESSAGES     @[@@@@C     @ @@@@      SUBROURQ
)@@G@@TINE ERR(ERRMES)  @ @@@@      DIMENSION ERRMES(3)     @^@@@@      CALL SRR
)@@G@@1WHR(F)     @B@@@@C  BACK POINTER UP 2, LOOK FOR NON-BLANK. @]@@[@      RS
)@@G@@FF=F-2@^@@[@        IF(FF.LT.1) FF=1@^@@[@      DO 8990 H=FF,1,-1 @ #@@@RT
)@@G@@      CALL S1PRFT(FMT,H,CHAR) @A@@@@      IF(CHAR.NE.1H ) GO TO 8994    RU
)@@G@@@#@@@@8990  CONTINUE    @^@@[@        DO 8991 H=FF,F,1@A@@[@        CALLRV
)@@G@@ S1PRFT(FMT,H,CHAR)     @A]@@@        IF(CHAR.NE.1H ) GO TO 8994  @#@@@@RW
)@@G@@8991    CONTINUE  @]@@[@      H=FF  @A@@[@      IF(FLDWTH.EQ.1)GO TO 899RX
)@@G@@4     @ @@[@      CALL S1SERR('S1GLST')   @#@@[@      RETURN 7    @]@@@@RY
)@@G@@8994  F=H   @^@@@@C  G IS CARD NUMBER.    @#@@@@      G=(F-1)/64+1@^@@@@RZ
)@@G@@        CALL S1PCHD(2)  @ @@@@      PRINT 9000,ERRMES,G     @G@@@@9000  SA
)@@G@@FORMAT ('0***** FORMAT ERROR - ',3A6,' AS SPECIFIED BY THIS FORMAT@D@@@@SB
)@@G@@     1 ON CARD ', I3, ' OF FORMAT SPECIFICATION')     @C@@@@C        DO SC
)@@G@@NOT POINT OUT PARENTHESIS ERROR     @ @@@@      IF(FLDWTH.EQ.1) RETURN  SD
)@@G@@@#@@@@      G=(G-1)*64+1@C@@@@C  G POINTS TO FIRST CHARACTER ON BAD CARDSE
)@@G@@.     @A@@@@      CALL S1TCHS(FMT,G,HLDFMT,1,64)@A@@@@      CALL S1SMCD(SF
)@@G@@HLDFMT,F-G+1)     @]@@@@      RETURN@]@@@@      END   ___   IF(NREC.LE.MSG
)@@G@@AXREC) GO TO 31   @#@@@@      FLDWTH=17   @#@@@@*[S@@@*SDFF*@D@@@@      SH
)@@G@@SUBROUTINE S11BVP(CN,CARD,NC,SCR,LSCR,NERR,$)   @ @@@@      IMPLICIT INTSI
)@@G@@EGER (A-Z)  @ @@@@      DIMENSION CARD(1),SCR(1)@[@@@@C     @A@@@@C     SJ
)@@G@@   PICT1 SCAT CARD PROCESSOR. @[@@@@C     @F@@@@C        SCAT CARD NUMBESK
)@@G@@R CN, STORED IN VECTOR CARD, IS DECODED   @F@@@@C        AND CHECKED.  SSL
)@@G@@UMMARY INFORMATION IS SAVED AT TAG 'SPLOT'@^@@@@C        AS FOLLOWS -   SM
)@@G@@@B@@@@C             1.  NUMBER OF SCAT CARDS    @E@@@@C             2.  SN
)@@G@@MAXIMUM NUMBER OF VARIABLES SPECIFIED     @B@@@@C             3.  MAXIMUSO
)@@G@@M NUMBER OF PLOTS @D@@[@C             4.  MAXIMUM SIZE OF PLOTS IN CHARASP
)@@G@@CTERS @C[@@@C             5.  MAXIMUM VERTICAL PLOT LENGTH  @D@@[@C     SQ
)@@G@@        6.  MAXIMUM TOTAL NUMBER OF CATEGORIES  @D@@[@C             7.  SR
)@@G@@MAXIMUM GROUPS VALUES LIST SIZE     @[@@@@C     @F@@@@C        OUTPUT SPSS
)@@G@@ECIFICATIONS ARE WRITTEN ON UNIT 1, AS FOLLOWS  @A@@@@C             1.  ST
)@@G@@SCAT CARD NUMBER  @F@@@@C             2.  20 WORD SPECS VECTOR - SEE BELSU
)@@G@@OW FOR CONTENTS   @A@@@@C             3.  VARIABLE LIST(S)  @D@@@@C     SV
)@@G@@        4.  5 BY NGROUP ARRAY - FOR EACH GROUPS @B@@@@C                 SW
)@@G@@   A.  VARIABLE INDEX   @B@@@@C                    B.  VARIABLE TYPE    SX
)@@G@@@C@@@@C                    C.  NUMBER OF CATEGORIES   @C@@@@C           SY
)@@G@@         D.  NUMBER OF VALUES, NVALS@C@@@@C                    E.  OTHERSZ
)@@G@@ AND MISSING SPECS@D@@@@C             5.  2 BY NVALS ARRAY FOR EACH GROUTA
)@@G@@PS    @B@@@@C                    A.  CATEGORY NUMBER  @ @@@@C           TB
)@@G@@         B.  VALUE@[@@@@C     @[@@@@C     @ @@@@      DIMENSION CWSPEC(1TC
)@@G@@24)   @^@@@@      DATA CWSPEC /     @C@@@@     -   'VARS        ',2,0,1,TD
)@@G@@200,2,-1,0,0,     @C@@@@     -   'HVARS       ',7,1,201,200,1,-1,0,0,   TE
)@@G@@@C@@@@     -   'VVARS       ',7,1,401,200,1,-1,0,0,   @C@@@@     -   'SITF
)@@G@@ZE        ',2,0,601,2,2,3,3,20,     @F@@@@     -   'HSCALE      ',2,0,62TG
)@@G@@1,2,1,3,-9999999999,9999999999,     @F@@@@     -   'VSCALE      ',2,0,64TH
)@@G@@1,2,1,3,-9999999999,9999999999,     @C@@@@     -   'GRID        ',2,0,66TI
)@@G@@1,2,2,9,0,20,     @B@@@@     -   'REGRESSION  ',2,0,681,2,0,8,0,0,@A@@@@TJ
)@@G@@     -   'LISTMD      ',2,0,691,0,  @A@@@@     -   'LISTOFF     ',2,0,69TK
)@@G@@2,0,  @C@@@@     -   'LABELVAR    ',2,0,701,1,1,-1,0,0,     @F@@@@     -TL
)@@G@@   'GROUPS      ',-2,0,721,200,2,27,-9999999999,9999999999, @A@@@@     -TM
)@@G@@   'FREQ        ',2,0,693,0,  @A@@@@     -   'OK          ',2,0,694,0/  TN
)@@G@@@[@@@@C     @[@@@@C     @#@@@@      COMMON X(1) @^@@@@      DIMENSION NETO
)@@G@@X(2)  @#@@@@      REAL RVAL   @ @@@@      EQUIVALENCE (VAL,RVAL)  @[@@@@TP
)@@G@@C     @[@@@@C     @ @@@@      DIMENSION SPECS(20)     @A@@@@      EQUIVATQ
)@@G@@LENCE(SPECS(1),NVARS)   @A@@@@      EQUIVALENCE(SPECS(2),NHVARS)  @A@@@@TR
)@@G@@      EQUIVALENCE(SPECS(3),NVVARS)  @A@@@@      EQUIVALENCE(SPECS(4),HSITS
)@@G@@ZE)   @A@@@@      EQUIVALENCE(SPECS(5),VSIZE)   @A@@@@      EQUIVALENCE(TT
)@@G@@SPECS(6),HSCALE)  @A@@@@      EQUIVALENCE(SPECS(7),HMIN)    @A@@@@      TU
)@@G@@EQUIVALENCE(SPECS(8),HMAX)    @A@@@@      EQUIVALENCE(SPECS(9),VSCALE)  TV
)@@G@@@A@@@@      EQUIVALENCE(SPECS(10),VMIN)   @A@@@@      EQUIVALENCE(SPECS(TW
)@@G@@11),VMAX)   @A@@@@      EQUIVALENCE(SPECS(12),HGRID)  @A@@@@      EQUIVATX
)@@G@@LENCE(SPECS(13),VGRID)  @A@@@@      EQUIVALENCE(SPECS(14),VIND)   @A@@@@TY
)@@G@@      EQUIVALENCE(SPECS(15),VDEP)   @A@@@@      EQUIVALENCE(SPECS(16),LITZ
)@@G@@STMD) @A@@@@      EQUIVALENCE(SPECS(17),LISTOF) @A@@@@      EQUIVALENCE(UA
)@@G@@SPECS(18),LABELV) @A@@@@      EQUIVALENCE(SPECS(19),FREQ)   @A@@@@      UB
)@@G@@EQUIVALENCE(SPECS(20),NGROUP) @B@@@@      REAL HSIZE,VSIZE,HMIN,HMAX,VMIUC
)@@G@@N,VMAX@[@@@@C     @[@@@@C     @^@@@@C             INITIALIZE@[@@@@C     UD
)@@G@@@C@@@@      CALL S1GTAG('SPLOT',IBV,DUM,DUM,$110)     @#@@@@      GO TO UE
)@@G@@120   @]@@@@ 110  NEL=10@B@@@@      CALL S1STFT('SPLOT',IBV,1,NEL,$155) UF
)@@G@@@^@@@@      DO 115 J=1,NEL    @#@@@@ 115  X(IBV+J-1)=0@B@@@@      CALL SUG
)@@G@@1IODR(1,'REWIND',DUM,DUM,DUM) @#@@[@      IDVAR=0     @C@@[@      CALL SUH
)@@G@@1GTAG('IDVAR',IDFW,DUM,DUM,$120)    @A@@[@      IF(X(IDFW) .EQ. 1) GO TOUI
)@@G@@ 117  @A@@[@      IF(X(IDFW) .NE. 4) GO TO 120  @B@@[@      CALL S1CKVN(UJ
)@@G@@X(IDFW+1),IDVAR,$120)   @#@@[@      GO TO 118   @^@@[@ 117  IDVAR=X(IDFWUK
)@@G@@+1)   @B@@[@ 118  CALL S1VLST('IDVAR  ',IDVAR,0,DUM)  @^@@@@ 120  X(IBV)UL
)@@G@@=X(IBV)+1   @[@@@@C     @D@@@@C             DECODE AND STORE CONTROL INFUM
)@@G@@ORMATION    @[@@@@C     @#@@@@ 150  LLIST=1501  @^@@@@      LMAX=LSCR-LLUN
)@@G@@IST   @A@@@@      IF(LMAX .GT. 100) GO TO 160   @ @@@@ 155  CALL S1SERR(UO
)@@G@@'S11BVP.')  @]@@@@      RETURN@F@@@@ 160  CALL S1ENDC('SCAT   ',CARD,NC,UP
)@@G@@SCR(LLIST),LMAX,LEND,NE,$155) @#@@@@      NERR=NERR+NE@G@@@@      CALL SUQ
)@@G@@1ENST('SCAT   ',SCR(LLIST),LEND,CWSPEC,14,DUM,SCR,1500,     @#@@@@     -UR
)@@G@@   DUM,NE)  @#@@@@      NERR=NERR+NE@[@@@@C     @C@@@@C             PROCUS
)@@G@@ESS VARS,HVARS, AND VVARS     @[@@@@C     @#@@@@ 200  NVARS=SCR(1)@A@@@@UT
)@@G@@      IF(NVARS .EQ. 0) GO TO 220    @B@@@@      CALL TSTALP('VARS   ',NVUU
)@@G@@ARS,SCR(2)) @#@@@@      GO TO 250   @^@@@@ 220  NHVARS=SCR(201)   @^@@@@UV
)@@G@@      NVVARS=SCR(401)   @F@@@@      IF(NHVARS .NE. 0) CALL TSTALP('HVARSUW
)@@G@@  ',NHVARS,SCR(202))    @F@@@@      IF(NVVARS .NE. 0) CALL TSTALP('VVARSUX
)@@G@@  ',NVVARS,SCR(402))    @D@@@@      IF(NHVARS .EQ. 0  .OR.  NVVARS .EQ. UY
)@@G@@0) GO TO 250@^@@@@      DO 240 I=1,NHVARS @^@@@@      VI=SCR(201+I)     UZ
)@@G@@@^@@@@      DO 230 J=1,NVVARS @B@@@@      IF(VI .NE. SCR(401+J)) GO TO 2VA
)@@G@@30    @#@@@@      CALL ERROR  @^@@@@      PRINT 9225,VI     @G@@@@ 9225 VB
)@@G@@FORMAT(' ***** PICT1 ERROR.  VARIABLE NUMBER',I4,' IS SPECIFIED WI@A@@@@VC
)@@G@@     -TH BOTH HVARS AND VVARS')     @#@@@@      GO TO 240   @#@@@@ 230  VD
)@@G@@CONTINUE    @#@@@@ 240  CONTINUE    @[@@@@C     @A@@@@C             PROCVE
)@@G@@ESS SIZE SPECS    @[@@@@C     @#@@[@ 250  HSIZE=6.    @#@@[@      VSIZE=VF
)@@G@@6.    @A]@@@      IF(SCR(601) .EQ. 0) GO TO 300 @A@@@@      CALL LOAD3(SVG
)@@G@@CR(601),HSIZE)    @A@@@@      IF(HSIZE .LE. 10.) GO TO 275  @#@@@@      VH
)@@G@@CALL ERROR  @#@@@@      PRINT 9270  @G@@@@ 9270 FORMAT(' ***** PICT1 ERRVI
)@@G@@OR.  HORIZONTAL PLOT SIZE SPECIFIED WITH S@ @@@@     -IZE EXCEEDS 10 INCVJ
)@@G@@HES') @A@@@@ 275  CALL LOAD3(SCR(603),VSIZE)    @[@@@@C     @B@@@@C     VK
)@@G@@        PROCESS HSCALE AND VSCALE   @[@@@@C     @C@@@@ 300  CALL PSCALE(VL
)@@G@@'H',SCR(621),HSCALE,HMIN,HMAX)@C@@@@      CALL PSCALE('V',SCR(641),VSCALVM
)@@G@@E,VMIN,VMAX)@[@@@@C     @A@@@@C             PROCESS GRID SPECS    @[@@@@VN
)@@G@@C     @#@@@@ 350  HGRID=0     @#@@@@      VGRID=0     @A@@@@      IF(SCRVO
)@@G@@(661) .EQ. 0) GO TO 400 @A@@@@      IF(SCR(661) .EQ. 4) GO TO 360 @A@@@@VP
)@@G@@      IF(SCR(661) .NE. 1) GO TO 400 @]@@@@      L=663 @^@@@@      HGRID=VQ
)@@G@@SCR(662)    @A@@@@      IF(HGRID .LT. HSIZE) GO TO 370@#@@@@      CALL EVR
)@@G@@RROR  @#@@@@      PRINT 9355  @G@@@@ 9355 FORMAT(' ***** PICT1 ERROR.  NVS
)@@G@@UMBER OF GRID LINES SPECIFIED IS NOT@B@@@@     - LESS THAN THE PLOT SIZEVT
)@@G@@ IN INCHES')@#@@@@      GO TO 370   @]@@@@ 360  L=664 @B@@@@      IF(SCRVU
)@@G@@(662) .EQ. 'NONE') GO TO 370  @B@@@@      IF(SCR(662) .NE. 'SDV') GO TO VV
)@@G@@365   @#@@@@      HGRID=-1    @#@@@@      GO TO 370   @#@@@@ 365  CALL EVW
)@@G@@RROR  @#@@@@      PRINT 9365  @G@@@@ 9365 FORMAT(' ***** PICT1 ERROR.  OVX
)@@G@@NLY INTEGERS OR ''NONE'' OR ''SDV'' @C@@@@     -CAN BE USED WITH THE CONVY
)@@G@@TROL WORD GRID')  @A@@@@ 370  IF(SCR(L) .EQ. 4) GO TO 380   @A@@@@      VZ
)@@G@@IF(SCR(L) .NE. 1) GO TO 400   @^@@@@      VGRID=SCR(L+1)    @A@@@@      WA
)@@G@@IF(VGRID .LT. VSIZE) GO TO 400@#@@@@      CALL ERROR  @#@@@@      PRINT WB
)@@G@@9355  @#@@@@      GO TO 400   @B@@@@ 380  IF(SCR(L+1) .EQ. 'NONE') GO TOWC
)@@G@@ 400  @B@@@@      IF(SCR(L+1) .NE. 'SDV') GO TO 385   @#@@@@      VGRID=WD
)@@G@@-1    @#@@@@      GO TO 400   @#@@@@ 385  CALL ERROR  @#@@@@      PRINT WE
)@@G@@9365  @[@@@@C     @B@@@@C             PROCESS REGRESSION SPECS    @[@@@@WF
)@@G@@C     @]@@@@ 400  VIND=0@]@@@@      VDEP=0@A@@@@      IF(SCR(681) .EQ. 0WG
)@@G@@) GO TO 450 @^@@@@      NMODIF=SCR(682)   @A@@@@      IF(NMODIF .NE. 0) WH
)@@G@@GO TO 410   @]@@@@      VIND=1@]@@@@      VDEP=1@#@@@@      GO TO 450   WI
)@@G@@@]@@@@ 410  L=683 @^@@@@      DO 440 J=1,NMODIF @B@@@@      IF(SCR(L) .NWJ
)@@G@@E. 'VIND') GO TO 420    @A@@@@      IF(VIND .EQ. 0) GO TO 415     @#@@@@WK
)@@G@@ 412  CALL ERROR  @#@@@@      PRINT 9410  @G@@@@ 9410 FORMAT(' ***** PICWL
)@@G@@T1 ERROR.  VIND OR VDEP IS USED MORE THAN ONCE W@B@@@@     -ITH THE REGRWM
)@@G@@ESSION CONTROL WORD')   @#@@@@      GO TO 440   @]@@@@ 415  VIND=1@#@@@@WN
)@@G@@      GO TO 440   @B@@@@ 420  IF(SCR(L) .NE. 'VDEP') GO TO 430    @A@@@@WO
)@@G@@      IF(VDEP .NE. 0) GO TO 412     @]@@@@      VDEP=1@#@@@@      GO TO WP
)@@G@@440   @#@@@@ 430  CALL ERROR  @#@@@@      PRINT 9435  @G@@@@ 9435 FORMATWQ
)@@G@@(' ***** PICT1 ERROR.  A MODIFIER OTHER THAN VIND AND VDEP I@C@@@@     -WR
)@@G@@S USED WITH THE REGRESSION CONTROL WORD') @]@@@@ 440  L=L+2 @[@@@@C     WS
)@@G@@@D@@@@C             PROCESS LISTMD,LISTOFF AND LABELVAR     @[@@@@C     WT
)@@G@@@^@@@@ 450  LISTMD=SCR(691)   @^@@@@      LISTOF=SCR(692)   @#@@@@      WU
)@@G@@OK=SCR(694) @^@@@@      LABELV=SCR(701)   @A@@@@      IF(LABELV .EQ. 0) WV
)@@G@@GO TO 500   @B@@@@      CALL S1VLST('LABELVAR',LABELV,0,DUM)@A@@@@      WW
)@@G@@CALL S1GTVT(LABELV,TYP,$460)  @^@@@@ 460  LABELV=LABELV*2   @A@@@@      WX
)@@G@@IF(TYP .EQ. 1) LABELV=LABELV+1@[@@@@C     @E@@@@C             SET FREQ AWY
)@@G@@ND BEGIN PROCESSING GROUPS SPECS    @[@@@@C     @^@@@@ 500  FREQ=SCR(693WZ
)@@G@@)     @^@@@@      NGROUP=SCR(721)   @#@@[@      ALLTOT=0    @#@@[@      XA
)@@G@@LDAT=700    @A@@@@      IF(NGROUP .GT. 0) GO TO 510   @]@@@@      FREQ=1XB
)@@G@@@#@@@@      GO TO 800   @A@@@@ 510  IF(NGROUP .LE. 20) GO TO 520  @#@@@@XC
)@@G@@      CALL ERROR  @#@@@@      PRINT 9515  @G@@@@ 9515 FORMAT(' ***** PICXD
)@@G@@T1 ERROR.  THE GROUPS CONTROL WORD IS USED MORE @^@@@@     -THAN 20 TIMEXE
)@@G@@S')   @#@@@@      NGROUP=20   @#@@@@ 520  LGD=600     @][@@@      NG=0  XF
)@@G@@@]@@@@      L=722 @#@@@@ 530  NG=NG+1     @A@@@@      IF(NG .GT. NGROUP)XG
)@@G@@ GO TO 800  @[@@@@C     @F@@@@C             GET NUMBER OF MODIFIERS AND XH
)@@G@@VARIABLE SPECIFICATIONS @[@@@@C     @^@@@@      NMODIF=SCR(L)     @]@@@@XI
)@@G@@      L=L+1 @A@@@@      IF(NMODIF .EQ. 0) GO TO 530   @]@@@@      VI=0  XJ
)@@G@@@ @@@@      CALL NEXT(MTYP,NEX)     @A@@@@      IF(MTYP .EQ. 4) GO TO 57XK
)@@G@@0     @A@@@@      IF(MTYP .EQ. 1) GO TO 560     @#@@@@      CALL ERROR  XL
)@@G@@@#@@@@      PRINT 9550  @G@@@@ 9550 FORMAT(' ***** PICT1 ERROR.  THE FIRXM
)@@G@@ST MODIFIER OF GROUPS IS NOT T@B@@@@     -HE NAME OR NUMBER OF A VARIABLXN
)@@G@@E')   @#@@@@      GO TO 580   @ @@@@ 560  CALL S1CKVI(NEX(1),$565)@#@@@@XO
)@@G@@      VI=NEX(1)   @#@@@@      GO TO 580   @#@@@@ 565  CALL ERROR  @^@@@@XP
)@@G@@      PRINT 9565,NEX(1) @G@@@@ 9565 FORMAT(' ***** PICT1 ERROR.  GROUPS XQ
)@@G@@VARIABLE NUMBER',I5,' HAS NOT @^@@@@     -BEEN DEFINED')    @#@@@@      XR
)@@G@@GO TO 580   @ @@@@ 570  CALL S1CKVN(NEX,VI,$575)@#@@@@      GO TO 580   XS
)@@G@@@#@@@@ 575  CALL ERROR  @^@@@@      PRINT 9575,NEX    @G@@@@ 9575 FORMATXT
)@@G@@(' ***** PICT1 ERROR.  GROUPS VARIABLE NAMED ',2A6,' IS NOT @#@@@@     -XU
)@@G@@DEFINED')   @]@@@@ 580  VTYP=0@ @@@@      IF(VI .EQ. 0) GO TO 590 @A@@@@XV
)@@G@@      CALL S1GTVT(VI,VTYP,$590)     @#@@@@ 590  SCR(LGD)=VI @B@@@@      XW
)@@G@@CALL S1VLST('GROUPS  ',VI,0,DUM)    @^@@@@      SCR(LGD+1)=VTYP   @[@@@@XX
)@@G@@C     @E@@@@C             IF THERE ARE 2 MODIFIERS - CHECK FOR ALLK     XY
)@@G@@@[@@@@C     @A@@@@      IF(NMODIF .EQ. 0) GO TO 530   @ @@@@      CALL NXZ
)@@G@@EXT(MTYP,NEX)     @A@@@@      IF(NMODIF .GT. 1) GO TO 650   @A@@@@      YA
)@@G@@IF(MTYP .NE. 4) GO TO 650     @#@@@@      TEMP=NEX(1) @A@@@@      CALL SYB
)@@G@@1TCHS('   ',1,TEMP,4,3) @A@@[@      IF(TEMP .EQ. 'ALL') GO TO 603 @#@@[@YC
)@@G@@      TEMP=NEX(1) @A@@[@      CALL S1TCHS('  ',1,TEMP,5,2)  @A@@[@      YD
)@@G@@IF(TEMP .NE. 'XALL') GO TO 650@]@@[@      FCH=5 @#@@[@      ALLCOD=-2   YE
)@@G@@@#@@[@      GO TO 605   @]@@[@ 603  FCH=4 @#@@[@      ALLCOD=-1   @^@@[@YF
)@@G@@ 605  DO 610 J=FCH,12   @ ]@@@      CALL S1PRFT(NEX,J,CHAR) @A@@@@      YG
)@@G@@IF(CHAR .EQ. ' ') GO TO 615   @B@@@@      IF(S1SPCT(CHAR) .NE. 2) GO TO YH
)@@G@@650   @#@@@@ 610  CONTINUE    @ @@[@ 615  IF(J .EQ. FCH) GO TO 650@B@@[@YI
)@@G@@      CALL S1TCHS('    ',1,NEX,1,FCH-1)   @ ]@@@      CALL S1VLU(NEX,J-1YJ
)@@G@@,ALLK)@D@@@@      IF(ALLK .GT. 1  .AND.  ALLK .LT. 36) GO TO 630  @#@@@@YK
)@@G@@      CALL ERROR  @#@@@@      PRINT 9625  @G@@@@ 9625 FORMAT(' ***** PICYL
)@@G@@T1 ERROR.  ALLK IS SPECIFIED WITH GROUPS AND K I@A@@@@     -S LESS THAN YM
)@@G@@2 OR EXCEEDS 35') @#@@@@      ALLK=36     @^@@@@ 630  SCR(LGD+2)=ALLK   YN
)@@G@@@ @@[@      ALLTOT=ALLTOT+ALLK+6    @^@@[@      SCR(LGD+3)=ALLCOD @#[@@@YO
)@@G@@      SCR(LGD+4)=0@#@@@@ 640  LGD=LGD+5   @#@@@@      GO TO 530   @[@@@@YP
)@@G@@C     @C@@@@C             BEGINNING OF LOOP TO SAVE VALUES  @[@@@@C     YQ
)@@G@@@#@@@@ 650  NVALS=0     @]@@@@      NGRP=1@#@@@@      OTHER=0     @#@@@@YR
)@@G@@      MISSNG=0    @#@@@@      ALPERR=0    @#@@@@      ALPSIZ=0    @#@@@@YS
)@@G@@      NUMERR=0    @D@@@@ 660  IF(MTYP .LT. 1  .OR.  MTYP .GT. 5) GO TO 6YT
)@@G@@75    @B@@@@      GO TO (700,720,680,740,760),MTYP    @^@@@@ 670  NVALS=YU
)@@G@@NVALS+1     @^@@@@      SCR(LDAT)=NGRP    @^@@@@      SCR(LDAT+1)=VAL   YV
)@@G@@@#@@@@      LDAT=LDAT+2 @A@@@@ 675  IF(NMODIF .EQ. 0) GO TO 680   @ @@@@YW
)@@G@@      CALL NEXT(MTYP,NEX)     @#@@@@      GO TO 660   @[@@@@C     @D@@@@YX
)@@G@@C             ALL VALUES SAVED - CHECK FOR DUPLICATES @[@@@@C     @^@@@@YY
)@@G@@ 680  SCR(LGD+2)=NGRP   @ @@[@      ALLTOT=ALLTOT+NGRP+6    @A@@[@      YZ
)@@G@@IF(NGRP .LT. 36) GO TO 682    @#@@[@      CALL ERROR  @#@@[@      PRINT ZA
)@@G@@9680  @G@@[@ 9680 FORMAT(' ***** PICT1 ERROR.  MORE THAN 35 CATEGORIES AZB
)@@G@@RE SPECIFIED@A@@[@     - WITH A GROUPS CONTROL WORD') @^@@[@ 682  SCR(LGZC
)@@G@@D+3)=NVALS  @A[@@@      SCR(LGD+4)=OTHER*1024 + MISSNG@A@@@@      IF(NVAZD
)@@G@@LS .LT. 2) GO TO 640    @^@@@@      LT=LDAT-NVALS*2 +1@^@@@@      DO 690ZE
)@@G@@ I=1,NVALS  @#@@@@      TEMP=SCR(LT)@#@@@@      LT=LT+2     @B@@@@      ZF
)@@G@@IF(TEMP .EQ. 'ERROR') GO TO 690     @#@@@@      LOW=I+1     @A@@@@      ZG
)@@G@@IF(LOW .GE. NVALS) GO TO 690  @]@@@@      LTT=LT@^@@@@      DO 685 J=LOWZH
)@@G@@,NVALS@B@@@@      IF(TEMP .NE. SCR(LTT)) GO TO 685    @#@@@@      CALL EZI
)@@G@@RROR  @#@@@@      PRINT 9685  @G@@@@ 9685 FORMAT(' ***** PICT1 ERROR.  TZJ
)@@G@@HE SAME VALUE IS USED MORE THAN ONCE@A@@@@     - IN A GROUPS SPECIFICATIZK
)@@G@@ON')  @#@@@@      GO TO 640   @#@@@@ 685  LTT=LTT+2   @#@@@@ 690  CONTINZL
)@@G@@UE    @#@@@@      GO TO 640   @[@@@@C     @ @@@@C             INTEGER VAZM
)@@G@@LUE   @[@@@@C     @#@@@@ 700  VAL='ERROR' @A@@@@      IF(VTYP .EQ. 0) GOZN
)@@G@@ TO 670     @A@@@@      IF(VTYP .EQ. 1) GO TO 710     @#@@@@      TNEX=NZO
)@@G@@EX(1) @ @@@@      ENCODE(NEX,702) TNEX    @#@@@@ 702  FORMAT(I12) @]@@@@ZP
)@@G@@      JS=0  @^@@@@      TEMP='      '     @^@@@@      DO 705 J=1,12     ZQ
)@@G@@@ @@@@      CALL S1PRFT(NEX,J,CHAR) @A@@@@      IF(CHAR .EQ. ' ') GO TO ZR
)@@G@@705   @#@@@@      JS=JS+1     @ @@@@      IF(JS .GT. 6) GO TO 708 @A@@@@ZS
)@@G@@      CALL S1PRST(TEMP,JS,CHAR)     @#@@@@ 705  CONTINUE    @#@@@@      ZT
)@@G@@VAL=TEMP    @#@@@@      GO TO 670   @#@@@@ 708  CALL ERROR  @^@@@@      ZU
)@@G@@PRINT 9708,TNEX   @G@@@@ 9708 FORMAT(' ***** PICT1 ERROR.  VALUE ',I12,'ZV
)@@G@@ USED WITH GROUPS HAS MO@ @@@@     -RE THAN 6 CHARACTERS')  @#@@@@      ZW
)@@G@@GO TO 670   @#@@@@ 710  RVAL=NEX(1) @#@@@@      GO TO 670   @[@@@@C     ZX
)@@G@@@A@@@@C             FLOATING POINT VALUE  @[@@@@C     @#@@@@ 720  VAL=NEZY
)@@G@@X(1)  @D@@@@      IF(NUMERR .NE. 0  .OR.  VTYP .NE. 2) GO TO 670  @#@@@@ZZ
)@@G@@      CALL ERROR  @^@@@@      PRINT 9725,VI     @G@@@@ 9725 FORMAT(' ***AA
)@@G@@** PICT1 ERROR.  GROUPS VARIABLE',I4,' IS ALPHANUMERIC@G@@@@     - BUT AAB
)@@G@@ VALUE SPECIFIED FOR IT IS NUMERIC WITH A DECIMAL POINT')   @#@@@@      AC
)@@G@@NUMERR=1    @#@@@@      GO TO 670   @[@@@@C     @A@@@@C             ALPHAD
)@@G@@ANUMERIC VALUE    @[@@@@C     @#@@@@ 740  VAL=NEX(1)  @A@@@@      IF(VALAE
)@@G@@ .EQ. 'OTHER') GO TO 780@F@@@@      IF(VAL .EQ. 'MISSIN'  .AND.  NEX(2) AF
)@@G@@.EQ. 'G') GO TO 790     @D@@@@      IF(ALPERR .NE. 0  .OR.  VTYP .NE. 1)AG
)@@G@@ GO TO 750  @#@@@@      CALL ERROR  @^@@@@      PRINT 9745,VI     @G@@@@AH
)@@G@@ 9745 FORMAT(' ***** PICT1 ERROR.  GROUPS VARIABLE',I4,' IS NUMERIC BUT AI
)@@G@@@C@@@@     -A VALUE SPECIFIED FOR IT IS ALPHANUMERIC')@#@@@@      ALPERRAJ
)@@G@@=1    @#@@@@      GO TO 670   @A@@[@ 750  IF(ALPSIZ .NE. 0) GO TO 755   AK
)@@G@@@B@@[@      IF(NEX(2) .EQ. '      ') GO TO 755  @#]@@@      CALL ERROR  AL
)@@G@@@#@@@@      PRINT 9755  @G@@@@ 9755 FORMAT(' ***** PICT1 ERROR.  ONE OR AM
)@@G@@MORE VALUES USED WITH GROUPS H@A@@@@     -AS MORE THE SIX CHARACTERS')  AN
)@@G@@@#@@@@      ALPSIZ=1    @B@@[@ 755  IF(VAL .EQ. '      ') GO TO 790     AO
)@@G@@@#@@@@      GO TO 670   @[@@@@C     @^@@@@C             SLASH     @[@@@@AP
)@@G@@C     @A@@@@ 760  IF(NVALS .EQ. 0) GO TO 675    @#@@@@      NGRP=NGRP+1 AQ
)@@G@@@#@@@@      GO TO 675   @[@@@@C     @^@@@@C             OTHER     @[@@@@AR
)@@G@@C     @A@@@@ 780  IF(OTHER .EQ. 0) GO TO 785    @#@@@@      CALL ERROR  AS
)@@G@@@#@@@@      PRINT 9785  @G@@@@ 9785 FORMAT(' ***** PICT1 ERROR.  OTHER OAT
)@@G@@R MISSING IS SPECIFIED MORE TH@ @@@@     -AN ONCE WITH GROUPS')   @#@@@@AU
)@@G@@ 785  OTHER=NGRP  @#@@@@      GO TO 675   @[@@@@C     @^@@@@C           AV
)@@G@@  MISSING   @[@@@@C     @A@@@@ 790  IF(MISSNG .EQ. 0) GO TO 795   @#@@@@AW
)@@G@@      CALL ERROR  @#@@@@      PRINT 9785  @#@@@@ 795  MISSNG=NGRP @#@@@@AX
)@@G@@      GO TO 675   @[@@@@C     @B@@@@C             UPDATE STORAGE SIZE VAAY
)@@G@@LUES  @[@@@@C     @#@@@@ 800  NV=NVARS    @^@@@@      NP=(NV*(NV-1))/2  AZ
)@@G@@@ @@@@      IF(NV .NE. 0) GO TO 820 @^@@@@      NV=NHVARS+NVVARS  @^@@@@BA
)@@G@@      NP=NHVARS*NVVARS  @#@@[@ 820  NV=NV+NGROUP@E@@[@      IF(LISTMD .EBB
)@@G@@Q. 0  .AND.  LISTOF .EQ. 0) GO TO 825     @D@@[@      IF(LABELV .NE. 0  BC
)@@G@@.OR.  IDVAR .NE. 0) NV=NV+1   @#@@[@ 825  NP=NP*NGROUP@B@@[@      IF(NV BD
)@@G@@.GT. X(IBV+1)) X(IBV+1)=NV    @B[@@@      IF(NP .GT. X(IBV+2)) X(IBV+2)=BE
)@@G@@NP    @^@@[@      HS=(HSIZE*10+10)/6@^@@[@      VS=VSIZE*6 + 4    @#@@[@BF
)@@G@@      NP=HS*VS    @B#@@@      IF(NP .GT. X(IBV+3)) X(IBV+3)=NP    @B@@@@BG
)@@G@@      IF(VS .GT. X(IBV+4)) X(IBV+4)=VS    @C@@[@      IF(ALLTOT .GT. X(IBH
)@@G@@BV+5)) X(IBV+5)=ALLTOT  @^@@[@      LDAT=LDAT-700     @B@@[@      IF(LDABI
)@@G@@T .GT. X(IBV+6)) X(IBV+6)=LDAT@[@@@@C     @B@@@@C             OUTPUT SPEBJ
)@@G@@CS IF NO ERRORS   @[@@@@C     @ @@@@ 850  IF(NERR .NE. 0) RETURN  @BA@@@BK
)@@G@@      CALL S1IODR(1,'WRITE',1,CN,DUM)     @B@@@@      CALL S1IODR(1,'WRIBL
)@@G@@TE',20,SPECS,DUM) @A@@@@      IF(NVARS .EQ. 0) GO TO 860    @C@@@@      BM
)@@G@@CALL S1IODR(1,'WRITE',NVARS,SCR(2),DUM)   @#@@@@      GO TO 870   @C@@@@BN
)@@G@@ 860  CALL S1IODR(1,'WRITE',NHVARS,SCR(202),DUM)@C@@@@      CALL S1IODR(BO
)@@G@@1,'WRITE',NVVARS,SCR(402),DUM)@ @@@@ 870  IF(NGROUP .EQ. 0) RETURN@D@@@@BP
)@@G@@      CALL S1IODR(1,'WRITE',5*NGROUP,SCR(600),DUM)    @B]@@@      CALL SBQ
)@@G@@1IODR(1,'WRITE',1,LDAT,DUM)   @ @@@@      IF(LDAT .EQ. 0) RETURN  @C@@@@BR
)@@G@@      CALL S1IODR(1,'WRITE',LDAT,SCR(700),DUM)  @]@@@@      RETURN@[@@@@BS
)@@G@@C     @[@@@@C     @C@@@@C        LOCAL SUBROUTINE FOR ERROR HANDLING    BT
)@@G@@@[@@@@C     @^@@@@      SUBROUTINE ERROR  @^@@@@      CALL S1PCHD(1)    BU
)@@G@@@#@@@@      NERR=NERR+1 @]@@@@      RETURN@[@@@@C     @[@@@@C     @F@@@@BV
)@@G@@C        LOCAL SUBROUTINE TO CHECK FOR ALPHANUMERIC VARIABLES     @[@@@@BW
)@@G@@C     @B@@@@      SUBROUTINE TSTALP(TYPE,NIN,LIST)    @ @@@@      DIMENSBX
)@@G@@ION LIST(NIN)     @^@@@@      DO 1100 I=1,NIN   @A@@@@      CALL S1VLST(BY
)@@G@@TYPE,LIST(I),1,NE)@ @@@@      IF(NE .EQ. 0) GO TO 1100@#@@@@      NERR=NBZ
)@@G@@ERR+NE@]@@@@      RETURN@#@@@@ 1100 CONTINUE    @]@@@@      RETURN@[@@@@CA
)@@G@@C     @[@@@@C     @D@@@@C        LOCAL SUBROUTINE TO LOAD INTEGER OR FP CB
)@@G@@VALUE @[@@@@C     @A@@@@      SUBROUTINE LOAD3(TSPEC,VALUE) @^@@@@      CC
)@@G@@DIMENSION TSPEC(2)@#@@@@      REAL VALUE  @A@@@@      IF(TSPEC(1) .EQ. 2CD
)@@G@@) GO TO 1800@^@@@@      VALUE=TSPEC(2)    @]@@@@      RETURN@ @@@@ 1800 CE
)@@G@@VALUE=BOOL(TSPEC(2))    @]@@@@      RETURN@[@@@@C     @[@@@@C     @C@@@@CF
)@@G@@C        LOCAL SUBROUTINE TO PROCESS SCALE SPECS@[@@@@C     @D@@@@      CG
)@@G@@SUBROUTINE PSCALE(HORV,SPECS,SCAL,SMIN,SMAX)    @^@@@@      DIMENSION SPCH
)@@G@@ECS(1)@^@@@@      REAL SMIN,SMAX    @^@@@@      SCAL=SPECS(1)     @ @@@@CI
)@@G@@      IF(SCAL .EQ. 0) RETURN  @A@@@@      CALL LOAD3(SPECS(2),SMIN)     CJ
)@@G@@@A@@@@      IF(SCAL .GT. 1) GO TO 2300    @D@@@@      IF(SMIN .GT. 0  .ACK
)@@G@@ND.  SMIN .LT. 10.) RETURN    @#@@@@      CALL ERROR  @^@@@@      PRINT CL
)@@G@@2250,HORV   @G@@@@ 2250 FORMAT(' ***** PICT1 ERROR.  NUMBER OF STANDARD CM
)@@G@@DEVIATIONS SPECIFI@D@@@@     -ED WITH ',A1,'SCALE MUST BE BETWEEN 0 AND CN
)@@G@@10')  @]@@@@      RETURN@A@@@@ 2300 CALL LOAD3(SPECS(4),SMAX)     @A@@@@CO
)@@G@@      IF(SMIN .NE. SMAX) RETURN     @#@@@@      CALL ERROR  @^@@@@      CP
)@@G@@PRINT 2450,HORV   @G@@@@ 2450 FORMAT(' ***** PICT1 ERROR.  MINIMUM SCALECQ
)@@G@@ VALUE SPECIFIED WITH ',@D@@@@     -   A1,'SCALE IS EQUAL TO THE MAXIMUMCR
)@@G@@ VALUE')    @]@@@@      RETURN@[@@@@C     @[@@@@C     @E@@@@C        LOCCS
)@@G@@AL SUBROUTINE TO GET NEXT MODIFIER OF GROUPS    @[@@@@C     @A@@@@      CT
)@@G@@SUBROUTINE NEXT(TYP,FIELD)    @^@@@@      DIMENSION FIELD(2)@#@@@@      CU
)@@G@@TYP=SCR(L)  @]@@@@      L=L+1 @^@@@@      FIELD(1)=SCR(L)   @^@@@@      CV
)@@G@@FIELD(2)=SCR(L+1) @^@@@@      NMODIF=NMODIF-1   @C@@@@      IF(TYP .LE. CW
)@@G@@0  .OR.  TYP .GT. 5) RETURN   @B@@@@      GO TO (2900,2900,2850,2850,295CX
)@@G@@0),TYP@]@@@@ 2850 L=L+1 @]@@@@ 2900 L=L+1 @]@@@@ 2950 RETURN@]@@@@      CY
)@@G@@END   ___TO 870   @C@@@@*[S@@@*SDFF*@^@@@@      SUBROUTINE S18CCP @ @@@@CZ
)@@G@@      IMPLICIT INTEGER (A-Z)  @A@@@@      DIMENSION  TABLE(13,8), D(9)  DA
)@@G@@@B@@@@CMAXST WILL BE SET TO 150K-10K-ANAL PHASE @ @@@@        DATA MAXSTDB
)@@G@@/100000/    @#@@@@      COMMON IX(2)@^@@@@      INCLUDE CCI,LIST  @B@@@@DC
)@@G@@      DATA((TABLE(I,J),I=1,13),J=1,8)/    @C@@@@     112HINPUT       ,1,DD
)@@G@@0,0,-1,0,0, 1,0,0,1, 0, @C@@@@     212HI/FORMAT    ,2,0,0,-1,0,0, 2,3,0,DE
)@@G@@0,-2, @C@@@@     312HINCHECKS    ,3,0,0, 0,0,0, 3,0,0,0, 0, @C@@@@     4DF
)@@G@@12HVNAMES      ,4,0,0, 0,0,0, 4,0,0,0, 0, @C@@@@     512HTRANSFRM    ,5,DG
)@@G@@0,0, 0,0,0, 5,0,0,0,-1, @C@@@@     612HTITLE       ,6,0,0, 0,0,0, 6,5,0,DH
)@@G@@0, 0, @C@@@@     712HWEIGHT      ,7,0,0, 0,0,0,30,0,0,0, 0, @C@@@@     8DI
)@@G@@12HOUTPUT      ,8,1,0, 0,0,2,38,0,0,0, 0/ @A@@@@      CALL  S1CCFS(TABLEDJ
)@@G@@,8,INFOR,0) @#@@@@      NCERR=0     @#@@@@      IVARS=NVARS @A@@@@      DK
)@@G@@IF(NTVARS.NE.0) IVARS=NTVARS  @]@@@@      NOBS=0@C@@@@      CALL S1GTAG(DL
)@@G@@'NOBS', LNOBS, NWE, NEL, $60) @^@@@@      NOBS = IX(LNOBS)  @D@@@@      DM
)@@G@@IF( NWE .EQ. 2) NOBS = IX(LNOBS+1) - NOBS + 1   @#@@@@2     NOUTS=0     DN
)@@G@@@C@@@@      CALL S1GTAG('NOUTS',NOUTS,DUM,DUM,$4)     @#@@@@      NOUTS=DO
)@@G@@1     @#@@@@      GO TO 25    @[@@@@C     @B@@@@C  SET UP DEFAULT VALUESDP
)@@G@@ - NO OUTPUT CARD @[@@@@C     @#@@@@4     CONTINUE    @C@@@@      CALL SDQ
)@@G@@1GTAG('TEMP',LLOW,NWE,LLIM,$999)    @B@@@@      CALL S1STFT('IXTRA',LXTRDR
)@@G@@A,1,1,$999) @B@@@@      CALL S1STFT('NOUTS',LNOUTS,1,1,$999)@B@@@@      DS
)@@G@@CALL S1STFT('MAX2',LMAX2,1,1,$999)  @B@@@@      CALL S1STFT('MAX3',LMAX3DT
)@@G@@,1,1,$999)  @#@@@@      LBUF=LLOW   @#@@@@      LBF2=LBUF+12@ @@@@      DU
)@@G@@IF(LLIM.LT.13)GO TO 999 @#@@@@      IX(LBUF)=0  @#@@@@      DO 5 I=1,12 DV
)@@G@@@#@@@@      IX(LBUF+I)=0@#@@@@5     CONTINUE    @#@@@@      IWEIT=0     DW
)@@G@@@#@@@@      ALPHA=0     @]@@@@      NUMH=0@B@@@@      CALL S1GVAL('WEIGHDX
)@@G@@T',IWEIT,$10,$10) @B@@@@      CALL S1VLST('DUMMYCW',IWEIT,0,NERR1)@^@@@@DY
)@@G@@      NERR=NERR+NERR1   @^@@@@10    IX(LBUF+3)=IWEIT  @#@@@@      K=NVARDZ
)@@G@@S     @#@@@@      IX(LBUF+4)=K@A@@@@      IF(IWEIT.NE.0)IX(LBUF+4)=K-1  EA
)@@G@@@C@@@@      IF(LLIM.LT.IX(LBUF+4)*2+4+13)GO TO 999    @]@@@@      M=0   EB
)@@G@@@#@@@@      DO 20 L=1,K @A@@@@      IF(IX(LBUF+3).EQ.L)GO TO 19   @^@@@@EC
)@@G@@      IX(LBF2+L+M)=L    @^@@@@      CALL S1CKVI(L,$20)@B@@@@      CALL SED
)@@G@@1GTVT(L,IX(LBF2+L+K+M),$20)   @A@@@@      IF(IX(LBF2+L+K+M).NE.1)ALPHA=1EE
)@@G@@@A@@@@      IF(IX(LBF2+L+K+M).EQ.1)NUMH=1 @B@@@@      CALL S1VLST('DUMMYEF
)@@G@@CW',L,0,NERR1)    @^@@@@      NERR=NERR+NERR1   @#@@@@      GO TO 20    EG
)@@G@@@]@@@@19    M=-1  @#@@@@20    CONTINUE    @ @@@@      KDFLT=MIN(NOBS,100EH
)@@G@@)     @]@@@@      MXIF=0@]@@@@      MXVL=0@^@@@@      LEN2=IX(LBUF+4)*2 EI
)@@G@@@ @@@@      IF(ALPHA.EQ.0)GO TO 22  @^@@@@      IX(LBF2+LEN2+1)=4 @^@@@@EJ
)@@G@@      IX(LBF2+LEN2+2)=1 @^@@@@      IX(LBF2+LEN2+3)=0 @ @@@@      IX(LBFEK
)@@G@@2+LEN2+4)=KDFLT   @#@@@@      IX(LBUF+9)=4@#@@@@      LEN2=LEN2+4 @^@@@@EL
)@@G@@22    IX(LBUF+10 )=1    @^@@@@      IX(LMAX2)=LEN2    @^@@@@      IX(LBUEM
)@@G@@F+12)=LEN2  @#@@@@      IX(LXTRA)=0 @ @@@@      IF(NUMH.EQ.1)IX(LXTRA)=1EN
)@@G@@@#@@@@      IX(LNOUTS)=0@#@@@@      MAX2=LEN2   @]@@@@      LEN3=1@#@@@@EO
)@@G@@      IX(LMAX3)=0 @B@@@@      CALL S1IODR(4,'REWIND',DUM,DUM,DUM) @C@@@@EP
)@@G@@      CALL S1IODR(4,'WRITE',13,IX(LBUF),DUM)    @C@@@@      CALL S1IODR(EQ
)@@G@@4,'WRITE',LEN2,IX(LBF2+1),DUM)@ @@@@      IF(ALPHA.NE.1)GO TO 24  @#@@@@ER
)@@G@@      MXIF=KDFLT  @#@@@@      MXVL=KDFLT  @]@@@@      LEN3=6@#@@@@      ES
)@@G@@MAX3=LEN3   @^@@@@      IX(LMAX3)=MAX3    @#@@@@      IX(LBUF)=6  @#@@@@ET
)@@G@@      IX(LBUF+1)=5@ @@@@      IX(LBUF+2)='DEFAUL'     @ @@@@      IX(LBUEU
)@@G@@F+3)='T: ALP'     @ @@@@      IX(LBUF+4)='HAHIST'     @ @@@@      IX(LBUEV
)@@G@@F+5)='(F)   '     @#@@@@24    CONTINUE    @B@@@@      CALL S1IODR(4,'WRIEW
)@@G@@TE',1,LEN3,DUM)   @ @@@@      IF(LEN3.LE.1)GO TO 25   @C@@@@      CALL SEX
)@@G@@1IODR(4,'WRITE',MAX3,IX(LBUF),DUM)  @#@@@@25    CONTINUE    @ @@@@      EY
)@@G@@CALL S1VLSC(3,MXVARS)   @ @@@@      IF(MXVARS.EQ.0)GO TO 90 @B@@@@      EZ
)@@G@@CALL S1GVAL('IXTRA',IXTRA,$90,$90)  @#@@[@      NEEDW=1     @C@@[@C     FA
)@@G@@     ALWAYS NEED AT LEAST ONE WEIT ARRAY  @##@@@      MV=MXVARS   @#@@@@FB
)@@G@@      MX=IXTRA    @B@@[@C          TAKE OUT FOR ONE WEIT ARRAY    @ [@@@FC
)@@G@@      IAVAIL=MAXST-NOBS*NEEDW @#@@@@      IRECS=0     @F@@@@C          IFD
)@@G@@ MUST BE THE SMALLEST POSITIVE MULTIPLE OF 28>=NOBS   @#@@@@      I=NOBSFE
)@@G@@/28   @]@@@@      I=I*28@ @@@@      IF(NOBS-I.GT.0)I=I+28   @C@@@@C     FF
)@@G@@     AT LEAST ONE OBSERVATION MUST FIT    @ @@@@      IF(I.GT.IAVAIL)GO FG
)@@G@@TO 200@^@@@@C          IS IXTRA=2   @ @@@@      IF(IXTRA.NE.2)GO TO 30  FH
)@@G@@@D@@@@C          YES, TRY FOR INEED=I*(MXVARS+2) NEEDW=2    @#@@@@      FI
)@@G@@NEEDW=2     @C@@@@      IF(I*(MXVARS+2)+NOBS.LE.IAVAIL)GO TO 40   @C@@@@FJ
)@@G@@C          TRY FOR INEED=I*(MXVARS+1) NEEDW=1   @#@@@@      NEEDW=1     FK
)@@G@@@]@@@@      MX=1  @B@@@@      IF(I*(MXVARS+1).LE.IAVAIL)GO TO 40  @B@@@@FL
)@@G@@C          TRY FOR INEED=I*(1+1) NEEDW=2  @B@@@@C          WILL NEED TO FM
)@@G@@STORE ON DRUM     @#@@@@      IRECS=1     @#@@@@      NEEDW=2     @]@@@@FN
)@@G@@      MV=1  @A@@@@      IF(I*2+NOBS.LE.IAVAIL)GO TO 40@A@@@@C          TFO
)@@G@@HEN INEED=I*1 NEEDW=1   @]@@@@      MX=0  @#@@@@      NEEDW=1     @#@@@@FP
)@@G@@      GO TO 40    @E@@@@C          GET HERE ONLY WHEN IXTRA=0,1 (ALPHA,NFQ
)@@G@@UMERIC)     @D@@[@C          TRY FOR INEED=I*(MXVARS+IXTRA) NEEDW=1     FR
)@@G@@@C[@@@30    IF(I*(MXVARS+IXTRA).LE.IAVAIL)GO TO 40    @A@@[@C          TFS
)@@G@@HEN INEED=I*1 NEEDW=1   @B[@@@C          WILL NEED TO STORE ON DRUM     FT
)@@G@@@#@@@@      IRECS=1     @]@@@@      MV=1  @]@@@@      MX=0  @^@@@@40    FU
)@@G@@INEED=I*(MV+MX)   @#@@@@      IXTRA=MX    @]@@@@      IXT=0 @ @@@@      FV
)@@G@@IF(IRECS.EQ.0)IXT=IXTRA @B@@@@      IF(28*(MXVARS+IXT).LE.INEED)GO TO 55FW
)@@G@@@C@@@@      IF(28*(MXVARS+IXT).GT.IAVAIL)GO TO 200    @ @@@@      INEED=FX
)@@G@@28*(MXVARS+IXT)   @#@@@@55    CONTINUE    @B@@@@      CALL S1GTAG('IXTRAFY
)@@G@@',LXTRA,1,1,$999) @^@@@@      IX(LXTRA)=IXTRA   @B@@@@      CALL S1STFT(FZ
)@@G@@'IRECS',LRECS,1,1,$999) @^@@@@      IX(LRECS)=IRECS   @#@@@@      IAVAILGA
)@@G@@=INEED@#@@@@      GO TO 80    @C@@@@60    CALL S1GTAG('STJBIN',LSTJB,DUMGB
)@@G@@,DUM,$70)   @^@@@@      NOBS=IX(LSTJB)    @#@@@@      GO TO 2     @#@@@@GC
)@@G@@70    CONTINUE    @ @@@@      NCCERR = NCCERR + 1     @^@@@@      CALL SGD
)@@G@@1PCHD(2)    @#@@@@      PRINT 9901  @G@@@@9901  FORMAT('0***** UNISTAT2 GE
)@@G@@ERROR. CONTROL WORD NOBS MUST BE PUNCHED O@ @@@@     *N THE INPUT CARD.'GF
)@@G@@)     @#@@@@80    CONTINUE    @ @@@@      IF(NOUTS.EQ.0)GO TO 90  @]@@@@GG
)@@G@@      MAX2=0@B@@@@      CALL S1GVAL('MAX2',MAX2,$90,$90)    @]@@@@      GH
)@@G@@MAX3=0@B@@@@      CALL S1GVAL('MAX3',MAX3,$90,$90)    @B@@@@      CALL SGI
)@@G@@1GVAL('MXIF',MXIF,$90,$90)    @B@@@@      CALL S1GVAL('MXVL',MXVL,$90,$9GJ
)@@G@@0)    @#@@@@90    CONTINUE    @#@@@@      D(1)=IVARS  @#@@@@      D(2)=MGK
)@@G@@XVARS @^@@@@      D(3)=NOBS*NEEDW   @#@@@@      D(4)=13     @#@@@@      GL
)@@G@@D(5)=MAX2   @#@@@@      D(6)=MAX3   @#@@@@      D(7)=IAVAIL @#@@@@      GM
)@@G@@D(8)=MXIF   @#@@@@      D(9)=MXVL   @B@@@@      CALL S1STFT('IAVAIL',LIAGN
)@@G@@V,1,1,$999) @^@@@@      IX(LIAV)=IAVAIL   @B@@@@      CALL S1STFT('MXVARGO
)@@G@@S',LMV,1,1,$999)  @^@@@@      IX(LMV)=MXVARS    @^@@@@      CALL S1STOR(GP
)@@G@@9,D)  @B@@@@      CALL S1IODR(4,'REWIND',DUM,DUM)     @]@@@@      RETURNGQ
)@@G@@@^@@@@200     CALL S1PCHD(2)  @#@@@@        PRINT 9902@G@@@@9902  FORMATGR
)@@G@@('0***** UNISTAT2 ERROR.  NUMBER OF OBSERVATIONS TOO LARGE.'@D@@@@     *GS
)@@G@@/7X,'PROGRAM CANNOT BE RUN WITH THIS DATA SET.')@^@@@@        NCCERR=NCCGT
)@@G@@ERR+1 @#@@@@        GO TO 80  @ @@@@999     CALL S1SERR('S18CCP') @]@@@@GU
)@@G@@      RETURN@]@@@@      END   ___  TRY FOR INEED*[S@@@*SDFF*@C@@@@      GV
)@@G@@SUBROUTINE S1CCFS(TABLE,NTYPE,INFOR,SPCCP)@ @@@@      IMPLICIT INTEGER(AGW
)@@G@@-Z)   @^@@@@      INCLUDE CCI,LIST  @F@@@@        COMMON/S1CNTL/DEMAND,PGX
)@@G@@APERS,LINENO,PAGLEN,CCLIST,RECLST   @A@@@@      DIMENSION TABLE(13,NTYPEGY
)@@G@@)     @[@@@@C     @ @@@@      DIMENSION OCCUR(25)     @[@@@@C     @^@@@@GZ
)@@G@@      DIMENSION ERR(15) @#@@@@      LOGICAL ERR @[@@@@C     @^@@@@      HA
)@@G@@DIMENSION ME(14)  @G@@@@      DATA (ME(I),I=1,14)/1,2,3,4,5,6,7,8,9,10,1HB
)@@G@@1,12,13,14/M1/15/M2/16/ @B@@@@     1M3/17/M4/18/M5/19/M6/20/M7/21/M8/22/HC
)@@G@@@[@@@@C     @^@@@@      DIMENSION CARD(14)@B@@@@        COMMON/S1BANK/STHD
)@@G@@JBAN,CARD,ITYPE   @[@@@@C     @^@@@@        LOGICAL CERR    @^@@@@      HE
)@@G@@LOGICAL COMMA     @^@@@@      LOGICAL NOPROC    @ @@@@      LOGICAL PLUSHF
)@@G@@, LPLUS     @[@@@@C     @^@@@@      DIMENSION NEWID(2)@[@@@@C     @^@@@@HG
)@@G@@      COMMON STOR(2000) @[@@@@C     @ @@@@      DIMENSION CCSPEC(13)    HH
)@@G@@@ @@@@      DIMENSION LASTID(2)     @B@@@@      EQUIVALENCE  (LASTID(1),HI
)@@G@@CCSPEC(1))  @A@@@@      EQUIVALENCE  (ORDER,CCSPEC(3))@A@@@@      EQUIVAHJ
)@@G@@LENCE  (MULTC,CCSPEC(4))@B@@@@      EQUIVALENCE  (MASTER,CCSPEC(5))     HK
)@@G@@@A@@@@      EQUIVALENCE  (USE,CCSPEC(6))  @B@@@@      EQUIVALENCE  (PREDHL
)@@G@@IC,CCSPEC(7))     @A@@@@      EQUIVALENCE  (PRINT,CCSPEC(8))@ @@@@      HM
)@@G@@LOGICAL MULTC,STJBAN    @[@@@@C     @^@@@@C******************     @[@@@@HN
)@@G@@C     @G@@@@C       THIS ROUTINE HANDLES THE FIRST SIXTEEN COLUMNS OF COHO
)@@G@@NTROL CARDS,@G@@@@C       DOING SEQUENCE CHECKING, RUNID CHECKING, AND CHP
)@@G@@ALLS S1CCPD TO    @G@@@@C       CALL PROCESSORS FOR EACH TYPE OF CONTROLHQ
)@@G@@ CARD. THIS ROUTINE IS  @^@@@@C       TABLE DRIVEN    @[@@@@C     @^@@@@HR
)@@G@@C******************     @G@@@@C       S1CCFS     SYMBOL USAGE SUMMARY ALHS
)@@G@@L VAIABLES ARE INTEGERS UNLESS@B@@@@C                  OTHERWISE SPECIFIHT
)@@G@@ED.   @^@@@@C******************     @[@@@@C     @F@@@@C       CARD      HU
)@@G@@ DIMENSIONED (14), IMAGE NOW BEING LOOKED AT.   @G@@@@C       CCI       HV
)@@G@@ FORTRAN PROC WHICH CONTAINS INFORMATION ON COMMON    @ @@@@C           HW
)@@G@@       BLOCK S1CCI@C@@@@C CCLIST =1 IF CONTROL CARDS ARE TO BE LISTED   HX
)@@G@@@E@@@@C       CCNA       FIRST NUMBER OF THE CONTROL CARD OR ZERO @G@@@@HY
)@@G@@C       CCNB       SECOND NUMBER OF THE CONTROL CARD OR -1 IF ERROR     HZ
)@@G@@@B@@@@C                  OR 0 IF NOT PRESENT.   @G@@@@C       CCNUM     IA
)@@G@@ CONTROL CARD NUMBER IF SUCH NUMBERING IS APPLICABLE  @B@@@@C           IB
)@@G@@       AS IN MODEL CARDS.     @G@@@@C       CCSPEC     DIMENSIONED (13),IC
)@@G@@ THE SPECIFICATIONS FROM TABLE FOR  @E@@@@C                  CONTROL CARID
)@@G@@D NOW BEING PROCESSED. EQUIV. @D@@@@C                     CCSPEC (1) = LIE
)@@G@@ASTID (1) - NAME  @D@@@@C                     CCSPEC (2) = LASTID (2) - IF
)@@G@@NAME  @G@@@@C                     CCSPEC (3) = ORDER - NUMBER SPECIFYINGIG
)@@G@@ ORDER THAT @G@@@@C                        CARDS MUST APPEAR IN.CARD CANIH
)@@G@@NOT PRECEED CARD  @C@@@@C                        WITH LOWER NUMBER.     II
)@@G@@@G@@@@C                     CCSPEC (4) = MULTC, =1 IF MULTIPLE CARDS OF IJ
)@@G@@THIS  @E@@@@C                        TYPE, =0 IF ONLY ONE SET ALLOWED.  IK
)@@G@@@G@@@@C                     CCSPEC (5) = MASTER, =N IF THIS CARD HAS SECIL
)@@G@@ONDARY@G@@@@C                        CARDS WHICH ARE THE NEXT CARD THROUIM
)@@G@@GH CARD N IN@D@@@@C                        TABLE. =0 IF NOT MUSTER OF   IN
)@@G@@@G@@@@C                        TABLE. =0 IF NOT MASTER OR SECONDARY, =K,IO
)@@G@@ IF   @G@@@@C                        SECONDARY CARD. MASTER IS IN POSITIIP
)@@G@@ON K OF     @A@@@@C                        THE TABLE. @B@@@@C           IQ
)@@G@@          CCSPEC (6) = USE    @C@@@@C                        = -1, CARD IR
)@@G@@REQUIRED    @B@@@@C                        =0, CARD OPTIONAL@G@@@@C     IS
)@@G@@                   > CARD CONDITIONED ON CARD SPECIFIED IN PREDIC @G@@@@IT
)@@G@@C                        =1 CARD MAY BE USED ONLY IF PREDIC IS USED     IU
)@@G@@@G@@@@C                        =2 CARD MAY BE USED ONLY IF PREDIC IS NOTIV
)@@G@@ USED.@F@@@@C                        =3 CARD MUST BE USED IF PREDIC IS UIW
)@@G@@SED   @F@@@@C                        =4 CARD MUST BE USED IF PREDK IS NOIX
)@@G@@T USED@G@@@@C                        =5 CARD MUST BE USED IF PREDIC IS NIY
)@@G@@OT USED.    @B@@@@C                  CCSPEC (7) = PREDIC    @G@@@@C     IZ
)@@G@@                   AN INTEGER >0 POINTER TO ANOTHER CARD IN THE   @E@@@@JA
)@@G@@C                        TABLE IS >0, IGNORED OTHERWISE     @G@@@@C     JB
)@@G@@                CCSPEC (8) = PRINT, =0 IF NO SPECIAL SKIP, =1 IF  @G@@@@JC
)@@G@@C                        SPECIAL SKIP, =2 IF SPECIAL SKIP ONLY FIRST    JD
)@@G@@@B@@@@C                        TIME CARD PRINTED@G@@@@C                 JE
)@@G@@    CCSPEC (9) IS PROSSOR NUMBER TO BE USED FOR THE   @ @@@@C           JF
)@@G@@             CARD @G@@@@C                     CCSPEC (10 TO 12) IS SPECIJG
)@@G@@AL INFORMATION TO BE    @E@@@@C                        USED BY THE PROCEJH
)@@G@@SSOR OF THE CARD. @F@@@@C                     CCSPEC (13) IS WHETHER A TJI
)@@G@@ERMINAL PROCESSOR @G@@@@C                        EXISTS FOR THIS CARD. =JJ
)@@G@@0 NONE, = POSITIVE,     @G@@@@C                        CALL ALWAYS, = NEJK
)@@G@@GATIVE, CALL ONLY IF THE CARD @A@@@@C                        IS FOUND   JL
)@@G@@@G@@@@C       CERR       LOGICAL, TRUE IF ERROR IN READING CARD FROM S1RJM
)@@G@@EAD.  @G@@@@C       CH         TEMPORARY VARIABLE FOR MOVING DATA SET LAJN
)@@G@@BEL INTO    @ @@@@C                  'DSL'.     @F@@@@C       CHAR      JO
)@@G@@ TEMPORARY VARIABLE TO HOLD RETRIEVED CHARACTER.@G@@@@C       COMMA     JP
)@@G@@ LOGICAL, TRUE IF COMMA OCCURRED IN THE SEQUENCE FIELD@G@@@@C       COP JQ
)@@G@@       IN COMMON BLOCK S1CCI - =1 IF COP ON INPUT CARD ,    @A@@@@C     JR
)@@G@@             =0 OTHERWISE.    @G@@@@C       DEMAND     IN COMMON BLOCK SJS
)@@G@@1CNTL, =4 IF DEMAND, =6 IF BATCH.   @F@@@@C       EPA        POINTER TO JT
)@@G@@MASTER CARD FOR THIS SECONDARY CARD.@F@@@@C       EPB        POINTER TO JU
)@@G@@MASTER CARD THAT PREVIOUSLY OCCURED.@G@@@@C       EPC        POINTER TO JV
)@@G@@CARD THAT THIS CARD IS USED WITH (OR MAY  @B@@@@C                  NOT BJW
)@@G@@E USED WITH, ETC).@F@@@@C       ERR        LOGICAL, DIMENSIONED (15), IFJX
)@@G@@ TRUE, THAT ERROR @ @@@@C                  OCCURED    @D@@@@C           JY
)@@G@@          ERR (1) = * MISSING FROM 16     @F@@@@C                     ERJZ
)@@G@@R (2) = RUN ID DIFFERS FROM PREVIOUS CARD @D@@@@C                     ERKA
)@@G@@R (3) = ILLEGAL SYMBOL IN 6-15@E@@@@C                     ERR (4) = ILLEKB
)@@G@@GAL CONTROL CARD TYPE   @F@@@@C                     ERR (5) = CAR TYPE PKC
)@@G@@REVIOUSLY PROCESSED     @F@@@@C                     ERR (6) = CARD TYPE KD
)@@G@@PREVIOUSLY PROCESSED    @E@@@@C                     ERR (7) = INVALID COKE
)@@G@@NTINUATION NUMBER @E@@@@C                     ERR (8) = CONTROL CARD NUMKF
)@@G@@BER ERROR   @F@@@@C                     ERR (9) = INCORRECT CONTINUATIONKG
)@@G@@ NUMBER     @G@@@@C                     ERR (10) = CARD TYPE ALREADY PROKH
)@@G@@CESSED SINCE LAST @A@@@@C                     --- CARD.     @F@@@@C     KI
)@@G@@                ERR (11) = CARD TYPE MUST FOLLOW --- CARD   @F@@@@C     KJ
)@@G@@                ERR (12) = CONTROL CARD NUMBER DOESNOT MATCH@C@@@@C     KK
)@@G@@                THAT ON LAST --- CARD     @G@@@@C                     ERKL
)@@G@@R (13) = CARD TYPE MAY BE USED ONLY IF --- CARD @B@@@@C                 KM
)@@G@@    IS PREVIOUSLY USED. @G@@@@C                     ERR (14) = CARD TYPEKN
)@@G@@ MAY BE USED ONLY IF --- CARD @C@@@@C                     IS NOT PREVIOUKO
)@@G@@SLY USED.   @E@@@@C       ERRA       ERROR COUNTER FOR INCREMENTING NCCEKP
)@@G@@RR.   @F@@@@C       FW         FIRST WORD OF TAG BEING CREATED OR RETRIEKQ
)@@G@@VED.  @B@@@@C       I          TEMPORARY VARIABLE.    @G@@@@C       INFOKR
)@@G@@R      FORMAL PARAMETER, CONTAINS ADDITIONAL INFORMATION FOR@F@@@@C     KS
)@@G@@             INPUT CARD PROCESSOR, CONSISTING OF ADDITIONAL @E@@@@C     KT
)@@G@@             CONTROL WORDS TO ALLOW ON THE INPUT CARD.@G@@@@C       ITP KU
)@@G@@       TYPE OF FIELD AS RETURNED BY S1GTFD. =1 MEANS NUMBER @ @@@@C     KV
)@@G@@             WAS FOUND. @D@@@@C       ITYPE      TYPE OF CARD FOUND BY SKW
)@@G@@1READ =0    @ @@@@C                     = 0     @ @@@@C                 KX
)@@G@@    = 1'S   @B@@@@C                     = 2 IS RUN CARD     @C@@@@C     KY
)@@G@@                = 3 IS BEGINDATA CARD     @D@@@@C                     = KZ
)@@G@@ANYTHING ELSE IS ILLEGAL.     @B@@@@C       J          TEMPORARY VARIABLLA
)@@G@@E.    @B@@@@C       KEMP       TEMPORARY VARIABLE.    @B@@@@C       KEMPLB
)@@G@@2      TEMPORARY VARIABLE.    @E@@@@C       LASTCC     FIRST WORD OF NAMLC
)@@G@@E OF LAST CONTROL CARD. @G@@@@C       LASTID     DIMENSIONED (2), EQUIV.LD
)@@G@@ CCSPEC(1), NAME OF CONTROL   @^@@@@C                  CARD.@G@@@@C     LE
)@@G@@  LASTN      LAST SEQUENCE NUMBER, = 0 MEANS ANYTHING ALLOWED,    @G@@@@LF
)@@G@@C                  =-2 IS LAST WAS INVALID, =-1 IS INCORRECT. =POSITIVE LG
)@@G@@@A@@@@C                  IS ACTUAL NUMBER.@G@@@@C       LB         POINTLH
)@@G@@ER TO PLACE TO PUT NEXT CARD IMAGE'S TEST TO    @B@@@@C                 LI
)@@G@@ PASS TO PROCESSOR.     @[@@@@C     @G@@@@C       LCCN       NUMBER OF TLJ
)@@G@@HIS CARD WHEN IT HAS A ID NUMBER, ZERO IF @E@@@@C                  NO IDLK
)@@G@@ NUMBER, -1 IF ID NUMBER INVALID.   @G@@@@C       LCH        POINTER TO LL
)@@G@@LECATION TO PUT NEXT INFORMATION FIELD    @B@@@@C                  INTO,LM
)@@G@@ IN CHARACTERS.   @D@@@@C LINENO NUMBER OF LINES FROM TOP OF PAGE ON ENTLN
)@@G@@RY.   @F@@@@C       LLIM       LENGTH OF TAG 'TEMP' WHICH IS USED FOR SCLO
)@@G@@RATCH @F@@@@C                  SPACE AND WHICH IS ALWAYS THE FIRST TAG. LP
)@@G@@IT IS @F@@@@C                  CREATED BY S1GTST IN CONSTANTS AT COMPILELQ
)@@G@@ TIME.@E@@@@C       LLL        CHARACTER POINTER, TEMPORARY VARIABLE.   LR
)@@G@@@E@@@@C       LLOW       POINTER TO FIRST WORD OF TAG 'TEMP'.     @G@@@@LS
)@@G@@C       LORDER     ORDER NUMBER OF LAST CARD OR ZERO IF NO LAST CARD.   LT
)@@G@@@F@@@@C       LPLUS      LOGICAL, TRUE IF LAST CARD HAS A + FOR SEQUENCELU
)@@G@@@ @@@@C                  NUMBER.    @B@@@@C       LSTRUN     RUNID FROM LV
)@@G@@LAST CARD.  @F@@@@C       MASTCN     NUMBER IN TABLE OF LAST MASTER CONTLW
)@@G@@ROL CARD.   @G@@@@C       MASTER     EQUIV. CCSPEC (5), NUMBER IN TABLE LX
)@@G@@OF THIS CARD'S    @ @@@@C                  MASTER.    @F@@@@C       MASTLY
)@@G@@IN     NUMBER IN TABLE OF MASTER CURRENTLY IN USE     @F@@@@C       NASTLZ
)@@G@@LS     NUMBER IN TABLE OF LAST SECONDARY CARD FOR THIS@ @@@@C           MA
)@@G@@       MASTER     @G@@@@C       ME         DIMENSIONED (14), SET TO 1-14MB
)@@G@@ BY A DATA STATEMENT,   @G@@@@C                  PASSED TO S1MSG1 AS ERRMC
)@@G@@OR MESSAGE NUMBERS PAIRED     @ @@@@C                  WITH ERR.  @G@@@@MD
)@@G@@C       MULTC      LOGICAL, EQUIV CCSPEC (4), TRUE IF MULTIPLE COPIES   ME
)@@G@@@G@@@@C                  OF THE CARD ARE LEGAL AND THE CARD HAS ID NUMBEMF
)@@G@@RS.   @B@@@@C       M1         = 15, PASSED TO S1MSG1.@B@@@@C       M2  MG
)@@G@@       = 16, PASSED TO S1MSG1.@B@@@@C       M3         = 17, PASSED TO SMH
)@@G@@1MSG1.@B@@@@C       M4         = 18, PASSED TO S1MSG1.@B@@@@C       M5  MI
)@@G@@       = 19, PASSED TO S1MSG1.@B@@@@C       M6         = 20, PASSED TO SMJ
)@@G@@1MSG1.@B@@@@C       M7         = 21, PASSED TO S1MSG1.@B@@@@C       M8  MK
)@@G@@       = 22, PASSED TO S1MSG1.@D@@@@C       NCARD      NUMBER OF CARDS OML
)@@G@@F THIS TYPE FOUND.@F@@@@C       NCCERR     IN COMMON BLOCK S1CCI, NUMBERMM
)@@G@@ OF CONTROL CARD  @ @@@@C                  ERRORS.    @E@@@@C       NEWIMN
)@@G@@D      DIMENSIONED (2), NAME FROM CURRENT CARD. @E@@@@C       NOPROC    MO
)@@G@@ LOGICAL, IF TRUE DON'T PROCESS THIS CARD.@G@@@@C       NTYPE      FORMAMP
)@@G@@L PARAMETER, NUMBER O DIFFERENT CARD TYPES IN   @ @@@@C                 MQ
)@@G@@ TABLE.     @C@@@@C       NUNID      NUMBER OF UNIDENTIFIED CARDS.@G@@@@MR
)@@G@@C       OCCUR      DIMENSIONED (25), ONE ELEMENT FOR EACH CARD TYPE,    MS
)@@G@@@G@@@@C                  = 0 UNLESS CARD TYPE HAS OCCURRED ALREADY, THENMT
)@@G@@ = 1. @F@@@@C       ORDER      EQUIV. CCSPEC (3), NUMBER TO PLACE THIS CMU
)@@G@@ARD IN@G@@@@C                  ORDER, NO HIGHER NUMBERD CARDS MAY PRECEEMV
)@@G@@D THIS CARD.@E@@@@C PAGLEN NUMBER OF LINES PER PAGE INCLUDING TOP MARGINMW
)@@G@@.     @C@@@@C PAPERS =1 IF SUPER PAPER SAVING MODE IS ON.   @E@@@@C     MX
)@@G@@  PLUS       LOGICAL, TRUE IF PLUS SIGN ON THIS CARD. @G@@@@C       PLUSMY
)@@G@@CL      COLUMN NUMBER IN WHICH WE FOUND PLUS ON CARD, TO    @A@@@@C     MZ
)@@G@@              REINSERT IT.    @F@@@@C       PREDIC     EQUIV. CCSPEC (7)NA
)@@G@@, POINTER TO CARD TYPE THIS IS@D@@@@C                  SEPENDENT ON AS SNB
)@@G@@PECIFIED BY USE.  @G@@@@C       PRINT      EQUIV CCSPEC (8), IF IT IS = NC
)@@G@@1 SKIP AN EXTRA LINE.   @G@@@@C                  IF IT = 2 AND OCCURRED ND
)@@G@@BEFORE, SKIP AN EXTRA LINE.   @D@@@@C RECLST =1 IF RECORD SUMMARIES ARE NE
)@@G@@TO BE LISTED.     @F@@@@C       RUNA       FIRST CHARACTER OF RUNID OR BNF
)@@G@@LANK IF WAS ZERO. @C@@@@C       RUNAF      FIRST CHARACTER OF RUNID     NG
)@@G@@@C@@@@C       RUNB       SECOND CHARACTER OF RUNID    @G@@@@C       SPCCNH
)@@G@@P      FORMAL PARAMETER, PASSED TO S1CCPD AND S1CCPT TO     @G@@@@C     NI
)@@G@@             BE CALLED FOR PROCESSOR 10 FOR DEBUGGING BUT S1CCPD  @C@@@@NJ
)@@G@@C                  AND S1CCPT DON'T CALL THEM.  @ @@@@C STJBAN TRUE IF SNK
)@@G@@TJBANK INPUT@B@@@@C       STOR       BLANK COMMON ARRAY.    @F@@@@C     NL
)@@G@@  S1BACK     ROUTINE IN S1SCAN THAT RESETS POINTER TO THE   @E@@@@C     NM
)@@G@@             CHARACTER STRING TO A SPECIFIED COLUMN.  @C@@@@C S1BANK COMNN
)@@G@@MON BLOCK FOR STJBANK PARAMETERS.   @G@@@@C       S1BUF      ROUTINE IN NO
)@@G@@S1SCAN THAT INITIALIZES WITH A NEW IMAGE  @A@@@@C                  TO BENP
)@@G@@ SCANNED.   @G@@@@C       S1CADD     ROUTINE IN S1STCH THAT APPENDS A CHNQ
)@@G@@ARACTER TO THE    @B@@@@C                  STRING BEING BUILT.    @G@@@@NR
)@@G@@C       S1CBUF -   ROUTINE IN S1STCH TO PASS THE BUFFER TO BE FILLED ANDNS
)@@G@@@E@@@@C                  TO INITIALIZE THE ACCUMULATION OF SYMBOL.@G@@@@NT
)@@G@@C       S1CCPD     ROUTINE THAT CALLS ALL THE NORMAL CARD HANDLERS.     NU
)@@G@@@G@@@@C       S1CCPT     ROUTINE THAT CALLS THE TERMINAL CARD PROCESSORSNV
)@@G@@.     @D@@@@C       S1CHPT     RETURNS POINTER TO S1STCH BUFFER   @G@@@@NW
)@@G@@C       S1CLIM     ROUTINE THAT SETS A LIMIT ON THE SIZE OF FIELD THAT  NX
)@@G@@@D@@@@C                  S1GTFD MAY ACCUMULATE. IN S1GTFD.  @F@@@@C     NY
)@@G@@  S1CNTL     COMMON BLOCKHOLDING SYSTEM CONTROL INFORMATION.@G@@@@C     NZ
)@@G@@  S1GTAG     ROUTINE THAT RETRIEVES POINTERS TO A TAG'S STORAGE.  @D@@@@OA
)@@G@@C       S1GTFD     ROUTINE THAT ACCUMULATES A FIELD.  @D@@@@C       S1MSOB
)@@G@@G1     ROUTINE WHICH PRINTS ERROR MESSAGES@F@@@@C       S1OFST     ROUTIOC
)@@G@@NE IN S1SCAN TO SKIP CHARACTERS AT THE    @C@@@@C                  BEGINOD
)@@G@@NING OF THE BUFFER.     @G@@@@C       S1PRFT     ROUTINE IN S1PRIM TO FEOE
)@@G@@TCH ONE CHARACTER FROM AN     @ @@@@C                  ARRAY.     @F@@@@OF
)@@G@@C       S1PRNT     ROUTINE IN S1READ TO PRINT THE LAST CARD READ. @D@@@@OG
)@@G@@C       S1PRSK     ROUTINE IN S1READ TO SKIP ONE LINE.@G@@@@C       S1PROH
)@@G@@ST     ROUTINE IN S1PRIM TO STORE ONE CHARACTER INTO AN     @ @@@@C     OI
)@@G@@             ARRAY.     @D@@@@C       S1READ     ROUTINE TO READ ONE CONOJ
)@@G@@TROL CARD.  @F@@@@C       S1SCAN     ROUTINE TO RETURN NEXT CHARACTER INOK
)@@G@@ THE STREAM.@F@@@@C       S1SERR     ROUTINE TO PRINT STATJOB SYSTEM ERROL
)@@G@@OR IN ------@A@@@@C                  ROUTINE MESSAGE. @E@@@@C       S1SPOM
)@@G@@CT     FUNCTION TO ASCERTAIN TYPE OF CHARACTER. @C@@@@C       S1STFT    ON
)@@G@@ ROUTINE TO CREATE A TAG.     @D@@@@C       S1VLU      FIND NUMERIC VALUOO
)@@G@@E OF A STRING.    @G@@@@C       TABLE      FORMAL PARAMETER, DIMENSIONEDOP
)@@G@@ (13,NTYPE), CONTAINS   @F@@@@C                  THE SPECIFICATIONS FOR OQ
)@@G@@LEGAL CONTROL CARDS. SEE@D@@@@C                  CCSPEC FOR DETAIL DESCROR
)@@G@@IPTIONS.    @E@@@@C       TRANS1     IF PROGRAM IS TRANS1, = 1, OTHERWISOS
)@@G@@E = 0.@F@@@@C       USE        EQUIV. CCSPEC (6), THE LEGAL USE SPECIFICOT
)@@G@@ATION.@B@@@@C                  SEE CCSPEC FOR DETAILS.@[@@@@C     @^@@@@OU
)@@G@@C******************     @[@@@@C     @B@@@@C       S1CCFS     TAGGED STOROV
)@@G@@AGE SUMMARY @[@@@@C     @^@@@@C******************     @[@@@@C     @G@@@@OW
)@@G@@C       'TEMP'     IS RETRIEVED TO GET 5000 WORDS OF SCRATCH ARRAY.     OX
)@@G@@@E@@@@C                  'TEMP' IS CREATED BY CONSTANTS IN S1GTST.@F@@@@OY
)@@G@@C       'PROGNM'   IS RETRIEVED TO ASCERTAIN WHETHER THIS PROGRAM @ @@@@OZ
)@@G@@C                  IS TRANS1. @G@@@@C       'RUNID'    IS CREATED WITH TPA
)@@G@@HE TWO-CHARACTER RUNID ON THESE     @ @@@@C                  CARDS.     PB
)@@G@@@G@@@@C       'DSL'      IS CREATED WITH COLUMNS 17-80 OF THE BEGINDATA PC
)@@G@@CARD. @[@@@@C     @^@@@@C******************     @[@@@@C     @ @@@@C     PD
)@@G@@        INITIALIZATION  @[@@@@C     @^@@@@       DO 105 J=1,NTYPE @#@@@@PE
)@@G@@ 105  OCCUR(J)=0  @^@@@@        STJBAN=.FALSE.  @#@@@@      NCARD=0     PF
)@@G@@@]@@@@      LCH=1 @]@@@@      ERRA=0@#@@@@      LSTRUN=0    @#@@@@      PG
)@@G@@LASTN=0     @#@@@@      LORDER=0    @^@@@@        LASTID(1)=0     @^@@@@PH
)@@G@@        LASTID(2)=0     @#@@@@      MASTIN=0    @#@@@@      LASTCC=0    PI
)@@G@@@^@@@@      PLUS = .FALSE.    @C@@@@C                            GET BUFPJ
)@@G@@FER STORAGE @C@@@@      CALL S1GTAG(4HTEMP,LLOW,1,LLIM,$9999)     @[@@@@PK
)@@G@@C     @ @@@@C             READ NEXT CARD  @[@@@@C     @#@@@@ 200  NUNID=PL
)@@G@@0     @^@@@@      DO 205 J=1,15     @^@@@@ 205  ERR(J)=.FALSE.    @#@@@@PM
)@@G@@      LPLUS = PLUS@^@@@@      PLUS = .FALSE.    @[@@@@C     @A@@@@ 210  PN
)@@G@@CALL S1READ(CARD,ITYPE,CERR)  @A@@@@      IF(ITYPE .EQ. 1) CERR=.FALSE. PO
)@@G@@@A@@@@      IF(ITYPE .EQ. 2) GO TO 300    @A@@@@      IF(ITYPE .NE. 0) GPP
)@@G@@O TO 900    @A@@@@      IF(NUNID .EQ. 0) CALL S1PRSK  @#@@@@      CALL SPQ
)@@G@@1PRNT @[@@@@C     @B@@@@C       THIS CARD CANNOT BE IDENTIFIED.   @[@@@@PR
)@@G@@C     @ @@@@      CALL S1MSG1(M1,0,0,0,0) @#@@@@      ERRA=ERRA+1 @ @@@@PS
)@@G@@      IF(CERR) ERRA=ERRA+1    @^@@@@      NUNID=NUNID+1     @A@@@@      PT
)@@G@@IF(NUNID .LT. 10) GO TO 210   @[@@@@C     @C@@@@C       TEN CONSECUTIVE PU
)@@G@@UNIDENTIFIED CARDS ...  @[@@@@C     @ @@@@      CALL S1MSG1(M2,0,0,0,0) PV
)@@G@@@#@@@@      GO TO 900   @[@@@@C     @F@@@@C             DECODE FIRST 16 PW
)@@G@@COLUMNS - MAKE PRELIMINARY CHECKS   @[@@@@C     @E@@@@C-FIRST REPLACE ANPX
)@@G@@Y PLUS CONTINUATION NUMBERS WITH A ZERO   @[@@@@C     @ @@@@300   DO 302PY
)@@G@@  J = 15,1,-1     @A@@@@      CALL S1PRFT( CARD, J, CHAR)   @A@@@@      PZ
)@@G@@IF( CHAR .EQ. 1H ) GO TO 302  @A@@@@      IF( CHAR .NE. 1H+) GO TO 304  QA
)@@G@@@A@@@@      CALL S1PRST( CARD, J, 1H )    @^@@@@      PLUS = .TRUE.     QB
)@@G@@@#@@@@        PLUSCL=J  @#@@@@      GO TO 304   @#@@@@302   CONTINUE    QC
)@@G@@@ @@@@304   CALL S1BUF( CARD, 15, 0)@ @@@@      CALL S1OFST(3,$9999)    QD
)@@G@@@B@@@@C                            CHECK RUNID  @ @@@@      CALL S1SCAN(QE
)@@G@@RUNA,$9999) @#@@@@      RUNAF = RUNA@ @@@@      CALL S1SCAN(RUNB,$9999) QF
)@@G@@@ @@@@      CALL S1CBUF(KEMP,6)     @D@@@@      IF (RUNA.EQ.1H0.AND.S1SPQG
)@@G@@CT(RUNB).EQ.2) RUNA=1H  @ @@@@      CALL S1CADD(RUNA,$9999) @ @@@@      QH
)@@G@@CALL S1CADD(RUNB,$9999) @A@@@@      IF(LSTRUN .EQ. 0) GO TO 310   @B@@@@QI
)@@G@@      IF(LSTRUN .NE. KEMP) ERR(2)=.TRUE.  @#@@@@      GO TO 312   @B@@@@QJ
)@@G@@310   CALL S1STFT(5HRUNID,FW,1,1,$9999)   @A@@@@      CALL S1CBUF( STOR(QK
)@@G@@FW), 6)     @A@@@@      CALL S1CADD( RUNAF, $9999)    @A@@@@      CALL SQL
)@@G@@1CADD( RUNB, $9999)     @#@@@@312   LSTRUN=KEMP @D@@@@C                 QM
)@@G@@           CHECK * IN COLUMN 16     @]@@@@      CHAR=0@A@@@@      CALL SQN
)@@G@@1PRFT(CARD,16,CHAR)     @C@@@@      IF(S1SPCT(CHAR) .NE. 8) ERR(1)=.TRUEQO
)@@G@@.     @B@@@@C                            GET CARD TYPE@ @@@@      CALL SQP
)@@G@@1CBUF(NEWID,8)    @^@@@@      DO 320 J=6,15     @ @@@@      CALL S1SCAN(QQ
)@@G@@CHAR,$9999) @^@@@@      KEMP=S1SPCT(CHAR) @A@@@@      IF(KEMP .EQ. 3) GOQR
)@@G@@ TO 320     @D@@@@      IF(KEMP .NE. 1  .AND.  KEMP .NE. 9) GO TO 330   QS
)@@G@@@ @@@@      CALL S1CADD(CHAR,$325)  @#@@@@ 320  CONTINUE    @^@@@@      QT
)@@G@@CALL S1CHPT(KEMP) @A@@@@      IF(KEMP .NE. 0) GO TO 335     @^@@@@ 325  QU
)@@G@@ERR(3)=.TRUE.     @#@@@@      GO TO 800   @^@@@@ 330  CALL S1CHPT(KEMP2)QV
)@@G@@@A@@@@      IF(KEMP2 .EQ. 0) GO TO 325    @A@@@@      IF(KEMP .EQ. 2) GOQW
)@@G@@ TO 350     @^@@@@      ERR(3)=.TRUE.     @#@@@@      GO TO 335   @^@@@@QX
)@@G@@ 332  ERR(7)=.TRUE.     @]@@@@ 335  CCNA=0@^@@@@ 340  COMMA=.FALSE.     QY
)@@G@@@#@@@@      GO TO 400   @E@@@@C                            GET CONTINUATQZ
)@@G@@ION NUMBER, ETC   @^@@@@ 350  CALL S1WHR(KEMP)  @A@@@@      CALL S1BACK(RA
)@@G@@KEMP-1,$9999)     @D@@@@      CALL S1GTFD(3HNUM,KEMP,0,ITP,CHAR,KEMP2,$9RB
)@@G@@999)  @A@@@@      CALL S1VLU(KEMP,KEMP2,CCNA)   @A@@@@      IF(CHAR .EQ.RC
)@@G@@ 0) GO TO 340     @A@@@@      IF(CHAR .NE. 1H,) GO TO 332   @^@@@@      RD
)@@G@@COMMA= .TRUE.     @D@@@@      CALL S1GTFD(3HNUM,KEMP,0,ITP,CHAR,KEMP2,$3RE
)@@G@@60)   @D@@@@      IF(ITP .EQ. 1  .AND. CHAR .EQ. 0) GO TO 370     @#@@@@RF
)@@G@@      CCNB=-1     @#@@@@      GO TO 400   @]@@@@ 360  CCNB=0@#@@@@      RG
)@@G@@GO TO 400   @A@@@@ 370  CALL S1VLU(KEMP,KEMP2,CCNB)   @[@@@@C     @ @@@@RH
)@@G@@C             CHECK CARD TYPE @[@@@@C     @F@@@@ 400  IF(NEWID(1) .NE. 'RI
)@@G@@VLABEL'  .AND.  NEWID(1) .NE. 'VARLAB')   @#@@@@     -   GO TO 410@^@@@@RJ
)@@G@@      NEWID(1)='VLABEL' @^@@@@      NEWID(2)='      ' @C@@@@ 410  IF(NEWRK
)@@G@@ID(1) .NE. LASTID(1)) GO TO 420     @C@@@@      IF(NEWID(2) .NE. LASTID(RL
)@@G@@2)) GO TO 420     @A@@@@      IF( .NOT. MULTC) GO TO 700    @ @@@@      RM
)@@G@@IF(ERR(7)) GO TO 700    @A@@@@      IF(CCNA .EQ. LCCN) GO TO 700  @#@@@@RN
)@@G@@      GO TO 500   @^@@@@420   DO 430 I=1,NTYPE  @C@@@@        IF(NEWID(1RO
)@@G@@).NE.TABLE(1,I))GO TO 430     @C@@@@      IF(NEWID(2) .EQ.  TABLE(2,I)) RP
)@@G@@GO TO 500   @#@@@@ 430  CONTINUE    @G@@@@        IF(NEWID(1).EQ.'COMMENRQ
)@@G@@' .AND. (NEWID(2).EQ.'TS' .OR. NEWID(2)   @ @@@@     1  .EQ. 'T'))GO TO RR
)@@G@@800   @^@@@@      ERR(4)= .TRUE.    @#@@@@      GO TO 800   @[@@@@C     RS
)@@G@@@A@@@@C             PROCESS CARD IN BUFFER@[@@@@C     @C@@@@C           RT
)@@G@@  SEE ALSO STATEMENTS 750, ETC.     @C@@@@ 500  IF(NCARD .EQ. 0  .OR.  NRU
)@@G@@OPROC) GO TO 550  @^@@@@      LLL=6*(LB-LLOW)   @^@@@@      DO 505 J=LCHRV
)@@G@@,LLL  @A@@@@505   CALL S1PRST(STOR(LLOW),J,1H ) @G@@@@      CALL S1CCPD(RW
)@@G@@STOR(LLOW),NCARD,CCSPEC,LCCN,INFOR,SPCCP,STOR(LB),    @^@@@@     *LLOW+LRX
)@@G@@LIM-LB)     @]@@@@      LCH=1 @^@@@@      CALL S1CLIM(12)   @[@@@@C     RY
)@@G@@@#@@@@ 550  NCARD=0     @#@@@@      LASTN=0     @^@@@@      LPLUS = .FALRZ
)@@G@@SE.   @#@@@@      LB=LLOW     @^@@@@      NOPROC=.FALSE.    @[@@@@C     SA
)@@G@@@B@@@@C             CHECK USAGE OF NEW CARD TYPE@[@@@@C     @^@@@@      SB
)@@G@@DO 605 J=1,13     @ @@@@ 605  CCSPEC(J)=TABLE(J,I)    @D@@@@C           SC
)@@G@@                 CHECK ALREADY PROCESSED  @C@@@@      IF(OCCUR(I) .EQ. 0SD
)@@G@@  .OR.  MULTC) GO TO 610@^@@@@      ERR(5)= .TRUE.    @#@@@@      GO TO SE
)@@G@@699   @C@@@@C                            CHECK OUT OF ORDER @B@@@@ 610  SF
)@@G@@IF(LORDER .LE. ORDER) GO TO 615     @^@@@@      ERR(6)=.TRUE.     @#@@@@SG
)@@G@@ 615  LORDER=ORDER@ @@@@      OCCUR(I)=OCCUR(I)+1     @D@@@@C           SH
)@@G@@                 GET CONTROL CARD NUMBER  @A@@@@      IF( .NOT. MULTC) GSI
)@@G@@O TO 620    @#@@@@      CCNUM=CCNA  @ @@@@      IF(ERR(7)) CCNUM=-1     SJ
)@@G@@@A@@@@ 620  IF(MASTER .GE. 0) GO TO 640   @C@@@@C                       SK
)@@G@@     SECONDARY CARD     @#@@@@      EPA=-MASTER @A@@@@      IF(EPA .EQ. SL
)@@G@@MASTIN) GO TO 625 @^@@@@      ERR(11)= .TRUE.   @^@@@@      NOPROC=.TRUESM
)@@G@@.     @#@@@@      GO TO 640   @A@@@@ 625  IF(OCCUR(I) .EQ. 1) GO TO 630 SN
)@@G@@@^@@@@      ERR(10)= .TRUE.   @#@@@@      GO TO 699   @B@@@@ 630  IF(CCNSO
)@@G@@UM .EQ. MASTCN) GO TO 700     @^@@@@      ERR(12)= .TRUE.   @#@@@@      SP
)@@G@@GO TO 700   @F@@@@C                            CHECK USAGE OF PRIOR MASTSQ
)@@G@@ER CARD     @A@@@@ 640  IF(MASTIN .EQ. 0) GO TO 650   @^@@@@      KEMP=MSR
)@@G@@ASTIN+1     @ @@@@      DO 645 J=KEMP,MASTLS    @E@@@@      IF(OCCUR(J) SS
)@@G@@.NE. 0  .OR.  TABLE(6,J) .EQ. 0) GO TO 645@^@@@@      ERR(15)= .TRUE.   ST
)@@G@@@#@@@@      EPB=MASTIN  @#@@@@ 645  CONTINUE    @ @@@@ 650  IF(MASTER)70SU
)@@G@@0,670,660   @D@@@@C                            MASTER CARD - SET FLAGS  SV
)@@G@@@#@@@@ 660  MASTIN=I    @^@@@@      MASTLS=MASTER     @#@@@@      MASTCNSW
)@@G@@=CCNUM@#@@@@      KEMP=I+1    @ @@@@      DO 665 J=KEMP,MASTER    @#@@@@SX
)@@G@@ 665  OCCUR(J)=0  @#@@@@      GO TO 700   @E@@@@C                       SY
)@@G@@     NOT MASTER OR SECONDARY CARD   @#@@@@ 670  MASTIN=0    @ @@@@      SZ
)@@G@@IF(USE .LE. 0) GO TO 700@#@@@@      EPC=PREDIC  @ @@@@      KEMP= OCCUR(TA
)@@G@@PREDIC)     @B@@@@      GO TO (675,680,700,700,680), USE    @A@@@@ 675  TB
)@@G@@IF(KEMP .NE. 0) GO TO 700     @^@@@@      ERR(13)= .TRUE.   @#@@@@      TC
)@@G@@GO TO 699   @A@@@@ 680  IF(KEMP .EQ. 0) GO TO 700     @^@@@@      ERR(14TD
)@@G@@)=.TRUE.    @[@@@@C     @^@@@@ 699  NOPROC= .TRUE.    @[@@@@C     @D@@@@TE
)@@G@@C             FINISH CHECKING CARD - SAVE INFO FIELD  @[@@@@C     @ @@@@TF
)@@G@@ 700  IF(MULTC) GO TO 705     @]@@@@      LCCN=0@ @@@@      IF(COMMA) ERTG
)@@G@@R(7)=.TRUE. @#@@@@      GO TO 720   @D@@@@C                            CTH
)@@G@@HECK CONTROL CARD NUMBER@ @@@@ 705  IF(ERR(7)) GO TO 710    @#@@@@      TI
)@@G@@LCCN=CCNA   @C@@@@        IF(LCCN.NE.0.OR.NCARD.NE.0) GO TO 707   @^@@@@TJ
)@@G@@        CALL S1PCHD(1)  @A@@@@        PRINT 706,NEWID(1),NEWID(2) @G@@@@TK
)@@G@@706     FORMAT(' ***** WARNING: MISSING ',A6,A2,' NUMBER. ZERO ASSUMED.'TL
)@@G@@@]@@@@     1   )  @#@@@@707     CONTINUE  @#@@@@      CCNA=CCNB   @ @@@@TM
)@@G@@      IF( .NOT. COMMA) CCNA=0 @C@@@@      IF(COMMA .AND. CCNB .EQ. -1) ETN
)@@G@@RR(7)=.TRUE.@#@@@@      GO TO 720   @#@@@@ 710  LCCN =-1    @^@@@@      TO
)@@G@@ERR(7)=.FALSE.    @^@@@@      ERR(8)=.TRUE.     @#@@@@      GO TO 725   TP
)@@G@@@D@@@@C                            CHECK CONTINUATION NUMBER@A@@@@ 720  TQ
)@@G@@IF( .NOT. ERR(7)) GO TO 730   @#@@@@ 725  LASTN =-2   @#@@@@      GO TO TR
)@@G@@750   @A@@@@ 730  IF(LASTN .EQ. -2) GO TO 745   @A@@@@      IF(LASTN .EQTS
)@@G@@. -1) GO TO 740   @ @@@@      IF( PLUS) GO TO 750     @A@@@@      IF(LASTT
)@@G@@TN .GT. 0) GO TO 735    @A@@@@      IF(CCNA .EQ. 0) GO TO 745     @G@@@@TU
)@@G@@735   IF( CCNA .EQ. LASTN+1  .OR.  (LPLUS .AND. CCNA .GT. LASTN))GOTO745TV
)@@G@@@^@@@@ 740  ERR(9)=.TRUE.     @#@@@@ 745  LASTN=CCNA  @A@@@@      IF(LASTW
)@@G@@TN .EQ. 0) LASTN=-1     @D@@@@C                            SAVE INFORMATTX
)@@G@@ION FIELD   @^@@@@ 750  NCARD=NCARD+1     @ @@@@      IF(NOPROC) GO TO 8TY
)@@G@@00    @A@@[@      IF(LCH+63.GT.LLIM*6)GO TO 9999@C@@@@        CALL S1TCHTZ
)@@G@@S(CARD(3),5,STOR(LLOW),LCH,64)@#@@@@      LCH=LCH+64  @#@@@@      LB=LB+UA
)@@G@@12    @G@@@@C             NOTE - IT SEEMS THAT LB SHOULD BE INCREMENTED UB
)@@G@@BY 11, NOT  @G@@@@C                    12. NO MATTER, SINCE EXTRA WORDS UC
)@@G@@ARE BLANKED OUT   @D@@@@C                    ANYWAY.  SEE STMTS 500, ETCUD
)@@G@@.     @G@@@@C                    THUS A CCP CAN TAKE EACH CARD IMAGE TO UE
)@@G@@BE 11 OR 12 @F@@@@C                    WORDS LONG AND IS SAFE.  MAYBE THUF
)@@G@@AT'S WHY... @[@@@@C     @^@@@@C             PRINT CARD@[@@@@C     @C@@@@UG
)@@G@@C                            CHECK LINE SKIP    @B@@@@800     IF(NEWID(1UH
)@@G@@).NE.6HCOMMEN)GO TO 810 @B@@@@      IF(LASTCC .EQ. 6HCOMMEN) GO TO 820  UI
)@@G@@@#@@@@      GO TO 805   @#@@@@ 805  CALL S1PRSK @#@@@@      GO TO 820   UJ
)@@G@@@B@@@@ 810  IF(LASTCC .EQ. 6HCOMMEN) GO TO 805  @A@@@@      IF(NCARD .NEUK
)@@G@@. 1) GO TO 820    @#@@@@      CALL S1PRSK @A@@@@      IF(PRINT .EQ. 1) CUL
)@@G@@ALL S1PRSK  @E@@@@      IF(PRINT .EQ. 2  .AND.  OCCUR(I) .EQ. 1) CALL S1UM
)@@G@@PRSK  @D@@@@C                            CHECK SUPPRESS FIRST 16  @ @@@@UN
)@@G@@ 820  IF(CERR)ERRA=ERRA+1     @^@@@@      DO 825 J=1,15     @A@@@@      UO
)@@G@@IF( .NOT. ERR(J)) GO TO 825   @#@@@@      CERR=.TRUE. @#@@@@      ERRA=EUP
)@@G@@RRA+1 @#@@@@ 825  CONTINUE    @A@@@@      IF( .NOT. PLUS) GO TO 850     UQ
)@@G@@@A@@@@        CALL S1PRST(CARD,PLUSCL,1H+)@#@@@@850     CONTINUE  @A@@@@UR
)@@G@@        IF(CCLIST.EQ.1) CALL S1PRNT @D@@@@C                            SUS
)@@G@@UMMARIZE CARD ERRORS    @^@@@@      DO 860 J=1,14     @A@@@@      IF( .NUT
)@@G@@OT. ERR(J)) GO TO 860   @ @@@@      IF(J .GT. 9) GO TO 855  @A@@@@      UU
)@@G@@CALL S1MSG1(ME(J),0,0,0,0)    @#@@@@      GO TO 860   @#@@@@ 855  KEMP=EUV
)@@G@@PA    @ @@@@      IF(J .GT. 12) KEMP=EPC  @E@@@@      CALL S1MSG1(ME(J),UW
)@@G@@TABLE(1,KEMP),TABLE(2,KEMP),0,0)    @#@@@@ 860  CONTINUE    @A@@@@      UX
)@@G@@IF(.NOT. ERR(15)) GO TO 890   @#@@@@      ERRA=ERRA-1 @#@@@@      KEMP=EUY
)@@G@@PB+1  @^@@@@      KEMP2=TABLE(5,EPB)@ @@@@      DO 870 J=KEMP,KEMP2     UZ
)@@G@@@E@@@@      IF(OCCUR(J) .NE. 0  .OR.  TABLE(6,J) .EQ. 0) GO TO 870@#@@@@VA
)@@G@@      ERRA=ERRA+1 @[@@@@C     @F@@@@C       REQUIRED -- CARD WAS NOT FOUVB
)@@G@@ND FOLLOWING LAST -- CARD.    @[@@@@C     @G@@@@      CALL S1MSG1(M3,TABVC
)@@G@@LE(1,J),TABLE(2,J),TABLE(1,EPB),TABLE(2,EPB))   @#@@@@ 870  CONTINUE    VD
)@@G@@@C@@@@C                            READY FOR NEXT CARD@^@@@@890     LASTVE
)@@G@@CC=NEWID(1) @#@@@@      GO TO 200   @[@@@@C     @D@@@@C             TERMVF
)@@G@@INATION - CONTROL CARDS ALL READ    @[@@@@C     @C@@@@ 900  IF(NCARD .EQVG
)@@G@@. 0  .OR.  NOPROC) GO TO 910  @^@@@@      LLL=6*(LB-LLOW)   @^@@@@      VH
)@@G@@DO 905 J=LCH,LLL  @@@@@@@A@@@@905   CALL S1PRST(STOR(LLOW),J,1H ) @G@@@@VI
)@@G@@      CALL S1CCPD(STOR(LLOW),NCARD,CCSPEC,LCCN,INFOR,SPCCP,STOR(LB),LLIMVJ
)@@G@@@#@@@@     *+LLOW-LB)   @]@@@@      LCH=1 @^@@@@      CALL S1CLIM(12)   VK
)@@G@@@[@@@@C     @C@@@@C                            PRINT TERMINATOR   @A@@@@VL
)@@G@@910   IF (ITYPE.EQ.0) GO TO 920     @A@@@@      IF (ITYPE.EQ.3) GO TO 91VM
)@@G@@5     @#@@@@      CALL S1PRSK @#@@@@      CALL S1PRNT @ @@@@      IF(CERVN
)@@G@@R) ERRA=ERRA+1    @[@@@@C     @D@@@@C       BEGINDATA CARD MISSING OR OUVO
)@@G@@T OF SEQUENCE.    @[@@@@C     @ @@@@      CALL S1MSG1(M4,0,0,0,0) @#@@@@VP
)@@G@@      ERRA=ERRA+1 @#@@@@      GO TO 920   @B@@@@915   CALL S1STFT('DSL',VQ
)@@G@@FW,1,11,$9999)    @^@@@@        DO 916 I=0,10   @^@@@@        STOR(FW+I)VR
)@@G@@=1H   @#@@@@916     CONTINUE  @C@@@@        CALL S1STFT('BEGDAT',FW,1,11VS
)@@G@@,$9999)     @A@@@@C PUT TEXT FROM BEGINDATA THEERE.   @^@@@@       DO 91VT
)@@G@@7 J=1,64    @A@@@@      CALL S1PRFT(CARD,J+16,CH)     @A@@@@917   CALL SVU
)@@G@@1PRST(STOR(FW),J,CH)    @A@@@@      CALL S1PRST(STOR(FW),65,1H )  @A@@@@VV
)@@G@@      CALL S1PRST(STOR(FW),66,1H )  @^@@@@ 920  CALL S1PCHD(4)    @#@@@@VW
)@@G@@      PRINT 925   @D@@@@ 925  FORMAT(//31H0CONTROL CARD LISTING COMPLETEVX
)@@G@@  )   @[@@@@C     @D@@@@C                            CHECK MISSING SECONVY
)@@G@@DARY  @A@@@@      IF(MASTIN .EQ. 0) GO TO 940   @^@@@@      KEMP=MASTIN+VZ
)@@G@@1     @ @@@@      DO 930 J=KEMP,MASTLS    @E@@@@      IF(OCCUR(J) .NE. 0WA
)@@G@@  .OR.  TABLE(6,J) .EQ. 0) GO TO 930@G@@@@      CALL S1MSG1(M3,TABLE(1,JWB
)@@G@@),TABLE(2,J),TABLE(1,MASTIN),TABLE(2,MASTI@]@@@@     *   N))@#@@@@      WC
)@@G@@ERRA=ERRA+1 @#@@@@ 930  CONTINUE    @D@@@@C                            CWD
)@@G@@HECK FOR MISSING CARDS  @^@@@@940   DO 960 J=1,NTYPE  @^@@@@      USE=TAWE
)@@G@@BLE(6,J)    @A@@@@      IF(TABLE(5,J))960,950,950     @D@@@@ 945  IF(USEWF
)@@G@@ .EQ. 0  .OR.  OCCUR(J) .GT. 0) GO TO 960 @[@@@@C     @E@@@@        IF(TWG
)@@G@@ABLE(1,J).EQ.6HI/FORM.AND.STJBAN) GO TO 960     @C@@@@C       REQUIRED -WH
)@@G@@- CARD HAS NOT BEEN FOUND.    @C@@@@      CALL S1MSG1(M5,TABLE(1,J),TABLWI
)@@G@@E(2,J),0,0) @#@@@@      GO TO 959   @ @@@@950   IF( USE) 945,951,955    WJ
)@@G@@@C@@@@951   IF( TABLE(1,J) .NE. 6HI/FORM) GO TO 960   @C@@@@C           WK
)@@G@@ OTHERWISE CHECK COP VS OCCUR(J)    @B@@@@      CALL S1GTAG('PROGNM',FW,WL
)@@G@@I,I,$9999)  @F@@@@      IF(OCCUR(J).GT.0  .OR.  COP.NE.0  .OR.  STOR(FW)WM
)@@G@@.EQ.'ROTATE'@^@@@@     1   .OR.STJBAN)    @B@@@@     *                  WN
)@@G@@      GO TO 960   @C@@@@C       REQUIRED -- CARD HAS NOT BEEN FOUND.    WO
)@@G@@@D@@@@            CALL S1MSG1(M5,TABLE(1,J),TABLE(2,J),0,0) @#@@@@      WP
)@@G@@GO TO 959   @^@@@@ 955  PREDIC=TABLE(7,J) @^@@@@      KEMP=OCCUR(PREDIC)WQ
)@@G@@@B@@@@      GO TO (960,960,9553,9554,9555),USE  @E@@@@ 9553  IF(KEMP .EQWR
)@@G@@. 0  .OR.  OCCUR(J) .GT. 0) GO TO 960     @E@@@@C       THE -- CARD MUSTWS
)@@G@@ BE USED IF THE -- CARD IS USED.    @G@@@@      CALL S1MSG1(M6,TABLE(1,JWT
)@@G@@),TABLE(2,J),TABLE(1,PREDIC),TABLE(2,PREDI@]@@@@     *   C))@#@@@@      WU
)@@G@@GO TO 959   @D@@@@ 9554 IF(KEMP .GT. 0  .OR.  OCCUR(J) .GT.0) GO TO 960 WV
)@@G@@@E@@@@C       THE -- CARD MUST BE USED IF THE -- CARD IS NOT USED.@G@@@@WW
)@@G@@      CALL S1MSG1(M7,TABLE(1,J),TABLE(2,J),TABLE(1,PREDIC),TABLE(2,PREDIWX
)@@G@@@]@@@@     *   C))@#@@@@      GO TO 959   @E@@@@ 9555 IF(KEMP .GT. 0  .AWY
)@@G@@ND.  OCCUR(J) .EQ. 0) GO TO 960     @E@@@@      IF(KEMP .EQ. 0  .AND.  OWZ
)@@G@@CCUR(J) .GT. 0) GO TO 960     @G@@@@C       EITHER THE -- CARD OR THE --XA
)@@G@@ CARD MUST BE USED BUT NOT BOTH     @G@@@@      CALL S1MSG1(M8,TABLE(1,JXB
)@@G@@),TABLE(2,J),TABLE(1,PREDIC),TABLE(2,PREDI@]@@@@     *   C))@#@@@@ 959  XC
)@@G@@ERRA=ERRA+1 @#@@@@ 960  CONTINUE    @^@@@@      NCCERR=NCCERR+ERRA@D@@@@XD
)@@G@@C                            CALL TERMINAL PROCESSORS @G@@@@C-THE INDENTXE
)@@G@@ED CODING HERE IS FOR THE SPECIAL CASE OF THE TRANS1 OUTPUT @B@@@@CCARD XF
)@@G@@TERMINAL PROCESSOR HAVING TO BE LAST@^@@@@         TRANS1 = 0     @C@@@@XG
)@@G@@         CALL S1GTAG('PROGNM', FW, I, I, $9999) @C@@@@         IF( STOR(XH
)@@G@@FW) .EQ. 'TRANS1') TRANS1 = 1 @ @@@@      DO 980 J=NTYPE,1,-1     @B@@@@XI
)@@G@@         IF( TRANS1 .EQ. 0) GO TO 969     @C@@@@         IF( TABLE(1,J) XJ
)@@G@@.NE. 'OUTPUT') GO TO 969@#@@@@         I = J    @#@@@@         GO TO 980XK
)@@G@@@#@@@@969      CONTINUE @E@@@@        IF(TABLE(1,J).EQ.6HI/FORM .AND. STXL
)@@G@@JBAN) GO TO 975   @A@@@@      IF(TABLE(13,J))970,980,975    @A@@@@ 970  XM
)@@G@@IF(OCCUR(J) .EQ. 0) GO TO 980 @F@@@@975   CALL S1CCPT( TABLE(1,J),INFOR,XN
)@@G@@SPCCP,STOR(LLOW),LLIM,ERRA)   @^@@@@      NCCERR=NCCERR+ERRA@#@@@@ 980  XO
)@@G@@CONTINUE    @A@@@@         IF( TRANS1 .EQ. 0) RETURN  @F@@@@         CALXP
)@@G@@L S1CCPT( TABLE(1,I),INFOR,SPCCP,STOR(LLOW),LLIM,ERRA)@A@@@@         NCCXQ
)@@G@@ERR = NCCERR + ERRA     @]@@@@      RETURN@[@@@@C     @ @@@@9999    CALLXR
)@@G@@ S1SERR('S1CCFS.')@#@@@@        RETURN    @]@@@@      END   ___ 960     XS
)@@G@@@C@@@@C       REQUIRED -- CARD HAS NOT BEEN FOUND.    @C@@@@      CALL SXT
)@@G@@1MSG1(M5,TABLE(1,J),TABLE(2,J),0,0) @#@@@@      *[S@@@*SDFF*@E@@@@      XU
)@@G@@SUBROUTINE S1CCOF( IFLD, NW, NV, SCR, LSCR, NERR)     @[@@@@C     @G@@@@XV
)@@G@@C      *****************************************************************XW
)@@G@@@G@@@@C     **************  O/FORMAT CONTROL CARD PROCESSOR*************XX
)@@G@@******@G@@@@C     ******************************************************XY
)@@G@@************@F@@@@C                                                RJVOYXZ
)@@G@@TECKI  NOV69@ @@@@      IMPLICIT INTEGER (A - Z)@#@@@@      COMMON  X(1)YA
)@@G@@@G@@@@        DIMENSION CDS(13)/1HD,1HE,1HF,1HG,1HI,1HA,1HR,1HO,1HL,1HB,YB
)@@G@@3*1H./@C@@@@      DIMENSION IFLD(1), SCR(1), TVTYP(2), TI(2)@^@@@@      YC
)@@G@@LOGICAL IEDOUT    @]@@@@C......     @]@@@@C.......    @C@@@@        CALLYD
)@@G@@ S1STFT('TEMPOF',FWGV,1,1,$999)     @#@@@@        X(FWGV)=0 @C@@@@      YE
)@@G@@  CALL S1GVAL('ODROUT',OTYPE,$998,$998)   @A@@@@        IF(OTYPE.NE.4) GYF
)@@G@@O TO 10     @C@@@@        CALL S1GTAG('TEMPPV',FW,NEL,NEL,$8)     @#@@@@YG
)@@G@@        GO TO 10  @#@@@@8       CONTINUE  @^@@@@        CALL S1PCHD(1)  YH
)@@G@@@#@@@@        PRINT 9   @G@@@@9       FORMAT(' ***** THE O/FORMAT CARD IYI
)@@G@@S NOT ALLOWED WITH STJBANK '  @^@@@@     1    ,'OUTPUT.')   @^@@@@      YJ
)@@G@@  NERR=NERR+1     @#@@@@        RETURN    @#@@@@10      CONTINUE  @]@@@@YK
)@@G@@C......     @D@@@@C....  CALL S1GLST AFTER GETTING 'OCHARS' AND 'ONCR'  YL
)@@G@@@]@@@@C......     @C@@@@      CALL S1GVAL('OCHARS', OCHARS, $998,$998)  YM
)@@G@@@D@@@@      CALL S1GTAG( 'ONCR', FWONC, NWE, NEL, $998)     @#@@[@      YN
)@@G@@ONCR=100    @^]@@@      KSTOR=ONCR+2*NV   @A@@@@      IF(LSCR.LT.KSTOR) YO
)@@G@@GO TO 997   @^@@@@      DO 11 I=1,KSTOR   @#@@@@11    SCR(I)=0    @#@@@@YP
)@@G@@      ONCRU = ONCR@^@@@@      FWL = ONCR + 1    @F@@@@      CALL S1GLST(YQ
)@@G@@ IFLD, NW*6, NV, SCR(FWL), SCR, ONCRU, $1002)   @E@@@@C       SET A FLAGYR
)@@G@@ THAT THE FORMAT IS BEING WRITTEN OUT.    @#@@@@        X(FWGV)=1 @B@@@@YS
)@@G@@        CALL S1IODR(3,'REW',NEL,NEL,NEL)  @D@@@@      CALL S1IODR( 3, 'WYT
)@@G@@RITE', NV*2, SCR(FWL), NEL)   @C@@@@      CALL S1IODR( 3, 'END', NEL, NEYU
)@@G@@L, NEL)     @C@@@@      CALL S1IODR( 3, 'REW', NEL, NEL, NEL)     @B@@@@YV
)@@G@@      CALL S1STFT('ONCRU', FW, 1, 1, $999)@^@@@@      X(FW) = ONCRU     YW
)@@G@@@H@@@@C CHECK TO SEE IF NCR SPECIFIED CORRECTLY. DO THE CHECK IF NOT DEFYX
)@@G@@AULTED.     @C@@@@C IF FORMAT DEFAULTED S1OFMT SETS NCR CORRECTLY @C@@@@YY
)@@G@@        CALL S1GTAG('TEMPPV',FW,NWE,NEL,$13)    @A@@@@        IF(X(FWONCYZ
)@@G@@).EQ.-1)GO TO 15  @#@@@@C DEFAULT IS -1   @ @@@@13      EFNCR=IABS(X(FWOZA
)@@G@@NC))  @A@@[@        IF(EFNCR.EQ.ONCRU)GO TO 14  @^[@@@        CALL S1PCHZB
)@@G@@D(1)  @#@@[@      PRINT 130   @G@@[@130   FORMAT(' ***** ERROR. FORMAT AZC
)@@G@@ND NLR ON OUTPUT CARD ARE INCONSISTE@]@@[@     *NT.') @^#@@@        NERRZD
)@@G@@=NERR+1     @A@@[@      IF (EFNCR.LT.ONCRU) GO TO 14  @^@@[@      CALL SZE
)@@G@@1PCHD(2)    @#@@[@      PRINT 131   @G@@[@131   FORMAT(7X,'PROGRAM FORMEZF
)@@G@@RLY ALLOWED NLR TO BE LARGER THAN NECESSAR@A@@[@     *Y, AND ADDED BLANKZG
)@@G@@ RECORDS.'/ @F@@[@     *7X,'IF YOU NEED THIS CAPABILITY, SEE A STATJOB CZH
)@@G@@ONSULTANT.')@^@@@@14      ONCRU=EFNCR     @^@@@@15      X(FWONC)=ONCRU  ZI
)@@G@@@]@@@@C......     @E@@@@C....  FOR EACH VARIABLE CHECK VARIABLE TYPE IN ZJ
)@@G@@FORMAT LIST @E@@@@C......                           AGAINST 'TVTYPE' LISZK
)@@G@@T     @ @@@@        IF(NV.EQ.0) GO TO 281 @#@@@@      FWTVT = 0   @^@@@@ZL
)@@G@@      TI(1) = 6HTRANSF  @^@@@@      TI(2) = 6HORMED   @D@@@@      CALL SZM
)@@G@@1GTAG('TVTYPE', FWTVT, NWE, NEL, $200)    @#@@@@      GO TO 205   @D@@@@ZN
)@@G@@200   CALL S1GTAG('FMTLST', FWIFMT, NWE, NEL, $998)   @#@@@@      TI(1) ZO
)@@G@@= 6H  @^@@@@      TI(2) = TI(1)     @#@@@@205   J=FWL-2     @#@@@@      ZP
)@@G@@JJ=FWIFMT-2 @^@@@@      IEDOUT = .FALSE.  @^@@@@      DO 28  TVN = 1, NVZQ
)@@G@@@]@@@@      J=J+2 @#@@@@      JJ=JJ+2     @ @@@@      TYPE=FLD(18,6,SCR(ZR
)@@G@@J+1)) @C@@@@        IF(TYPE.LT.1.OR.TYPE.GT.13)GO TO 21     @E@@@@      ZS
)@@G@@  GO TO ( 21,23,23,23,22,24,21,21,21,23,21,21,21),TYPE@E@@@@C           ZT
)@@G@@    D  E  F  G  I  A  R  O  L  B UN UN UNUSED   @[@@@@C     @ @@@@21    ZU
)@@G@@PHYREC=FLD(0,18,SCR(J)) @ @@@@      FCOL=FLD(18,18,SCR(J))  @ @@@@      ZV
)@@G@@LCOL=FLD(0,18,SCR(J+1)) @^@@@@      CALL S1PCHD(1)    @B@@@@      PRINT ZW
)@@G@@2100, TVN, PHYREC, FCOL, LCOL @G@@@@2100  FORMAT(' ***** FORMAT ERROR.  ZX
)@@G@@ILLEGAL EDITING CODE SPECIFIED FOR T@G@@@@     2RANSFORMED VARIABLE', I5ZY
)@@G@@, ' IN  LOGICAL RECORD',I3,', COLUMNS', I4@^@@@@     3, ' THRU',I4)     ZZ
)@@G@@@^@@@@      NERR = NERR + 1   @#@@@@      GO TO 28    @^@@@@22    IEDOUTAA
)@@G@@ = .TRUE.   @#@@@@23    NA36 = 3    @#@@@@      GO TO 25    @#@@@@24    AB
)@@G@@NA36 = 6    @A@@@@25    IF( FWTVT .NE. 0) GO TO 258   @ @@@@      TN=FLDAC
)@@G@@(18,6,X(JJ+1))    @B@@@@      IF(TN.LT.1.OR.TN.GT.13) GO TO 28    @F@@@@AD
)@@G@@        GO TO (28,251,251,251,251,252,28,28,28,252,28,28,28),TN   @]@@@@AE
)@@G@@251   TN = 3@#@@@@      GO TO 259   @]@@@@252   TN = 6@#@@@@      GO TO AF
)@@G@@259   @ @@@@258   TN = X(FWTVT+TVN-1)     @D@@@@259   IF( TN .EQ. NA36  AG
)@@G@@.OR.  TN .EQ. 0) GO TO 28     @^@@@@      CODE = CDS(TYPE)  @ @@@@      AH
)@@G@@IF( TN .EQ. 6) GO TO 26 @ @@@@      TVTYP(1) = 6H  NUME     @^@@@@      AI
)@@G@@TVTYP(2) = 6HRIC  @#@@@@      GO TO 27    @ @@@@26    TVTYP(1) = 6H ALPHAJ
)@@G@@A     @^@@@@      TVTYP(2) = 6HBETIC@^@@@@27    CALL S1PCHD(1)    @B@@@@AK
)@@G@@      PRINT 2700,  TI, TVN, TVTYP, CODE   @E@@@@2700  FORMAT(' ***** FORAL
)@@G@@MAT ERROR.' ,2A6,      'VARIABLE',  @G@@@@     2 I4, ' HAS BEEN DEFINED AM
)@@G@@AS', 2A6, 'AND THUS CANNOT BE OUTPUT WITH @ @@@@     3AN ', A1, ' FIELD'AN
)@@G@@)     @^@@@@      NERR = NERR + 1   @#@@@@28    CONTINUE    @#@@@@281   AO
)@@G@@  CONTINUE  @E@@@@      IF( IEDOUT)  CALL S1STFT('OINTEG', FW, 1, 1, $99AP
)@@G@@9)    @[@@@@C     @G@@@@C               NOW CHECK OCHARS AGAINST RECORD AQ
)@@G@@WIDTHS AND STORE THESE  @[@@@@C     @C@@@@        CALL S1GVAL('ODROUT',OAR
)@@G@@TYPE,$998,$998)   @#@@@@        SEQ=0     @C@@@@        CALL S1GTAG('SEQAS
)@@G@@',SEQ,NWE,NEL,$312)     @#@@@@312     CONTINUE  @#@@@@        NOSEQ=0   AT
)@@G@@@C@@@@        CALL S1GTAG('NOSEQ',NOSEQ,NWE,NEL,$313) @#@@@@313     CONTAU
)@@G@@INUE  @E@@@@        IF(SEQ.EQ.0.AND.NOSEQ.EQ.0.AND.OTYPE .EQ.1)SEQ=1    AV
)@@G@@@C@@@@      CALL S1STFT('ORCWTH', FW, 1, ONCR, $999)  @^@@@@      DO 31 AW
)@@G@@ I = 1, ONCR@B@@@@      IF( SCR(I) .LE. OCHARS) GO TO 311   @^@@@@      AX
)@@G@@CALL S1PCHD(1)    @ @@@@      PRINT 3000, I, OCHARS   @G@@@@3000  FORMATAY
)@@G@@(' ***** FORMAT ERROR.   LOGICAL RECORD', I3, ' IS SPECIFIED@B@@@@     2AZ
)@@G@@ AS LONGER THAN', I4, ' CHARACTERS')@^@@@@      NERR = NERR + 1   @#@@@@BA
)@@G@@311     CONTINUE  @ @@@@        IF(SEQ.EQ.0) GO TO 314@B@@@@        IF(SBB
)@@G@@CR(I).LE.OCHARS-8) GO TO 314  @^@@@@        CALL S1PCHD(1)  @^@@@@      BC
)@@G@@  PRINT 3001,I    @G@@@@3001    FORMAT(' ***** FORMAT ERROR.  LOGICAL REBD
)@@G@@CORD',I3,' SPECIFIES '  @D@@@@     1  ,'FORMATTING IN THE SEQUENCE NUMBEBE
)@@G@@RING AREA.')@^@@@@        NERR=NERR+1     @#@@@@314     CONTINUE  @^@@@@BF
)@@G@@31    X(FW+I-1) = SCR(I)@[@@@@C     @D@@@@C            FINALLY STORE FORBG
)@@G@@MAT UNDER TAG  'O/FORM' @[@@@@C     @C@@@@      CALL S1GTAG('O/FORM', FWBH
)@@G@@, NWE, NEL, $39)  @]@@@@      RETURN@C@@@@39    CALL S1STFT('O/FORM', IBBI
)@@G@@, 1, NW , $999)   @^@@@@      DO 40  I = 1, NW  @^@@@@      X(IB) = IFLDBJ
)@@G@@(I)   @#@@@@40    IB = IB + 1 @]@@@@      RETURN@[@@@@C     @[@@@@C     BK
)@@G@@@C@@@@997   CALL S1SERR('S1CCOF. LSCR TOO SMALL.')    @#@@@@      GO TO BL
)@@G@@1000  @F@@@@998     CALL S1SERR('S1CCOF. S1GTAG OR S1GVAL ERROR RETURN.'BM
)@@G@@)     @#@@@@        GO TO 1000@D@@@@999     CALL S1SERR('S1CCOF. S1STFT BN
)@@G@@ERROR RETURN.')   @^@@@@1000    NERR=NERR+1     @]@@@@      RETURN@#@@@@BO
)@@G@@1002  CONTINUE    @#@@@@      NERR = 1    @]@@@@      RETURN@]@@@@      BP
)@@G@@END   ___28),TN   @]@@@@251   TN = 3@#@@@@      GO TO 259   @]@@@@252   BQ
)@@G@@*[S@@@*SDFF*@G@@@@      SUBROUTINE S1CCPD(IFLD,NCARD,CCSPEC,CCN,INFOR,SPBR
)@@G@@CCP,SCR,LSCR)     @ @@@@      IMPLICIT INTEGER(A-Z)   @#@@@@      COMMONBS
)@@G@@  X(1)@G@@@@      COMMON/S1CCI/IHD(8),PROGNM(2),DATE(2),CCINP(2),NCCERR,BT
)@@G@@NIOERR,     @B@@@@     1TESTFG,MAPFG,NVARS,NTVARS,NCR,COP   @F@@@@      BU
)@@G@@DIMENSION CCSPEC(13),IFLD(1),INFOR(1),SCR(1),INITLV(12)     @B@@@@      BV
)@@G@@DATA (INITLV(I),I=1,12)/0,11*1H /   @^@@@@C******************     @F@@@@BW
)@@G@@C       S1CCPD     CALLS THE CONTROL CARD HALDLERS FOR S1CCFS.    @[@@@@BX
)@@G@@C     @^@@@@C******************     @[@@@@C     @F@@@@C       S1CCPD    BY
)@@G@@ SYMBOL USAGE SUMMARY ALL VARIABLES ARE INTEGERS@^@@@@C*****************BZ
)@@G@@*     @[@@@@C     @G@@@@C       CCINP      DIMENSIONED (2), IN COMMON BLCA
)@@G@@OCK S1CCI, NOT USED     @^@@@@C                  HERE.@F@@@@C       CCN CB
)@@G@@       FORMAL PARAMETER, =LCCN IN S1CCFS, LAST CONTROL@A@@@@C           CC
)@@G@@       CARD'S NUMBER.   @G@@@@C       CCSPEC     FORMAL PARAMETER, TABLECD
)@@G@@ ENTRY FOR THIS CARD HANDLER. @C@@@@C                  FOR A DESCRIPTIONCE
)@@G@@ SEE S1CCFS.@G@@@@C       COP        IN COMMON BLOCK S1CCI, =1 IF COP INCF
)@@G@@PUT =0 IF NOT.    @G@@@@C       DATE       IN COMMON BLOCK S1CCI, DIMENSCG
)@@G@@IONED (2), NOT USED     @^@@@@C                  HERE.@E@@@@C       FW  CH
)@@G@@       POINTER TO THE FIRST WORD OF THE TAG.    @F@@@@C       IFLD      CI
)@@G@@ FORMAL PARAMETER, THE CARD IMAGE TO BE HANDLED.@G@@@@C       IHD       CJ
)@@G@@ IN COMMON BLOCK S1CCI, DIMENSIONED (8), NOT USED     @^@@@@C           CK
)@@G@@       HERE.@G@@@@C       INFOR      FORMAL PARAMETER, THE TABLE INPUT TCL
)@@G@@O S1CCFS WITH     @G@@@@C                  OPTIONAL CONTROL WORDS. FOR ICM
)@@G@@NPUT CARD OR GENERAL    @A@@@@C                  ENLIST PROCESSOR.@G@@@@CN
)@@G@@C       INITLV     12-WORD ARRAY CONTAINING INITIALIZATION CONTENTS FOR CO
)@@G@@@F@@@@C                  VLABEL CONTROL CARD STORAGE FILE (VLABEL$.)    CP
)@@G@@@B@@@@C       KK         TEMPORARY VARIABLE.    @B@@@@C       KKA       CQ
)@@G@@ TEMPORARY VARIABLE.    @F@@@@C       LSCR       FORMAL PARAMETER, LENGTCR
)@@G@@H, IN WORDS, OF THE     @A@@@@C                  SCRATCH ARRAY.   @E@@@@CS
)@@G@@C       MAPFG      IN COMMON BLOCK S1CCI, NOT USED HERE.    @B@@@@C     CT
)@@G@@  N          TEMPORARY VARIABLE.    @F@@@@C       NCARD      FORMAL PARACU
)@@G@@METER, NUMBER OF CARD IMAGES FOR THE@ @@@@C                  HANDLER.   CV
)@@G@@@G@@@@C       NCCERR     IN COMMON BLOCK S1CCI, NUMBER OF CONTROL CARD ECW
)@@G@@RRORS.@G@@@@C       NCR        IN COMMON BLOCK S1CCI, NUMBER OF LOGICAL CX
)@@G@@RECORDS PER @A@@@@C                  INPUT RECORD.    @E@@@@C       NERRCY
)@@G@@       NUMBER OF ERRORS DETECTED IN PROCESSOR.  @E@@@@C       NIOERR    CZ
)@@G@@ IN COMMON BLOCK S1CCI, NOT USED HERE.    @E@@@@C       NOB        NUMBEDA
)@@G@@R OF OBSERVATIONS PER INPUT RECORD. @F@@@@C       NTVARS     IN COMMON BDB
)@@G@@LOCK S1CCI, NUMBER OF TRANSFORMED   @ @@@@C                  VARIABLES. DC
)@@G@@@C@@@@C       NV         NUMBER OF INPUT VARIABLES    @B@@@@C       NVARDD
)@@G@@S      NUMBER OF VARIABLES.   @E@@@@C       PROGNM     IN COMMON BLOCK SDE
)@@G@@1CCI, NOT USED HERE.    @G@@@@C       SCR        FORMAL PARAMETER, DIMENDF
)@@G@@SIONED (1), SCRATCH ARRAY.    @D@@@@C       SPCCP      FORMAL PARAMETER,DG
)@@G@@ NOT USED HERE.   @E@@@@C       SW         CARD HANDLER NUMBER FOR COMPUDH
)@@G@@TED GO TO.  @G@@@@C       S1CCEN     GENERALIZED ENLIST PROCESSOR, PROCEDI
)@@G@@SSOR NUMBER 7.    @A@@@@C       S1CCI      COMMON BLOCK     @F@@@@C     DJ
)@@G@@  S1CCIC     IN CHECKS CARD HANDLER, PROCESSOR NUMBER 3.    @F@@@@C     DK
)@@G@@  S1CCIF     I/FORMAT CARD HANDLER, PROCESSOR NUMBER 2.     @E@@@@C     DL
)@@G@@  S1CCIN     INPUT CARD HANDLER FOR ALL BUT ONEWAY1   @D@@@@C           DM
)@@G@@       AND COLFREQ1, PROCESSOR NUMBER 1.  @G@@@@C       S1CCMD     MODELDN
)@@G@@ CARD HANDLER FOR STEPREG1, PROCESSOR NUMBER 8  @E@@@@C       S1CCNM    DO
)@@G@@ VNAMES CARD HANDLER, PROCESSOR NUMBER 4  @F@@@@C       S1CCOD     TRANSDP
)@@G@@1 OUTPUT CARD HANDLER, PROCESSOR NUMBER 9.@F@@@@C       S1CCOF     O/FORDQ
)@@G@@MAT CARD HANDLER, PROCESSOR NUMBER 24.    @G@@@@C       S1CCOT     REGANDR
)@@G@@/STEPREG/FACTOR OUTPUT CARD PROCESSOR, NO. 34.  @E@@@@C       S1CCTI    DS
)@@G@@ TITLE CARD HANDLER, PROCESSOR NUMBER 6.  @E@@@@C       S1CCWT     WEIGHDT
)@@G@@T CARD HANDLER, PROCESSOR NUMBER 30.@F@@@@C       S1CTAG     ROUTINE IN DU
)@@G@@S1GTST TO CHANGE THE NAME OF A TAG. @G@@@@C       S1GTAG     ROUTINE IN DV
)@@G@@S1FTST TO RETRIEVE THE POINTERS TO A TAG  @G@@@@C       S1GVAL     ROUTIDW
)@@G@@NE IN S1FTST TO RETRIEVE THE VALUE OF A TAG.    @F@@@@C       S1STFT    DX
)@@G@@ ROUTINE IN S1GTST TO CREATE A TAG AND ALLOCATE @A@@@@C                 DY
)@@G@@ STORAGE FOR IT.  @F@@@@C       S1STRS     ROUTINE IN S1GTST TO CREATE ADZ
)@@G@@ TAG AND RESERVE  @E@@@@C                  STORAGE FOR IT IN THE ANALYSIEA
)@@G@@S PHASE.    @F@@@@C       S1ZTRC     TRANSFRM CARD HANDLER, PROCESSOR NUEB
)@@G@@MBER 5.     @G@@@@C       S11CCV     PICT1 VARLABEL CARD HANDLER, PROCESEC
)@@G@@SOR NUMBER 21.    @G@@@@C       S11GXY     PICT1 GRAPH, HEAD, XLABEL, YLED
)@@G@@ABEL CARD PROCESSOR,    @B@@@@C                  PROCESSOR NUMBER 22.   EE
)@@G@@@G@@@@C       S15CCI     COLFREQ1 INPUT CARD PROCESSOR, PROCESSOR NUMBEREF
)@@G@@ 25.  @G@@@@C       S15CCO     COLFREQ1 OUTPUT CARD HANDLER, PROCESSOR NEG
)@@G@@UMBER 26.   @G@@@@C       S17CCO     UNISTAT1 OUTPUT CARD HANDLER, PROCEEH
)@@G@@SSOR NUMBER 29.   @G@@@@C       S2CCO      DSTAT2 OUTPUT/SUBSET CARD HANEI
)@@G@@DLER, PROCESSOR NO. 27. @G@@@@C       S22CLD     CROSTAB2 CONTROL CARDS EJ
)@@G@@PROCESSOR, PROCESSOR NUMBER   @^@@@@C                  32.  @G@@@@C     EK
)@@G@@  S3CCMD     REGAN2 MODEL CARD PROCESSOR, PROCESSOR NUMBER 15.    @G@@@@EL
)@@G@@C       S31MOD     DISCRIM1 MODEL CARD HANDLER, PROCESSOR NUMBER 32.    EM
)@@G@@@G@@@@C       S6CCMD     FACTOR1 MODEL CARD HANDLER, PROCESSOR NUMBER 14EN
)@@G@@.     @G@@@@C       S61CCR     ROTATE1 ROTATE CARD PROCESSOR, PROCESSOR EO
)@@G@@NUMBER 33.  @G@@@@C       S63MOD     FACTOR3 MODEL CARD PROCESSOR, PROCEEP
)@@G@@SSOR NUMBER 35.   @G@@@@C       S8CCIN     ONEWAY1 INPUT CARD HANDLER, PEQ
)@@G@@ROCESSOR NUMBER 13.     @G@@@@C       S9ANPF     NWAY1 ANALYSIS CARD HANER
)@@G@@DLER, PROCESSOR NUMBER 16.    @F@@@@C       S9CODP     NWAY1 CODE CARD HES
)@@G@@ANDLER, PROCESSOR NUMBER 18.  @F@@@@C       S9DNPF     NWAY1 DESIGN CARDET
)@@G@@ HANDLER, PROCESSOR NUMBER 19.@F@@@@C       S9OUTP     NWAY1 OUTPUT CARDEU
)@@G@@ HANDLER, PROCESSOR NUMBER 23.@G@@@@C       TESTFG     IN COMMON BLOCK SEV
)@@G@@1CCI, TEST FLAG, NOT USED HERE.     @B@@@@C       X          BLANK COMMOEW
)@@G@@N ARRAY.    @[@@@@C     @^@@@@C******************     @[@@@@C     @C@@@@EX
)@@G@@C       S1CCPD     TAGGED STORAGE USAGE SUMMARY @[@@@@C     @^@@@@C*****EY
)@@G@@*************     @[@@@@C     @G@@@@C       'TVTYPE'   IS RETRIEVED TO AEZ
)@@G@@SCERTAIN THAT TRANSFORMATIONS WERE  @ @@@@C                  SUCCESSFUL.FA
)@@G@@@G@@@@C       'IVARS'    IS CREATED TO HOLD THE NUMBER OF INPUT VARIABLEFB
)@@G@@S     @G@@@@C       'NVARS'    IS RETRIEVED TO CHANGE ITTO NUMBER OF TRAFC
)@@G@@NSFORMED    @ @@@@C                  VARIABLES  @B@@@@C       'VNAMES'  FD
)@@G@@ IS CHANGED TO 'INAMES' @C@@@@C       'INAMES'   IS CREATED FROM 'VNAMESFE
)@@G@@'     @B@@@@C       'TVNAME'   IS CHANGED TO 'VNAMES'.@G@@@@C       'LDAFF
)@@G@@TA'    IS RESERVED TO HOLD TRANSFORMED DATA IN ANALYSIS.    @F@@@@C     FG
)@@G@@  'NOBPIR'   IS RETRIEVED FOR NUMBER OF OBSERVATIONS PER    @A@@@@C     FH
)@@G@@             INPUT RECORD.    @[@@@@C     @^@@@@C******************     FI
)@@G@@@#@@@@      SW=CCSPEC(9)@#@@@@      NERR = 0    @G@@@@      GO TO(250,30FJ
)@@G@@0,350,400,450,500,550,600,650,999,750,800,850,900,    @F@@@@     * 950,1FK
)@@G@@000,999,1100,1150,1200,1250,1300,1350,1400,1450,1500  @F@@@@     *  ,155FL
)@@G@@0,1600,1650,1700,1750,1800,1850,1900,1950,2000,2050,  @^@@@@     *2100,2FM
)@@G@@150),SW     @[@@@@C     @A@@@@C         CALL INPUT CARD PROCESSOR @]@@@@FN
)@@G@@C       #1  @[@@@@C     @^@@@@250   KK=CCSPEC(12)     @]@@@@      KKA=0 FO
)@@G@@@A@@@@      IF (KK.NE.0) KKA=INFOR(KK)    @G@@@@      CALL S1CCIN(IFLD,NFP
)@@G@@CARD,SCR,LSCR,CCSPEC(10),CCSPEC(11),KKA,INFOR(KK@C@@@@     1+1),INFOR(KKFQ
)@@G@@+2),NVARS,NCR,COP,NERR,$999)  @[@@@@C     @G@@@@C         INITIALIZE NVAFR
)@@G@@RS SECTORS OF FILE 'VLABEL$' ASSIGNED IN SZEROS @[@@@@C     @^@@@@      FS
)@@G@@DO 255 I=1,NVARS  @C@@[@255   CALL S1DRUM($999,'VLAB$$ ',3,INITLV,I,12) FT
)@@G@@@#[@@@      GO TO 405   @[@@@@C     @B@@@@C         CALL I/FORMAT CARD PFU
)@@G@@ROCESSOR    @]@@@@C       #2  @[@@@@C     @B@@@@300   CALL S1GVAL('NOBPIFV
)@@G@@R',NOB,$999,$999) @F@@@@      CALL S1CCIF(IFLD,NCARD,NVARS,NOB,NCR,COP,SFW
)@@G@@CR,LSCR,NERR)     @#@@@@      GO TO 405   @[@@@@C     @B@@@@C         CAFX
)@@G@@LL INCHECKS CARD PROCESSOR    @]@@@@C       #3  @[@@@@C     @F@@@@350   FY
)@@G@@CALL S1CCIC( IFLD, NCARD, CCSPEC, NCR, SCR, LSCR, NERR)     @#@@@@      FZ
)@@G@@GO TO 405   @[@@@@C     @A@@@@C         CALL VNAMES CARD PROCESSOR@]@@@@GA
)@@G@@C       #4  @[@@@@C     @#@@@@400   NV=NVARS    @B@@@@      IF(PROGNM(1)GB
)@@G@@.NE.'ROTATE')GO TO 401  @A@@@@      CALL S1GVAL('NV',NV,$999,$999)@B@@@@GC
)@@G@@401   CALL S1CCNM(IFLD,NCARD,NV,NERR)     @^@@@@405   NCCERR=NCCERR+NERRGD
)@@G@@@]@@@@      RETURN@[@@@@C     @B@@@@C        CALL TRANSFRM CARD PROCESSOGE
)@@G@@R     @]@@@@C       #5  @[@@@@C     @C@@@@450   CALL S1GTAG('REPMEA',DUMGF
)@@G@@,DUM,DUM,$460)    @^@@@@      CALL S1PCHD(4)    @#@@@@      PRINT 455   GG
)@@G@@@G@@@@455   FORMAT('0***** WARNING. ALTHOUGH REPMEANS IS ON THE INPUT CAGH
)@@G@@RD, MI@G@@@@     *SSING DATA IS NOT ACTUALLY REPLACED IN THE DATA.'/7X,'GI
)@@G@@DO NOT ASSUM@G@@@@     *E MEANS HAVE BEEN REPLACED WHEN USING TRANSFORMAGJ
)@@G@@TIONS.'/7X,'BLANK @G@@@@     *INPUT VALUES ARE TREATED AS ZERO IN ARITHMGK
)@@G@@ETIC TRANSFORMATIONS.') @D@@@@460   CALL S1ZTRC(IFLD,NCARD*12,SCR,LSCR,NGL
)@@G@@ERR,NVARS)  @C@@@@      CALL S1GTAG('TVTYPE', FW, N, NTVARS, $405)@C@@@@GM
)@@G@@      CALL S1STFT( 'IVARS', FW, 1, 1, $999)     @#@@@@      NV=NVARS    GN
)@@G@@@^@@@@      X(FW) = NVARS     @B@@@@      CALL S1GTAG('NVARS', FW, N, N,GO
)@@G@@ $999)@^@@@@      X(FW) = NTVARS    @^@@@@      NVARS = NTVARS    @B@@@@GP
)@@G@@      CALL S1CTAG('VNAMES', 'INAMES')     @B@@@@      CALL S1CTAG('TVNAMGQ
)@@G@@E', 'VNAMES')     @B@@@@      CALL S1STRS('LDATA', 1, NV+2, $999) @[@@@@GR
)@@G@@C     @H@@@@C         IF TRANSFORMS ADDED ANY VARIABLES, INITIALIZE ADDIGS
)@@G@@TIONAL SECTORS    @[@@@@C     @ @@@@      IF(NVARS.LE.NV)GOTO 405 @^@@@@GT
)@@G@@      DO 465 I=NV,NVARS @C@@[@465   CALL S1DRUM($999,'VLAB$$ ',3,INITLV,GU
)@@G@@I,12) @#[@@@       GO TO 405  @[@@@@C     @A@@@@C         CALL TITLE CARGV
)@@G@@D PROCESSOR @]@@@@C       #6  @[@@@@C     @C@@@@500   CALL S1CCTI(IFLD,NGW
)@@G@@CARD,CCSPEC(10),NERR)   @#@@@@      GO TO 405   @[@@@@C     @C@@@@C     GX
)@@G@@    CALL GENERAL ENLIST CARD PROCESSOR    @]@@@@C       #7  @[@@@@C     GY
)@@G@@@^@@@@550   KK=CCSPEC(10)     @G@@@@      CALL S1CCEN(CCSPEC,IFLD,NCARD,GZ
)@@G@@INFOR(KK),CCSPEC(11),CCSPEC(12),    @ @@@@     1SCR,LSCR,NERR,$999)     HA
)@@G@@@#@@@@      GO TO 405   @[@@@@C     @C@@@@C         CALL STEPREG1 MODEL HB
)@@G@@CARD PROCESSOR    @]@@@@C       #8  @[@@@@C     @E@@@@600   CALL S1CCMD(HC
)@@G@@CCN,IFLD,NCARD,SCR,LSCR,NERR,NVARS,$999)  @#@@@@      GO TO 405   @[@@@@HD
)@@G@@C     @B@@@@C            CALL OUTDATA CARD PROCESSOR  @]@@@@C       #9  HE
)@@G@@@[@@@@C     @C@@@@650   CALL S1CCOD( IFLD, NCARD, SCR, LSCR, NERR)@#@@@@HF
)@@G@@      GO TO 405   @[@@@@C     @A@@@@C         CALL TAB CARD PROCESSOR   HG
)@@G@@@]@@@@C       #11 @[@@@@C     @B@@@@750   CALL S1SERR('STMT 750, S1CCPD'HH
)@@G@@)     @]@@@@      RETURN@[@@@@C     @D@@@@C         CALL ROW, COL, LEVELHI
)@@G@@, HEAD CARD PROCESSOR   @]@@@@C       #12 @[@@@@C     @B@@@@800   CALL SHJ
)@@G@@1SERR('STMT 800, S1CCPD')     @]@@@@      RETURN@[@@@@C     @B@@@@C     HK
)@@G@@   CALL ONEWAY1 INPUT CARD PROCESSOR@]@@@@C       #13 @[@@@@C     @C@@@@HL
)@@G@@850   CALL S8CCIN(IFLD,NCARD,SCR,LSCR,NERR)     @#@@@@      GO TO 405   HM
)@@G@@@[@@@@C     @^@@@@C        U N U S E D    @]@@@@C       #14 @[@@@@C     HN
)@@G@@@#@@@@900   GO TO 999   @[@@@@C     @B@@@@C         CALL REGAN2 MODEL CAHO
)@@G@@RD PROCESSOR@]@@@@C       #15 @[@@@@C     @E@@@@950   CALL S3CCMD(CCN,IFHP
)@@G@@LD,NCARD,SCR,LSCR,NERR,NVARS,$999)  @#@@@@      GO TO 405   @[@@@@C     HQ
)@@G@@@ @@@@999     CALL S1SERR('S1CCPD') @]@@@@      RETURN@[@@@@C     @E@@@@HR
)@@G@@C         CALL NWAY1  FACTORID  ANALYSIS CARD PROCESSOR     @]@@@@C     HS
)@@G@@  #16 @[@@@@C     @#@@@@1000  CONTINUE    @C@@@@      CALL S9ANPF(IFLD,NHT
)@@G@@CARD,SCR,LSCR,NERR)     @#@@@@      GO TO 405   @[@@@@C     @C@@@@C     HU
)@@G@@    CALL NWAY1  CODE WORD CARD PROCESSOR  @]@@@@C       #18 @[@@@@C     HV
)@@G@@@#@@@@1100  CONTINUE    @C@@@@      CALL S9CODP(IFLD,NCARD,SCR,LSCR,NERRHW
)@@G@@)     @#@@@@      GO TO 405   @[@@@@C     @D@@@@C         CALL NWAY1   FHX
)@@G@@ACTORID DESIGN CARD PROCESSOR @]@@@@C       #19 @[@@@@C     @#@@@@1150  HY
)@@G@@CONTINUE    @C@@@@      CALL S9DNPF(IFLD,NCARD,SCR,LSCR,NERR)     @#@@@@HZ
)@@G@@      GO TO 405   @[@@@@C     @C@@@@C         CALL GENERAL VLABEL CARD PIA
)@@G@@ROCESSOR    @]@@@@C       #20 @[@@@@C     @B@@@@1200  CALL S1CCV(CCN,IFLIB
)@@G@@D,NCARD,NERR)     @#@@@@      GOTO 405    @[@@@@C     @C@@@@C         CAIC
)@@G@@LL PICT1 VARLABEL CARD PROCESSOR    @]@@@@C       #21 @[@@@@C     @#@@@@ID
)@@G@@1250  CONTINUE    @B@@@@      CALL S11CCV(CCN,IFLD,NCARD,NERR)    @#@@@@IE
)@@G@@      GO TO 405   @[@@@@C     @E@@@@C         CALL PICT1 GRAPH,HEAD,XLABIF
)@@G@@EL,YLABEL CARD PROCESSOR@]@@@@C       #22 @[@@@@C     @#@@@@1300  CONTINIG
)@@G@@UE    @F@@@@      CALL S11GXY(CCSPEC(1),IFLD,NCARD,CCN,SCR,LSCR,NERR,$99IH
)@@G@@9)    @#@@@@      GO TO 405   @[@@@@C     @C@@@@C      CALL S9OUTP    OUII
)@@G@@TPUT CARD PROCESSOR     @]@@@@C       #23 @[@@@@C     @#@@@@1350  CONTINIJ
)@@G@@UE    @C@@@@      CALL S9OUTP(IFLD,NCARD,SCR,LSCR,NERR)     @#@@@@      IK
)@@G@@GO TO 405   @[@@@@C     @B@@@@C            CALL O/FORMAT CARD PROCESSOR IL
)@@G@@@]@@@@C       #24 @[@@@@C     @E@@@@1400  CALL S1CCOF( IFLD, NCARD*12, NIM
)@@G@@VARS, SCR, LSCR, NERR)  @#@@@@      GO TO 405   @[@@@@C     @C@@@@C     IN
)@@G@@    CALL COLFREQ1 INPUT CARD PROCESSOR    @]@@@@C       #25 @[@@@@C     IO
)@@G@@@^@@@@1450  KK=CCSPEC(12)     @]@@@@      KKA=0 @A@@@@      IF(KK.NE.0) IP
)@@G@@KKA=INFOR(KK)     @G@@@@      CALL S15CCI(IFLD,NCARD,SCR,LSCR,CCSPEC(10)IQ
)@@G@@,CCSPEC(11),KKA,INFOR(KK@C@@@@     *+1),INFOR(KK+2),NVARS,NCR,COP,NERR,$IR
)@@G@@999)  @#@@@@      GO TO 405   @[@@@@C     @C@@@@C         CALL COLFREQ1 IS
)@@G@@OUTPUT CARD PROCESSOR   @]@@@@C       #26 @[@@@@C     @C@@@@1500  CALL SIT
)@@G@@15CCO(NCARD,IFLD,SCR,LSCR,NERR,$999)@#@@@@      GO TO 405   @[@@@@C     IU
)@@G@@@E@@@@C         CALL DSTAT2 OUTPUT AND SUBSET CARD PROCESSOR.     @]@@@@IV
)@@G@@C       #27 @[@@@@C     @F@@@@ 1550 CALL S2CCO(CCSPEC(1),CCN,IFLD,NCARD,IW
)@@G@@SCR,LSCR,NERR,$999)     @#@@@@      GO TO 405   @[@@@@C     @B@@@@C     IX
)@@G@@   CALL UNISTAT1 HIST CARD PROCESSOR@]@@@@C       #28 @[@@@@C     @D@@@@IY
)@@G@@1600  CALL S17HST(NCARD,IFLD,SCR,SCR,LSCR,NERR,$999)  @#@@@@      GO TO IZ
)@@G@@405   @[@@@@C     @C@@@@C        CALL UNISTAT1 OUTPUT CARD PROCESSOR    JA
)@@G@@@]@@@@C       #29 @[@@@@C     @C@@@@1650  CALL S17CCO(NCARD,IFLD,SCR,LSCJB
)@@G@@R,NERR,$999)@#@@@@      GO TO 405   @[@@@@C     @A@@@@C        CALL WEIGJC
)@@G@@HT CARD PROCESSOR @]@@@@C       #30 @[@@@@C     @C@@@@ 1700 CALL S1CCWT(JD
)@@G@@IFLD,NCARD,SCR,LSCR,NERR,$999)@#@@@@      GO TO 405   @[@@@@C     @C@@@@JE
)@@G@@C        CALL CROSTAB2 CONTROL CARDS PROCESSOR  @]@@@@C       #31 @[@@@@JF
)@@G@@C     @F@@@@ 1750 CALL S22CLD(CCSPEC(1),CCN,IFLD,NCARD,SCR,LSCR,NERR,$99JG
)@@G@@9)    @#@@@@      GO TO 405   @[@@@@C     @C@@@@C         CALL DISCRIM1 JH
)@@G@@MODEL CARD PROCESSOR    @]@@@@C       #32 @[@@@@C     @D@@@@1800  CALL SJI
)@@G@@31MOD(CCN,IFLD,NCARD,SCR,LSCR,NERR,$999)  @#@@@@      GO TO 405   @C@@@@JJ
)@@G@@C         CALL ROTATE1 ROTATE CARD PROCESSOR    @]@@@@C       #33 @[@@@@JK
)@@G@@C     @D@@@@ 1850 CALL S61CCR(CCN,IFLD,NCARD,SCR,LSCR,NERR,$999)  @#@@@@JL
)@@G@@      GO TO 405   @[@@@@C     @E@@@@C        CALL REGAN/STEPREG/FACTOR3 JM
)@@G@@OUTPUT CARD PROCESSOR   @]@@@@C      #34  @[@@@@C     @C@@@@ 1900 CALL SJN
)@@G@@1CCOT(IFLD,NCARD,SCR,LSCR,NERR,$999)@#@@@@      GO TO 405   @[@@@@C     JO
)@@G@@@B@@@@C        CALL FACTOR3 MODEL CARD PROCESSOR@]@@@@C      #35  @[@@@@JP
)@@G@@C     @D@@@@ 1950 CALL S63MOD(CCN,IFLD,NCARD,SCR,LSCR,NERR,$999)  @#@@@@JQ
)@@G@@      GO TO 405   @[@@@@C     @C@@@@C         CALL CLASSIFY1 MODEL CARD JR
)@@G@@PROCESSOR   @]@@@@C       #36 @[@@@@C     @D@@@@ 2000 CALL S32MDL(CCN,IFJS
)@@G@@LD,NCARD,SCR,LSCR,NERR,$999)  @#@@@@      GO TO 405   @[@@@@C     @D@@@@JT
)@@G@@C         CALL PROCESSOR FOR ONEWAY2 CONTROL CARDS    @]@@@@C      #37  JU
)@@G@@@[@@@@C     @F@@@@ 2050 CALL S82CLD(CCSPEC(1),CCN,IFLD,NCARD,SCR,LSCR,NEJV
)@@G@@RR,$999)    @#@@@@      GO TO 405   @[@@@@C     @C@@@@C         CALL UNIJW
)@@G@@STAT2 OUTPUT CARD PROCESSOR   @]@@@@C       #38 @[@@@@C     @D@@@@2100  JX
)@@G@@CALL S18CCO(CCN,IFLD,NCARD,SCR,LSCR,NERR,$999)  @#@@@@      GO TO 405   JY
)@@G@@@[@@@@C     @B@@@@C         CALL PICT1 SCAT CARD PROCESSOR  @]@@@@C     JZ
)@@G@@  #39 @[@@@@C     @D@@@@ 2150 CALL S11BVP(CCN,IFLD,NCARD,SCR,LSCR,NERR,$KA
)@@G@@999)  @#@@@@      GO TO 405   @]@@@@      END   ___   CALL S15CCI(IFLD,NKB
)@@G@@CARD,SCR,LSCR,CCSPEC(10)*[@@@@*SDFF*@C@@@@      SUBROUTINE S1CCV(NUMVAR,KC
)@@G@@IFLD,NCARD,NERR)  @A@@@@      DIMENSION IFLD(11),IFLDS(12)  @#@@@@      KD
)@@G@@COMMON X(1) @ @@@@      IMPLICIT INTEGER(A-Z)   @^@@@@      DATA NOVARL/KE
)@@G@@0/    @[@@@@C     @F@@@@C     THIS SUBROUTINE PROCESSES THE VLABEL CARD KF
)@@G@@EXECPT FOR PICT1  @[@@@@C     @ @@@@      IF(NOVARL.NE.0)  GO TO 2@B@@@@KG
)@@G@@      CALL S1STFT('NOVARL',LVARL,1,1,$999)@A@@@@    2 IF(NCARD.EQ.1)   GKH
)@@G@@O TO 10     @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(1)    @#@@@@KI
)@@G@@      PRINT 5     @G@@@@ 5    FORMAT(      ' ***** ERROR.  CONTINUATION KJ
)@@G@@CARDS ARE NOT ALLOWED FO@ @@@@     -R THE VLABEL CARD')     @#@@@@10    KK
)@@G@@CONTINUE    @ @@@@      IF(NUMVAR .EQ. 0) RETURN@ @@@@      CALL S1CKVI(KL
)@@G@@NUMVAR,$800)@^@@@@      IFLDS(1)=NUMVAR   @#@@@@      DO 15 I=1,11@^@@@@KM
)@@G@@   15 IFLDS(I+1)=IFLD(I)@D@@[@      CALL S1DRUM($997,'VLAB$$ ',3,IFLDS,NKN
)@@G@@UMVAR,12)   @^[@@@      NOVARL=NOVARL+1   @^@@@@      X(LVARL)=NOVARL   KO
)@@G@@@]@@@@      RETURN@#@@@@ 800  NERR=NERR+1 @^@@@@      CALL S1PCHD(1)    KP
)@@G@@@^@@@@      PRINT 810,NUMVAR  @F@@@@ 810  FORMAT(' *****  ERROR.  THERE KQ
)@@G@@IS NO VARIABLE NUMBER',I8)    @]@@@@      RETURN@#@@@@997   PRINT 996   KR
)@@G@@@F@@@@996   FORMAT('***** ERROR IN WRITING INTO VLABEL STORAGE FILE')   KS
)@@G@@@ @@@@999   CALL S1SERR ('S1CCV.')  @]@@@@      RETURN@]@@@@      END   KT
)@@G@@___@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@KU
)@@G@@*[S@@@*SDFF*@D@@@@      SUBROUTINE S1CKBN(CW,NAME,NADD,IV,BUFSIZ,NERR)  KV
)@@G@@@ @@@@      IMPLICIT INTEGER (A-Z)  @ @@@@      DIMENSION CW(2),NAME(2) KW
)@@G@@@^@@@@      DIMENSION IV(2)   @[@@@@C     @F@@@@C            SUBROUTINE KX
)@@G@@TO CHECK ERROR CONDITIONS FOR VARIABLES TO@B@@@@C        BE ADDED TO THEKY
)@@G@@ INPUT STJBANK.   @F@@@@C             CW - CONTROL WORD USED TO SPECIFY KZ
)@@G@@ADDING VARIABLES. @D@@@@C             NAME - NAME OF VARIABLE(S) TO BE ALA
)@@G@@DDED. @F@@@@C             NADD - MAXIMUM NUMBER OF VARIABLES TO BE ADDEDLB
)@@G@@.  IF @F@@@@C                       NADD .GT. 1 THEN DIGITS 1,2,... WILLLC
)@@G@@ LATER@E@@@@C                       BE APPENDED TO THE VARIABLE NAME.   LD
)@@G@@@G@@@@C             IV - RETURNED WITH SLOT NUMBERS IN WHICH VARIABLES ALE
)@@G@@RE    @G@@@@C                       TO BE ADDED.  IF IV(1) = 'VARIES' WHLF
)@@G@@EN S1CKBN   @G@@@@C                       IS CALLED, THEN ZERO IS RETURNLG
)@@G@@ED FOR UNIDENTI-  @F@@@@C                       FIED VARIABLES TO DENOTELH
)@@G@@ NEXT UNUSED SLOT.@F@@@@C             BUFSIZ - RETURNED WITH BUFFER SIZELI
)@@G@@ NEEDED FOR ADDING@B@@@@C                       NADD VARIABLES.   @G@@@@LJ
)@@G@@C             NERR - RETURNED WITH THE NUMBER OF ERROR MESSAGES PRINTED.LK
)@@G@@@[@@@@C     @[@@@@C     @#@@@@      COMMON X(2) @^@@@@      DIMENSION NMLL
)@@G@@(2)   @[@@@@C     @C@@[@C  ABORT RUN IF CC ERRORS&VARS ADDED TO STJBANK LM
)@@G@@@[@@@@C     @B@@[@      CALL S1STFT('ERRADD',LEA,1,1,$999)  @#@@@@      LN
)@@G@@VARIES=IV(1)@B@@@@      CALL S1GVAL('NVARS',NVARS,$999,$999)@B@@@@      LO
)@@G@@CALL S1GVAL('IVARS',NVARS,$999,$10) @#@@@@  10  CONTINUE    @#@@@@      LP
)@@G@@BUFSIZ=0    @]@@@@      NERR=0@B@@@@      CALL S1GTAG('STJBIN',FW,NWE,NELQ
)@@G@@L,$20)@#@@@@      GO TO 30    @B@@@@ 20   IF(VARIES .EQ. 'SKPERR') RETURLR
)@@G@@N     @#@@@@      CALL ERROR  @#@@@@      PRINT 25,CW @G@@@@ 25   FORMATLS
)@@G@@(' ***** CONTROL WORD ',2A6,' IS NOT ALLOWED UNLESS STJBANK @ @@@@     -LT
)@@G@@IS ON THE INPUT CARD')  @]@@@@      RETURN@#@@@@ 30   MAXNOB=X(FW)@^@@@@LU
)@@G@@      NORIG=X(FW+1)     @^@@@@      NEMPTY=X(FW+2)    @^@@@@      NUSED=LV
)@@G@@X(FW+3)     @#@@@@      LUSED=FW+3  @#@@@@      MAXK=X(FW+4)@^@@@@      LW
)@@G@@MULUSE=X(FW+5)    @^@@@@        BANKER=X(FW+6)  @^@@@@      XUSED=X(FW+7LX
)@@G@@)     @B@@@@      IF(VARIES .EQ. 'SKPERR') GO TO 100  @B@@@@      CALL SLY
)@@G@@1GTAG('NOBS',FW,NWE,NEL,$35)  @ @@@@      IF(NWE .EQ. 2) GO TO 33 @A@@@@LZ
)@@G@@      IF(X(FW) .LT. MAXNOB) GO TO 40@#@@@@      GO TO 35    @E@@@@ 33   MA
)@@G@@IF(X(FW) .GT. 1  .OR.  X(FW+1) .LT. MAXNOB) GO TO 40  @B@@@@ 35   CALL SMB
)@@G@@1GTAG('SKIPIF',FW,NWE,NEL,$50)@#@@@@ 40   CALL ERROR  @#@@@@      PRINT MC
)@@G@@45    @G@@@@ 45   FORMAT(' ***** VARIABLES CANNOT BE ADDED TO AN STJBANKMD
)@@G@@ IF OBSERVAT@G@@@@     -IONS ARE SKIPPED BY TRANSFORMATIONS OR BY NOBS OME
)@@G@@N THE INPUT CARD')@A@@@@ 50   IF(MULUSE .EQ. 0) GO TO 57    @#@@@@      MF
)@@G@@CALL ERROR  @#@@@@      PRINT 55    @G@@@@ 55   FORMAT(' ***** VARIABLESMG
)@@G@@ CANNOT BE ADDED TO INPUT STJBANK IF ANY S@D@@@@     -TJBANK IS INPUT MOMH
)@@G@@RE THAN ONCE IN THE RUN')     @A@@@@ 57   IF(XUSED .EQ. 0) GO TO 60     MI
)@@G@@@#@@@@      CALL ERROR  @^@@@@        CALL S1PCHD(1)  @#@@@@      PRINT MJ
)@@G@@58    @G@@@@ 58   FORMAT(' ***** VARIABLES CANNOT BE ADDED TO AN STJBANKMK
)@@G@@ UNLESS ITS @F@@@@     -FILE IS ASSIGNED WITH EXCLUSIVE USE (X-OPTION ONML
)@@G@@ @ASG)',    @A@@@@     -/' ***** AND WRITEABLE.')     @#@@@@      X(FW+7MM
)@@G@@)=0   @#@@@@ 60   DO 62 K=1,9 @ @@@@      CALL S1PRFT(NAME,K,CH)  @ @@@@MN
)@@G@@      IF(CH .NE. ' ') GO TO 62@#@@@@      NAMCHR=K-1  @#@@@@      GO TO MO
)@@G@@100   @#@@@@ 62   CONTINUE    @#@@@@ 63   CALL ERROR  @#@@@@      PRINT MP
)@@G@@65,CW @G@@@@ 65   FORMAT(' ***** VARIABLE NAME SPECIFIED WITH CONTROL WOMQ
)@@G@@RD ',2A6,   @A@@@@     -' HAS TOO MANY CHARACTERS')   @^@@@@ 70   NUSED=MR
)@@G@@NUSED+NADD  @A@@@@      IF(NUSED .LE. NEMPTY) GO TO 80@#@@@@72      CONTMS
)@@G@@INUE  @A@@@@        IF(BANKER.NE.0) GO TO 80    @#@@@@        CALL ERRORMT
)@@G@@@#@@@@      PRINT 75,CW @G@@@@ 75   FORMAT(' ***** INPUT STJBANK DOES NOMU
)@@G@@T CONTAIN ADEQUATE RESERVED SP@C@@@@     -ACE TO ADD VARIABLE(S) SPECIFIMV
)@@G@@ED BY ',2A6)@^@@@@ 80   X(LUSED)=NUSED    @]@@@@      RETURN@[@@@@C     MW
)@@G@@@[@@@@C     @C@@@@ 100  CALL S1GTAG('INAMES',FW,NWE,NEL,$1001)    @#@@@@MX
)@@G@@      GO TO 101   @B@@@@ 1001 CALL S1GTAG('VNAMES',FW,NWE,NEL,$70)@#@@@@MY
)@@G@@ 101  CONTINUE    @^@@@@      NM(1)=NAME(1)     @^@@@@      NM(2)=NAME(2MZ
)@@G@@)     @^@@@@      DO 150 J=1,NADD   @A@@@@      IF(NADD .EQ. 1) GO TO 11NA
)@@G@@0     @^@@@@      ENCODE(TEMP,102) J@#@@@@ 102  FORMAT(I3)  @#@@@@      NB
)@@G@@KS=NAMCHR   @#@@@@      DO 105 K=1,3@ @@@@      CALL S1PRFT(TEMP,K,CH)  NC
)@@G@@@A@@@@      IF(CH .EQ. ' ') GO TO 105     @#@@@@      KS=KS+1     @ @@@@ND
)@@G@@      CALL S1PRST(NM,KS,CH)   @#@@@@ 105  CONTINUE    @ @@@@      IF(KS NE
)@@G@@.GT. 8) GO TO 63  @]@@@@ 110  L=FW  @^@@@@      DO 120 I=1,NORIG  @A@@@@NF
)@@G@@      IF(NM(1) .NE. X(L)) GO TO 120 @B@@@@      IF(NM(2) .NE. X(L+1)) GONG
)@@G@@ TO 120     @#@@@@      CALL ERROR  @^@@@@      PRINT 115,NM,I    @G@@@@NH
)@@G@@ 115  FORMAT(' ***** NAME ',A6,A2,' OF VARIABLE TO BE ADDED IS THE SAME NI
)@@G@@@E@@@@     -AS THE NAME OF VARIABLE',I4,' OF THE INPUT STJBANK')  @#@@@@NJ
)@@G@@      GO TO 142   @]@@@@ 120  L=L+2 @#@@@@      LOW=NORIG+1 @^@@@@      NK
)@@G@@LUP=NVARS+NUSED   @^@@@@      MAX=NVARS+NEMPTY  @ @@@@      IF(LUP .GT. NL
)@@G@@MAX) LUP=MAX@A@@@@      IF(LUP .LT. LOW) GO TO 142    @^@@@@      DO 140NM
)@@G@@ I=LOW,LUP  @#@@@@      NAMA=X(L)   @#@@@@      NAMB=X(L+1) @]@@@@      NN
)@@G@@L=L+2 @ @@@@      CALL S1PRFT(NAMB,6,CHAR)@ @@@@      CALL S1PRST(NAMB,6NO
)@@G@@,' ') @A@@@@      IF(NM(1) .NE. NAMA) GO TO 140 @A@@@@      IF(NM(2) .NENP
)@@G@@. NAMB) GO TO 140 @A@@@@      IF(CHAR .NE. ' ') GO TO 130   @#@@@@      NQ
)@@G@@IV(J)=I     @A@@@@      CALL S1PRST(X(L-1),6,'X')     @#@@@@      GO TO NR
)@@G@@150   @#@@@@ 130  CALL ERROR  @#@@@@      PRINT 135,NM@G@@@@ 135  FORMATNS
)@@G@@(' ***** VARIABLE ',A6,A2,' ALREADY SPECIFIED TO BE ADDED IN@#@@@@     -NT
)@@G@@ THIS RUN') @#@@@@      GO TO 175   @#@@@@ 140  CONTINUE    @^@@@@ 142  NU
)@@G@@NUSED=NUSED+1     @B@@@@      IF(NUSED .LE. NEMPTY) GO TO 146     @#@@@@NV
)@@G@@      CALL ERROR  @#@@@@      PRINT 144,NM@G@@@@ 144  FORMAT(' ***** INPNW
)@@G@@UT STJBANK DOES NOT CONTAIN ADEQUATE SPACE TO AD@ @@@@     -D VARIABLE 'NX
)@@G@@,A6,A2)     @#@@@@      GO TO 80    @ @@@@ 146  CALL S1PRST(NM,12,'X')  NY
)@@G@@@#@@@@      LV=FW+2*LUP @#@@@@      X(LV)=NM(1) @^@@@@      X(LV+1)=NM(2NZ
)@@G@@)     @^@@@@      IV(J)=NVARS+NUSED @B@@@@      IF(VARIES .EQ. 'VARIES')OA
)@@G@@ IV(J)=0    @#@@@@ 150  CONTINUE    @^@@@@ 170  BUFSIZ=MAXK*NADD  @#@@@@OB
)@@G@@      GO TO 80    @]@@@@ 175  RETURN@[@@@@C     @ @@@@ 999  CALL S1SERR(OC
)@@G@@'S1CKBN.')  @]@@@@      RETURN@[@@@@C     @[@@@@C     @C@@@@C         LOOD
)@@G@@CAL SUBROUTINE FOR ERROR COUNTING   @[@@@@C     @^@@@@      SUBROUTINE EOE
)@@G@@RROR  @#@@@@      NERR=NERR+1 @^@@@@      CALL S1PCHD(1)    @]@@@@      OF
)@@G@@RETURN@]@@@@      END   ___ONTAIN ADEQUATE RESERVED SP@C@@@@     -ACE TOOG
)@@G@@ ADD VARIABLE(S) SPECIFIED BY ',2A6)@^@@@@ 80   X(LUSED)=NUSED    @]@@@@OH
)@@G@@*[S@@@*SDFF*@D@@@@        SUBROUTINE S1SJBD(SCR,LSCR,NERR,CWSP,NEWCW)   OI
)@@G@@@ @@@@        IMPLICIT INTEGER (A-Z)@D@@@@        DIMENSION TEXT(14),HEAOJ
)@@G@@DER(28),SCR(1),CWSP(1)  @^@@@@        DIMENSION FMT(4)@^@@@@        COMMOK
)@@G@@ON X(1)     @F@@@@        LOGICAL ORIGER,NVARER,VNAMER,NSLOTR,TYPEER,MDAOL
)@@G@@TAR ,FILECL,@#@@@@     *  CONTNU    @[@@@@C     @F@@@@C       ROUTINE TOOM
)@@G@@ READ FORWARD IN THE DECK AND GET THE BEGINDATA @G@@@@C       CARDS TO RON
)@@G@@ETRIEVE THE FILE NAMES AND ELEMENT NAMES OF STJBANK   @F@@@@C       INPUOO
)@@G@@T.  CREATES A TAG CALLED 'STJFIL' CONTAINING THE NAMES@E@@@@C       ON AOP
)@@G@@LL THE CARDS IN THE SAME FORMAT USED BY S1ENST. @G@@@@C       IT ALSO CROQ
)@@G@@EATES A TAG 'STJBIN'  WHICH IS 8 WORDS LONG AND HAS:  @A@@@@C       1 - OR
)@@G@@NUMBER OF OBSERVATIONS  @B@@@@C       2 - NUMBER OF ORIGINAL VARIABLES  OS
)@@G@@@C@@@@C       3 - NUMBER OF EMPTY (RESERVED) SLOTS.   @G@@@@C       4 - OT
)@@G@@ZERO, NUMBER OF EMPTY SLOTS USED BY ADDING. SET BY OTHERS   @F@@@@C     OU
)@@G@@  5 - NUMBER OF OBSERVATIONS PER INPUT BLOCK IN THE BANKS.  @E@@@@C     OV
)@@G@@6 - NON-ZERO IF AN STJBANK IS USED MORE THAN ONCE     @E@@@@C     8 - NOOW
)@@G@@N-ZERO IF SOME STJBANK IS NOT ASSIGNED WITH X   @G@@@@C       IT ALSO CROX
)@@G@@EATES THE TAG 'FMTLST' WITH THE CRACKED FORMAT, LOOKIN@G@@@@C       LIKEOY
)@@G@@ ALL VARIABLES START IN COLUMN ONE OF THE FIRST RECORD.     @G@@@@C     OZ
)@@G@@  AND TAG 'VNAMES' WITH THE VARIABLE NAMES, AND SETS TAG 'NVARS'  @C@@@@PA
)@@G@@C       TO THE NUMBER OF VARIABLES IN THE BANKS.@D@@@@C       ALL SPECIFPB
)@@G@@IED INPUT STJBANKS MUST MATCH ON:   @#@@@@C       1 - NVARS @B@@@@C     PC
)@@G@@  2 - ORIGINAL NUMBER OF VARIABLES. @A@@@@C       3 - NUMBER OF EMPTY SLPD
)@@G@@OTS.  @ @@@@C       4 TYPES AND WIDTHS.   @C@@@@C       5 - NUMBER OF AVPE
)@@G@@AILABLE RESERVED SLOTS. @[@@@@C     @G@@@@C       DIAGNOSTICS ARE PRODUCPF
)@@G@@ED AND PRINTED IMMIDIATELY AFTER INPUT CAR@[@@@@C     @[@@@@C     @G@@@@PG
)@@G@@        ORIGER=.FALSE. @ NO ERRRORS YET IN ORIGINAL NUMBER OF VARIABLES.PH
)@@G@@@G@@@@        NVARER=.FALSE. @ NO ERRORS YET IN NUMBER OF INPUT VARIABLEPI
)@@G@@S.    @C@@@@        VNAMER=.FALSE. @ NO ERRORS YET IN VNAMES@C@@@@      PJ
)@@G@@  NSLOTR=.FALSE. @ NOR IN RESERVED SLOTS. @B@@@@        TYPEER=.FALSE. @PK
)@@G@@ NOR IN TYPES.    @B@@@@        MDATAR=.FALSE. @ NOR IN MDATA     @C@@@@PL
)@@G@@        CALL S1STFT('STJBIN',FWST,8,1,$999)     @^@@@@        X(FWST+5)=PM
)@@G@@0     @^@@@@        X(FWST+7)=0     @[@@@@C     @C@@@@        SCR(1)=0 @PN
)@@G@@ NUMBER OF BEGINDATA CARDS=0  @E@@@@        SCR(2)=0 @ NUMBER OF BANKS OPO
)@@G@@N FIRST BEGINDATA CARD=0@F@@@@        FRONT=2                          @PP
)@@G@@ POINTER TO NFLD AREA.  @G@@@@        PTR=3                           @ PQ
)@@G@@FIRST BANK NAME STARTS IN SCR(@E@@@@        NDATAS=0                    PR
)@@G@@    @ NO BEGINDATAS YET.@^@@@@        SCR(LSCR)=0     @#@@@@        CN=LPS
)@@G@@SCR   @E@@@@100     CONTINUE @ START OF LOOP THROUGH BEGINDATA CARDS.   PT
)@@G@@@C@@@@        CONTNU=.FALSE. @NO CONTINUATION YET     @G@@@@        CALLPU
)@@G@@ S1LOOK(TEXT,$180) @ ASK S1CCFS FOR NEXT BEGINFATA CARD.    @[@@@@C     PV
)@@G@@@^@@@@        NDATAS=NDATAS+1 @G@@@@        NFLD=0                      PW
)@@G@@    @ NO FIELDS YET ON BEGINDATA CAR@C@@@@101     CALL S1BUF(TEXT,80,0) PX
)@@G@@@ SET UP S1SCAN.  @C@@@@        CALL S1OFST(16,$999) @ SKIP 16 COLUMNS. PY
)@@G@@@ @@@@        CALL S1SCAN(CHAR,$999)@#@@@@105     CONTINUE  @D@@@@      PZ
)@@G@@  TYPE=S1SPCT(CHAR) @ GET TYPE OF CHARACTER.    @F@@@@        IF(TYPE.EQQA
)@@G@@.1.OR.TYPE.EQ.2.OR.TYPE.EQ.7.OR.TYPE.EQ.12)     @D@@@@     1            QB
)@@G@@                       GO TO 110    @B@@@@        IF(TYPE.EQ.3.AND.CONTNQC
)@@G@@U)GO TO 172 @B@@@@        IF(TYPE.NE.4) GO TO 991 @ ILLEGAL @^@@@@C FOUNQD
)@@G@@D A PERIOD FIRST. @C@@@@        IF(NFLD.NE.0) GO TO 108 @ FIRST FIELD?  QE
)@@G@@@]@@@@C       YES.@^@@@@        SCR(PTR)='TPF$' @ @@@@        SCR(PTR+1)QF
)@@G@@='    '     @C@@@@        GO TO 120 @ READY FOR ELEMENT NAME.     @#@@@@QG
)@@G@@108     CONTINUE  @D@@@@C       GOT PERIOD WITH NO FILE, GET LAST FILE NQH
)@@G@@AME.  @ @@@@        SCR(PTR)=SCR(PTR-4)   @ @@@@        SCR(PTR+1)=SCR(PQI
)@@G@@TR-3) @C@@@@        GO TO 120 @ READY FOR ELEMENT NAME.     @#@@@@110   QJ
)@@G@@  CONTINUE  @C@@@@C       GOT THE FIRST CHARACTER OF A FILE NAME. @G@@@@QK
)@@G@@        CALL S1CBUF(SCR(PTR),12)@ SET UP ACCUMULATOR INTO FILENAME AREA.QL
)@@G@@@C@@@@111     CONTINUE @ FILE NAME ACCUMULATION LOOP  @D@@@@        CALLQM
)@@G@@ S1CADD(CHAR,$992) @ ACCUMULATE CHARACTER.@D@@@@        CALL S1SCAN(CHARQN
)@@G@@,$140) @ GET NEXT CHARACTER.  @F@@@@        TYPE=S1SPCT(CHAR) @ CHAR IS QO
)@@G@@TO BE CLASSIFIED AS TO TYPE.  @A@@@@C       IS IT LEGAL IN FILENAME?    QP
)@@G@@@F@@@@        IF(TYPE.EQ.1.OR.TYPE.EQ.2.OR.TYPE.EQ.7.OR.TYPE.EQ.12)     QQ
)@@G@@@D@@@@     1                                   GO TO 111    @A@@@@C     QR
)@@G@@  NO, IS IT LEGAL TERMINATION?@ @@@@        IF(TYPE.EQ.15.OR.     @G@@@@QS
)@@G@@     1  TYPE.EQ.3.OR.TYPE.EQ.5) GO TO 150   @ IF SO, IT IS ELEMENT NA   QT
)@@G@@@F@@@@        IF(TYPE.NE.4) GO TO 991    @ IF NOT PERIOD, YOU LOSE.     QU
)@@G@@@#@@@@120     CONTINUE  @D@@@@C       GOT THE FILE, LET'S GET THE ELEMENQV
)@@G@@T NAME.     @A@@@@        CALL S1CBUF(SCR(PTR+2),12)  @D@@@@        CALLQW
)@@G@@ S1SCAN(CHAR,$991) @ GET NEXT CHARACTER.  @ @@@@        TYPE= S1SPCT(CHAQX
)@@G@@R)    @F@@@@        IF(TYPE.EQ.1.OR.TYPE.EQ.2.OR.TYPE.EQ.7.OR.TYPE.EQ.12QY
)@@G@@)     @D@@@@     1                                   GO TO 121    @G@@@@QZ
)@@G@@        GO TO 991 @ IF IT AIN'T LEGAL IN ELEMENT NAME, IT AIN'T LEGAL HERA
)@@G@@@#@@@@121     CONTINUE  @C@@@@C       ANOTHER CHARACTER OF THE ELEMNT NARB
)@@G@@ME.   @F@@@@        CALL S1CADD(CHAR,$992) @ ADD T1E CHAR OT ELEMENT NAMRC
)@@G@@E.    @E@@@@        CALL S1SCAN(CHAR,$160) @ AND GET THE NEXT CHARACTER RD
)@@G@@@ @@@@        TYPE=S1SPCT(CHAR)     @F@@@@        IF(TYPE.EQ.1.OR.TYPE.ERE
)@@G@@Q.2.OR.TYPE.EQ.7.OR.TYPE.EQ.12)     @D@@@@     1                        RF
)@@G@@           GO TO 121    @#@@@@122     CONTINUE  @E@@@@        IF(TYPE.EQRG
)@@G@@.3) GO TO 170 @ END OF STRING - BLANK.    @A@@@@        IF(TYPE.NE.15)GORH
)@@G@@ TO 130     @#@@@@        PTR=PTR+4 @^@@@@        NFLD=NFLD+1     @^@@@@RI
)@@G@@        SCR(FRONT)=NFLD @G@@@@        CALL S1LOOK(TEXT,$123) @CONTINUED RJ
)@@G@@ON NEXT BEG DAT CARD..GET IT  @ @@@@        SCR(CN)=SCR(CN)+1     @E@@@@RK
)@@G@@        CONTNU=.TRUE.  @WE ARE NOW ON A CONTINUATION CARD   @F@@@@      RL
)@@G@@  GO TO 101 @ CONTINUE PROCESSING FROM NEXT BEGDAT CARD     @D@@@@123   RM
)@@G@@  CALL S1PCHD(2) @ NO NEXT BEGDAT CARD-IGNORE IT@#@@@@        PRINT 9123RN
)@@G@@@G@@@@9123    FORMAT(' ***** COLON USED AND IGNORED SINCE NO NEXT BEGINDRO
)@@G@@ATA ',@^@@@@     1  'CARD FOUND.')  @#@@@@        CN=CN-1   @#@@@@      RP
)@@G@@  SCR(CN)=0 @#@@@@        GO TO 180 @E@@@@130     IF(TYPE.NE.5) GO TO 99RQ
)@@G@@1 @ IF NOT COMMA YOU LOSE.    @G@@@@        PTR=PTR+4                   RR
)@@G@@     @ READY FOR NEXT ELEEMNT NAME. @D@@@@        NFLD=NFLD+1           RS
)@@G@@           @ NEW FIELD. @^@@@@        SCR(FRONT)=NFLD @C@@@@        CALLRT
)@@G@@ S1SKIP(CHAR,$991)@GOT NEXT CHAR.   @B@@@@        GO TO 105 @ TRY IT AS RU
)@@G@@FILE NAME.  @[@@@@C     @#@@@@140     CONTINUE  @D@@@@C       END OF CARRV
)@@G@@D IN FIRST NAME (ELT SPEC ONLY)     @#@@@@        TYPE=3    @#@@@@150   RW
)@@G@@  CONTINUE  @D@@@@C       COMMA,COLON OR BLANK AFTER ELEMENT NAME ONLY. RX
)@@G@@@E@@@@        SCR(PTR+2)=SCR(PTR)             @ FILENAME IS TPF$  @G@@@@RY
)@@G@@        SCR(PTR+3)=SCR(PTR+1)           @ AND ELEMENT NAME IS FILENAME. RZ
)@@G@@@^@@@@        SCR(PTR)='TPF$' @^@@@@        SCR(PTR+1)='   '@A@@@@      SA
)@@G@@  GO TO 122 @ END OF FILED.   @#@@@@160     CONTINUE  @B@@@@C       END SB
)@@G@@OF CARD AFTER ELEMENT NAME.   @ @@@@        TYPE=3 @ ASSUME BLANK.@#@@@@SC
)@@G@@170     CONTINUE  @A@@@@C       BLANK AFTER ELEMENT NAME.   @#@@@@      SD
)@@G@@  PTR=PTR+4 @^@@@@        NFLD=NFLD+1     @^@@@@        SCR(FRONT)=NFLD SE
)@@G@@@#@@@@172     FRONT=PTR @F@@@@        PTR=PTR+1                        @SF
)@@G@@ SPACE FOR NFLD AREA    @E@@@@        SCR(FRONT)=0                    @ SG
)@@G@@NO FIELDS YET.    @#@@@@        CN=CN-1   @#@@@@        SCR(CN)=0 @G@@@@SH
)@@G@@        GO TO 100                        @ GET NEXT BEGINDATA CARD.     SI
)@@G@@@#@@@@180     CONTINUE  @D@@@@C       DONE WITH THE TEXT OF THE BEGINDATSJ
)@@G@@A CARDS.    @A@@@@        IF(NDATAS.EQ.0) GO TO 993   @B@@@@        IF(PSK
)@@G@@TR.EQ.3) RETURN @ NO NAMES.   @#@@@@        PTR=PTR-1 @#@@@@        CN=CSL
)@@G@@N+1   @ @@@@        IF(CN.LT.PTR)GO TO 999@^@@@@        M=LSCR-CN+1     SM
)@@G@@@C@@@@        CALL S1STFT('BGCN',FWCN,1,M+1,$999)     @#@@@@        X(FWSN
)@@G@@CN)=1 @^@@@@        DO 189 I=1,M    @A@@@@        X(FWCN+I)=SCR(LSCR-I+1SO
)@@G@@)     @#@@@@  189   CONTINUE  @^@@@@        SCR(1)=NDATAS   @G@@@@      SP
)@@G@@  CALL S1STFT('STJFIL',FWFN,1,PTR,$999) @ PLACE TO STORE THESE.   @C@@@@SQ
)@@G@@C       MOVE FILE NAMES INTO TAGGED STORAGE.    @^@@@@        DO 190 I=1SR
)@@G@@,PTR  @ @@@@        X(FWFN+I-1)=SCR(I)    @#@@@@190     CONTINUE  @^@@@@SS
)@@G@@        NDATAS=X(FWFN)  @#@@@@        PTR=FWFN+1@ @@@@        DO 230 NI=ST
)@@G@@1,NDATAS    @^@@@@        NFLD=X(PTR)     @#@@@@        PTR=PTR+1 @#@@@@SU
)@@G@@      NOBTOT=0    @^@@@@        DO 220 NJ=1,NFLD@[@@@@C     @G@@@@C     SV
)@@G@@  LOOP THROUGH ALL STJBANKS, CREATINF TAGS AND CHECKING MATCHES.  @[@@@@SW
)@@G@@C     @^@@@@        FILECL=.FALSE.  @D@@@@      CALL S1CKBA(X(PTR),$249,SX
)@@G@@'IN',X(FWFN),XUSED)     @E@@@@      IF(X(FWST+7) .EQ. 0  .AND.  XUSED .NSY
)@@G@@E. 0) X(FWST+7)=1 @E@@@@        CALL S1SJIT(X(PTR),X(PTR+2),FILECD,HEADESZ
)@@G@@R,$249)     @^@@@@        FILECL=.TRUE.   @^@@@@C       FILE IS OPEN    TA
)@@G@@@B@@@@        IF(NJ.NE.NI.OR.NI.NE.1) GO TO 210 @A@@@@C       FIRST ONLYTB
)@@G@@ INITIALIZATION.  @^@@@@C       SET UP STJBIN   @A@@@@        X(FWST)=HETC
)@@G@@ADER(3) @ OBS     @^@@@@      NOBTOT=HEADER(3)  @E@@@@        X(FWST+1)=TD
)@@G@@HEADER(5) @ NUMBER OF ORIGINAL VARIABLES. @D@@@@        X(FWST+2)=HEADERTE
)@@G@@(4) @ NUMBER OF EMPTY SLOTS   @D@@@@        X(FWST+3)=0 @ EMPTY SLOTS USTF
)@@G@@ED. SET BY OTHERS.@F@@@@        X(FWST+4)=HEADER(23) @ K - NUMBER OF OBSTG
)@@G@@ PER INPUT BLOCK. @[@@@@C     @ @@@@C SET UP FIRST DATA SET LABEL @C@@@@TH
)@@G@@C  THE DATA SET LABELS DO NOT NEED TO MATCH.    @B@@@@        CALL S1STFTI
)@@G@@T('FSTDSL',FW,1,11,$999)@^@@@@        DO 181 I=1,11   @A@@@@        X(FWTJ
)@@G@@+I-1) = HEADER(7+I)     @#@@@@181     CONTINUE  @C@@@@        CALL S1GTATK
)@@G@@G('NVARS',FWNV,NEL,NEL,$999)  @#@@@@        MDATA=0   @B@@@@        IF(HTL
)@@G@@EADER(25).EQ.0) GO TO 184     @#@@@@        MDATA=1   @C@@@@        CALLTM
)@@G@@ S1GTAG('MDATA',FWM,DUM,DUM,$182)   @#@@@@        GO TO 184 @#@@@@182   TN
)@@G@@  CONTINUE  @C@@@@        CALL S1GVAL('CCPFG',CCPFG,$999,$999)    @F@@[@TO
)@@G@@        IF(CCPFG.EQ.9.OR.CCPFG.EQ.20.OR.CCPFG.EQ.10)GO TO 184     @A@@[@TP
)@@G@@        IF(CCPFG.EQ.21)GO TO 184    @B[@@@        CALL S1STFT('MDATA',FWTQ
)@@G@@M,1,1,$999) @A@@@@        X(FWM)=1 @ MISSING DATA     @A@@@@        IF(NTR
)@@G@@EWCW.EQ.0) GO TO 185    @#@@@@        MPTR=1    @#@@@@183     CONTINUE  TS
)@@G@@@C@@@@        IF(CWSP(MPTR).EQ.'MDATA') GO TO 184     @^@@@@        MPTRTT
)@@G@@=MPTR+6     @B@@@@        IF(CWSP(MPTR-1).NE.0) MPTR=MPTR+4 @^@@@@      TU
)@@G@@  NEWCW=NEWCW-1   @A@@@@        IF(NEWCW.GT.0) GO TO 183    @#@@@@185   TV
)@@G@@  CONTINUE  @ @@@@        CALL S1SJER(X(FWFN))  @^@@@@        CALL S1PCHTW
)@@G@@D(2)  @#@@@@        PRINT 1851@G@@@@1851    FORMAT(' ***** WARNING: THE TX
)@@G@@INPUT STJBANK WAS CREATED WITH '    @G@@@@     1  ,'MISSING DATA. THIS PTY
)@@G@@ROGRAM DOES NOT HANDLE MISSING DATA.'/    @E@@@@     2  ' ***** MISSING TZ
)@@G@@VALUES WILL BE TREATED AS ZERO.')   @#@@@@184     CONTINUE  @A@@@@      UA
)@@G@@  X(FWNV)=HEADER(2) @ NVARS   @^@@@@        NVARS=X(FWNV)   @@@@@@@D@@@@UB
)@@G@@        P=NVARS+X(FWST+2) @ TOTAL NUMBER OF SLOTS     @F@@@@        CALLUC
)@@G@@ S1STFT('VNAMES',FWVN,2,P,$999) @ CREATE VNAMES ARRAY @F@@@@        CALLUD
)@@G@@ S1STFT('FMTLST',FWFM,2,P,$999) @ AND FORMAT AREA.    @^@@@@        J=(NUE
)@@G@@VARS*2)-1   @ @@@@        K=(P-NVARS*2)+J-1     @^@@@@        DO 1841 I=UF
)@@G@@J,K   @^@@@@        X(FWVN+I)=0     @#@@@@1841    CONTINUE  @]@@@@      UG
)@@G@@  K=1 @#@@@@        J=NVARS   @A@@@@        IF(J*14.LT.LSCR) GO TO 186  UH
)@@G@@@#@@@@        D=LSCR/14 @#@@@@        J=K+D-1   @#@@@@186     CONTINUE  UI
)@@G@@@B@@@@        CALL S1SJLD(FILECD,K,J,SCR,$250)  @^@@@@        DO 200 I=KUJ
)@@G@@,J    @^@@@@      IPTR=(I-K)*14     @^@@@@        FPTR=(I-1)*2    @C@@@@UK
)@@G@@        X(FWVN+FPTR)=SCR(1+IPTR+1) @ VNAME1     @C@@@@        X(FWVN+FPTUL
)@@G@@R+1)=SCR(1+IPTR+2)@VNAME2     @A@@@@        FLD(0,18,X(FWFM+FPTR))=1    UM
)@@G@@@A@@@@        FLD(18,18,X(FWFM+FPTR  ))=1 @A@@@@        FLD(24,12,X(FWFMUN
)@@G@@+FPTR+1))=0 @D@@@@        IF(SCR(1+IPTR).NE.0) GO TO 195 @ ALPHANUMERIC?UO
)@@G@@@#@@@@C       NUMERIC   @A@@@@        FLD(0,18,X(FWFM+FPTR+1))=8  @A@@@@UP
)@@G@@        FLD(18,6,X(FWFM+FPTR+1))=3  @#@@@@        GO TO 199 @[@@@@C     UQ
)@@G@@@#@@@@195     CONTINUE  @^@@@@C       ALPHANUMERIC    @C@@@@        FLD(UR
)@@G@@0,18,X(FWFM+FPTR+1))=SCR(1+IPTR)    @A@@@@        FLD(18,6,X(FWFM+FPTR+1US
)@@G@@))=6  @[@@@@C     @#@@@@199     CONTINUE  @#@@@@200     CONTINUE  @A@@@@UT
)@@G@@        IF(J.EQ.NVARS) GO TO 187    @#@@@@        K=J+1     @ @@@@      UU
)@@G@@  J=MIN(NVARS,K+D-1)    @#@@@@      GO TO 186   @#@@@@187     CONTINUE  UV
)@@G@@@#@@@@        GO TO 219 @ @@@@C       NOT THE FIRST PASS    @#@@@@210   UW
)@@G@@  CONTINUE  @ @@@@      NOBTOT=NOBTOT+HEADER(3) @C@@@@        IF(X(FWST+UX
)@@G@@1).EQ.HEADER(5)) GO TO 211    @D@@@@C       NUMBER OF ORIGINAL VARIABLESUY
)@@G@@ DOES NOT MATCH.  @ @@@@        IF(ORIGER) GO TO 211  @B@@@@C       ONLYUZ
)@@G@@ PRINT EACH MESSAGE ONCE.     @ @@@@        CALL S1SJER(X(FWFN))  @^@@@@VA
)@@G@@        CALL S1PCHD(1)  @#@@@@        PRINT 2100@G@@@@2100    FORMAT(' *VB
)@@G@@**** NUMBER OF ORIGINAL VARIABLES IN STJBANK IS NOT'  @C@@@@     1,' IDEVC
)@@G@@NTICAL FOR ALL INPUT STJBANKS')     @^@@@@        NERR=NERR+1     @^@@@@VD
)@@G@@        ORIGER=.TRUE.   @#@@@@211     CONTINUE  @C@@@@        IF(X(FWST+VE
)@@G@@2).EQ.HEADER(4)) GO TO 212    @C@@@@C       NUMBER OF RESERVED SLOTS DO VF
)@@G@@NOT MATCH.  @ @@@@        IF(NSLOTR) GO TO 212  @ @@@@        CALL S1SJEVG
)@@G@@R(X(FWFN))  @^@@@@        CALL S1PCHD(1)  @#@@@@        PRINT 2110@G@@@@VH
)@@G@@2110    FORMAT(' ***** NUMBER OF AVAILABLE SLOTS IN STJBANK IS NOT ',   VI
)@@G@@@B@@@@     1 'IDENTICAL IN ALL INPUT STJBANKS') @^@@@@        NERR=NERR+VJ
)@@G@@1     @^@@@@        NSLOTR=.TRUE.   @#@@@@212     CONTINUE  @B@@@@      VK
)@@G@@  IF(X(FWNV).EQ.HEADER(2)) GO TO 213@ @@@@C       NVARS NOT MATCHED.    VL
)@@G@@@G@@@@        X(FWNV)=MAX(X(FWNV),HEADER(2)) @ SET TO LARGEST VALUE FOR VM
)@@G@@CC CHE@ @@@@        IF(NVARER) GO TO 213  @ @@@@        CALL S1SJER(X(FWVN
)@@G@@FN))  @^@@@@        CALL S1PCHD(1)  @#@@@@        PRINT 2120@G@@@@2120  VO
)@@G@@  FORMAT(' ***** NUMBER OF VARIABLES IN STJBANK IS NOT IDENTICAL I@ @@@@VP
)@@G@@     1N ALL INPUT STJBANKS.') @^@@@@        NERR=NERR+1     @^@@@@      VQ
)@@G@@  NVARER=.TRUE.   @#@@@@213     CONTINUE  @]@@@@        K=1 @#@@@@      VR
)@@G@@  J=NVARS   @A@@@@        IF(J*14.LT.LSCR) GO TO 2131 @#@@@@        D=LSVS
)@@G@@CR/14 @#@@@@        J=K+D-1   @#@@@@2131    CONTINUE  @C@@@@        CALLVT
)@@G@@ S1SJLD(FILECD,K,J    ,SCR,$250)    @^@@@@        DO 216 I=K,J    @^@@@@VU
)@@G@@      IPTR=(I-K)*14     @^@@@@        FPTR=(I-1)*2    @F@@@@        IF(XVV
)@@G@@(FWVN+FPTR).EQ.SCR(1+IPTR+1).AND.X(FWVN+FPTR+1).EQ.   @A@@@@     1    SCVW
)@@G@@R(1+IPTR+2)) GO TO 214  @ @@@@        IF(VNAMER) GO TO 214  @ @@@@      VX
)@@G@@  CALL S1SJER(X(FWFN))  @^@@@@        CALL S1PCHD(1)  @#@@@@        PRINVY
)@@G@@T 2130@G@@@@2130    FORMAT(' ***** VARIABLE NAMES FOR ALL VARIABLES DO NVZ
)@@G@@OT MATCH ', @A@@@@     1   'FOR ALL INPUT STJBANKS.') @^@@@@        NERRWA
)@@G@@=NERR+1     @^@@@@        VNAMER=.TRUE.   @#@@@@214     CONTINUE  @G@@@@WB
)@@G@@        IF(SCR(1+IPTR).EQ.0.AND.FLD(18,6,X(FWFM+FPTR+1)).EQ.3) GO TO 215WC
)@@G@@@G@@@@        IF(SCR(1+IPTR).NE.0.AND.FLD(0,18,X(FWFM+FPTR+1)).EQ. SCR(1WD
)@@G@@+IPTR)@ @@@@     1          )GO TO 215    @G@@@@        IF(SCR(1+IPTR).NWE
)@@G@@E.0.AND.FLD(18,6,X(FWFM+FPTR+1)).EQ.6)GO TO 215 @ @@@@        IF(TYPEER)WF
)@@G@@ GO TO 215  @ @@@@        CALL S1SJER(X(FWFN))  @^@@@@        CALL S1PCHWG
)@@G@@D(1)  @#@@@@        PRINT 2140@G@@@@2140    FORMAT(' ***** TYPES OF ALL WH
)@@G@@VARIABLES DO NOT MATCH FOR ALL INPUT@#@@@@     1 STJBANKS.')@^@@@@      WI
)@@G@@  NERR=NERR+1     @^@@@@        TYPEER=.TRUE.   @#@@@@215     CONTINUE  WJ
)@@G@@@#@@@@216     CONTINUE  @A@@@@        IF(J.EQ.NVARS) GO TO 217    @#@@@@WK
)@@G@@        K=J+1     @ @@@@        J=MIN(NVARS,K+D-1)    @#@@@@        GO TWL
)@@G@@O 2131@#@@@@217     CONTINUE  @B@@@@        IF(MDATA.EQ.HEADER(25)) GO TWM
)@@G@@O 218 @^@@@@C MDATA DOES NOT MATCH  @ @@@@        IF(MDATAR) GO TO 218  WN
)@@G@@@ @@@@        CALL S1SJER(X(FWFN))  @^@@@@        CALL S1PCHD(1)  @#@@@@WO
)@@G@@        PRINT 2170@G@@@@2170    FORMAT(' ***** SOME BUT NOT ALL INPUT STWP
)@@G@@JBANKS HAVE MISSING ',  @^@@@@     1     'DATA.')     @^@@@@        NERRWQ
)@@G@@=NERR+1     @^@@@@        MDATAR=.TRUE.   @#@@@@218     CONTINUE  @[@@@@WR
)@@G@@C     @#@@@@        GO TO 219 @#@@@@249     CONTINUE  @^@@@@        NERRWS
)@@G@@=NERR+1     @#@@@@250     CONTINUE  @[@@@@C     @#@@@@219     CONTINUE  WT
)@@G@@@ @@@@C       DONE WITH AN STJBANK. @E@@@@        IF(FILECL)CALL S1SJIC(WU
)@@G@@FILECD,$999) @ CLOSE THE FILE @#@@@@        PTR=PTR+4 @#@@@@220     CONTWV
)@@G@@INUE  @A@@@@      X(FWST)=MAX(X(FWST),NOBTOT)   @B@@@@C       DONE WITH WW
)@@G@@ONE BEGINDATA CARD.     @#@@@@230     CONTINUE  @ @@@@C       DONE WITH WX
)@@G@@ALL STJBANKS@E@@@@        IF(ORIGER.OR.NSLOTR.OR.NVARER.OR.TYPEER)X(FWSTWY
)@@G@@+6)=1 @^@@@@          K=HEADER(23)  @D@@@@      CALL S1STRS('BUFFER',10,WZ
)@@G@@(K*NVARS+9)/10,$999)    @[@@@@C     @A@@@@C       CHECK FOR DUPLICATE BAXA
)@@G@@NKS   @[@@@@C     @^@@@@        NDATAS=X(FWFN)  @#@@@@        PTR=FWFN+1XB
)@@G@@@ @@@@        DO 330 NI=1,NDATAS    @^@@@@        NFLD=X(PTR)     @#@@@@XC
)@@G@@        PTR=PTR+1 @^@@@@        DO 320 NJ=1,NFLD@[@@@@C     @[@@@@C     XD
)@@G@@@#@@@@        KPTR=PTR+4@A@@@@        IF(NJ.EQ.NFLD) GO TO 310    @#@@@@XE
)@@G@@        K=NJ+1    @^@@@@        DO 307 J=K,NFLD @^@@@@        DO 305 II=XF
)@@G@@0,3   @C@@@@        IF(X(PTR+II).NE.X(KPTR+II)) GO TO 306   @#@@@@305   XG
)@@G@@  CONTINUE  @A@@@@        X(FWST+5)=1 @ DUP FOUND     @#@@@@306     CONTXH
)@@G@@INUE  @^@@@@        KPTR=KPTR+4     @#@@@@307     CONTINUE  @#@@@@310   XI
)@@G@@  CONTINUE  @A@@@@        IF(NI.EQ.NDATAS) GO TO 319  @#@@@@        IJ=NXJ
)@@G@@I+1   @ @@@@        DO 315 J=IJ,NDATAS    @^@@@@        KFLD=X(KPTR)    XK
)@@G@@@^@@@@        KPTR=KPTR+1     @^@@@@        DO 314 I=1,KFLD @^@@@@      XL
)@@G@@  DO 312 II=0,3   @C@@@@        IF(X(PTR+II).NE.X(KPTR+II))GO TO 313    XM
)@@G@@@#@@@@312     CONTINUE  @A@@@@        X(FWST+5)=1 @ DUP FOUND     @#@@@@XN
)@@G@@313     CONTINUE  @^@@@@        KPTR=KPTR+4     @#@@@@314     CONTINUE  XO
)@@G@@@#@@@@315     CONTINUE  @#@@@@319     CONTINUE  @#@@@@        PTR=PTR+4 XP
)@@G@@@#@@@@320     CONTINUE  @#@@@@330     CONTINUE  @#@@@@        RETURN    XQ
)@@G@@@[@@@@C     @[@@@@C     @#@@@@991     CONTINUE  @^@@@@        CALL S1PCHXR
)@@G@@D(3)  @A@@@@        PRINT 9910,(TEXT(I),I=1,14) @F@@@@9910    FORMAT(' *XS
)@@G@@**** ILLEGAL SPECIAL CHARACTER USAGE ON THIS',  @D@@@@     1    ' BEGINDXT
)@@G@@ATA CARD:'/' *****',1X,13A6,A2)     @#@@@@9911    CONTINUE  @^@@@@      XU
)@@G@@  CALL S1WHR(COL) @#@@@@        COL=COL+7 @ @@@@        ENCODE(FMT,9912)XV
)@@G@@COL   @B@@@@9912    FORMAT('(6H *****,T',I3,',1H*)')  @#@@@@        PRINXW
)@@G@@T FMT @^@@@@        NERR=NERR+1     @#@@@@        GOTO 170  @#@@@@992   XX
)@@G@@  CONTINUE  @^@@@@        CALL S1PCHD(3)  @A@@@@        PRINT 9920,(TEXTXY
)@@G@@(I),I=1,14) @G@@@@9920    FORMAT(' ***** TOO MANY CHARACTERS IN FILE OR XZ
)@@G@@ELEMENT NAME '    @D@@@@     1 ,'ON THIS BEGINDATA CARD:'/' ***** ',13A6YA
)@@G@@,A2)  @#@@@@        GO TO 9911@#@@@@993     CONTINUE  @^@@@@        CALLYB
)@@G@@ S1PCHD(1)  @#@@@@        PRINT 9930@G@@@@9930    FORMAT(' ***** NO BEGIYC
)@@G@@NDATA CARD FOUND. NUMBER AND TYPES OF ',  @ @@@@     1   'VARIABLES UNKNYD
)@@G@@OWN.')@^@@@@        NERR=NERR+1     @#@@@@        RETURN    @#@@@@999   YE
)@@G@@  CONTINUE  @ @@@@        CALL S1SERR('S1SJBD') @]@@@@        END ___   YF
)@@G@@  IF(FILECL)CALL S1SJIC(FILECD,$999) @ CLOSE THE FILE @#@@@@        PTR=YG
)@@G@@*[@@@@*SDFF*@ @@@@      SUBROUTINE S1ZFMT(MODE) @ @@@@      IMPLICIT INTYH
)@@G@@EGER (A-Z)  @ @@@@      COMMON/S1ZZZZ/CB(500)   @ @@@@        COMMON/S1ZYI
)@@G@@XXZ/LINO    @F@@@@        COMMON /S1CNTL / DEMAND,PAPERS,LINENO,PAGENO,CYJ
)@@G@@CLIST,RECLST@C@@[@      EQUIVALENCE(STMTLC,CB(77)),(ERRSW,CB(76)) @^[@@@YK
)@@G@@      DATA STMTLC/1/    @#@@@@      INTEGER CHAR@#@@@@      FIRST=STMTLCYL
)@@G@@@^@@@@      CALL S1WHR(LAST)  @#@@@@      STMTLC=0    @A@@@@      IF(MODYM
)@@G@@E.EQ.0) STMTLC=LAST     @#@@@@      LAST=LAST-1 @ @@[@      IF(MODE.EQ.0YN
)@@G@@)ERRSW=0    @ @@@@      IF(FIRST.EQ.0) RETURN   @ @@@@      IF(LAST.LE.FYO
)@@G@@IRST) RETURN@ @@@@      CALL S1BACK(FIRST,$9)   @^@@@@      CALL DUMPST(YP
)@@G@@0)    @]@@@@      BSW=0 @^@@@@      DO 1 I=FIRST,LAST @ @@@@      CALL SYQ
)@@G@@1SCAN(CHAR,$9)    @B@@@@      IF(BSW.EQ.0.AND.CHAR.EQ.' ') GOTO 1 @]@@@@YR
)@@G@@      BSW=1 @^@@@@      CALL DUMPST(CHAR) @#@@@@1     CONTINUE    @^@@@@YS
)@@G@@      CALL DUMPST(1)    @]@@@@11    RETURN@#@@@@9     CB(4)=25    @]@@@@YT
)@@G@@      RETURN@ @@@@      SUBROUTINE DUMPST(CHAR) @[@@@@C     @^@@@@C*****YU
)@@G@@*************     @[@@@@C     @ @@@@      IMPLICIT INTEGER(A-Z)   @^@@@@YV
)@@G@@      DIMENSION LINE(18)@A@@@@      DATA (LINE(I),I=1,18)/18*' '/ @#@@@@YW
)@@G@@      DATA LINO/0/@A@@@@91    FORMAT(18X,I3,3H:  ,18A6)     @#@@@@      YX
)@@G@@  INTEGER I @ @@@@      IF(CHAR.EQ.0) GOTO 21   @ @@@@      IF(CHAR.EQ.1YY
)@@G@@) GOTO 22   @A@@@@          IF(CPTR.LT.18*6)GO TO 12  @A@@@@        IF(CYZ
)@@G@@CLIST.EQ.0) GO TO 13    @^@@@@        CALL S1PCHD(1)  @B@@@@      PRINT ZA
)@@G@@91, LINO, (LINE(I), I=1,18)   @#@@@@      DO 11 I=1,18@#@@@@11    LINE(IZB
)@@G@@)=' ' @#@@@@13      CONTINUE  @#@@@@          CPTR=0  @#@@@@12        COZC
)@@G@@NTINUE@^@@@@          CPTR=CPTR+1   @B@@@@          CALL S1PRST(LINE(1),ZD
)@@G@@CPTR,CHAR)  @]@@@@      RETURN@#@@@@21        CONTINUE@#@@@@          CPZE
)@@G@@TR=0  @#@@@@      LINO=LINO+1 @^@@@@      DO 211 I=1,18     @#@@@@211   ZF
)@@G@@LINE(I)=' ' @]@@@@      RETURN@#@@@@22      CONTINUE  @ @@@@        CALLZG
)@@G@@ S1WHR(ITEMP)     @A@@@@          CALL S1SCAN(TCHAR,$23)    @ @@@@      ZH
)@@G@@  CALL S1BACK(ITEMP,$92)@A@@@@          IF(TCHAR.NE.'$')GO TO 23  @D@@@@ZI
)@@G@@C         LAST STATEMNT SHOULDNT'T HAVE TRAILING COMMA@B@@@@          CAZJ
)@@G@@LL S1PRST(LINE(1),CPTR,' ')   @#@@@@23        CONTINUE@ @@@@      IF(CCLZK
)@@G@@IST.EQ.0) GO TO 24@^@@@@        CALL S1PCHD(1)  @B@@@@        PRINT 91,LZL
)@@G@@INO,(LINE(I),I=1,18)    @#@@@@24    CONTINUE    @]@@@@      RETURN@C@@@@ZM
)@@G@@92      CALL S1SERR('S1ZFMT. S1SCAN PROBLEM.')  @]@@@@      END   ___@@@ZN
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ZO
)@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ZP
)@@G@@*[@@@@*SDFF*@^@@@@        COMPILER (FLD=T)@C@@@@      INTEGER FUNCTION SZQ
)@@G@@1ZST(TT,MAXT,VVV,TTT)   @[@@@@C     @ @@@@      IMPLICIT INTEGER (A-Z)  ZR
)@@G@@@G@@@@      COMMON/S1ZZZZ/ VOID1(35), HIGH, LOW, VOID2(57), LOOP(6), QZQZS
)@@G@@(400) @^@@@@      COMMON TAG(100)   @^@@@@      COMMON/S1ZXXZ/LINO@ @@@@ZT
)@@G@@      COMMON/S1ZJDY/NIODR     @B@@@@        EQUIVALENCE(TSTFLG,VOID2(28)ZU
)@@G@@)     @A@@@@      EQUIVALENCE(VNAMES,VOID2(29)) @A@@@@      EQUIVALENCE(ZV
)@@G@@TVNAME,VOID2(31)) @A@@@@      EQUIVALENCE (ERRSW,VOID2(39)) @^@@@@      ZW
)@@G@@DIMENSION TT(10)  @ @@@@          DIMENSION KEY(2)    @A@@@@      DEFINEZX
)@@G@@       RESULT=S1ZST     @ @@@@      DEFINE       T(X)=TT(X) @A@@@@      ZY
)@@G@@DEFINE    MAJOR(X)=FLD(0,12,X)@B@@@@      DEFINE    MINOR(X)=FLD(12,12,XZZ
)@@G@@)     @A@@@@      DEFINE    ADDR(X)=FLD(24,12,X)@A@@@@      DEFINE FLAG(AA
)@@G@@X)=FLD(0,6,X)     @A@@@@      DEFINE XVAL(X)=FLD(6,12,X)    @A@@@@      AB
)@@G@@DEFINE KIND(X)=FLD(18,3,X)    @A@@@@      DEFINE SPACE(X)=FLD(21,3,X)   AC
)@@G@@@B@@@@      DEFINE LOCATE(X)=S1ZOOM(X,TT,LOW,3) @D@@@@      DEFINE      AD
)@@G@@ NAME(X)=S1ZMKN(6HSOURCE,T(X),0)    @B@@@@      DEFINE       SYMBOL(X)=TAE
)@@G@@(T(X+2))    @C@@@@      DEFINE    SLINKS(X)=T(ADDR(T(X+2))+2)     @^@@@@AF
)@@G@@      DEFINE  SLACK=6   @B@@@@        DEFINE RANK(X)=FLD(33,3,T(X+1))   AG
)@@G@@@B@@@@        DEFINE EXPL(X)=FLD(32,1,T(X+1))   @B@@@@        DEFINE IMPAH
)@@G@@L(X)=FLD(31,1,T(X+1))   @ @@@@C         SYMBOL TABLE FORMAT @[@@@@C     AI
)@@G@@@G@@@@C         THERE ARE TWO AREAS OF THE SYMBOL TABLE, THE LOW AND THEAJ
)@@G@@ HIGH.@G@@@@C         THE LOW ADDRESSES, FROM 1 TO *LOW*, ARE 3 WORD ENTAK
)@@G@@RIES OF DESC@G@@@@C         RIPTORS, AND THE HIGH ADDRESSES (FROM *HIGH*AL
)@@G@@ TO *TOP*) ARE THE@B@@@@C         NAME ENTRIES. (ALSO 3 WORDS)    @[@@@@AM
)@@G@@C     @^@@@@C         LOW ENTRIES:  @[@@@@C     @A@@@@C         WORD 1 IAN
)@@G@@S A DESCRIPTOR.   @G@@@@C                   BITS 0-5  - FLAG - SIGN OF CAO
)@@G@@ONSTANT IN SUBSCRIPT.   @C@@@@C                                       1=AP
)@@G@@-, 0=+@G@@@@C                   BITS 6-17 - XVAL - CONSTANT MAGNITUDE FOAQ
)@@G@@R SUBSCRIPT @D@@@@C                   BITS 18-20 - KIND - TYPE OF VALUE.AR
)@@G@@@F@@@@C                                       0=FLOATING POINT NUMBER.  AS
)@@G@@@E@@@@C                                       1=INTEGER NUMBER    @B@@@@AT
)@@G@@C                                       2=@E@@@@C                       AU
)@@G@@                3=ALPHABETIC NUMBER @E@@@@C                             AV
)@@G@@          7=UNKNOWN TYPE.     @G@@@@C                   BITS 21-23 - SPAAW
)@@G@@CE - LOCATION OR TYPE OF VARIABLE.  @F@@@@C                             AX
)@@G@@          0=V - INPUT VARIABLE.     @F@@@@C                             AY
)@@G@@          1=TV - OUTPUT VARIABLE.   @D@@@@C                             AZ
)@@G@@          2=CONSTANT    @E@@@@C                                       3=BA
)@@G@@RESULT LOCATIONS  @G@@@@C                                       4=INTERNBB
)@@G@@AL TEMPORARY VARIABLE   @E@@@@C                                       5=BC
)@@G@@TABLE FOR RECODE. @G@@@@C                                       6=J ARRABD
)@@G@@Y( PARAMETER TO SUBROUTI@[@@@@C     @G@@@@C                   BITS 24-35BE
)@@G@@ - ADDR - DISPLACEMENT, PART OF REFERENCE @[@@@@C     @A@@@@C         WOBF
)@@G@@RD 2 IS A FLAG WORD     @C@@@@C                   0=UNDEFINED, 1=DEFINEDBG
)@@G@@.     @I@@@@C                   EXPL , BIT 32   =1, EXPLICITLY NAMES, =0BH
)@@G@@, NOT EXPLICITLY NAM    @G@@@@C         WORD3 IS A POINTER TO THE HIGH EBI
)@@G@@NTRY FOR THIS LOW ENTRY, BITS @B@@@@C         18-35. UPPER HALF IS UNUSEBJ
)@@G@@D.    @[@@@@C     @^@@@@C         HIGH ENTRY:   @[@@@@C     @G@@@@C     BK
)@@G@@    WORDS 1-2 ARE THE TWELVE CHARACTER FIELDATA NAME OF THE VARIAB@G@@@@BL
)@@G@@C                   OR THE VALUE OF THE CONSTANT IN THE FIRST WORD, AND BM
)@@G@@@C@@@@C                   THE SECOND WORD IS ZERO.    @G@@@@C         WOBN
)@@G@@RD 3 IS THE POINTER TO THE LOW ENTRY FOR THIS HIGH ENTRY.   @G@@@@C     BO
)@@G@@              IF BITS 0-11 ARE NON-ZERO THIS IS A OPERATOR ENTRY, @ @@@@BP
)@@G@@C                   SEE BELOW.@[@@@@C     @A@@@@C         OPERATOR ENTRYBQ
)@@G@@ LOW AREA.  @#@@@@C         WORD 1 :@F@@@@C                   BITS 0-11 BR
)@@G@@- FIRST OPERATOR CATEGORY NUMBER.   @F@@@@C                   BITS 12-23BS
)@@G@@ - SECOND OPERATOR CATEGORY NUMBER. @D@@@@C                   BITS 24-35BT
)@@G@@ - PRECEDENCE TABLE 1   @B@@@@C         WORD 2 -  PRECEDENCE TABLE 2.   BU
)@@G@@@E@@@@C         WORD 3 - POINTER TO HIGH AREA. LOWER 18 BITS.     @[@@@@BV
)@@G@@C     @A@@@@C         OPERATOR ENTRY HIGH AREA. @[@@@@C     @B@@@@C     BW
)@@G@@    WORDS 1-2 SYMBOL FOR A OPERATOR.@E@@@@C         WORD 3    - BITS 0-1BX
)@@G@@1 POINTER TO LOW AREA ENTRY.  @B@@@@C                   BITS 12-35 UNUSEBY
)@@G@@D.    @[@@@@C     @B@@@@C       RECODE TABLE NAME ENTRY FORMAT    @#@@@@BZ
)@@G@@C       LOW ENTRY @ @@@@C                   WORD 1.   @B@@@@C           CA
)@@G@@        BITS 0-17 - UNUSED.   @F@@@@C                   BITS 18-20, P, 0CB
)@@G@@=NTON,1=NTOA,2=ATON,3=ATOA.   @D@@@@C                   BITS 21-23, 5, TCC
)@@G@@ABLE NAME ENTRY.  @G@@@@C                   BITS 24-35, TABLEX, SEQUENTICD
)@@G@@AL NUMBER OF THIS TABLE.@ @@@@C                   WORD 2.   @F@@@@C     CE
)@@G@@              BITS 0-17 - STATMENT NUMBER THAT TABLE WAS IN.@H@@@@C     CF
)@@G@@              BITS 18-35, LOC- CHARACTER NUMBER OF STATEMENT START.     CG
)@@G@@@G@@@@C                                       POINTS AT CHAR AFTER SLASHCH
)@@G@@.     @C@@@@C                   WORD3 POINTS AT HIGH ENTRY. @#@@@@C     CI
)@@G@@  HIGH ENTRY@G@@@@C                   WORDS 1-2, TABLE NAME OR .TABLEX WCJ
)@@G@@HERE X IS NUMBER. @C@@@@C                   WORD 3, POINTS AT LOW ENTRY CK
)@@G@@@#@@@@      VARS=VVV    @#@@@@      TVARS=TTT   @]@@@@      LOW=-2@#@@@@CL
)@@G@@      TOP=MAXT    @#@@@@      HIGH=TOP+1  @^@@@@      DO 91 I=1,TOP     CM
)@@G@@@]@@@@91    T(I)=0@#@@@@      RESULT=0    @]@@@@      RETURN@^@@@@      CN
)@@G@@ENTRY S1ZQQQ(QQQ) @[@@@@C     @^@@@@C******************     @[@@@@C     CO
)@@G@@@D@@@@C       PASS EXTRA SPACE IN SYMBOL TABLE TO S1ZLOP.   @[@@@@C     CP
)@@G@@@A@@@@        IF(TSTFLG.EQ.2) CALL DUMP   @B@@@@      CALL S1ZLOP(TT(LOWCQ
)@@G@@+3),TOP-LOW-3)    @#@@@@      RESULT=QQQ  @]@@@@      RETURN@ @@@@      CR
)@@G@@ENTRY S1ZSYM(SW,A,B,C,D)@[@@@@C     @^@@@@C******************     @[@@@@CS
)@@G@@C     @ @@@@      GOTO(11,12,13,14,15),SW @B@@@@C ... LOOKUP A SOURCE NACT
)@@G@@ME IN THE TABLE   @[@@@@C     @#@@@@11        CONTINUE@#@@@@          KECU
)@@G@@Y(1)=A@#@@@@          KEY(2)=B@G@@@@          RESULT=S1SRCH(T(HIGH),(TOPCV
)@@G@@-HIGH+1)/3,3,2,KEY,$110)+HIGH-1     @^@@@@          GO TO 111     @#@@@@CW
)@@G@@110   CONTINUE    @#@@@@      RESULT=0    @]@@@@      RETURN@#@@@@111   CX
)@@G@@  CONTINUE  @E@@@@C         IF NAME IS TVNAME MAKE SURE IT POINTS AT TV CY
)@@G@@DESC. @F@@@@          K=S1SRCH(TAG(TVNAME),TVARS,2,2,T(RESULT),$112)+TVNCZ
)@@G@@AME-1 @^@@@@          GO TO 113     @#@@@@112     CONTINUE  @]@@@@      DA
)@@G@@RETURN@C@@@@113   ADDR(T(RESULT+2))=3*(VARS+(K-TVNAME)/2)+1 @]@@@@      DB
)@@G@@RETURN@D@@@@C ... UNCONDITIONALLY ADD AN OPERAND TO THE TABLE     @[@@@@DC
)@@G@@C     @#@@@@12    HIGH=HIGH-3 @#@@@@      LOW=LOW+3   @B@@@@      IF((HIDD
)@@G@@GH-LOW).LT.SLACK) GOTO 121    @#@@@@      T(HIGH)=A   @#@@@@      T(HIGHDE
)@@G@@+1)=B @^@@@@      T(HIGH+2)=LOW     @#@@@@      T(LOW)=C    @#@@@@      DF
)@@G@@T(LOW+1)=D  @^@@@@      T(LOW+2)=HIGH     @#@@@@      RESULT=HIGH @]@@@@DG
)@@G@@      RETURN@#@@@@121   RESULT=0    @#@@@@      HIGH=HIGH+3 @#@@@@      DH
)@@G@@LOW=LOW-3   @#@@@@        CALL DUMP @]@@@@      RETURN@G@@@@C ... ADD A DI
)@@G@@DEFINITION BLOCK POINTING TO THE SYMBOL BLOCK REF BY -A-    @[@@@@C     DJ
)@@G@@@#@@@@13    LOW=LOW+3   @B@@@@      IF((HIGH-LOW).LT.SLACK) GOTO 131    DK
)@@G@@@#@@@@      T(LOW)=C    @#@@@@      T(LOW+1)=D  @#@@@@      T(LOW+2)=A  DL
)@@G@@@#@@@@      RESULT=LOW  @]@@@@      RETURN@#@@@@131   RESULT=0    @#@@@@DM
)@@G@@      LOW=LOW-3   @#@@@@        CALL DUMP @]@@@@      RETURN@F@@@@C ... DN
)@@G@@COMBINATION LOOKUP AND ADDITION ... ADD IT IF ITS NOT THERE @[@@@@C     DO
)@@G@@@#@@@@14        CONTINUE@#@@@@          KEY(1)=A@#@@@@          KEY(2)=BDP
)@@G@@@G@@@@          RESULT=S1SRCH(T(HIGH),(TOP-HIGH+1)/3,3,2,KEY,$140)+HIGH-DQ
)@@G@@1     @#@@@@          RETURN  @#@@@@140   CONTINUE    @#@@@@      GOTO 1DR
)@@G@@2     @A@@@@      ENTRY S1ZSIM(A,B,C,D,E,F)     @[@@@@C     @^@@@@C*****DS
)@@G@@*************     @[@@@@C     @#@@@@      LOW=LOW+3   @#@@@@      HIGH=HDT
)@@G@@IGH-3 @B@@@@      IF((HIGH-LOW).LT.SLACK) GOTO 121    @]@@@@      Q=E   DU
)@@G@@@^@@@@      FLD(0,12,Q)=C     @^@@@@      FLD(12,12,Q)=D    @#@@@@      DV
)@@G@@T(LOW)=Q    @#@@@@      T(LOW+1)=F  @^@@@@        RANK(LOW)=F     @#@@@@DW
)@@G@@      T(HIGH)=A   @#@@@@      T(HIGH+1)=B @]@@@@      Q=0   @^@@@@      DX
)@@G@@FLD(0,12,Q)=LOW   @#@@@@      T(HIGH+2)=Q @#@@@@      RESULT=HIGH @]@@@@DY
)@@G@@      RETURN@A@@@@C ... EQUATING NAMES IN THE TABLE   @B@@@@C          TDZ
)@@G@@V(N) IS ...    (EXPLICIT NAME)@[@@@@C     @#@@@@15        CONTINUE@#@@@@EA
)@@G@@          KEY(1)=A@#@@@@          KEY(2)=B@[@@@@C     @ @@@@C          SEB
)@@G@@EARCH FOR TV NAME @[@@@@C     @F@@@@          I=S1SRCH(T(HIGH),(TOP-HIGHEC
)@@G@@+1)/3,3,2,KEY,$150)+HIGH-1    @^@@@@      J=ADDR(T(I+2))    @^@@@@      ED
)@@G@@K=SPACE(T(J))     @#@@@@      L=ADDR(T(J))@#@@@@      IF(K.GT.1)  @ @@@@EE
)@@G@@C         IS STATEMENT ERROR  @ @@@@     *CALL S1ZTXT(2,$1501,10) @^@@@@EF
)@@G@@          TAXX=VNAMES   @A@@@@          IF(K.EQ.1)TAXX=TVNAME     @^@@@@EG
)@@G@@          TAXY= VARS    @ @@@@          IF(K.EQ.1)TAXY=TVARS@#@@[@      EH
)@@G@@TAXX2=VNAMES@ @@[@      IF(K.NE.1)TAXX2=TVNAME  @#@@[@      TAXY2=VARS  EI
)@@G@@@ @@[@      IF(K.NE.1)TAXY2=TVARS   @^@@@@      TAX=TAXX+2*(L-1)  @A@@@@EJ
)@@G@@      IF(TAG(TAX).EQ.' ') GOTO 151  @ @@@@C         PREVIOUSLY NAMES    EK
)@@G@@@D@@@@      IF(TAG(TAX).EQ.C.AND.TAG(TAX+1).EQ.D) GOTO 151  @B@@@@C     EL
)@@G@@    IF( NOT EXPLICITLY NAMED) RENAME@A@@@@        IF(EXPL(J).NE.1) GO TOEM
)@@G@@ 151  @^@@@@C        ... RENAMED ...@C@@@@C      ALWAYS WANT THIS MESSAGEN
)@@G@@E TO BE PRINTED   @#@@@@      ERRSW=0     @F@@@@      CALL S1ZTX5(2,$150EO
)@@G@@1,11,SYMBOL(J),TAG(TAX),TAG(TAX+1),C,D)   @#@@@@      ERRSW=0     @#@@@@EP
)@@G@@      GOTO 151    @#@@@@150   CONTINUE    @ @@@@C          TV(N) NOT FOUEQ
)@@G@@ND    @ @@@@C         IS STATEMENT ERROR  @ @@@@      CALL S1ZTXT(2,$150ER
)@@G@@1,10) @#@@@@1501  RESULT=0    @]@@@@      RETURN@#@@@@151       CONTINUEES
)@@G@@@#@@@@          KEY(1)=C@#@@@@          KEY(2)=D@F@@@@          K=S1SRCHET
)@@G@@(T(HIGH),(TOP-HIGH+1)/3,3,2,KEY,$152)   +HIGH-1 @^@@@@          GO TO 15EU
)@@G@@4     @#@@@@152   CONTIN*[@@@@*SDFF*@C@@@[.   COPYRIGHT 1975 BY UNIVERSIEV
)@@G@@TY OF MARYLAND    @[@@@[.     @D@@@[.   QUESTIONS CONCERNING THIS SHOULDEW
)@@G@@ BE DIRECTED TO:  @[@@@[.     @ @@@[.        MARVIN V. ZELKOWITZ  @B@@@[EX
)@@G@@.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@[.        UNIVERSITY OF MEY
)@@G@@ARYLAND     @B@@@[.        COLLEGE PARK, MARYLAND 20742     @[@@@[.     EZ
)@@G@@@G@@@[.        PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMFA
)@@G@@S THEY@E@@@[.   REPRESENT IS GRANTED UNDER THE FOLLOWING CONDITIONS:    FB
)@@G@@@[@@@[.     @G@@@[.        1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS FC
)@@G@@REPRESENTED BY    @G@@@[.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OFD
)@@G@@R UNIVERSITY OF MARYLAND@E@@@[.   PL/1 COMPILER REMAINS ASSOCIATED WITH FE
)@@G@@THESE PROGRAMS.   @[@@@[.     @F@@@[.        2. MODIFICATIONS MAY BE MADFF
)@@G@@E TO THE LISTINGS PROVIDED:   @[@@@[.     @G@@@[.        (A) ANY RESULTIFG
)@@G@@NG PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   @G@@@[.        DESCRIBINFH
)@@G@@G SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM @E@@@[.        IS FI
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  @[@@@[.     @G@@@[.     FJ
)@@G@@   (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@[FK
)@@G@@.        OF ERRORS IN THE SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@[FL
)@@G@@.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTED    FM
)@@G@@@C@@@[.        TO THE UNIVERSITY OF MARYLAND, AND     @[@@@[.     @F@@@[FN
)@@G@@.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@[FO
)@@G@@.        WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  FP
)@@G@@@[@@@[.     @F@@@[.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTFQ
)@@G@@ED TO OTHER @G@@@[.        LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEFR
)@@G@@ARLY INDICATE     @G@@@[.        WHETHER THE PROGRAMS ARE EXACT COPIES OFS
)@@G@@F THE UNIVERSITY OF     @E@@@[.        MARYLAND PLUM COMPILER OR ARE MODFT
)@@G@@IFICATIONS TO IT. @[@@@[.     @G@@@[.        3. THESE CONDITIONS ONLY APFU
)@@G@@PLY TO THE PLUM COMPILER ITSELF,    @F@@@[.   AND ARE NOT MEANT TO APPLYFV
)@@G@@ TO ANY PROGRAM WRITTEN USING PLUM. @E@@@[.   THE PURPOSE OF THESE CONDIFW
)@@G@@TIONS IS TO ALLOW ANY USER TO @F@@@[.   EXPERIMENT WITH THE COMPILER AS FX
)@@G@@LONG AS THE RESULTING PRODUCT @G@@@[.   IS NOT SOLD AND AS LONG AS IT ISFY
)@@G@@ KNOWN THAT THE PRODUCT DEVELOPED   @#@@@[.   FROM PLUM.    @[@@@[.     FZ
)@@G@@@[@@@[.     @[@@@[.     @[@@@[.     @[@@@[.     @[@@@[/.    @A@@@@MSG*  GA
)@@G@@   PROC  *1 .     NUMBER,WORDS@ @@@@ZM*(MSG(1,1)) EQU 6*($-PART1) @ @@@@GB
)@@G@@ZX*(MSG(1,1)) EQU   MSG(1,2)  @#@@@@         END .    @#@@@@PT2*     PROGC
)@@G@@C .   @^@@@@FM       FORM  6,12,6,12@G@@@@K        DO    PT2(1,1) , FM +GD
)@@G@@ZX(2*K-2),ZM(2*K-2),ZX(2*K-1),ZM(2*K-1)   @#@@@@         END .    @#@@@@GE
)@@G@@         AXR$     @#@@@@         DCLRG    @#@@@@MSGS     CSECT 3  @#@@@@GF
)@@G@@MSG01*   LABEL .  @^@@@@         +PART2,PART1 . @#@@@@PART1   LABEL .   GG
)@@G@@@#@@@@         MSG   0,2@#@@@@         MSG   5,2@#@@@@         MSG   6,2GH
)@@G@@@#@@@@         MSG   7,2@#@@@@ 'NOT ASSIGNED '  @#@@@@         MSG   1,3GI
)@@G@@@^@@@@ 'INVALID OPTION @C '   @#@@@@         MSG   2,3@^@@@@ 'TOO MANY MGJ
)@@G@@ESSAGES '   @#@@@@         MSG   3,2@]@@@@ 'IO ERROR '@#@@@@         MSGGK
)@@G@@   4,3@^@@@@ 'TOO MUCH OUTPUT '     @#@@@@PART2    LABEL .  @#@@@@      GL
)@@G@@   PT2   4 .@#@@@@         END .    ___^Z 9!B@@@[[@^D+R;)@@,A<)^D+9(@^DZGM
)@@G@@9(@OFPR;@^D-'=@@@JR;@A  AFB@@]R;)@@ (@@^W\*4@^[?*[@@@@*SDFF*+@@@@[@F@@@#GN
)@@G@@ 0)^@)CTJE[TELDC9CE))AC9A85^[]FC)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@[@@@#GO
)@@G@@ 0)^@)@H@@@# 0)^@)EDPC(NE-DD9IES)CTJD1#C(MD1DD1B^[OD[DES)ETCD9PD-^^[]C*)GP
)@@G@@C-DEL CTOC(^^[OD8'@[@@@# 0)^@)@B@@@# 0)^@)^@)^@)^[HCDME1DD0)E0,^[UC(GDTJGQ
)@@G@@E9DE-U@E@@@# 0)^@)^@)^@)^[^C(KCDME-HC(IE))D9A^[#D9HE[PE- EK)ET#DD D1#C*)GR
)@@G@@@C@@@# 0)^@)^@)^@)^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC))@E@@@# 0)^@)^@)^@)GS
)@@G@@^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGCDIC))AK0A84AK)^@)@[@@@# 0)^@)@M@@@# 0)^@)GT
)@@G@@^@)^@)^[KC(MD(DETNDDJD0)E-J^[PET ^[OD[ ET ^[GDDNE-DD1BES)CDIC))E-CC*)CTJGU
)@@G@@D(KE(OC(M^[KELJC9MCDHES)E-CC(T@I@@@# 0)^@)EL E[MC(NC(IE))DDN^[BEL[D1OC(^GV
)@@G@@^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1B^[#D9IC-DE-DD9IES'@[@@@# 0)^@)@L@@@# 0)^@)GW
)@@G@@^@)^@)^@1 0)E(ID-DD(DE- C))E(NC*)D([FC)CL ^[HCD^C*)D9A^[OD[ ^[KELJC9MCDHGX
)@@G@@ES)EL E[MC(NC(IE- C))CLT@M@@@# 0)^@)E-CC(NC*)D-DETODDIC9N^[KELJE1DC- C))GY
)@@G@@E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JEK)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@J@@@#GZ
)@@G@@ 0)^@)E[G 81^[#D9HE[DD- EK)EL D([DDIES)CDNETJCTDCDOC(^^[RDDOD@)E-CC(NC*)HA
)@@G@@E[MD9BEL[D(N 0)^@)@[@@@# 0)^@)@K@@@# 0)^@)^@)^@)^@2 0)D(JC-DC1DCT[E-DD9IHB
)@@G@@ES)D([FC)CL ^[HCD^C*)E-J^[OD[ ^[GDDNE-DD1BES)E[MD9QDD^C(^BK)@[@@@# 0)^@)HC
)@@G@@@M@@@# 0)^@)^@)^@)^@*CC(^[[D1T^[MC(NE(GE-DD1B^[KELJC9MCDH ))D9M^[MC(KD9MHD
)@@G@@E)?^[KCDKC(M^[JEK)C-JCTPD( D1OCDODDJD0)^@)@M@@@# 0)^@)^@)^@)^[^C(NCTMDD]HE
)@@G@@DDIC8)ETPCTC^[KELJC9MCDH^[RDDGD))CTGC([ELGFC)DDIC-DCT[E- ^[OD[[E))E-CC*)HF
)@@G@@E[MD9BEL[D*)@J@@@# 0)^@)^@)^@)^[DES)CC)C-DCDGC(#E))D9A^[KD-PD*)D9M^[DES)HG
)@@G@@C- ELDE1 C))C1MD9H^[KD-PD*?^[[D1^^@)@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@*CK(HH
)@@G@@^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DD9IES?^[JE-CC(M^[OD[[D0)E-MDDQDD[D))CTJELMHI
)@@G@@C(#E-DD9IES)@K@@@# 0)^@)^@)^@)^[JC0)C(MELJELN^[DD0)E-CC*)ETJE(MCT ^[KELJHJ
)@@G@@C9MCDHES?^[ND[[D-G^[]C*)EL E[JELOC(^^[[D1^@L@@@# 0)^@)^@)^@)^[[^[]ELDC(AHK
)@@G@@^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)C1 CDOE(MC*)CD^C- C))ETCCDGD))CL ^[NE(]D(DHL
)@@G@@E-OC(^@F@@@# 0)^@)^@)^@)^[OD8)E-CC*)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^ ))HM
)@@G@@CDIC))@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@*CS(^[ID8)E[MD9BEL[D(N^[^C(MDDQC(^HN
)@@G@@^[AELJD*)E-CC(NC*)D-DETODDIC9N^[ND[[D-G^[]C*)ETJD-^^@)@M@@@# 0)^@)^@)^@)HO
)@@G@@^[RDDOD[JE(O^[RELDE-OC(I^[[E[KELJE1[D))C1MD9H^[OD[ ^[PD1DE1 ELNDDOFC)D9AHP
)@@G@@^[HCDMFDGCDIC)?^[[D1^^@)@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@*C)(^[#D9KDD ES)HQ
)@@G@@D9A^[OD[ ET ^[KELJC9MCDHES)D([FC)CL ^[OEL[D1ND(DE-OC(^^[OD8)D9OD[ EK)^@)HR
)@@G@@@L@@@# 0)^@)^@)^@)^[GD9#CDODDJD1N^[KELJE1DC- C))E-CCDO^[NE(#D@)E-MCDIETHHS
)@@G@@DDOE-[D-N^[#D- CDMD-T^[DD1^DD#CDOC*)@L@@@# 0)^@)^@)^@)^[RD[ E-CC(M^[OD[ HT
)@@G@@^[KELJC9MCDHES)CDMC*)C(SCD#E))CTJE[DC(N^[JC0)E-CC*)E(IDDQC(METDE-T^[JC0)HU
)@@G@@@J@@@# 0)^@)^@)^@)^[HCDMFDGCDIC))E[GE(H^[#D9HE[DD- EK)D9M^[[EL ^[HD9^DDAHV
)@@G@@DD#CDODDJD1N^[OD8)DDO 0)@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@3 0)E-CC(NC*)CTJHW
)@@G@@D1^DDODDJD1N^[JD1GFC)CDKE[GFC)E-J^[OD[ ^[KD-PD*)CTJD(KDDGC(M^[DE-NC(GC0?HX
)@@G@@@L@@@# 0)^@)CDIC))CDMC*)D1JE))D( CDIE))E-J^[[E[KD-T^[OD8)CDIFC)E[MD9BEL[HY
)@@G@@D*)E9MDDOE- D0)E(NDDIC8)E[GE(H 0)^@)@J@@@# 0)^@)E-CC*)E[PELKD9NC*)D9A^[OHZ
)@@G@@D[ ET ^[#D9IC-DE-DD9IES)DDN^[OD8)CDGD-JE8)CDIFC)E(NC(M^[OD8)@L@@@# 0)^@)IA
)@@G@@C(SE[ ELDD( D1O^[RDDOD@)E-CC*)CTJD(KDDGC(M^[[ES)D-JD1B^[[ES)E-CC*)EL ETPIB
)@@G@@D-ODDIC8)E[MD9^E(#E))^@)@M@@@# 0)^@)DDN^[ID9O^[ND9GC))CDIC))CDN^[GD9IC8)IC
)@@G@@CDN^[DE))DDN^[FD1JE9I^[OD[[E))E-CC*)E[MD9^E(#E))C- E1 D-JE[ C))^@)@^@@@#ID
)@@G@@ 0)^@)C1MD9H^[KD-PD*,^@)@[@@@# 0)^@)@[@@@# 0)^@)@[@@@# 0)^@)@[@@@# 0)^@)IE
)@@G@@@[@@@# 0)^@)@[@@@# 8,^@)@E@@@@D(NC8%^@)^@)^[KELJCS)^@%AC) 0)^@)^@)D1PD(]IF
)@@G@@C(M -RD9MC-N^@,^@)@C@@@@FLH K*D(NC8*AC?AC( C)C(LE*)A)% @= (KCDME)1 C) 0)IG
)@@G@@@C@@@@FLS K*D(NC8*AC?AC( C)C(LE*)^@)D(NC8*AC?AK(^@,^@)@^@@@@^@)^@)^@)^@)IH
)@@G@@^[ D1^^@,^@)@^@@@@E[OAK%^@)^@)^[KELJCS) 0)@B@@@@C1H^@)^@)^@)^[AD9MD*)^@6II
)@@G@@ )1AK?A0?AC2^@,^@)@M@@@@DS)^@)^@)^@)^[^D8)^@)^[KE)2 @1 )1 C) ))C1H^@:FLSIJ
)@@G@@ @2 LF *2 C?FLH @2 LF *2 C?FLS @2 LF *1 C?FLH @2 LF *1 C) 0)@^@@@@^@)^@)IK
)@@G@@^@)^@)^[ D1^^@,^@)@^@@@@^@)^@)^@)^@)^[[F[M^)) 0)@^@@@@^@)^@)^@)^@)^[^CTGIL
)@@G@@ELB^@,@ @@@@D(NC9N^@)^@)^[#ET CTO^@3^@,^@)@^@[@@D(NC81AC%^@)^[GCD]C(G^@,IM
)@@G@@@^@@@[D(NC82AC%^@)^[GCD]C(G^@,@A@@@@^@)^@)^@)^@)^@:E[[ELOAK?E[[ELOAC) 0)IN
)@@G@@@^@@@@E[[ELOAC)^@)D-[CL D)) 0)@ @@@@^@)^@)^@)^@)^[HETB^@)^@0 )3^@,@B@@@@IO
)@@G@@^@$ET\IL2JC-^[IH94^[(H(0H->H(>H14G(=^8) 0)@ @@@@^@)^@)^@)^@)^[HETB^@)^@1IP
)@@G@@ )3^@,@A@]@@^@$DD,I1-H-(G))H90I-(H9,^[@C0)^8) 0)@ @@@@^@)^@)^@)^@)^[HETBIQ
)@@G@@^@)^@6 )2^@,@ @@@@^@)^@)^@)^@)^[HETB^@)^@7 )2^@,@ @@@@^@$D1\I))GD3IT(G9,IR
)@@G@@G(=^@$^@,^@)@ @@@@^@)^@)^@)^@)^[HETB^@)^@2 )3^@,@A@@@@^@$E-\H8)H(-H19^[!IS
)@@G@@G(3IT-G9>IS)^8) 0)@ @@@@^@)^@)^@)^@)^[HETB^@)^@3 )2^@,@^@@@@^@$DC\D8)G(2IT
)@@G@@IL\IK)^8) 0)@ @@@@^@)^@)^@)^@)^[HETB^@)^@4 )3^@,@A@@@@^@$E-\H8)H(5GT*^[\IU
)@@G@@I(4I[5I))^8) 0)^@)@ @]@@^@)^@)^@)^@)^[HETB^@)^@5 )3^@,@ @@@]^@)^@)^@)^@)IV
)@@G@@^[HETB^@)^@5 )2^@,@B@]@@^@$ET9H(+H9?^[4GD+H->^[\I1>IL&H-\I8)^8) 0)@ @]@@IW
)@@G@@^@)^@)^@)^@)^[HETB^@)^@8 )5^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@8 )2^@,@C@]@@IX
)@@G@@^@$A00^[+HD4IS)I(3G(=^[&H92^[,I(!GL>IK)^8) 0)^@)@ @]@@^@)^@)^@)^@)^[HETBIY
)@@G@@^@)^@9 )5^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@9 )2^@,@C@]@@^@$AC7^[=HD$HD4IS)IZ
)@@G@@I(3G(=^[&H92^[,I(!GL>IK)^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@1A@?A)) 0)^@)JA
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@1A@?AK) 0)^@)@B@]@@^@$D15H(+G(2^[\I(4^[\G0)JB
)@@G@@IL-H1$G*)^8) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@1AC?AS) 0)^@)@A@@@]^@)^@)JC
)@@G@@^@)^@)^[HETB^@)^@1AC?AK) 0)^@)@ @]@@^@$D1-H(>^[4H9\^[?H9,G8)^8) 0)@A@@@@JD
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1AK?AK) 0)^@)@ @]@@^@$DD?H->G9-H))IT9H(+H9?^@$^@,JE
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@1AS?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1JF
)@@G@@AS?AK) 0)^@)@D@]@@^@$CT\H(!G(,I))GD<IL\IT3^[?HD,G*)GL\I(,G--IL9^@$^@,^@)JG
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@1A)?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1JH
)@@G@@A)?AK) 0)^@)@D@]@@^@$D15H(+G(2^[-GT2H93IS)H-(H1>^[+H95H1=GD2JC)^8) 0)^@)JI
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@1A*?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1JJ
)@@G@@A*?AK) 0)^@)@D@]@@^@$ET4IL(H1$^[-GT2H93IS)H-(H1>^[+H95H1=GD2JC)^8) 0)^@)JK
)@@G@@@A@@@@^@)^@)^@)^@)^[HETB^@)^@1A0?AK) 0)^@)@A@]@@^@$D[-IT*I--GL?G*)H96G(2JL
)@@G@@G1?H97^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@1A8?AC) 0)^@)@A@@@]^@)^@)^@)^@)JM
)@@G@@^[HETB^@)^@1A8?AK) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@2A@?AC) 0)^@)@A@@@]JN
)@@G@@^@)^@)^@)^@)^[HETB^@)^@2A@?AK) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@2AC?AC)JO
)@@G@@ 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2AC?AK) 0)^@)@#@]@@^@$D15H(+G(2^@$^@,JP
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@1B@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1JQ
)@@G@@B@?AK) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@1BC?AC) 0)^@)@A@@@]^@)^@)^@)^@)JR
)@@G@@^[HETB^@)^@1BC?AK) 0)^@)@^@]@@^@$C(8I[\H1>H14^@$^@,^@)@A@]@@^@)^@)^@)^@)JS
)@@G@@^[HETB^@)^@2AS?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2AS?AK) 0)^@)@ @]@@JT
)@@G@@^@$CT\H-5H(,^@1^[5IT>G))^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@2A)?AK) 0)^@)JU
)@@G@@@^@]@@^@$DD?H->G9-H)) K\^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@2A*?AK) 0)^@)JV
)@@G@@@B@]@@^@$DD,GT\H(0H->I->^[>J[0IL>IT3HD\H0)^8) 0)@A@]@@^@)^@)^@)^@)^[HETBJW
)@@G@@^@)^@2A0?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2A0?AK) 0)^@)@C@]@@^@$D((JX
)@@G@@IT3HD,G8)GD2G95H(>H14 0)AC)I(3G(=^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@2JY
)@@G@@A8?AK) 0)^@)@ @]@@^@$D((IT3HD,G8)GT\H(!GC)^8) 0)@A@@@@^@)^@)^@)^@)^[HETBJZ
)@@G@@^@)^@2B@?AK) 0)^@)@^@]@@^@$C(!I[4JC)H-(IT4^@$^@,@A@]@@^@)^@)^@)^@)^[HETBKA
)@@G@@^@)^@2BC?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2BC?AK) 0)^@)@B@]@@^@$C(8KB
)@@G@@I-2GC)H->G14^[0GD2G(,I-*G(3HD3^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@3A@?AS)KC
)@@G@@ 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3A@?AK) 0)^@)@C@]@@^@$D((IT3HD,G8)IL(KD
)@@G@@G9*I))I[-IL>H14H[>IT(IS)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@3AC?AK) 0)^@)KE
)@@G@@@ @]@@^@$DD!I[2H90G(2^[,H94^@$^@,^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@3AK?AS)KF
)@@G@@ 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3AK?AK) 0)^@)@A@]@@^@$D1>IT4HD,G8)I-\KG
)@@G@@H8)G->G(0^@$^@,^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@3AS?AS) 0)^@)@A@@@]^@)^@)KH
)@@G@@^@)^@)^[HETB^@)^@3AS?AK) 0)^@)@C@]@@^@$D((IT3HD,G8)H->G14^[0GD2G(,I-*G(3KI
)@@G@@HD3^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@3A)?AK) 0)^@)@ @]@@^@$C(8I-2GC)KJ
)@@G@@GT\H(!GC)^8) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@3A*?AS) 0)^@)@A@@@]^@)^@)KK
)@@G@@^@)^@)^[HETB^@)^@3A*?AK) 0)^@)@A@]@@^@$CC)G1\IL!GD4^[-IT3I(!G(=^@$^@,^@)KL
)@@G@@@A@@@@^@)^@)^@)^@)^[HETB^@)^@3A0?AK) 0)^@)@ @]@@^@$E[2G(&HD8^[\IL=G(2^@$KM
)@@G@@^@,^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@3A8?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETBKN
)@@G@@^@)^@3A8?AK) 0)^@)@ @]@@^@$D95I))H9&^[3I[-GT>^@$^@,^@)@A@]@@^@)^@)^@)^@)KO
)@@G@@^[HETB^@)^@3B@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3B@?AK) 0)^@)@#@]@@KP
)@@G@@^@$CT*G(<HS)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@3BC?AK) 0)^@)@A@]@@^@$D((KQ
)@@G@@IT3HD,G8)HT>JD7H92G))^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@4A@?AK) 0)^@)KR
)@@G@@@ @]@@^@$D((IT3HD,G8)H--GL>H))^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@4AC?AK)KS
)@@G@@ 0)^@)@A@]@@^@$ET4GD4G(!G(,I))G->H->I->G))^8) 0)@A@]@@^@)^@)^@)^@)^[HETBKT
)@@G@@^@)^@4AK?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4AK?AK) 0)^@)@F@]@@^@$E(,KU
)@@G@@IL>GT\G9,HD'GD+H->^[>H->H(>H14^[(H0)IT4GD4G(!G(,I))^8) 0)^@)@A@]@@^@)^@)KV
)@@G@@^@)^@)^[HETB^@)^@4AS?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4AS?AK) 0)^@)KW
)@@G@@@ @]@@^@$E(,IL>GD<H[-GL?G*)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@4A)?AK)KX
)@@G@@ 0)^@)@A@]@@^@$C(8I-2GC)IT>H((GT\H-\H0)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETBKY
)@@G@@^@)^@4A*?AK) 0)^@)@A@]@@^@$D((IT3HD,G8)G(8I[2G(3IT(H9,^@$^@,@A@@@@^@)^@)KZ
)@@G@@^@)^@)^[HETB^@)^@4A0?AK) 0)^@)@ @]@@^@$D((IT3HD,G8)E-CC(I^@$^@,^@)@A@@@@LA
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4A8?AK) 0)^@)@A@]@@^@$D((IT3HD,G8)IT>H((GT\H-\H0)LB
)@@G@@^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@4B@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETBLC
)@@G@@^@)^@4B@?AK) 0)^@)@#@]@@^@$D--GL>H))^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@4LD
)@@G@@BC?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4BC?AK) 0)^@)@A@]@@^@)^@)^@)^@)LE
)@@G@@^[HETB^@)^@6AS?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6AS?AK) 0)^@)@ @]@@LF
)@@G@@^@$E-CC(I^[\IK)C(GET ^@$^@,^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@5A@?AC) 0)^@)LG
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@5A@?AK) 0)^@)@#@]@@^@$D90I-(H9,^@$^@,@A@]@@LH
)@@G@@^@)^@)^@)^@)^[HETB^@)^@5AC?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@5AC?AK)LI
)@@G@@ 0)^@)@]@]@@^@$E-J^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@5AK?AC) 0)^@)@A@@@]LJ
)@@G@@^@)^@)^@)^@)^[HETB^@)^@5AK?AK) 0)^@)@]@]@@^@$CLT^@$^@,@A@]@@^@)^@)^@)^@)LK
)@@G@@^[HETB^@)^@5AS?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@5AS?AK) 0)^@)@#@]@@LL
)@@G@@^@$E9CDDGC*)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@5A)?AK) 0)^@)@A@]@@^@$C-JLM
)@@G@@^[3I[>GT(G1(GT-I-(H9,^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@5A*?AK) 0)^@)LN
)@@G@@@^@]@@^@$D((IT3HD,G8)B*)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@5A0?AK) 0)^@)LO
)@@G@@@A@]@@^@$D((IT3HD,G8)I1-IL(GD+H->^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@5LP
)@@G@@A8?AK) 0)^@)@^@]@@^@$DC\D8)I[*IL-IT>^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@5LQ
)@@G@@B@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@5B@?AK) 0)^@)@#@]@@^@$C1JELHCDOLR
)@@G@@^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@5BC?AK) 0)^@)@ @]@@^@$D((IT3HD,G8)C(ILS
)@@G@@C))^8) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@6A@?A*) 0)^@)@A@@@]^@)^@)^@)^@)LT
)@@G@@^[HETB^@)^@6A@?AK) 0)^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@9A8?A*) 0)^@)@D@]@@LU
)@@G@@^@$D1\I))JD>I))HD!I[?G(!G(,I->G))HD,^[KD-PD*)^8) 0)^@)@A@]@@^@)^@)^@)^@)LV
)@@G@@^[HETB^@)^@6AC?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6AC?AK) 0)^@)@B@]@@LW
)@@G@@^@$C(,I-2JC)H1\I))HD,^[0IL\GT>G-5IL>^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@6LX
)@@G@@AK?AK) 0)^@)@B@]@@^@$D(5H-4HD0H->^[=G(<H--IL-I-(H9,^@$^@,^@)@A@@@@^@)^@)LY
)@@G@@^@)^@)^[HETB^@)^@6A)?AK) 0)^@)@ @]@@^@$D((IT3HD,G8)GT\H-\H0)^8) 0)@A@]@@LZ
)@@G@@^@)^@)^@)^@)^[HETB^@)^@6A*?A)) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6A*?AK)MA
)@@G@@ 0)^@)@B@]@@^@$D1J^[#D[ CTF^[&H92^[ID9#D[ CTF^@$^@,^@)@A@@@@^@)^@)^@)^@)MB
)@@G@@^[HETB^@)^@6A0?AK) 0)^@)@A@]@@^@$DD!I[2H90G(2^[QCDMFDDD1B^@$^@,^@)@A@]@@MC
)@@G@@^@)^@)^@)^@)^[HETB^@)^@6A8?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6A8?AK)MD
)@@G@@ 0)^@)@C@]@@^@$D((IT3HD,G8)G(8I->IL,GD?^[0IL\GT>G-5IL>^@$^@,@A@]@@^@)^@)ME
)@@G@@^@)^@)^[HETB^@)^@6B@?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6B@?AK) 0)^@)MF
)@@G@@@B@]@@^@$D((IT3HD,G8)E[MD9#C(NES)GT-IL=^@$^@,^@)@A@]@@^@)^@)^@)^@)^[HETBMG
)@@G@@^@)^@6BC?AS) 0)^@)@A@]@@^@$D1\^[!GD(H0)I[2H9<G(=I(2G*)^8) 0)@A@]@@^@)^@)MH
)@@G@@^@)^@)^[HETB^@)^@7A@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@7A@?AK) 0)^@)MI
)@@G@@@^@]@@^@$CT\H1=HD4HD\H0)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@7AC?AK) 0)^@)MJ
)@@G@@@B@]@@^@$E[-IL-H(>I->IK)GD4I-2HD+I(4G*)^8) 0)^@)@A@]@@^@)^@)^@)^@)^[HETBMK
)@@G@@^@)^@7AK?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@7AK?AK) 0)^@)@#@]@@^@$C(IML
)@@G@@E-MFC)^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@7AS?A)) 0)^@)@A@@@]^@)^@)^@)^@)MM
)@@G@@^[HETB^@)^@7AS?AK) 0)^@)@B@]@@^@$C(8I->IL,GD?^[,GD!G*)I-\H8)H-\H1$^@$^@,MN
)@@G@@@A@]@@^@)^@)^@)^@)^[!IT$^@)^@7A)?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[!IT$^@)^@7MO
)@@G@@A)?AK) 0)^@)@D@]@@^@$E[2H9$IL-H*)HD,IT5G1&HD<HD>H14H-9^[<H9!H(>H14G(=^@$MP
)@@G@@@A@@@@^@)^@)^@)^@)^[HETB^@)^@7A*?AK) 0)^@)@ @]@@^@$DD!I[2H90G(2^[3GT-H->MQ
)@@G@@^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@7A0?AK) 0)^@)@A@]@@^@$DD!I[2H90G(2^[0MR
)@@G@@IL>GT(IT(H9,^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@7A8?AS) 0)^@)@A@@@]^@)^@)MS
)@@G@@^@)^@)^[HETB^@)^@7A8?AK) 0)^@)@B@]@@^@$E-\H8)H(-H19^[(G->H14HD&HD>IL3^@$MT
)@@G@@^@,^@)@A@]@@^@)^@)^@)^@)^[HETB^@)^@7B@?AS) 0)^@)@A@@@]^@)^@)^@)^@)^[HETBMU
)@@G@@^@)^@7B@?AK) 0)^@)@C@]@@^@$DD!I[2H90G(2^[3I-2I(<I-5IL>^[?G(6G(?^@$^@,^@)MV
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@7BC?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@7MW
)@@G@@BC?AK) 0)^@)@^@]@@^@$CD4I-2HD+I(4G*)^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@8MX
)@@G@@A@?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@8A@?AK) 0)^@)@^@]@@^@$C-(H(>H13MY
)@@G@@HD\H0)^8) 0)@A@]@@^@)^@)^@)^@)^[HETB^@)^@8AC?AC) 0)^@)@A@@@]^@)^@)^@)^@)MZ
)@@G@@^[HETB^@)^@8AC?AK) 0)^@)@^@]@@^@$CT\H16G(2IT(H9,^@$^@,@A@]@@^@)^@)^@)^@)NA
)@@G@@^[HETB^@)^@8AK?AC) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@8AK?AK) 0)^@)@#@]@@NB
)@@G@@^@$C1-GT4H92^@$^@,@A@]@@^@)^@)^@)^@)^[HETB^@)^@8AS?A)) 0)^@)@A@@@]^@)^@)NC
)@@G@@^@)^@)^[HETB^@)^@8AS?AK) 0)^@)@E@]@@^@$DD!I[2H90G(2^[-I-4IL(GL5I->^[(H0)ND
)@@G@@IT4IL5GT4I(2G*)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@8A)?AK) 0)^@)@^@]@@NE
)@@G@@^@$C(8I-2GC) C)^8) 0)^@)@^@@@]^@$D1\I))GD3IT(G9,G(=^@$@A@@@@^@)^@)^@)^@)NF
)@@G@@^[HETB^@)^@8A*?AK) 0)^@)@A@@@@^@$DD!I[2H90G(2^[DD1DE-DCDG^8) 0)^@)@A@@@@NG
)@@G@@^@)^@)^@)^@)^[HETB^@)^@8A0?A8) 0)^@)@E@@@@^@$F-P^[(IS)GD!GL(G95H95IS,^[JNH
)@@G@@H1>^[-I))F1O^[5IT>G))^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@8A8?A)) 0)^@)NI
)@@G@@@A@@@@^@$^(PG-\G(3^[,H94^[2G(3H9?I1>^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@8NJ
)@@G@@B@?AC) 0)^@)@#@@@@^@$E-9I[>^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@8BC?AC)NK
)@@G@@ 0)^@)@^@@@@^@$D90G(2GD,G))^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@9A@?AS)NL
)@@G@@ 0)^@)@C@@@@^@$ET4IL5GT4I(2G(3^[,H94^[(H(0H->H(>H14G(=^@$^@,@A@@@@^@)^@)NM
)@@G@@^@)^@)^[HETB^@)^@9AC?AK) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@9AS?AK) 0)^@)NN
)@@G@@@ @@@@^@$CT\H(0HD?G(2 0)ET D([^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@9AK?A))NO
)@@G@@ 0)^@)@D@@@@^@$D15H(+G(2^[\G0)GD2G95H(>H14IS)HD,GT\IL2G(<I))^8) 0)@A@@@@NP
)@@G@@^@)^@)^@)^@)^[HETB^@)^@9A)?AS) 0)^@)@B@@@@^@$ET D([^[4GD+H->^[\I1>IL&H-\NQ
)@@G@@I8)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@9A*?AK) 0)^@)@A@@@@^@$ET5GL3GT2NR
)@@G@@HD0I->G))H--GL>H))^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@9A0?A*) 0)^@)@D@@@@NS
)@@G@@^@$F-QI(3G(=^[&H92^[(H16GD?HD=^[>J[0IL>IT3HD\H0)^8) 0)@ @@@]^@)^@)^@)^@)NT
)@@G@@^[!IT$^@)^@9A8?A*)@C@@@]^@$D1\I))JD>I))HD!I[?G(!G(,I->G))HD,^[KD-PD*)^8)NU
)@@G@@@A@@@@^@)^@)^@)^@)^[HETB^@)^@9B@?A)) 0)^@)@A@@@@^@$F-PI(3G(=^[-IS)GD2IL-NV
)@@G@@JC)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@9BC?BC) 0)^@)@J@@@@^@$D1\I))I[2NW
)@@G@@H90G(2^[,I(!GL>IK)H9&^[-IL$I(!G(,I-3^[\IK)IT5GL3GT2HD0I-3^[&H92^[WE*)^8)NX
)@@G@@ 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@1A@0 )3^@,^@)@C@@@@^@$DD?H->G9-H))GT\NY
)@@G@@H(0H->J@)GT\H(0GD2G*)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@1A@1 )3^@,^@)NZ
)@@G@@@C@@@@^@$CD$G92G($GD4G*)G(8I[2G(3IT(H9,^[>IL2H92^@$^@,@A@@@@^@)^@)^@)^@)OA
)@@G@@^[HETB^@)^@1A@2 )7^@,^@)@J@@@@^@$CD2IL-JC)G-(H(>H13HD\H13^[,H94^[<H9!I[-OB
)@@G@@I-(GL?G*)HD,^[-IL2GD9^[>J[0IL>IT3HD\H0)^8) 0)^@)@A@@@@^@)^@)^@)^@)^[HETBOC
)@@G@@^@)^@1A@3 )6^@,^@)@F@@@@^@$CD3IT(G9,HD,G8)GD2IL-JC)I-\^[-^[3GT-H--IK)I1-OD
)@@G@@IL(GD+H->^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@1A@4 )4^@,^@)@C@@@@^@$DD,OE
)@@G@@I1-H-(G))I[-IL-H(>I->IK)G1\IK)F-P^@$^@,^@)@A@@@@^@)^@)^@)^@)^[HETB^@)^@1OF
)@@G@@A@5 )2^@,^@)@ @@@@^@$D((IT3HD,G8)G(2IL\IK)^8) 0)@A@@@@^@)^@)^@)^@)^[HETBOG
)@@G@@^@)^@1A@6 )2^@,^@)@A@@@@^@$DD,I1-H-(G))IT5GL3GT2HD0I))^8) 0)@A@@@@^@)^@)OH
)@@G@@^@)^@)^[HETB^@)^@1A@7 )7^@,^@)@G@@@@^@$CL5HD?I-(H0)G15H1<I-(H9,^[WE(5IT>OI
)@@G@@G))GD3^[0IT>I(=H8)I1-IL(GD+H->^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@1A@8 )5OJ
)@@G@@^@,^@)@B@@@@^@$F-PHD3^[,H94^[4JD0G*)E[JDDIE- EK)^8) 0)@A@@@@^@)^@)^@)^@)OK
)@@G@@^[HETB^@)^@1A@9 )7^@,^@)@E@@@@^@$CT-H1,H94^[?G(-I1>^[-^[]C(BDDI^[\IK)E[MOL
)@@G@@D9#^[+H-\GT:^@$^@,@A@@@@^@)^@)^@)^@)^[HETB^@)^@1AC0 )5^@,^@)@C@@@@^@$D--OM
)@@G@@GL>H))H1\I))H9,^[(I->IL-I-(I1>^[^D8)^8) 0)@A@@@@^@)^@)^@)^@)^[HETB^@)^@1ON
)@@G@@AC1 )3^@,^@)@A@@@@^@$CT[ET ^[0IL>G1(J@)G(2IL\IK)^8) 0)@^@@@@E[[ELOAK)^@)OO
)@@G@@^[GCD]C(G^@,@ @@@@^@)^@)^@)^@)^[KE)2^@)^@5A0) 0)@^@@@@^@)^@)^@)^@)^[ D1^OP
)@@G@@^@,^@)___ETB^@)^@6A@?A*) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@6A@?AK) 0)^@)OQ
)@@G@@@A@]@@^@)^@)^@)^@)^[HETB^@)^@9A8?A*) 0)^@)@D@]@@^@$D1\I))JD>I))HD!I[?G(!OR
)@@G@@*[@@@@*SDFF*@C@@@-.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@-OS
)@@G@@.     @D@@@-.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@-OT
)@@G@@.     @ @@@-.        MARVIN V. ZELKOWITZ  @B@@@-.        DEPARTMENT OF COU
)@@G@@OMPUTER SCIENCE   @A@@@-.        UNIVERSITY OF MARYLAND     @B@@@-.     OV
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@-.     @G@@@-.        PERMISSIOOW
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@-.   REPRESENOX
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@-.     @G@@@-.     OY
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@-OZ
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDPA
)@@G@@@E@@@-.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@-PB
)@@G@@.     @F@@@-.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDPC
)@@G@@ED:   @[@@@-.     @G@@@-.        (A) ANY RESULTING PROGRAM, OR REPORT, PPD
)@@G@@APER OR DOCUMENTATION   @G@@@-.        DESCRIBING SUCH PROGRAM WILL CLEAPE
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@-.        IS A DIALECT OF PLUM OR IS PF
)@@G@@DERIVED FROM PLUM, AND  @[@@@-.     @G@@@-.        (B) ALL SUCH MODIFICAPG
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@-.        OF ERRORS IN THPH
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@-.        A BRIEF DESCRIPPI
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@-.        TO THE UNPJ
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@-.     @F@@@-.        (C) NO PROGRAMSPK
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@-.        WITHOUT WRITTENPL
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@-.     @F@@@-.     PM
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@-.     PN
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@-PO
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     PP
)@@G@@@E@@@-.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@-PQ
)@@G@@.     @G@@@-.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERPR
)@@G@@ ITSELF,    @F@@@-.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN PS
)@@G@@USING PLUM. @E@@@-.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USPT
)@@G@@ER TO @F@@@-.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRPU
)@@G@@ODUCT @G@@@-.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT PV
)@@G@@DEVELOPED   @#@@@-.   FROM PLUM.    @[@@@-.     @[@@@-.     @[@@@-.     PW
)@@G@@@[@@@-.     @[@@@-.     @[@@@-/.    @[@@@).     @]@@@)       AXR$ @]@@@)PX
)@@G@@       DCLRG@]@@@)       REGS @]@@@)       ALREG@#@@@)        UNLIST .  PY
)@@G@@@]@@@)@ADD PLTVDS @]@@@)@ADD PLCGST @]@@@)@ADD PLDSAW @]@@@)   CEND     PZ
)@@G@@@#@@@)         LIST .   @#@@@)/      PLWORD     @]@@@)       PLCGD@]@@@)QA
)@@G@@       PLSD @]@@@)       PLIG @A@@@)GGKNST CSECT 3     . MY CONSTANTS   QB
)@@G@@@C@@@)K332S9 EQU  DCVDTB       . LOG 10/LOG 2  * 2**14@G@@@)KKSCL  EQU  QC
)@@G@@ 14          . HOW FAR TO SHIFT CONVERSION CONSTANT (K332S9)@B@@@)KBXMXPQD
)@@G@@ EQU   35    . MAX PREC FOR BIN FIX @B@@@)KDXMXP EQU   18    . MAX PREC QE
)@@G@@FOR DEC FIX @C@@@)KBFMXP EQU   60    . MAX PREC FOR BIN FLOAT     @C@@@)QF
)@@G@@KSFTMX EQU   36    . SINGLE WORD MAX SHIFT COUNT@E@@@)XGCOMM EQU   02000QG
)@@G@@0 . FLAG FOR COMMUTATIVE COMPARISONS (=,_)@ @@@)GGNEMS SF    0537  . TNEQH
)@@G@@,U    @]@@@)GGNHMS SF   @]@@@)GGNLMS SF   @#@@@)DGBTMK   SFW 0 .  @D@@@)QI
)@@G@@         +SD0STR,SDARST+SDCHBT,0,1 . BIT STRING FLAGS @D@@@)DGTRFA   SFWQJ
)@@G@@     0 .               SET TRUE AND FALSE @C@@@)         LA,U    A3,'1' QK
)@@G@@.          ASSUME TRUE  @D@@@)         LA,U    A3,'0' .          NOPE FAQL
)@@G@@LSE IF HERE @D@@@)DGTNE    SF      0510000 .         OPCODE FOR TNE     QM
)@@G@@@]@@@)       CEND @#@@@)XGACT2 CSECT 3 .  @[@@@).     @E@@@).        TARQN
)@@G@@GETING AND STAGEING FOR RELATIONAL COMPARES     @[@@@).     @#@@@)XGRCABQO
)@@G@@*  LABEL .  @D@@@)FILL(1)  SAC     GGTARI,GGSREL .   TARGETING,STAGEING QP
)@@G@@@E@@@)FILL(1)  SAC     GGFRAB,GGFCAB .   FLOAT REAL,FLOAT COMPLEX @E@@@)QQ
)@@G@@FILL(1)  SAC     GGBRAB,GGBCAB .   BIN REAL,BIN COMPLEX     @#@@@)XGRCBAQR
)@@G@@*  LABEL .  @D@@@)FILL(1)  SAC     GGTARI,GGSREL .   TARGETING,STAGEING QS
)@@G@@@E@@@)FILL(1)  SAC     GGFRBA,GGFCBA .   FLOAT REAL,FLOAT COMPLEX @E@@@)QT
)@@G@@FILL(1)  SAC     GGBRBA,GGBCBA .   BIN REAL,BIN COMPLEX     @[@@@).     QU
)@@G@@@F@@@).        BIT STRING RELATIONAL COMPARE TARGETING AND STAGEING     QV
)@@G@@@^@@@).                TABLES @[@@@).     @#@@@)XGCMBA* LABEL  .  @F@@@)QW
)@@G@@FILL(1) SAC   XGCMCC,XGCNBA   . COMPARING STRINGS OR NUMBERS?     @F@@@)QX
)@@G@@FILL(1) SAC   0,XGCMST .           THIS IS FOR STRING MAX LEN MODE@#@@@)QY
)@@G@@XGCNBA  LABEL   . @ @@@)FILL(1) SAC   GGTCMP,GGSCMP . @ @@@)FILL(1) SAC QZ
)@@G@@  GGFRBA,GGFCBA   @ @@@)FILL(1) SAC   GGBRBA,GGBCBA . @D@@@)FILL(1) SAC RA
)@@G@@  GSCMBA,0 .           STRING COMPARE     @#@@@)XGCMAB* LABEL  .  @F@@@)RB
)@@G@@FILL(1) SAC   XGCMCC,XGCNAB   . COMPARING STRINGS OR NUMBERS?     @F@@@)RC
)@@G@@FILL(1) SAC   0,XGCMST .           THIS IS FOR STRING MAX LEN MODE@#@@@)RD
)@@G@@XGCNAB  LABEL   . @ @@@)FILL(1) SAC   GGTCMP,GGSCMP . @ @@@)FILL(1) SAC RE
)@@G@@  GGFRAB,GGFCAB . @ @@@)FILL(1) SAC   GGBRAB,GGBCAB . @D@@@)FILL(1) SAC RF
)@@G@@  GSCMAB,0 .           STRING COMPARE     @G@@@)XGCMST  LABEL   . .     RG
)@@G@@           TARGETING AND STAGING FOR COMPARES   @F@@@).                 RH
)@@G@@                 WHEN IN MAX LEN MODE (I THINK) @ @@@)FILL(1) SAC   GGTNRI
)@@G@@OP,GGCMSM . @ @@@)FILL(1)  SAC   GGNOOP,0 .     @#@-@)XGORTB* LABEL  .  RJ
)@@G@@@B@@@-XGORTB* LABEL  .                   OR     @ @@@)FILL(1) SAC   XGCMRK
)@@G@@CC,XGOR1 .  @B@@@)FILL(1) SAC   0,XGAO2    . SAME FOR AND/OR@#@-@)XGANTBRL
)@@G@@* LABEL  .  @B@@@-XGANTB* LABEL  .                   AND    @ @@@)FILL(1RM
)@@G@@) SAC   XGCMCC,XGAN1 .  @B@@@)FILL(1) SAC   0,XGAO2    . SAME FOR AND/ORRN
)@@G@@@#@-@)XGNOTT* LABEL  .  @B@@@-XGNOTT* LABEL  .                   NOT    RO
)@@G@@@ @@@)FILL(1) SAC   XGCMCC,XGNOT1 . @^@@@)FILL(1) SAC   0,XGNOT2 .@#@-@)RP
)@@G@@XGCATT* LABEL  .  @C@@@-XGCATT* LABEL  .                   CONCATTENATE RQ
)@@G@@@ @@@)FILL(1) SAC   XGCMCC,XGCAT1 . @^@@@)FILL(1) SAC   0,XGCAT2 .@#@@@)RR
)@@G@@XGOR1  LABEL  .   @ @@@)FILL(1) SAC   GGTBTS,GGSNOP . @ @-@)FILL(1) SAC RS
)@@G@@  GGAOCT,GGOR .   @ @@@-FILL(1) SAC   GGAOCT,0, .     @#@@@)XGAN1  LABELRT
)@@G@@  .   @ @@@)FILL(1) SAC   GGTBTS,GGSNOP . @ @-@)FILL(1) SAC   GGAOCT,GGARU
)@@G@@ND .  @ @@@-FILL(1) SAC   GGAOCT,0, .     @#@@@)XGNOT1 LABEL  .   @ @@@)RV
)@@G@@FILL(1) SAC   GGTNBT,GGSNOP . @ @-@)FILL(1) SAC   GGNOT,GGNOOP .  @^@@@-RW
)@@G@@FILL(1) SAC   GGNOT,0, .@#@@@)XGCAT1 LABEL  .   @ @@@)FILL(1) SAC   GGTCRX
)@@G@@HR,GGSNOP . @ @-@)FILL(1) SAC   GGAOCT,GGAOCT . @ @@@-FILL(1) SAC   GGAORY
)@@G@@CT,0, .     @F@@@)XGAO2  LABEL  .                    THIS IS FOR STRING RZ
)@@G@@MAX LEN MODE@H@-@)FILL(1) SAC   GGTNOP,GGSLMX .   FOR NOW, ASSUME ALL LESA
)@@G@@NGTHS ARE IN HALFWS, SO @ @@@-FILL(1) SAC   GGTNOP,GGSNOP . @H@-@)FILL(1SB
)@@G@@) SAC   GGLXFF,GGLXFH.     NEED NO STAGING AND ONLY ONE ICODE ROUTIE    SC
)@@G@@@^@<@-FILL(1) SAC   GGMSUM,0 .@^@@@<FILL(1) SAC   GGMMAX,0 .@ @-@)FILL(1SD
)@@G@@)  SAC   GGLXHF,GGLXHH .@F@@@)XGNOT2 LABEL  .                    THIS ISSE
)@@G@@ FOR STRING MAX LEN MODE@ @@@)FILL(1) SAC   GGTNOP,GGSNOP . @ @@@)FILL(1SF
)@@G@@) SAC   GGNOOP,0  .     @F@@@)XGCAT2 LABEL  .                    THIS ISSG
)@@G@@ FOR STRING MAX LEN MODE@H@-@)FILL(1) SAC   GGTNOP,GGSLMX .   FOR NOW, ASH
)@@G@@SSUME ALL LENGTHS ARE IN HALFWS, SO @ @@@-FILL(1) SAC   GGTNOP,GGSNOP . SI
)@@G@@@H@-@)FILL(1) SAC   GGLAFF,GGLAFH.     NEED NO STAGING AND ONLY ONE ICODSJ
)@@G@@E ROUTIE    @^@<@-FILL(1) SAC   GGMMAX,0 .@^@@@<FILL(1) SAC   GGMSUM,0 .SK
)@@G@@@ @-@)FILL(1)  SAC   GGLAHF,GGLAHH .@A@@@)/.           TARGETING ROUTINESL
)@@G@@S     @#@@@)XGCMCC* LABEL .   @E@@@)       ADD   X5,DXGOPS  . DXGOPS HADSM
)@@G@@ BETTER CONTAIN 0/1     @D@@@)       LOAD  X5,W1H2,X5 . ACTTAB FOR STRS SN
)@@G@@OR NOS??    @A@@@)       LOAD  X6,W1H1,X5         .   @A@@@)       GOTO SO
)@@G@@ 0,X6  . DO TARGETING   @[@@@).     @F@@@).            TARGETING FOR COMSP
)@@G@@PARISONS (EQ,NE,GT,GE,LT,LE,NG,NL)  @[@@@).     @#@@@)GGTCMP LABEL .    SQ
)@@G@@@E@@@)       USING SGDSCT,X7 .     AS ALWAYS, X7 -> TOP OF STACK  @#@@@)SR
)@@G@@       GNTR 2 .   @F@@@)       IF  SDARST,OFF,SGDCLS  THEN,GGTAR2   . ->SS
)@@G@@COMPARING ARITHS  @B@@@)       MOVE  DGFLGZ,0,I . CLEAR IGEN FLAGS@F@@@)ST
)@@G@@       LOAD  X4,4,I     . OFFSET TO STR COMPARE ICODE  (GGSCM)    @F@@@)SU
)@@G@@       IF  SDCHBT,OFF,SGDCLS  THEN,GGTRET   . RIGHT IS CHAR STR.  @G@@@)SV
)@@G@@       IF  SDCHBT,OFF,SGDCLS+DCGSLT  THEN,GGTRET . -> LEFT IS CHAR STR  SW
)@@G@@@D@@@)       SET   IGBTCP,ON,DGFLGZ     . BOTH ARE BIT STRS @#@@@)GGTRETSX
)@@G@@* LABEL .   @F@@@)       STORE X4,DCGSV2+9     . SO RETURN CODE WILL BE SY
)@@G@@RETURNED    @#@@@)       GRTN 2     @[@-@).     @[@-@).     @^@-@).     SZ
)@@G@@   MAX OF (L1,L2) @[@-@).     @[@-@).     @#@-@)GGSLMX   LABEL .  @^@-@)TA
)@@G@@.        0=FULL FULL    @^@-@).        1=HALF FULL    @^@-@).        2=FTB
)@@G@@ULL HALF    @^@-@).        3=HA  F HALF   @[@-@).     @#@-@)         GNTTC
)@@G@@R  2 .@D@-@)         LOAD  X4,0,I .            SET FULL FULLL     @C@-@)TD
)@@G@@         IF    SGDHLF,OFF,SGDID THEN,GGSLX1 .   @^@-@)         ADD   X4,TE
)@@G@@2,I . @#@-@)GGSLX1   LABEL .  @D@-@)         IF    SGDHLF,OFF,SGDID+DCGSTF
)@@G@@LT THEN,GGSLX2 .  @^@-@)         ADD   X4,1,I . @#@-@)GGSLX2   LABEL .  TG
)@@G@@@B@-@)         SET   SGDHLF,OFF,SGDID+DCGSLT .  @C@-@)         GOTO  GGTTH
)@@G@@RET .            ->RETURN     @B@@@)/.           TARGETTING FOR BITWISE TI
)@@G@@AND/OR@#@@@)GGTBTS LABEL .    @#@@@)       GNTR 2 .   @G@-@)       IF  STJ
)@@G@@DARST,OFF,SGDCLS  THEN,GGTBAO   . OP IS IN ARITH QUANTITIES @C@@@)      TK
)@@G@@ LINK  GGTCHB     . CHECK AND CONVERT ARGR@D@-@)         XGPOP .        TL
)@@G@@           NOW CHECK 2ND ARG  @D@@@-       XGPOP .                   NOWTM
)@@G@@ CHECK 2ND ARG    @]@@@)GGTBT1 LABEL@C@@@)       LINK  GGTCHB     . CHECTN
)@@G@@K AND CONVERT ARGL@G@@@)       SUB   X7,DCGSLT,I .       'PUT' THE OTHERTO
)@@G@@ ARG BACK ON THE STACK  @C@-@)       LOAD  X4,0,I     . CLEAR RETIRN CODTP
)@@G@@E     @A@-@)       GOTO  GGTRET     . RETURN    @C@@@-       GOTO  GGTRETQ
)@@G@@0     . RETURN CLEAR CODE     @[@-@).     @C@-@).            TARGETTING TR
)@@G@@FOR ARITHMETIC AND/OR   @[@-@).     @]@-@)GGTBAO LABEL@C@-@)       LOAD TS
)@@G@@ X3,X7 .       FOR GGTNAB AND CGCONV@E@-@)       LINK  GGTNAB     . COMPTT
)@@G@@UTE (P,0)  X5 PTS TO A(REALAW)@C@-@)       CGCONV DGGSTK  R,X3    . CONVTU
)@@G@@ERT ARGR    @G@-@)       GENMR GGTFRC     . FORCE TO POSITIVE  (USES X5 TV
)@@G@@AS SET IN GGTNAB) @C@-@)       LOADA X3,SGDAID+DCGSLT . POINT TO ARGL   TW
)@@G@@@E@-@)       LINK  GGTNAB     . COMPUTE (P,0)  X5 PTS TO AREAL)   @C@-@)TX
)@@G@@       CGCONV R,X7   R,X3    . CONVERT ARGL     @^@-@)       LOAD  A7,SGTY
)@@G@@DPRE .@B@-@)       SUB   A7,SGDPRE+DCGSLT     . PR-PL @B@-@)       IF  ATZ
)@@G@@7,EQ,0,I  THEN,GGTBA1 . PR=PL @E@-@)       LOADA X5,SGDRBS+DCGSLT     . UA
)@@G@@ASSUME WE'LL SCALE ARGL @C@-@)       IF  A7,GE,1,I  THEN,GGTBA2 . -> PL<UB
)@@G@@PR    @A@-@)       LOADA X5,SGDRBS  . SCALE ARGR@^@-@)       LOADM A7,A7UC
)@@G@@ .    @]@-@)GGTBA2 LABEL@B@-@)       STORE A7,AGX0OF  . PAD WITH ZEROS  UD
)@@G@@@#@-@)       GENM .     @ @-@)       GIFR  GGTBA4,AGPTX5    @^@-@)      UE
)@@G@@ GLOAD AGPTX5 .   @#@-@)GGTBA4 GLBL .     @A@-@)       GSHIN OPLSSC,AGPTUF
)@@G@@X5,AGXR0 .  @E@-@)         GINST   OPLMA,AGPTX5,AGPTX5  'NO' . MAKE IT PUG
)@@G@@OS    @#@-@)       GFIN .     @]@-@)GGTBA1 LABEL@B@-@)       LOAD  X4,1,UH
)@@G@@I     . INDICITE ARITH  @D@-@)         MOVE    AGX0OF,36,I .     SET SHIUI
)@@G@@FT COUNT    @A@-@)       GOTO  GGTRET     . RETURN    @[@@@).     @B@@@)UJ
)@@G@@.            TARGETTING FOR BITWISE NOT   @[@@@).     @#@@@)GGTNBT LABELUK
)@@G@@ .    @#@@@)       GNTR 2 .   @E@-@)       IF  SDARST,ON,SGDCLS  THEN,GGUL
)@@G@@TBT2    . RIGHT IS STR  @E@-@)       LINK  GGTNAB     . COMPUTE (P,0)  XUM
)@@G@@5 PTS TO AREAL)   @ @-@)       CGCONV DGGSTK  R,X7 .  @G@-@)       GENMRUN
)@@G@@ GGTFRC     . FORCE TO POSITIVE  (USES X5 AS SET IN GGTNAB) @^@-@)      UO
)@@G@@ LOAD  A7,KSFTMX,I@^@-@)       SUB   A7,SGDPRE .@^@-@)       STORE A7,AGUP
)@@G@@X0OF .@F@-@)       GENM .                      CHECK IF IN REG!!!   ????UQ
)@@G@@***???@#@-@)         GLIT 1 . @D@-@)         LOADN   A3,0,I .          GUR
)@@G@@ET A NEGATIVE ZERO@F@-@)       GSHIN OPSSL,AGRA3,AGXR0    . JUST P 1'S RUS
)@@G@@IGHT JUSTIFIED    @D@-@)       GINST OPXOR,AGRL1,AGRA3 .    FLIP THOSE BUT
)@@G@@ITS   @D@-@)         GAPPN GGTBT3 .          SET SHIFT COUNT TO 36@E@-@)UU
)@@G@@         GSHIN   OPDSL,AGRL1,AGXR0 . PUT BACK IN  ODD REG   @#@-@)      UV
)@@G@@ GFIN .     @^@-@)       GOTO  GGTBA1 .   @#@-@)GGTBT3   GLBL .   @D@-@)UW
)@@G@@         MOVE    AGX0OF,36,I .     SHIFT INTO ODD REG @B@-@)         LJMUX
)@@G@@P .                    RETURN @B@-@)GGTBT2   LABEL . SET STACK TO BIT STUY
)@@G@@RING  @E@@@)         LINK    GGTCHB .          CHECK AND CONVERT ARG    UZ
)@@G@@@D@-@)         LOAD    X4,0,I .          CLEAR RETURN CODE  @D@-@)      VA
)@@G@@   GOTO    GGTRET .          RETURN TO XGEN     @E@@@-         GOTO    GVB
)@@G@@GTRE0 .          RETURN CLEAR CODE TO XGEN@[@@@).     @B@@@).           VC
)@@G@@ TARGETTING FOR STRING CONCAT.@[@@@).     @#@@@)GGTCHR LABEL .    @#@@@)VD
)@@G@@       GNTR 2 .   @C@=@)       LOAD  X4,0,I     . CLEAR RETIRN CODE     VE
)@@G@@@[@=@).     @A@=@).                ASSUME CHAR CONCAT.@[@=@).     @F@=@)VF
)@@G@@       IF  SDCHBT,OFF,SGDCLS  THEN,GGTCH1   . ->RIGHT IS CHAR     @H@@@=VG
)@@G@@       IF  SDCHBT,ON,SGDCLS  THEN,GGTRE0   . ->RIGHT IS BIT, RESULT IS LVH
)@@G@@EFT   @F@=@)       IF  SDCHBT,OFF,SGDCLS+DCGSLT  THEN,GGTRET . ->LEFT ISVI
)@@G@@ CHAR @B@=@)       ADD   X4,1,I     . BOTH ARE BIT STR@A@=@)       GOTO VJ
)@@G@@ GGTRET     . RETURN    @]@=@)GGTCH1 LABEL@E@@@)       SET SDCHBT,OFF,SGVK
)@@G@@DCLS+DCGSLT . SET RESULT TO BE CHAR @A@=@)       GOTO  GGTRET     . RETUVL
)@@G@@RN    @A@@@=       GOTO  GGTRE0     . RETURN    @[@@@).     @E@@@).     VM
)@@G@@           STRING STAGEING------------------------    @[@@@).     @B@@@)VN
)@@G@@GGSNOP   LLOC .  STAGEING FOR STRINGS     @D@@@)         LJMP .         VO
)@@G@@           NOTHING TO DO HERE @[@@@).     @G@@@).            THIS ENSUREVP
)@@G@@S TOP STACK ENTRY IS BIT STR AND POPS STACK     @[@@@).     @#@@@)GGTCHBVQ
)@@G@@ LOCAL .    @G@@@)       IF  SDCHBT,ON,SGDCLS  THEN,GGTCB1    . -> ITS AVR
)@@G@@LREADY BIT STR    @#@@@)       GENM .     @B@@@)       GINST OPLA,AGRA3,VS
)@@G@@AGRL1,U  'NO'  .  @^@@@)       GFREE AGRL1 .    @E@-@)         GSET    AVT
)@@G@@GRL1,AGSTK .     SET RESULT IS ON STACK   @E@@@-       GSET    AGRL1,AGSVU
)@@G@@TK .     SET RESULT IS ON STACK     @E@-@)         GINST   OPLA,AGRA2,AGVV
)@@G@@STK,U  'NO' . SET LHS IS TEMP @E@@@-       GINST   OPLA,AGRA2,AGSTK,U  'VW
)@@G@@NO' . SET LHS IS TEMP   @D@@@)       GSUB  EXBCA     . RUNTIME CONVERT TVX
)@@G@@O BITSTR    @#@@@)       GFIN .     @]@@@)GGTCB1 LABEL@E@@@)       MOVE VY
)@@G@@ SGDCLS,SDCHBT++SDARST,I    . RESULT IS BIT     @]@@@)       JMP .@[@-@)VZ
)@@G@@.     @C@-@).            ICODE TO FORCE FIXBIN IN X5 TO POS.@[@-@).     WA
)@@G@@@#@-@)GGTFRC GLBL .     @D@-@)       GGETGR AGIM1     . A REG TO USE TEMWB
)@@G@@PORARILY    @A@-@)       GINST OPLMA,AGIM1,AGPTX5 .   @ @-@)       GSET WC
)@@G@@ AGPTX5,AGIM1 .   @#@-@)       GFIN .     @[@-@).     @G@-@).           WD
)@@G@@ THIS COMPUTES PREC (Q=0) FOR ARITH TO STRING CONVERSION    @[@-@).     WE
)@@G@@@]@-@)GGTNAB LLOC @B@-@)       USING SGDSCT,X3  . FOR THIS ROUTINE@^@-@)WF
)@@G@@       LOAD  A7,SGDPRE .@D@-@)       IF  SDFXFL,ON,SGDCLS  THEN,GGTNA1  WG
)@@G@@  . -> FLOAT@^@-@)       LOAD  A8,SGDSCL .@^@-@)       SLB   A8,27 .    WH
)@@G@@@G@-@)       SSA   A8,27 .      SIGNED SALLE                           *WI
)@@G@@******@^@-@)       SUB   A7,A8 . P-Q@]@-@)GGTNA1 LABEL@D@-@)       IF  SWJ
)@@G@@DDCBN,ON,SGDCLS  THEN,GGTNA2    . BINARY  @^@-@)       MPYS  A7,K332S9  WK
)@@G@@@^@-@)       SLB   A7,KKSCL . @B@-@)       ADD   A7,1,I     . CEIL((P-Q)WL
)@@G@@*3.32)@]@-@)GGTNA2 LABEL@C@-@)       IF  A7,GE,0,I  THEN,GGTNA3 . -> P IWM
)@@G@@S OKAY@^@-@)       LOAD  A7,0,I .   @]@-@)GGTNA3 LABEL@E@-@)       IF  AWN
)@@G@@7,LT,KBXMXP+1,I  THEN,GGTNA4    . -> P OKAY     @ @-@)       LOAD  A7,KBWO
)@@G@@XMXP,I .    @]@-@)GGTNA4 LABEL@A@-@)       STORE A7,DGGPRE  . STORE PT  WP
)@@G@@@A@-@)       MOVE  DGGSCL,0,I . NO SCALE  @B@-@)       LOADA X5,1,X3   .WQ
)@@G@@ ADDR OF REAL AW  @#@-@)       LJMP .     @C@-@)       USING SGDSCT,X7  WR
)@@G@@. RETURN TO NORMALCY    @B@@@)/.     ------ STAGING ROUTINES -------    WS
)@@G@@@[@@@).     @[@@@).     @C@@@).            STAGING FOR COMPARISON OPERATWT
)@@G@@ORS   @[@@@).     @#@@@)GGSCMP LABEL .    @#@@@)       GNTR 2     @E@@@)WU
)@@G@@       IF  4,ON,DCGSV2+9  THEN,GGSCM1  . -> ITS A STR CPMP  @[@@@).     WV
)@@G@@@B@@@).        ARITH COMPARES INTO BIT STRING   @[@@@).     @^@@@)      WW
)@@G@@ LOAD  A7,SGDSCL .@H@@@)       IF      A7,EQ,SGDSCL+DCGSLT  THEN,GGSCM1 WX
)@@G@@ . ->QL=QR, NO SCALING NEEDED @C@@@)       LINK  GGSSCL     . SCALE SMALWY
)@@G@@LER OPERAND @F@@@)GGSCM1 LABEL .                     SET RESULT WILL BE WZ
)@@G@@BIT STRING  @G@@@)         SET     IGRCMP,OFF,DGFLGZ . TELL ICODE TO CONXA
)@@G@@VERT TO BIT STRING@E@@@)         MOVE    SGDAID+DCGSLT,DGBTMK . SET PROPXB
)@@G@@ER BITS     @G@@@)         MOVE    AGTMP1,0,I . CLEAR ADDRESS WORD FOR JXC
)@@G@@UMP IF COMPLEX    @#@@@)GGSRET* LABEL .   @#@@@)       GRTN  2    @[@@@)XD
)@@G@@.     @D@@@).        STAGEING FOR ''IF TYPE'' RELATIONAL OPERATORS@C@@@)XE
)@@G@@.        ONLY ONE 'COMPARE' ALLOWED ON THESE    @[@@@).     @#@@@)GGSRELXF
)@@G@@   LABEL .  @#@@@)         GNTR 2 . @E@@@)         LOAD    A7,SGDSCL .  XG
)@@G@@     PICK UP SCALE OF NUM     @G@@@)         IF  A7,EQ,SGDSCL+DCGSLT  THXH
)@@G@@EN,GGRCM1 . QR = QL, NO SCALING     @D@@@)         LINK    GGSSCL .     XI
)@@G@@     GO SCALE NUMBERS   @#@@@)GGRCM1   LABEL .  @ @@@)         USING   WXJ
)@@G@@ORD,X7 .    @E@@@)         MOVE    W1H2+DCGSLT,DXGARG . TYPE OF JUMP FORXK
)@@G@@ FALSE@F@@@)         MOVE    SGDID+DCGSLT,SGDCC,I . SET CONDITION CODE TXL
)@@G@@YPE   @F@@@)         SET     IGRCMP,ON,DGFLGZ . TELL ICODE ''IF TEST'' CXM
)@@G@@OMPARE@E@@@)         MOVE    AGTMP1,0,I .      CLEAR JUMP ADDRESS WORD  XN
)@@G@@@B@@@)         GOTO    GGSRET .          RETURN @C@@@)/.           ICODEXO
)@@G@@ FOR TARGETING AND STAGING    @H@@@).            GERERATE CODE FOR COMPAXP
)@@G@@RES, FUDGING THE INST CODES FOR TESTS     @I@@@).            DEPENDING OXQ
)@@G@@N THE COMPARE, SUBTRACT 2 FROM 1 (BA) OR 1 FROM 2 (AB).     @ @@@).     XR
)@@G@@       FLOATING COMPARES@[@@@).     @[@@@).     @C@@@)       GMODE 'M'  XS
)@@G@@ . SET BIT FOR PACKING ICODE  @#@@@)GGFCBA GLBL .     @D@@@)         GIFXT
)@@G@@R    G1FCBA,AGIM2 .    SEE IF IN A REG    @A@@@)       GGETGR AGXTMP    XU
)@@G@@ . TEMP REG @A@@@)       GDBLE OPDL,AGXTMP,AGIM2 .    @D@@@)         GGOXV
)@@G@@TO   G2FCBA .          GO DO SUBTRACT     @F@@@)G1FCBA   GLBL .         XW
)@@G@@           AGIM2 IS ALREADY A REGISTER    @C@@@)         GSET    AGXTMP,XX
)@@G@@AGIM2 .    POINT TO IT  @C@@@)G2FCBA   GLBL .                    MERGE HXY
)@@G@@ERE   @A@@@)       GFLOAT OPDFAN,AGXTMP,AGIM1 . @B@@@)       GBAL  GGCCTXZ
)@@G@@S     . GEN PROPER TEST @#@@@)GGFRBA GLBL .     @E@@@)         GIFR    GYA
)@@G@@1FRBA,AGRL2 .    IS AGRL2 IN A REG YEG?   @A@@@)       GGETGR AGXTMP    YB
)@@G@@ . TEMP REG @A@@@)       GDBLE OPDL,AGXTMP,AGRL2 .    @D@@@)         GGOYC
)@@G@@TO   G2FRBA .           GO DO SUBTRACT    @F@@@)G1FRBA   GLBL .         YD
)@@G@@           AGRL2 IS IN A REGISTER ALREADY @C@@@)         GSET    AGXTMP,YE
)@@G@@AGRL2 .     POINT TO IT @C@@@)G2FRBA   GLBL .                    MERGE HYF
)@@G@@ERE   @A@@@)       GFLOAT OPDFAN,AGXTMP,AGRL1 . @B@@@)       GGOTO GGCRTYG
)@@G@@S     . GEN PROPER TEST @[@@@).     @#@@@)GGFCAB GLBL .     @E@@@)      YH
)@@G@@   GIFR    G1FCAB,AGIM1 .    IS AGIM1 A REGISTER?     @A@@@)       GGETGYI
)@@G@@R AGXTMP     . TEMP REG @A@@@)       GDBLE OPDL,AGXTMP,AGIM1 .    @D@@@)YJ
)@@G@@         GGOTO   G2FCAB .          GO DO SUBTRACT     @F@@@)G1FCAB   GLBYK
)@@G@@L .                    AGIM1 IS A REGISTER ALREADY    @C@@@)         GSEYL
)@@G@@T    AGXTMP,AGIM1 .    POINT TO IT  @E@@@)G2FCAB   GLBL .               YM
)@@G@@     MERGE HERE FOR SUBTRACT  @A@@@)       GFLOAT OPDFAN,AGXTMP,AGIM2 . YN
)@@G@@@B@@@)       GBAL  GGCCTS     . GEN PROPER TEST @#@@@)GGFRAB GLBL .     YO
)@@G@@@F@@@)         GIFR    G1FRAB,AGRL1 .    IS AGRL1 A REGISTER ALREADY    YP
)@@G@@@A@@@)       GGETGR AGXTMP     . TEMP REG @A@@@)       GDBLE OPDL,AGXTMPYQ
)@@G@@,AGRL1 .    @D@@@)         GGOTO   G2FRAB .          GO DO SUBTRACT     YR
)@@G@@@E@@@)G1FRAB   GLBL .                    AGRL1 IS IN A REGISTER   @C@@@)YS
)@@G@@         GSET    AGXTMP,AGRL1 .    POINT TO IT  @E@@@)G2FRAB   GLBL .   YT
)@@G@@                 MERGE HERE FOR SUBTRACT  @A@@@)       GFLOAT OPDFAN,AGXYU
)@@G@@TMP,AGRL2 . @B@@@)       GGOTO GGCRTS     . GEN PROPER TEST @[@@@).     YV
)@@G@@@ @@@).            BINARY COMPARES  @[@@@).     @#@@@)GGBCBA GLBL .     YW
)@@G@@@D@@@)         GIFR    G1BCBA,AGIM2 .    IS AGIM2 IN A REG? @A@@@)      YX
)@@G@@ GGETGR AGXTMP     . TEMP REG @ @@@)       GINST OPLA,AGXTMP,AGIM2@D@@@)YY
)@@G@@         GGOTO   G2BCBA .          GO DO SUBTRACT     @B@@@)G1BCBA   GLBYZ
)@@G@@L .  AGIM2 IS IN A REG NOW    @C@@@)         GSET    AGXTMP,AGIM2 .    PZA
)@@G@@OINT TO IT  @B@@@)G2BCBA   GLBL .  MERGE HERE FOR SUBTRACT  @A@@@)      ZB
)@@G@@ GINST OPANA,AGXTMP,AGIM1     @B@@@)       GBAL  GGCCTS     . GEN PROPERZC
)@@G@@ TEST @#@@@)GGBRBA GLBL .     @D@@@)         GIFR    G1BRBA,AGRL2 .    IZD
)@@G@@S AGRL2 IN A REG? @A@@@)       GGETGR AGXTMP     . TEMP REG @ @@@)      ZE
)@@G@@ GINST OPLA,AGXTMP,AGRL2@D@@@)         GGOTO   G2BRBA .          GO DO SZF
)@@G@@UBTRACT     @D@@@)G1BRBA   GLBL .                    AGRL2 IS IN A REG  ZG
)@@G@@@C@@@)         GSET    AGXTMP,AGRL2 .    POINT TO IT  @E@@@)G2BRBA   GLBZH
)@@G@@L .                    MERGE HERE FOR SUBTRACT  @A@@@)       GINST OPANAZI
)@@G@@,AGXTMP,AGRL1     @B@@@)       GGOTO GGCRTS     . GEN PROPER TEST @[@@@)ZJ
)@@G@@.     @#@@@)GGBCAB GLBL .     @D@@@)         GIFR    G1BCAB,AGIM1 .    IZK
)@@G@@S AGIM1 IN A REG? @A@@@)       GGETGR AGXTMP     . TEMP REG @ @@@)      ZL
)@@G@@ GINST OPLA,AGXTMP,AGIM1@D@@@)         GGOTO   G2BCAB .          GO DO SZM
)@@G@@UBTRACT     @D@@@)G1BCAB   GLBL .                    AGIM1 IS IN A REG  ZN
)@@G@@@C@@@)         GSET    AGXTMP,AGIM1 .    POINT TO IT  @E@@@)G2BCAB   GLBZO
)@@G@@L .                    MERGE HERE FOR SUBTRACT  @A@@@)       GINST OPANAZP
)@@G@@,AGXTMP,AGIM2 .   @B@@@)       GBAL  GGCCTS     . GEN PROPER TEST @#@@@)ZQ
)@@G@@GGBRAB GLBL .     @D@@@)         GIFR    G1BRAB,AGRL1 .    IS AGRL1 IN AZR
)@@G@@ REG  @A@@@)       GGETGR AGXTMP     . TEMP REG @A@@@)       GINST OPLA,ZS
)@@G@@AGXTMP,AGRL1 .    @D@@@)         GGOTO   G2BRAB .          GO DO SUBTRACZT
)@@G@@T     @D@@@)G1BRAB   GLBL .                    AGRL1 IS IN A REG  @C@@@)ZU
)@@G@@         GSET    AGXTMP,AGRL1 .    POINT TO IT  @B@@@)G2BRAB   GLBL .  MZV
)@@G@@ERGE HERE FOR SUBTRACT  @A@@@)       GINST OPANA,AGXTMP,AGRL2 .   @C@@@)ZW
)@@G@@/.       NOW THAT THE STUFF IS SUBTRACTED...    @B@@@).        SET UP THZX
)@@G@@E PROPER TESTS FOR IT   @[@@@).     @#@@@)GGCRTS GLBL .     @E@@@)      ZY
)@@G@@   GINST  OPAA,AGXTMP,AGDZRO 'NO' . NO NEG 0'S ALLOWED@E@@@)         GBOZZ
)@@G@@N    GGCRTR,IGRCMP .   BIT STRING OR IF TEST?   @[@@@).     @D@@@).     AA
)@@G@@           BIT STRING CREATION AFTER TEST HERE  @[@@@).     @G@@@)      AB
)@@G@@   GAPPN   GGTRFA .          SET A9,A10 WITH PROPER T/F TESTS     @F@@@)AC
)@@G@@         GLITRG  A9 .              ASSUME TRUE (SET UP BEFORE)    @E@@@)AD
)@@G@@         GLITRG  A7 .              GENERATE TEST INSTRUCTION@E@@@)      AE
)@@G@@   GLABEL  AGTMP1 .          LABEL FOR COMPLEX JUMPS  @F@@@)         GFRAF
)@@G@@EE   AGXTMP .          FREE THE REGISTER FOR OTHER USE@D@@@)         GLIAG
)@@G@@TRG  A10 .             ''FALSE'' BIT HERE @G@@@)         GSUB    EXA3DV AH
)@@G@@.          CONVERT A3 TO BIT, CREATE DV FOR BIT @C@@@)         GGOTO   GAI
)@@G@@GCRTE .          -> MERGE     @ @@@)GGCRTR   GLBL .  ''IF TEST''  @E@@@)AJ
)@@G@@         GSET  AGRL2,AGXTMP .     SET AW TO POINT TO RESULT @ @@@)GGCRTEAK
)@@G@@   GLBL .  ->MERGE HERE @E@@@)         GNI     07777-IGRCMP .    SET BITAL
)@@G@@ OFF IN DCGFLGZ   @F@@@)         GFIN    'POP' .           POP OFF EXTRAAM
)@@G@@ STACK ELEMENT    @D@@@)GGCCTS   GLBL .  COMPLEX TYPES ''LOOP'' THROUGH AN
)@@G@@HERE  @D@@@)         GAPPN   GGFUDG .          SET UP TEST IN A7  @C@@@)AO
)@@G@@         GLITRG  A7 .              GENERATE TEST@G@@@)         GJUMP   AAP
)@@G@@GTMP1 .          JUMP TO PLACE IN REAL TEST IF FALSE  @#@@@)         GRTAQ
)@@G@@RN .  @[@@@).     @C@@@).        SUBROUTINES TO DO THE STACK MANAGEMENT AR
)@@G@@@[@@@).     @G@@@)GGFUDG   GLBL .            SET 'TEST TRUE'   AND SET SAS
)@@G@@TACK TO BIT STRING@F@@@)         LOAD    X3,AGXTMP .       GET REGISTER AT
)@@G@@NUMBER FOR TEST   @C@@@)         LOAD    A7,DXGARG .       GET OPCODE   AU
)@@G@@@E@@@)         SLB     A7,18 .           PUT IN PROPER POSITION   @E@@@)AV
)@@G@@         ADD     A7,RGSWRN,X3 .    ADD IN REGISTER NUMBER   @E@@@)      AW
)@@G@@   ADD     A7,A0-X0,I .      ADD IN OFFSET OF REG     @F@@@)         STOAX
)@@G@@RE   A7,DCGSV4+1 .     PUT IT WHERE ICODE CAN FIND IT @#@@@)         LJMAY
)@@G@@P .   @D@@@)GGTRFA   GLBL .  SET UP PROPER T/F BIT LOADS IN A9,A10@H@@@)AZ
)@@G@@         MOVE    SGDRBS+DCGSLT-FH1,AGSTK . SET TEMP STRING IN STRING STABA
)@@G@@CK    @F@@@)         LOAD    X3,AGXTMP .       GET REGISTER NUMBER FOR TBB
)@@G@@EST   @C@@@)         LOAD    A7,DXGARG .       GET OPCODE   @E@@@)      BC
)@@G@@   SLB     A7,18 .           PUT IN PROPER POSITION   @E@@@)         ADDBD
)@@G@@     A7,RGSWRN,X3 .    ADD IN REGISTER NUMBER   @E@@@)         ADD     ABE
)@@G@@7,A0-X0,I .      ADD IN OFFSET OF REG     @F@@@)         STORE   A7,DCGSBF
)@@G@@V4+1 .     PUT IT WHERE ICODE CAN FIND IT @E@@@)         LOADD   A7,DGTRBG
)@@G@@FA .       SET BITS TRUE, FALSE     @G@@@)         STORED  A7,DCGSV4+3 .BH
)@@G@@     PUT THEM WHERE ICODE CAN FIND THEM   @[@@@).     @C@@@).           BI
)@@G@@     SEE IF COMPLEX, AND \= OPERATOR@[@@@).     @D@@@)         IF  SDRLCBJ
)@@G@@X,OFF,SGDCLS  THEN,LJMP . -> REAL   @C@@@)         LOAD    A3,DXGARG .  BK
)@@G@@     SEE IF \=    @C@@@)         IF  A3,NE,DGTNE  THEN,LJMP . -> NOT \= BL
)@@G@@@F@@@)         LDSC    A7,36 .           SWITCH BITS FOR FALSE & TRUE   BM
)@@G@@@G@@@)         STORED  A7,DCGSV4+3 .     PUT THEM WHERE ICODE CAN FIND TBN
)@@G@@HEM   @#@@@)         LJMP .   @[@@@)/.    @ @@@).            STRING COMPBO
)@@G@@ARE   @[@@@).     @#@@@)GSCMAB   GLBL .   @A@-@)       GINST OPLA,AGRA3,BP
)@@G@@AGRL1,U     @^@@@-         GLIT    1 .    @A@-@)       GINST OPLA,AGRA2,BQ
)@@G@@AGRL2,U     @^@@@-         LA,XU   A1,-1 .@F@@@)         GGOTO   GSCMBB BR
)@@G@@.          GO CHOOSE PROPER SUB TO CALL   @G@@@)GSCMBA   GLBL .         BS
)@@G@@           SWITCH THE ORDER OF COMPARE HERE     @D@-@)         GINST   OBT
)@@G@@PLA,AGRA3,AGRL2,U . POINT TO LHS    @^@@@-         GLIT    1 .    @^@@@-BU
)@@G@@         LA,U    A1,1 . @D@-@)         GINST   OPLA,AGRA2,AGRL1,U . POINBV
)@@G@@T TO RHS    @F@@@)GSCMBB   GLBL .                    MREGE HERE TO CHOOSBW
)@@G@@E ROUTINE   @D@@@-         GINST   OPLA,AGRA2,AGRL2,U . POINT TO LHS    BX
)@@G@@@D@@@-         GINST   OPLA,AGRA3,AGRL1,U . POINT TO RHS    @E@@@)      BY
)@@G@@   GBON    GSCMBC,IGBTCP .   CALL BIT ROUTINE THERE   @F@@@)         GSUBZ
)@@G@@B    EXSTCM .          RUNTIME STRING COMPARE ROUTINE @D@@@)         GGOCA
)@@G@@TO   GSCMCC .          MERGE TO FINISH    @D@@@)GSCMBC   GLBL .         CB
)@@G@@           BIT COMPARE HERE   @E@@@)         GSUB    EXBTCM .          CCC
)@@G@@ALL FOR BIT COMPARE     @E@@@)GSCMCC   GLBL .                    CONTINUCD
)@@G@@E THE WORK HERE   @C@@@)         GLIT 1 .                   LOAD TRUE   CE
)@@G@@@ @@@)         LA,U    A3,'1' .     @D@@@)         GAPPN   GGFXA7 .     CF
)@@G@@     FIX UP TEST INTO A7@C@@@)         GLITRG  A7 .              GENERATCG
)@@G@@E TEST@C@@@)         GLIT 1 .                  LOAD FALSE   @ @@@)      CH
)@@G@@   LA,U    A3,'0' .     @E@@@)         GSUB    EXA3DV .          PRODUCECI
)@@G@@ DV FOR BIT IN A3 @B@@@)         GFIN    'POP' .           DONE   @E@@@)CJ
)@@G@@GGFXA7   GLBL .  SET STACK TO STRING, AND PRODUCE TEST IN A7@C@@@)      CK
)@@G@@   LOAD    A7,DXGARG .       GET TEST     @E@@@)         SLB     A7,18 .CL
)@@G@@           PUT IT IN OPCODE FIELD   @D@@@)         ADD     A7,A1,I .    CM
)@@G@@     ADD ADDRESS OF A1  @F@@@)         STORE   A7,DCGSV4+1 .     PUT IT CN
)@@G@@WHER ICODE CAN FIND IT  @E@@@)         MOVE    SGDAID+DCGSLT,DGBTMK . SECO
)@@G@@T STACK TO BIT    @G@@@)         MOVE    SGDRBS+DCGSLT-FH1,AGSTK . SET SCP
)@@G@@TRING IN TEMP STACK     @#@@@)         LJMP .   @[@@@).     @E@@@).     CQ
)@@G@@       STAGING FOR COMPARES IN STRING-LENGTH STATE    @[@@@).     @#@-@)CR
)@@G@@GGCMSM   LABEL    @#@+@-GGCMSM   LLOCL .  @#@@@+GGCMSM   LLOC .   @D@@@)CS
)@@G@@         GFIX  SGDCDE+DCGSLT .     RESET CODE GENNED  @C@@@)         LOACT
)@@G@@D  A8,X11 .            SAVE RETURN  @#@@@)         GENM     @^@@@)      CU
)@@G@@   GFREE AGRL1 .  @^@@@)         GFREE AGRL2 .  @^@@@)         GFIN  'POCV
)@@G@@P' .  @E@@@)         LOAD  X11,A8 .            RESET RETURN ADDRESS     CW
)@@G@@@E@@@)         LOAD  A7,1,I .            SET SIZE OF STRING VALUE @D@@@)CX
)@@G@@         GOTO  CBSLLA .            GEN CODE TO LOAD 1 @D@-@)/.          CY
)@@G@@ LOGOCAL AND MISCELLANEOUS I-CODE ROUTINES@D@@@-/.           LOGICAL ANDCZ
)@@G@@ MISCELLANEOUS I-CODE ROUTINES@#@-@)GGAND  GLBL .     @A@-@)       GINSTDA
)@@G@@ OPAND,AGRL2,AGRL1 .    @E@-@)         GINST   OPDSL,AGRL2,AGXR0 .    PUDB
)@@G@@T BACK IN REGISTER@^@-@)       GFIN  'POP'  .   @#@-@)GGOR   GLBL .     DC
)@@G@@@A@-@)       GINST OPOR,AGRL2,AGRL1 .     @E@-@)         GINST   OPDSL,ADD
)@@G@@GRL2,AGXR0 .    PUT BACK IN REGISTER@^@-@)       GFIN  'POP'  .   @#@@@)DE
)@@G@@GGAOCT GLBL .     @B@@@)       GINST OPLA,AGRA2,AGRL2,U 'NO'  .   @^@@@)DF
)@@G@@       GFREE AGRL2 .    @B@@@)       GINST OPLA,AGRA3,AGRL1,U 'NO'  .   DG
)@@G@@@^@@@)       GFREE AGRL1 .    @^@@@)       GSUB  'BILTN' .  @ @@@)      DH
)@@G@@ GSET  AGRL2,AGSTK .    @^@@@)       GFIN  'POP'  .   @#@@@)GGNOT  GLBL DI
)@@G@@.     @B@@@)       GINST OPLA,AGRA3,AGRL1,U 'NO'  .   @^@@@)       GFREEDJ
)@@G@@ AGRL1 .    @B@@@)       GSUB  'BILTN' . RUNTIME NEGATE     @ @@@)      DK
)@@G@@ GSET  AGRL1,AGSTK .    @#@@@)GGNOOP* GLBL .    @#@@@)       GFIN .     DL
)@@G@@@[@-@).     @[@-@).     @B@-@).        ICODE FOR RESULT=L(A2)+L(A1)     DM
)@@G@@@[@-@).     @#@-@)GGLAFH   GLBL     @ @-@)         GSET  AGXTMP,AGRL1   DN
)@@G@@@ @-@)         GSET  AGRL1,AGRL2 .  @#@-@)GGLAHF   GLBL     @C@-@)      DO
)@@G@@   GIFR  GGLAHH,AGRL2 .      A1 TO REG    @^@-@)         GLOAD AGRL2,1  DP
)@@G@@@#@-@)GGLAHH   GLBL .   @ @-@)         GIFR  GGLAH3,AGRL2   @^@-@)      DQ
)@@G@@   GGETGR AGXTMP  @A@-@)         GINST  OPLA,AGXTMP,AGRL2,H1@ @-@)      DR
)@@G@@   GSET  AGRL2,AGXTMP   @#@-@)GGLAH3   GLBL     @ @-@)         GIFR  GGLDS
)@@G@@AFF,AGRL1   @A@-@)         GINST OPAA,AGRL2,AGRL1,H1  @#@-@)GGLAH1   GLBDT
)@@G@@L     @^@-@)         GAPPN GGLPXL . @^@-@)         GFIN  'POP'    @#@-@)DU
)@@G@@GGLAFF   GLBL     @ @-@)         GIFR  GGLAF1,AGRL2 . @ @-@)         GSEDV
)@@G@@T  AGXTMP,AGRL2   @ @-@)         GSET  AGRL2,AGRL1    @ @-@)         GSEDW
)@@G@@T  AGRL1,AGXTMP   @ @-@)         GIFR  GGLAF1,AGRL2   @^@-@)         GLODX
)@@G@@AD AGRL2,1  @#@-@)GGLAF1   GLBL     @A@-@)         GINST OPAA,AGRL2,AGRLDY
)@@G@@1     @^@-@)         GGOTO GGLAH1   @[@-@).     @[@-@).     @#@-@)GGLPXLDZ
)@@G@@   GLBL     @C@-@)         IF    IGITER,OFF,DGFLGZ THEN,LJMP .    @A@-@)EA
)@@G@@         LOAD  A7,SGDRBS+DCGSLT-FH1 @C@-@)         IF    A7,EQ,SGDRAB+DCEB
)@@G@@GSLT-FH1 THEN,LJMP@^@-@)         SETGC 2,GGLPX  @#@-@)         LJMP .   EC
)@@G@@@#@-@)GGLPX    GLBL .   @A@-@)         GINST OPLA,SGDRAB,AGRL2    @ @-@)ED
)@@G@@         GSET  AGRL2,SGDRAB   @^@-@)         GFIN  'POP'    @[@-@).     EE
)@@G@@@[@-@).     @ @-@).        ICODE FOR MAX(L1+L2) @[@-@).     @#@-@)GGLXHHEF
)@@G@@   GLBL     @ @-@)         GIFR  GGLXHF,AGRL2 . @^@-@)         GGETGR AGEG
)@@G@@XTMP  @A@-@)         GINST  OPLA,AGXTMP,AGRL2,H1@ @-@)         GSET  AGREH
)@@G@@L2,AGXTMP . @#@-@)GGLXHF   GLBL     @ @-@)         GIFR  GGLXFF,AGRL1   EI
)@@G@@@B@-@)         GGETGR                    AGXTMP @A@-@)         GINST OPLEJ
)@@G@@A,AGXTMP,AGRL1    @ @-@)         GSET  AGRL1,AGXTMP   @^@-@)         GGOEK
)@@G@@TO GGLXFF   @#@-@)GGLXFH   GLBL     @ @-@)         GIFR  GGLXFF,AGRL2   EL
)@@G@@@^@-@)         GGETGR AGXTMP  @A@-@)         GINST OPLA,AGXTMP,AGRL2,H1 EM
)@@G@@@ @-@)         GSET  AGRL2,AGXTMP   @#@-@)GGLXFF   GLBL     @ @-@)      EN
)@@G@@   GIFR  GGLXF2,AGRL1   @^@-@)         GLOAD AGRL1,1  @#@-@)GGLXF2   GLBEO
)@@G@@L     @ @-@)         GIFR  GGLXF3,AGRL2   @^@-@)         GLOAD AGRL2,1  EP
)@@G@@@#@-@)GGLXF3   GLBL     @B@-@)         GINST OPTLE,AGRL2,AGRL1 'NO'     EQ
)@@G@@@A@-@)         GINST OPLA,AGRL2,AGRL1     @^@-@)         GFIN  'POP'    ER
)@@G@@@]@@@)       CEND @]@@@)       END .___,U . POINT TO RHS    @F@@@)GSCMBBES
)@@G@@   GLBL .                    MREGE HERE TO CHOOS*[S@@@*SDFF*@C@@@/.   COET
)@@G@@PYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@/.     @D@@@/.   QUESTIONEU
)@@G@@S CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@/.     @ @@@/.        MAREV
)@@G@@VIN V. ZELKOWITZ  @B@@@/.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@/EW
)@@G@@.        UNIVERSITY OF MARYLAND     @B@@@/.        COLLEGE PARK, MARYLANEX
)@@G@@D 20742     @[@@@/.     @G@@@/.        PERMISSION TO USE THESE LISTINGS EY
)@@G@@AND THE COMPUTER PROGRAMS THEY@E@@@/.   REPRESENT IS GRANTED UNDER THE FEZ
)@@G@@OLLOWING CONDITIONS:    @[@@@/.     @G@@@/.        1. UNLIMITED USE MAY FA
)@@G@@BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@/.   THESE LISTINGS PROVIFB
)@@G@@DED THAT THE NAME PLUM OR UNIVERSITY OF MARYLAND@E@@@/.   PL/1 COMPILER FC
)@@G@@REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@/.     @F@@@/.        2. FD
)@@G@@MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDED:   @[@@@/.     @G@@@/FE
)@@G@@.        (A) ANY RESULTING PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   FF
)@@G@@@G@@@/.        DESCRIBING SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PRFG
)@@G@@OGRAM @E@@@/.        IS A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  FH
)@@G@@@[@@@/.     @G@@@/.        (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAFI
)@@G@@L CORRECTIONS     @F@@@/.        OF ERRORS IN THE SOURCE PROGRAMS, SHALLFJ
)@@G@@ BE REPORTED AND  @G@@@/.        A BRIEF DESCRIPTION OF THE FEATURE ADDEFK
)@@G@@D SHALL BE SUBMITTED    @C@@@/.        TO THE UNIVERSITY OF MARYLAND, ANFL
)@@G@@D     @[@@@/.     @F@@@/.        (C) NO PROGRAMS DERIVED FROM THESE LISTFM
)@@G@@INGS SHALL BE SOLD@G@@@/.        WITHOUT WRITTEN APPROVAL FROM THE UNIVEFN
)@@G@@RSITY OF MARYLAND, AND  @[@@@/.     @F@@@/.        (D) COPIES OF THESE PFO
)@@G@@ROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@/.        LOCATIONS PROVIDED THFP
)@@G@@AT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@/.        WHETHER THE PROFQ
)@@G@@GRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     @E@@@/.        MARYLAND FR
)@@G@@PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@/.     @G@@@/.        3. FS
)@@G@@THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILER ITSELF,    @F@@@/.   ANFT
)@@G@@D ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN USING PLUM. @E@@@/.   THFU
)@@G@@E PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USER TO @F@@@/.   EXPERIMEFV
)@@G@@NT WITH THE COMPILER AS LONG AS THE RESULTING PRODUCT @G@@@/.   IS NOT SFW
)@@G@@OLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DEVELOPED   @#@@@/.   FRFX
)@@G@@OM PLUM.    @[@@@/.     @[@@@/.     @[@@@/.     @[@@@/.     @[@@@/.     FY
)@@G@@@[@@@//.    @#@@@9         AXR$ .   @#@@@9         DCLRG .  @#@@@9      FZ
)@@G@@   UNLIST   @#@@@9@ADD,P PLTVDS     @#@@@9         LIST .   @#@@@9@ADD,PGA
)@@G@@ PLCGST     @#@@@9@ADD,P PLDSAW     @#@@@9         CEND .   @#@@@9      GB
)@@G@@    PLSD .  @#@@@9          PLAC .  @#@@@9          PLAR .  @#@@@9      GC
)@@G@@   PLCGD .  @C@@@9         PLIG .                    ICODE EQU'S  @#@@@9GD
)@@G@@          PLWORD .@^@@@9.        ICODE FLAGS    @^@@@9CODEX    DSECT 12 GE
)@@G@@.     @#@@@9CDINST   SF .     @^@@@9         ORIGIN CDINST .@#@@@9CDOP  GF
)@@G@@   SS .     @#@@@9CDUFLD   SH .     @^@@@9         ORIGIN CDINST .@#@@@9GG
)@@G@@CDINPT   SH .     @#@@@9         DEND .   @D@@@9DGRSET   EQU   0001 .   GH
)@@G@@           SINGLE ENTRY POINT @C@@@9DGRMT    EQU   0002 .              RGI
)@@G@@EMOTE ENTRY @C@@@9DGCONT   EQU   0004 .              GENM ENTRY   @C@@@9GJ
)@@G@@DGXTED   EQU   0010 .        IMMEDIATE DATA FLAG@C@@@9DGXTDL   EQU   002GK
)@@G@@0 .        IN-SUBROUTINE FLAG @D@@@9/. TITLE PLUM - CODE GENERATOR:  INTGL
)@@G@@ERPRETIVE CODER   @^@@@9AWRGPT   EQU   AWRWPT . @#@@@9IGCD     CSECT 3 .GM
)@@G@@@ @@@9         USING CODEX,X10 .    @#@@@9XGCODE*  GNTR  4 .@C@@@9      GN
)@@G@@   LOAD  F,DGRSET,I .        SINGLE ENTRY @ @@@9          GOTO   GSTRT15GO
)@@G@@ .    @#@@@9XGENR*   GNTR 4 . @ @@@9         LOAD F,DGRMT,I .     @ @@@9GP
)@@G@@          GOTO   GSTAR11 .    @E@@@9XGENMR*  GNTR 4 .                  MGQ
)@@G@@ULTIPLE REMOTE ENTRY    @A@@@9         LOAD  F,DGCONT+DGRMT,I .   @^@@@9GR
)@@G@@         GOTO  GSTAR11 .@#@@@9XGENM*   GNTR 4 . @ @@@9         LOAD  F,DGS
)@@G@@GCONT,I .   @#@@@9GSTRT15   LABEL   @D@@@9         USING WORD,A0 .      GT
)@@G@@     GET PTR TO ICODES  @^@'@9         SUB   A0,1,I . @B@'@9         LOAGU
)@@G@@D  X2,W1H2,*A0 .       GET PTR@B@@@'         LOAD  X2,W1H2,A0 .        GGV
)@@G@@ET PTR@#@@@9GSTAR11  LABEL .  @D@'@9         SETGC 6,0,X2 .            SGW
)@@G@@ET TO REAC ICODE  @D@@@'.        SETGC 6,0,X2 .            SET TO READ IGX
)@@G@@CODE  @ @@@'         LOAD    X1,W1U,X2 .  @ @@@'         LOADXI  X1,1,I GY
)@@G@@.     @ @@@'         LOAD    A1,KLCH6W .  @E@@@9         MOVE  DGSTOR,0,GZ
)@@G@@I .        CLEAR BASE-DISP CALC.    @ @@@9         MOVE  DGADMD,0,I .   HA
)@@G@@@#@@@9GNEXT     LABEL   @C@@@9         GETC .                    ICODE IHB
)@@G@@N A8  @C@@@9         SRBD  A8,1 .              FLAG IN A9   @D@@@9      HC
)@@G@@   LOAD  X4,A8 .             PUT INTO X REG     @H@@@9          GOTO   *HD
)@@G@@GBRTBL,X4 .            -> ACTION APPROPRIATE TO OP-CODE     @B@@@9.     HE
)@@G@@           ICODE OPERAND DECODER    @ @@@9GARGMK   LLOC  . FLAG DECODER HF
)@@G@@@A@@@9         GETC  . GET HIGH ORDER BITS@F@@@9         SLBD  A7,36+6  HG
)@@G@@     . ACCUMULATE HIGH AND LOW BITS IN A7 @A@@@9         GETC  . GET LOWHH
)@@G@@ ORDER BITS @C@@@9         ADD   A7,A8         . ENTIRE FLAG IN A7@ @@@9HI
)@@G@@         LJMP  . -> RETURN    @E@@@9GARG     LLOC .                    GHJ
)@@G@@ET AW FROM ARGUMENT     @B@@@9         GETC  .                   TYPE,J HK
)@@G@@@C@@@9         LOAD  A3,A8 .             LEAVE J ONLY @G@@@9         ANDHL
)@@G@@,U A3,017 .                                          *******@^@@@9      HM
)@@G@@   LOAD  A10,A4 . @C@@@9         SRB   A8,4 .              GET TYPE     HN
)@@G@@@^@@@9         LOAD  X2,A8 .  @C@@@9         GETC .                    GHO
)@@G@@ET ARGUMENT @C@@@9         GOTO  *$+1,X2 .           GO TO ROUTINE@D@@@9HP
)@@G@@         +GARG0A .                 IMMEDIATE DATA     @B@@@9         +GAHQ
)@@G@@RG1 .                  STACK  @C@@@9         +GARG2 .                  PHR
)@@G@@ERMANENT    @C@@@9         +GARG3 .                  PARAMETER    @#@@@9HS
)@@G@@GARG3    LABEL .  @C@@@9         ADD   A8,DCGSV4,I .       GET PARAMETERHT
)@@G@@@^@@@9         LOAD  X2,A8.   @D@@@9         LOAD  X2,0,X2 .           GHU
)@@G@@ET PARAMETER REG. @B@@@9         LJMP .                    RETURN @#@@@9HV
)@@G@@GARG2    LABEL .  @E@@@9         ADD   A8,+(IN 63,U,1,AGAW) .         PEHW
)@@G@@RMANENT     @C@@@9         GOTO  GARG0 .             -> RETURN    @C@@@9HX
)@@G@@GARG0A   LABEL               . IMMEDIATE DATA   @E@@@9         SET   DGXHY
)@@G@@TED,ON     . SET FLAG FOR IMMEDIATE DATA  @C@@@9         SLB   A10,6 .  HZ
)@@G@@     GET HIGH ORDER BITS@D@@@9         ADD   A8,A10 .      ADD TO LOW ORIA
)@@G@@DER BITS    @D@@@9         MOVE  A10,0,I .     CLEAR J CODE REGISTER    IB
)@@G@@@ @@@9         GOTO  GARG0         .@#@@@9GARG1    LABEL .  @E@@@9      IC
)@@G@@   ADD   A8,W1U,X7 .         GET STACK ENTRY ADDRESS  @#@@@9GARG0    LABID
)@@G@@EL .  @^@@@9         LOAD  X2,A8 .  @B@@@9         LJMP .               IE
)@@G@@     RETURN @E@@@9GADRAW   LLOC .                    RELATIVE PTR PARAMEIF
)@@G@@TER   @F@@@9         LOAD  X5,X1 .             GET START OF RELATIVE ADDIG
)@@G@@RESS  @D@@@9         GETC .                    GET DISPLACEMENT   @D@@@9IH
)@@G@@         SLBD  A7,42 .             GET LOW 6 BITS     @C@@@9         GETII
)@@G@@C .                    LOW 6 BITS   @F@@@9         ADD   A7,A8 .        IJ
)@@G@@     GET FULL 12 BIT DISPLACEMENT   @D@@@9         SLB   A7,24 .        IK
)@@G@@     PROPAGATE SIGN     @G@@@9         SSA   A7,24 .                    IL
)@@G@@                       *******@E@@@9         ADD   X5,A7 .             SIM
)@@G@@ET NEW ICODE ADDRESS    @B@@@9         LJMP .                    RETURN IN
)@@G@@@D@@@9GBRTBL    LABEL .                       BRANCH TABLE  @^@@@9LBLAD IO
)@@G@@    FORM   18,18 .@E@@@9          LBLAD 0,GNEXT . 0         -> NULL, NEXIP
)@@G@@T ICODE     @C@@@9          LBLAD  0,IGLIT0 .  GLITRG,   GLIT     @A@@@9IQ
)@@G@@          LBLAD  0,IGMOV0 . 04 GMOVE@A@@@9          LBLAD  0,IGDRX0 . 06IR
)@@G@@ GDBLE@B@@@9          LBLAD  0,IGRX0 .   010 GINST    @B@@@9          LBIS
)@@G@@LAD  0,IGFRX0 .  012 GFLOAT   @B@@@9          LBLAD  0,IGMVI0 .  014 GMVIT
)@@G@@I, GXI@B@@@9          LBLAD  0,IGOI0 .   016 GOI,  GNI@C@@@9          LBIU
)@@G@@LAD  0,IGIFO0 .  020 GIFO, GIFE     @B@@@9          LBLAD  0,IGJGD0 .  0IV
)@@G@@22 GJGD     @B@@@9          LBLAD  0,IGLABEL . 024 GLABEL   @B@@@9      IW
)@@G@@    LBLAD  0,IGGOTO0 . 026 GGOTO    @B@@@9          LBLAD  0,IGBAL0 .  0IX
)@@G@@30 GBAL     @B@@@9          LBLAD  0,IGAPPN0 . 032 GAPPN    @C@@@9      IY
)@@G@@    LBLAD 0,IGON0 .    034 GBOFF , GBON   @C@@@9          LBLAD 0,IGMRK0IZ
)@@G@@ .   036 GMRK, GUSE     @B@@@9          LBLAD  0,IGRTRN0 . 040 GRTRN    JA
)@@G@@@B@@@9          LBLAD  0,IGFREE0 . 042 GFREE    @B@@@9          LBLAD  0JB
)@@G@@,IGSET0 .  044 GSET     @ @@@9          LBLAD 0,IGLOAD0 .   @ @@@9      JC
)@@G@@    LBLAD 0,IGSHIN0 .   @ @@@9          LBLAD  0,IGSHIFT .  @ @@@9      JD
)@@G@@    LBLAD  0,IGFSR0 .   @B@@@9          LBLAD 0,IGIFR0 .  056 GIFR,GIFX JE
)@@G@@@B@@@9          LBLAD 0,IGBRC0 .   060 GJUMP    @ @@@9          LBLAD  0JF
)@@G@@,IGSUB0 .   @ @@@9          LBLAD 0,IGGETGR0 .  @ @@@9          LBLAD 0,JG
)@@G@@IGGTT0 .    @D@@@9          LBLAD  0,IGFIN0 .  070 GFIN, GFIN 'POP'     JH
)@@G@@@C@@@9          LBLAD  0,IGBR0   . 072 GBR ( OFF, ON )@ @@@9          LBJI
)@@G@@LAD 0,IGKEEP0 .   @C@@@9          LBLAD  0,IGLMJ$ .  076 GLMJ, GCJMP    JJ
)@@G@@@E@@@9IGLMJ$   LABEL .                   LOAD $+1 INTO AW REGISTER@C@@@9JK
)@@G@@         LINK  RGXLD .              GET REGISTER@E@@@9         JN    A9,JL
)@@G@@IGCJMP .         -> REALLY GCJMP COMMAND  @B@@@9         LOAD  X2,0,X2 .JM
)@@G@@           GET RSW@ @@@9         USING RGSWRD,X2 .    @G@@@9         LOAJN
)@@G@@D  A3,07454*4,I .   SET LMJ OP CODE (LEAVE 4 BITS FOR REG #)@D@@@9      JO
)@@G@@   ADD   A3,RGSWRA .          SET LMJ RN,$+1    @F@@@9         SLB   A3,JP
)@@G@@22 .             LEAVE ROOM FOR ADDRESS IN INST @B@@@9         LOADXM A3JQ
)@@G@@,X10 .           GET $  @B@@@9         ADD   A3,1,I .            GET $+1JR
)@@G@@@A@@@9         STORE A3,CDINST,*X10 .     @A@@@9         GCORE 0 'LABEL'JS
)@@G@@,GEND0 .    @ @@@9IGDJZ0   LABEL               .@F@@@9         LOAD  A7,JT
)@@G@@071*020+OPDJZ,I        . F AND J FIELD FOR DJZ  @F@@@9         GOTO  IGCJU
)@@G@@JP1        . -> MERGE WITH TEST-JUMP PROCESSING @F@@@9IGCJMP   LABEL    JV
)@@G@@           . -> CONDITIONAL JUMP GENERATION     @G@@@9         LOAD  A7,JW
)@@G@@074*020,I  . LOAD OPCODE F-FIELD FOR CONDITIONAL JUMP @B@@@9         ADDJX
)@@G@@   A7,A10        . ADD J FIELD@D@@@9IGCJP1   LABEL               . MERGEJY
)@@G@@ POINT FROM DJZ   @ @@@9         SLB   A7,4          .@D@@@9         LOAJZ
)@@G@@D  X2,W1,X2      . POINT TO RSW USING RAW @ @@@9         USING RGSWRD,X2KA
)@@G@@     .@D@@@9         ADD   A7,RGSWRN,X2  . ADD REGISTER NUMBER    @D@@@9KB
)@@G@@IGCJP2   LABEL               . MERGE POINT FROM JGD   @F@@@9         SLBKC
)@@G@@   A7,4+18       . LEFT JUSTIFY INSTRUCTION IN WORD   @C@@@9         LINKD
)@@G@@K  GARG          . GET LABEL AW     @E@@@9         GOTO  IGBRC3        .KE
)@@G@@ -> MERGE WITH JUMP GENERATION@ @@@9IGJGD0   LABEL               .@D@@@9KF
)@@G@@         LINK  RGXLD         . GET POINTER TO RAW     @ @@@9         USIKG
)@@G@@NG RGSWRD,X2     .@G@@@9         LOAD  A7,070*0400,I           . LOAD SHKH
)@@G@@IFTED OPCODE FOR JGD    @C@@@9         LOAD  X2,W1,X2      . POINT TO RGKI
)@@G@@SW    @D@@@9         ADD   A7,RGSWRA     . ADD ADDRESS OF REGISTER@D@@@9KJ
)@@G@@         AND,U A7,RGSWRR     . CHECK IF R-REGISTER    @D@@@9         ADDKK
)@@G@@   A7,A8         . DO CONVERSION IF R-REG @ @@@9         GOTO  IGCJP2   KL
)@@G@@     .@G@@@9IGIFO0   LABEL               . TEST IF RSWN IS ODD (EVEN), TKM
)@@G@@HEN JUMP    @B@@@9         LINK  GARG          . GET AW     @C@@@9      KN
)@@G@@   LOAD  X2,W1,X2      . POINT TO RSW     @ @@@9         USING RGSWRD,X2KO
)@@G@@     .@D@@@9         LOAD  A7,RGSWRN,X2  . GET REGISTER NUMBER    @C@@@9KP
)@@G@@         JN    A9,IGIFE0     . -> JUMP IF EVEN  @H@@@9         IF    A7,KQ
)@@G@@ODD THEN,IGGOTO0 ELSE,GEND1 . -> REG IS ODD / SKIP JUMP LOC @F@@@9IGIFE0KR
)@@G@@   LABEL               . JUMP TO LOC IF REG NUMBER IS EVEN  @G@@@9      KS
)@@G@@   IF    A7,EVEN THEN,IGGOTO0 ELSE,GEND1 . -> REG IS EVEN, JUMP   @F@@@9KT
)@@G@@IGMRK0   LABEL               . STORE NEXT AVAILABLE ADDRESS IN AW @D@@@9KU
)@@G@@         LINK  GARG          . GET POINTER TO AW IN X2@B@@@9         IF KV
)@@G@@   A9,LT,0,I THEN,IGUSE0 .    @F@@@9         STORE X10,W1H2,X2     . STOKW
)@@G@@RE VALUE IN LOWER HALF OF AW  @ @@@9         GOTO  GEND0         .@D@@@9KX
)@@G@@IGUSE0   LABEL               . SET GEN ADDRESS TO AW  @ @@@9         LOAKY
)@@G@@DXM X10,W1H2,X2  .@ @@@9         GOTO  GEND0         .@#@@@9IGFIN0    LAKZ
)@@G@@BEL . @D@@@9         IF    A9,GE,0,I THEN,GFIN1 . -> NO 'POP'     @C@@@9LA
)@@G@@         ADD   X7,DCGSLT,I .       POP STACK    @B@@@9         GOTO  GFILB
)@@G@@N1 .             -> QUIT@D@@@9GEND1    LABEL .                   SKIP ONLC
)@@G@@E ICODE AW  @#@@@9         GETC .   @#@@@9         GETC .   @#@@@9GEND0 LD
)@@G@@    LABEL . @E@@@9         IF    DGCONT+DGXTDL,ON THEN,GNEXT . -> NOT DOLE
)@@G@@NE    @#@@@9GFIN1     LABEL . @D@@@9         IF    DGRMT,ON THEN,GEXIT1 LF
)@@G@@. -> REMOTE EXIT  @B@@@9         IF    A1,EQ,KLCH6W THEN,GFIN2 .  @^@@@9LG
)@@G@@         USING WORD,A0 .@D@@@9         ADD   X1,1,I .            UP RETULH
)@@G@@RN POINTER  @#@@@9GFIN2    LABEL .  @^@;@9         SUB   A0,1,I . @E@@@9LI
)@@G@@         STORE X1,W1H2 .           FUDGE RETURN ADDRESS     @^@'@9      LJ
)@@G@@   ADD   A0,1,I . @#@@@9GEXIT1    LABEL . @^@@@9          GRTN   4 .    LK
)@@G@@@#@@@9IGLIT0    LABEL . @E@@@9         JP    A9,IGLITRG .        -> REALLL
)@@G@@LY LITERAL IN REG @C@@@9         GETC .                    GET WORDS    LM
)@@G@@@B@@@9         IF    A1,EQ,KLCH6W THEN,IGLIT1 . @D@@@9         ADD   X1,LN
)@@G@@1,I .            POINT TO WORD LIST @ @@@9         LOAD  A1,KLCH6W .    LO
)@@G@@@#@@@9IGLIT1   LABEL .  @^@@@9         USING WORD,X1 .@C@@@9         MOVLP
)@@G@@E  CDINST,W1,R,A8 .    MOVE LIST    @^@@@9         USING WORD,X1 .@^@@@9LQ
)@@G@@         ADD   X1,A8 .  @D@@@9         GCORE R,A8 'LABEL',GEND0 . -> UP LR
)@@G@@POINTER     @#@@@9IGLITRG   LABEL . @C@@@9         GETC .               LS
)@@G@@     GET REG NAME @F@@@9         ADD   A8,DCGSV4-A7+1,I .  GET PARAMETERLT
)@@G@@ REG CONTENTS     @ @@@9         LOADA A6,DCGSV4 .    @B@@@9         IF LU
)@@G@@   A8,GT,A6 THEN,IGLTR1 .     @ @@@9         ADD   A8,A7-X1+5 .   @#@@@9LV
)@@G@@IGLTR1   LABEL .  @C@@@9         LOAD  X3,A8 .             GET DATUM    LW
)@@G@@@C@@@9         LOAD  A7,0,X3 .           GET DATUM    @D@@@9         STOLX
)@@G@@RE A7,CDINST,*X10 .    SET INSTRUCTION    @A@@@9         GCORE 0 'LABEL'LY
)@@G@@,GEND0 .    @D@@@9IGMOV0   LABEL .                   MOVE STACK ENTRIES LZ
)@@G@@@F@@@9         JP    A9,IGMOV4     . -> STACK ITEM POINTED TO BY AW'S   MA
)@@G@@@B@@@9         GETC  . FETCH 'TO' STACK ADDRESS @ @@@9         LOAD  X3,MB
)@@G@@A8         .@C@@@9         ADD   X3,X7         . COMPUTE LOCATION @B@@@9MC
)@@G@@         GETC  . FETCH 'FROM' STACK OFFSET@ @@@9         LOAD  X2,A8    MD
)@@G@@     .@C@@@9         ADD   X2,X7         . COMPUTE LOCATION @D@@@9      ME
)@@G@@   LOAD  A8,DCGSLT,I   . SET STANDARD ITEM SIZE @B@@@9         GOTO  IGMMF
)@@G@@OV5        . -> MERGE   @C@@@9IGMOV4   LABEL . COMPUTE LOCATIONS FROM AWMG
)@@G@@'S    @C@@@9         LINK  GARG          . GET 'TO' ADDRESS @ @@@9      MH
)@@G@@   LOAD  X3,X2         .@E@@@9         LINK  GARG          . GET 'FROM' MI
)@@G@@ADDRESS IN X2     @D@@@9         GETC  . FETCH NUMBER OF WORDS TO MOVE IMJ
)@@G@@N A8  @F@@@.IGMOV5   LABEL . MERGE FROM GETTING STANDARD STACK ITEM ADDRMK
)@@G@@ESSES @ @@@9         LOADXI X2,1,I       .@ @@@9         LOADXI X3,1,I  ML
)@@G@@     .@F@.@9IGMOV5   LABEL . MERGE FROM GETTING STANDARD STACK ITEM ADDRMM
)@@G@@ESSES @C@@@9         LOAD  R2,RGMASK     . MASK OUT KEEP BIT@E@@@9      MN
)@@G@@   LOADA A9,DRSX1-1    . LOAD LOWEST ADDRESS OF RGSW'S@F@@@9         LOAMO
)@@G@@DA A10,DRAX10-1  . LOAD HIGHEST ADDRESS OF RGSW'S     @G@@@9         LOAMP
)@@G@@DA X4,W1,X3      . COMPUTE DIFFERENCE BETWEEN ITEM ADDRESSES@ @@@9      MQ
)@@G@@   SUB   X4,W1U,X2     .@ @@@9         LOAD  R1,A8         .@ @@@9      MR
)@@G@@   LOAD  A2,X2         .@ @@@9IGMOV3   LABEL               .@D@@@9      MS
)@@G@@   MSW   A9,0,*A2      . LOOK FOR RAW'S IN STACK@E@@@9         GOTO  IGMMT
)@@G@@OV2        . -> SEARCH FOR RAW'S IS DONE  @ @@@9         ANU,U A2,1     MU
)@@G@@     .@D@@@9         LOAD  X5,W1,A3      . POINT TO RSW USING RAW @ @@@9MV
)@@G@@         USING RGSWRD,X5     .@ @@@9         LOAD  A7,RGSWUR     .@ @@@9MW
)@@G@@         USING WORD,A3       .@F@@@9         IF    A7,NE,W1U THEN,IGMOV3MX
)@@G@@ . -> RSW DOES NOT POINT TO AW@E@@@9         ADD   A7,X4         . COMPUMY
)@@G@@TE NEW LOCATION OF RAW  @C@@@9         STORE A7,RGSWUR     . POINT RGSW MZ
)@@G@@TO RAW@G@@@9         GOTO  IGMOV3        . -> CONTIMUE TO SEARCH FOR ACTNA
)@@G@@IVE RAW'S   @ @@@9IGMOV2   LABEL               .@E@@@9         LOAD  R2,NB
)@@G@@RGMSK2     . MASK FOR KEEP BIT AND OFFSETS@E@@@9         LOAD  A2,X2    NC
)@@G@@     . SET STARTING FROM LOCATION   @E@@@9         LOAD  R1,A8         .ND
)@@G@@ GET NUMBER OF WORDS TO CHECK @G@@@9         LOAD  A9,W1U,X2     . SET LNE
)@@G@@OWER ADDRESS OF STACK FROM ITEM     @E@@@9         SUB   A9,1,I        .NF
)@@G@@ ADJUST ADDRESSES DOWN BY ONE @F@@@9         AU    A9,A8         . COMPUNG
)@@G@@TE UPPER ADDRESS OF STACK     @H@@@9         SLBD  A9,18         . SHIFTNH
)@@G@@ POINTERS TO UPPER HALVES OF REGISTERS    @F@@@9IGMOV7   LABEL . MERGE TNI
)@@G@@O CONTINUE SEARCH FOR INTERNAL POINTERS   @E@@@9         MSW   A9,0,*A2 NJ
)@@G@@     . SEARCH FOR INTERNAL POINTERS @C@@@9         GOTO  IGMOV6        .NK
)@@G@@ -> SEARCH IS DONE@F@@@9         ANU,U A2,1          . BACK INDEX UP TO NL
)@@G@@WORD JUST LOCATED @C@@@9         LOAD  X5,W1H1,A3    . LOAD THE POINTER NM
)@@G@@@E@@@9         ADD   X5,X4         . ADD IN THE APPROPRIATE OFFSET@ @@@9NN
)@@G@@         STORE X5,W1H1,A3    .@D@@@9         GOTO  IGMOV7        . -> CONO
)@@G@@NTINUE SEARCH     @B@@@9IGMOV6   LABEL . TRANSFER THE STACK ITEMS @C@@@9NP
)@@G@@         LOAD  R1,A8         . RESET BT COUNTER @B@@@9         BT    X3,NQ
)@@G@@0,*X2      . MOVE ITEMS @D@@@9         GOTO  GEND0         . -> CHECK FONR
)@@G@@R COMPLETION@B@@@9IGMVI0    LABEL .            OR IGXI0     @C@@@9      NS
)@@G@@    LINK   GARGMK .               GET MASK@D@@@9         JP    A9,IGMVI1NT
)@@G@@     .                ******* @ @@@9         LXOR  A7,DGFLGZ     .@ @@@9NU
)@@G@@IGMVI1   LABEL               .@E@@@9          STORE  A7,DGFLGZ .        NV
)@@G@@    SET GLOBAL FLAGS    @C@@@9         GOTO  GEND0 .             -> NEXTNW
)@@G@@ ICODE@#@@@9IGOI0     LABEL . @C@@@9          LINK   GARGMK .           NX
)@@G@@    GET MASK@G@@@9         JN    A9,IGNI0      . -> REALLY FLAG AND DGFLNY
)@@G@@GZ         *******@E@@@9          LOR    A7,DGFLGZ .            SET SELENZ
)@@G@@CTED FLAGS  @ @@@9          STORE  A7,DGFLGZ .  @^@@@9         GOTO  GENOA
)@@G@@D0 .  @#@@@9IGNI0     LABEL . @ @@@9          LAND   A7,DGFLGZ .  @G@@@9OB
)@@G@@          STORE  A7,DGFLGZ .            -> PROCESS NEXT INSTRUCTION     OC
)@@G@@@^@@@9         GOTO  GEND0 .  @C@@@9IGBRC0   LABEL .                   GOD
)@@G@@ENERATE JUMP@B@@@9         LINK  GARG .              GET AW @ @@@9      OE
)@@G@@   USING  AWDS,X2 .     @D@@@9         LOAD  A7,0742000,I .      GET JUMOF
)@@G@@P OP CODE   @^@@@9         SLB   A7,18 .  @F@@@9IGBRC3   LABEL          OG
)@@G@@     . MERGE POINT FROM CONDITIONAL JUMP  @G@@@9         ADD   A7,AWOFSTOH
)@@G@@ .         ADD IN U FILED OR ELSE NEXT INST     @E@@@9         IF    AWROI
)@@G@@GPT,ZERO THEN,IGBRC1 . -> NO ADDRESS YET  @#@@@9IGBRC2   LABEL .  @D@@@9OJ
)@@G@@         STORE A7,CDINST,*X10 .     SET JUMP INST     @C@@@9         GCOOK
)@@G@@RE 0 'LABEL',GEND0 . RESERVE SPACE  @#@@@9IGBRC1   LABEL .  @D@@@9      OL
)@@G@@   STORE X10,AWOFST .        SET PTR TO INST    @^@@@9         GOTO  IGBOM
)@@G@@RC2 . @#@@@9IGLABEL   LABEL . @F@@@9          LINK   GARG .             ON
)@@G@@    GET REFERENCE TO LABEL    @C@@@9         LOAD  X3,X2 .             SOO
)@@G@@AVE AW PTR  @#@@@9IGLABEL1  LABEL . @^@@@9         USING WORD,X2 .@D@@@9OP
)@@G@@         LOAD  A7,W1H2 .           GET UFIELD OF INST @F@@@9         STOOQ
)@@G@@RE X10,W1H2,X2 .       SET U FIELD IN BRANCH INST     @F@@@9         IF OR
)@@G@@   A7,EQ,0,I THEN,IGLBL2 . -> END OF CHAIN, SET PTR   @^@@@9         LOAOS
)@@G@@D  X2,A7 .  @E@@@9          GOTO   IGLABEL1 .             TEST NEXT REFEOT
)@@G@@RENCE @#@@@9IGLBL2   LABEL .  @D@@@9         STORE X10,W1,X3 .         SOU
)@@G@@ET AW PTR TO CODE @C@@@9         GOTO  GEND0 .             -> NEXT ICODEOV
)@@G@@@ @@@9          USING  WORD,X5 .    @#@@@9IGBAL0    LABEL . @C@@@9      OW
)@@G@@   LINK  GADRAW .            GET ADDRESS  @D@@@9         STORE X1,DGLKSKOX
)@@G@@ .         SAVE ICDOE PTR     @ @@@9         STORE A1,DGLKS2 .    @D@@@9OY
)@@G@@         SET   DGXTDL,ON     . SET SUBROUTINE FLAG    @C@@@9         GOTOZ
)@@G@@O  IGGOTO1 .           -> BRANCH    @#@@@9IGGOTO0   LABEL . @C@@@9      PA
)@@G@@   LINK  GADRAW .            GET ADDRESS  @#@@@9IGGOTO1  LABEL .  @^@'@9PB
)@@G@@         SETGC 6,0,X5 . @^@@@'.        SETGC 6,0,X5 . @ @@@'         LOAPC
)@@G@@DXM  X1,W1U,X5 .  @ @@@'         LOAD    A1,KLCH6W .  @F@@@9          GOPD
)@@G@@TO   GNEXT .                -> PROCESS NEW IGEN INST  @#@@@9IGAPPN0   LAPE
)@@G@@BEL . @C@@@9         LINK  GADRAW .            GET ADDESS   @G@@@9      PF
)@@G@@   LMJ   X11,0,X5 .          GO TO ROUTINE                 *******@G@@@9PG
)@@G@@          GOTO   GEND0 .                -> RETURN PROCESS INST AT (X5)  PH
)@@G@@@#@@@9IGON0     LABEL . @C@@@9         GETC .                    GET FLAPI
)@@G@@GS    @E@@@9         SLBD  A7,6+36 .           GET FULL 9 (12) BIT FLAG PJ
)@@G@@@#@@@9         GETC .   @D@@@9         ADD   A7,A8 .       ADD IN LOWER PK
)@@G@@PART OF FLAG@C@@@9         AND,H2 A7,DGFLGZ-(IN 63,H2,1,0)  .     @E@@@9PL
)@@G@@         JP    A9,IGOFF0 .   -> CHECKING OFF INSTEAD OF ON  @D@@@9      PM
)@@G@@   JNZ   A8,IGGOTO0 .        -> SOME BITS ON .  @C@@@9         GOTO  GENPN
)@@G@@D1 .             IGNORE ICODE @#@@@9IGOFF0    LABEL . @C@@@9         JZ PO
)@@G@@   A8,IGGOTO0 .        -> ALL OFF . @^@@@9         GOTO  GEND1    @#@@@9PP
)@@G@@IGRTRN0   LABEL . @D@@@9         LOADXM X1,DGLKSK .        RESET ICODE SPQ
)@@G@@TACK  @ @@@9         LOADXM A1,DGLKS2 .   @E@@@9         SET   DGXTDL,OFPR
)@@G@@F    . TURN OFF SUBROUTINE FLAG     @C@@@9         GOTO  GEND0 .        PS
)@@G@@     -> NEXT ICODE@#@@@9IGSET0    LABEL . @^@@@9          LINK   GARG . PT
)@@G@@@E@@@9          LOAD   X3,X2 .                X3 -> LEFT OPERAND  @E@@@9PU
)@@G@@          LINK   GARG .                 X2 -> RIGHT OPERAND @C@@@9      PV
)@@G@@   LOAD  A2,0,X2 .           A2=AW MOVED  @^@@@9         STORE A2,0,X3 .PW
)@@G@@@F@@@9         AND   A2,RGMSK2 .   GET RID OF KEEP BIT AND RGSW POINTER PX
)@@G@@@C@@@9         IF    A3,NE,0,I THEN,GEND0 . -> NOT RAW@ @@@9         USIPY
)@@G@@NG RGSWRD,A2 .    @E@@@9         SUB   X2,RGSWUR . CHECK IF RSW POINTS BPZ
)@@G@@ACK TO RAW  @F@@@9         IF    X2,NZERO THEN,GEND0 . -> RGSW DID NOT PQA
)@@G@@OINT TO AW  @E@@@9          STORE  X3,RGSWUR .            UPDATE RGSW POQB
)@@G@@INTER @C@@@9         GOTO  GEND0 .             -> NEXT ICODE@#@@@9IGLOADQC
)@@G@@0  LABEL .  @G@@@9         LINK  GARG .        GET AW <- X2 AND NUMBER OQD
)@@G@@F WORDS IN A10    @D@@@9         IF    A10,NE,2,I THEN,GLOADB . -> FIXEDQE
)@@G@@ LOAD @C@@@9         LINK  RGGETFPR .          GET 2 WORDS  @D@@@9      QF
)@@G@@   LOAD  A7,071,I .          SET FLOAT LOAD     @D@@@9         LOAD  A10QG
)@@G@@,013,I .         SET FLOAT J FIELD  @C@@@9         GOTO  GLOAD1 .       QH
)@@G@@     -> MERGE     @#@@@9GLOADB   LABEL .  @G@@@9         IF    A10,NE,3,QI
)@@G@@I THEN,GLOADC . -> ONE WORD 'A' REGISTER LOAD   @C@@@9         LINK  RGGQJ
)@@G@@ETXRG .    GET X REGISTER     @C@@@9         LOAD  A7,027,I . LOAD OPCODQK
)@@G@@E FOR LOAD X@D@@@9         GOTO  GLOAD2 . -> MERGE WITH ONE WORD LOAD   QL
)@@G@@@C@@@9GLOADC   LABEL . LOAD ONE WORD 'A' REGISTER     @D@@@9          LIQM
)@@G@@NK   RGGETGPR .             ->GET REGISTER@D@@@9         LOAD  A7,010,I QN
)@@G@@.          SET FIXED LOAD     @C@@@9GLOAD2   LABEL . MERGE POINT FOR ALLQO
)@@G@@ WORD LOADS @C@@@9         LOAD  A10,0,I .           SET J FIELD  @#@@@9QP
)@@G@@GLOAD1    LABEL . @C@@@9         STORE A7,DGOPCD .         SET OP CODE  QQ
)@@G@@@C@@@9         STORE A10,DGJCOD .        SAVE J FIELD @C@@@9         LOAQR
)@@G@@D  X3,X5 .             GET ARGUMENT @F@@@9         LOAD  X5,X2 .        QS
)@@G@@     SET PARAMETER TO FREE ROUTINE  @G@@@9          LINK   GFREE0 .     QT
)@@G@@          ->FREE OPERAND IF NECESSARY     @C@@@9         LOAD  A10,DGJCOQU
)@@G@@D .        SAVE J FIELD @F@@@9          LINK   IGRXLD .               ->QV
)@@G@@GENERATE RX FORM OF LOAD@ @@@9          USING  RGSWRD,X3 .  @F@@@9      QW
)@@G@@    STORE  X2,RGSWUR .            LINK NEW USER TO REGISTER @ @@@9      QX
)@@G@@    STORE  X3,0,X2 .    @C@@@9         GOTO  GEND0 .             -> NEXTQY
)@@G@@ ICODE@#@@@9IGSHIFT  LABEL .  @D@@@9          LINK   RGXLD .            QZ
)@@G@@     GET OPERAND  @F@@@9         LOAD  X5,0,X2 .           X5=A(RGSW) OFRA
)@@G@@ REG TO BE SHIFTED@ @@@9         USING RGSWRD,X5 .    @G@@@9         LOARB
)@@G@@D  A7,010001,I   . PREPARE TO ADD 1 TO REG NUM AND ADDRESS  @D@@@9      RC
)@@G@@   LOAD  A6,RGSWRN .         GET REG NUMBER     @A@@@9         IF    A6,RD
)@@G@@ODD THEN,IGSH2 .  @F@@@9         LOADN A7,010001,I   . SUBTRACT 1 FROM RRE
)@@G@@EG NUM AND ADDRESS@E@@@9IGSH2    LABEL     . SHIFT REGISTER NUMBERS IN ERF
)@@G@@VEN-ODD PAIR@E@@@9         ADD   A7,RGSWIF .   ADD IN REGISTER NUM AND ARG
)@@G@@DDRESS@G@@@9         IF    A6,NE,A15-A0,I THEN,IGSH3 . -> NOT A15-A16, SRH
)@@G@@ET SHIFT    @C@@@9         LOAD  A10,X2        . SAVE AW POINTER  @D@@@9RI
)@@G@@         LOADA X2,DRSW15 .   POINT TO RSW OF A15 - A16@G@@@9         LOARJ
)@@G@@D  A3,RGSWUF     . GET POINTER TO FROUNT OF IN-USE LIST     @H@@@9      RK
)@@G@@   IF    A3,NE,X2 THEN,IGSH4 . -> A15 IS NOT FIRST AVAILABLE USED REG   RL
)@@G@@@D@@@9         LOADA A3,RGSWFF     . POINT TO FREE LIST HEAD@G@@@9      RM
)@@G@@   IF    A3,NE,RGSWFB THEN,IGSH4 . -> THERE EXISTS A FREE REGISTER@H@@@9RN
)@@G@@         LINK  RGUNLINK      . REMOVE RSW(A15-A16) FROM FROUNT OF IN-USERO
)@@G@@ LIST @H@@@9         LOAD  X3,RGSWUB     . X3 -> CELL AFTER WHICH RSW(A1RP
)@@G@@5) TO BE ADDED    @F@@@9         LINK  RGLINK        . PUT RSW(A15) AT BRQ
)@@G@@ACK OF IN-USE LIST@G@@@9IGSH4    LABEL . MERGE POINT WHEN A15 WILL NOT BRR
)@@G@@E USED TO LOAD ITSELF   @ @@@9         USING RGSWRD,X2     .@G@@@9      RS
)@@G@@   IF    RGSW1W,ON,RGSWKY THEN,IGSH5 . -> 1 WORD REGISTER TYPE    @D@@@9RT
)@@G@@         LINK  RGGETFPR      . GET 2-WORD REGISTER    @ @@@9         GOTRU
)@@G@@O  IGSH6         .@ @@@9IGSH5    LABEL               .@D@@@9         LINRV
)@@G@@K  RGGETGPR      . GET 1-WORD REGISTER    @G@@@9IGSH6    LABEL          RW
)@@G@@     . MERGE HERE AFTER NEW RESISTER OBTAINED   @F@@@9         LOAD  A7,RX
)@@G@@RGOP4      . GET CIRCULARILY SHIFTED DL A0,A15  @ @@@9         USING RGSRY
)@@G@@WRD,X5     .@F@@@9         ADD   A7,RGSWRN     . ADD TO A0 THE OFFSET OFRZ
)@@G@@ REG PAIR   @I@@@9         LSSC  A7,22         . SHIFT DL A0+OFFSET,A15 SA
)@@G@@INTO PROPER FORMAT *******    @D@@@9         STORE A7,CDINST,*X10 .    SSB
)@@G@@ET INSTRUCTION    @C@@@9         GCORE 0 .                 RESERVE SPACESC
)@@G@@@D@@@9         LOAD  X2,A10        . GET SAVED POINTER TO AW@ @@@9      SD
)@@G@@   USING RGSWRD,X5     .@D@@@9         STORE X2,RGSWUR     . POINT RSW(NSE
)@@G@@EW) TO AW   @F@@@9         STORE X5,W1H2,X2    . STORE POINTER TO RSW(NESF
)@@G@@W) IN AW    @D@@@9         LOAD  A7,RGSWIF     . GET REG NUM AND ADDRESSSG
)@@G@@@E@@@9         ADD   A7,010001,I   . MAKE REG NUM AND ADDRESS EVEN@ @@@9SH
)@@G@@         STORE A7,RGSWIF     .@E@@@9         LOADA X5,DRSW15     . PREPASI
)@@G@@RE TO FREE RSW(A15-A16) @C@@@9         LINK  RGFREE .           FREE REGSJ
)@@G@@ A15  @^@@@9         GOTO  GEND0 .  @#@@@9IGSH3   LABEL .   @H@@@9      SK
)@@G@@   STORE A7,RGSWIF     . STORE SHIFTED VALUES OF REG NUM AND ADDRESS    SL
)@@G@@@C@@@9         GOTO  GEND0 .             -> NEXT ICODE@#@@@9IGFSR0    LASM
)@@G@@BEL . @D@@@9          LINK   RGXLD .                 GET OPERAND  @H@@@9SN
)@@G@@          LOAD   A7,0,X2 .              NEXT REQUEST FOR SCRATCH WILL GESO
)@@G@@T     @E@@@9         STORE A7,DRGSRH .         SET NEXT SCRATCH REG .   SP
)@@G@@@E@@@9         GOTO  GEND0 .             -> NEXT ICODE INSTRUCTION@D@@@9SQ
)@@G@@IGIFR0   LABEL .                   IF AW REG THEN, X  @D@@@9          LISR
)@@G@@NK   GARG .                 GET OPERAND   @E@@@9          USING  WORD,X2SS
)@@G@@ .              SET DSECT TO X2     @E@@@9         LOAD  A2,W1H1 .      ST
)@@G@@     SEE IF REGISTER WORD     @C@@@9         AND,U A2,0377777 . MASK OUTSU
)@@G@@ KEEP BIT   @E@@@9         IF    A3,NE,0,I THEN,GEND1 . -> IN CORE, NEXTSV
)@@G@@ ICODE@D@@@9         JP      A9,IGGOTO0 .      IS THIS A GIFX?    @C@@@9SW
)@@G@@         LOAD    X2,W1,X2 .        POINT TO RGSW@D@@@9         LOAD    ASX
)@@G@@2,RGSWRA,X2 .    GET REG ADDRESS    @G@@@9         IF A2,GE,021,I THEN,GSY
)@@G@@END1 ELSE,IGGOTO0 . NOT AN X REGISTER     @#@@@9IGFREE0  LABEL .  @B@@@9SZ
)@@G@@         LINK  GARG .              GET AW @C@@@9         LOAD  X5,X2 .  TA
)@@G@@           FREE THIS AW @D@@@9         LOADA X11,GEND0 .         SET RETTB
)@@G@@URN ADDRESS @F@@@9GFREE0   LLOC .              ENTRY POINT FROM INTERNALTC
)@@G@@ ROUTINES   @E@@@9         JN    A9,LJMP .     'NO' SPECIFIED ON INSTRUCTD
)@@G@@TION  @D@@@9         LOAD  A8,0,I .      USE FIRST OFFSET OF ZERO @#@@@9TE
)@@G@@GFREE1   LABEL .  @H@@@9         LOAD  A7,AWRGPT-FH1,X5 .      LOAD LEFTTF
)@@G@@ JUSTIFIED REGISTER POINTER   @D@@@9         JN    A7,LJMP .     -> KEEPTG
)@@G@@ BIT ON, RETURN   @E@@@9         IF    A7,LT,0377777,I THEN,GFREE2 . -> TH
)@@G@@RAW FOUND   @C@@@9         AND,U A7,0377777 .  SAVE OFFSET IN A8  @F@@@9TI
)@@G@@         LOAD  X5,AWRGPT,X5 .          FOLLOW CHAIN OF POINTERS   @^@@@9TJ
)@@G@@         GOTO  GFREE1 . @C@@@9GFREE2   LABEL .             RGSW HAS BEENTK
)@@G@@ FOUND@H@@@9         IF    A7,EQ,AGRX10 THEN,GFREE3 . ->BASE X10,SEE IF TL
)@@G@@TEMP FOR FREEING  @D@@@9         LOAD  X5,AWOFST,X5 .          X5 -> RGSTM
)@@G@@W     @G@@@9         GOTO  RGFREE .      RELEASE THE REGISTER, RETURN ADTN
)@@G@@DRESS IN X11@E@@@9GFREE3   LABEL .             BASE X10, SEE IF TEMPORARTO
)@@G@@Y     @F@@@9         IF    A8,LT,DTGTBT THEN,LJMP . -> TOO SMALL FOR TEMTP
)@@G@@PS    @G@@@9         GOTO  XGTMPF .      -> FREE TEMPORARY, RETURN ADDRETQ
)@@G@@SS IN X11   @C@@@9IGRX0    LABEL .                    GINST ICODE @C@@@9TR
)@@G@@         GETC .                    GET OP CODE  @D@@@9         SLBD  A7,TS
)@@G@@36 .             OP IN A7 J IN A8   @D@@@9         MOVE  DIGFRE,2,I .   TT
)@@G@@     SET TO FREE AW2    @E@@@9         IF    A7,GE,07,I THEN,GRX1 .    -TU
)@@G@@> NOT STORE INST  @D@@@9         MOVE  DIGFRE,1,I .        STORE, FREE ATV
)@@G@@W 1   @C@@@9         GOTO  GRX1 .              -> MERGE     @#@@@9IGDRX0TW
)@@G@@   LABEL .  @C@@@9         LINK  RGXLD .             GET J FIELD  @C@@@9TX
)@@G@@         IF    A10,EQ,OPDJZ,I THEN,IGDJZ0 .     @C@@@9         LOAD  A7,TY
)@@G@@071,I .          DOUBLE INST  @C@@@9         MOVE  DIGFRE,2,I .         TZ
)@@G@@FREE AW 2   @D@@@9         IF    A10,NE,012,I THEN,GRX1X . -> NOT DS    UA
)@@G@@@C@@@9         MOVE  DIGFRE,1,I .        FREE AW 1    @D@@@9         GOTUB
)@@G@@O  GRX1X .             -> DOUBLE LOAD     @C@@@9IGFRX0   LABEL .        UC
)@@G@@            FLOAT INST  @ @@@9         LOAD  A7,076,I .     @C@@@9      UD
)@@G@@   LINK  RGXLD .             GET J FIELD  @C@@@9         MOVE  DIGFRE,2,UE
)@@G@@I .        FREE AW 2    @#@@@9GRX1X    LABEL .  @ @@@9         STORE A7,UF
)@@G@@DGOPCD .    @ @@@9         STORE A10,DGJCOD .   @C@@@9         LOAD  X3,UG
)@@G@@0,X2 .           SET 2 WORD AW@ @@@9         USING RGSWRD,X3 .    @F@@@9UH
)@@G@@         MOVE  RGSWKY,RGSW2W+RGSWIU,I .        SET 2 WORD, IN USE @^@@@9UI
)@@G@@         GOTO  RGX1Y .  @C@@@9IGSHIN0  LABEL .                    SHIFT UJ
)@@G@@INST  @ @@@9         LOAD  A7,073,I .     @C@@@9         MOVE  DIGFRE,0,UK
)@@G@@I .        FREE 0 AW'S  @#@@@9GRX1      LABEL . @E@@@9         STORE A7,UL
)@@G@@DGOPCD .         SET OPCODE AND J FIELD   @F@@@9         LINK  RGXLD .  UM
)@@G@@           GET AW, TEST FOR REG CONTENTS  @ @@@9         STORE A10,DGJCOUN
)@@G@@D .   @#@@@9RGX1Y    LABEL .  @F@@@9          LOAD   X3,X2 .            UO
)@@G@@    X3-> LEFT OPERAND (REG)   @G@@@9          LINK   GARG .             UP
)@@G@@    X2-> RIGHT OPERAND (ADDRESS)    @C@@@9         LOAD  A10,DGJCOD .   UQ
)@@G@@     SET J FIELD  @E@@@9         IF    DGXTED,OFF THEN,RX1B . -> NOT IMMUR
)@@G@@EDIATE DATA @ @@@9         MOVE  DGXREG,0,I    .@ @@@9         STORE X2,US
)@@G@@CDUFLD     .@ @@@9         SET   DGXTED,OFF .   @D@@@9         LOAD  A7,UT
)@@G@@DGOPCD .    CHECK TYPE OF OPCODE    @G@@@9         TLE,U A7,070  .     SUU
)@@G@@EE IF FLOAT, DOUBLE, OR SHIFT      *******@D@@@9         LOAD  A10,U,I .UV
)@@G@@ OTHERWISE SET U IN J-FIELD   @B@@@9         LOAD  X3,0,X3 .     POINT TUW
)@@G@@O RSW @H@@@9         LOADA X11,GEND0 .   SET RETURN ADDRESS FOR AFTER FIUX
)@@G@@NISHING GENERATION@B@@@9         LOCAL . SET THE ADDRESS ON STACK @^@@@9UY
)@@G@@         GOTO  GADDRX . @E@@@9RX1B     LABEL .             MERGE WHEN NOUZ
)@@G@@T IMMEDIATE DATA  @C@@@9         LOAD  X11,DIGFRE .        GET FREE FLAGVA
)@@G@@@C@@@9         GOTO  *GRX1A,X11 .        BRANCH TABLE @#@@@9GRX1A    LABVB
)@@G@@EL .  @B@@@9         +GRX1B .                  NO FREE@B@@@9         +GRVC
)@@G@@X1C .                  AW 1   @C@@@9         +GRX1E .                  FVD
)@@G@@REE AW 2    @#@@@9GRX1E    LABEL .  @B@@@9         LOAD  X5,X2 .        VE
)@@G@@     AW 2   @^@@@9         GOTO  GRX1D .  @#@@@9GRX1C    LABEL .  @B@@@9VF
)@@G@@         LOAD  X5,X3 .             AW 1   @#@@@9GRX1D    LABEL .  @F@@@9VG
)@@G@@         IF    A10,GE,016,I THEN,GRX1B .    -> U FIELD, NO FREE   @^@@@9VH
)@@G@@         LINK GFREE0 .  @#@@@9GRX1B    LABEL .  @F@@@9          LOAD   XVI
)@@G@@3,0,X3 .              X3-> RGSW OF LEFT OPERAND @D@@@9         LOADA X11VJ
)@@G@@,GEND0 .         SET RETURN ADDRESS @#@@@9IGRXLD   LOCAL .  @C@@@9      VK
)@@G@@   LOAD  X5,X2 .             DECODE AW    @D@@@9          LINK   GADRX .VL
)@@G@@               -> DECODE AW   @C@@@9         LOAD  A7,DGOPCD .         SVM
)@@G@@ET OP CODE  @E@@@9GADDRX   LABEL .              MERGE POINT FOR IMMEDIATVN
)@@G@@E DATA@ @@@9          USING  RGSWRD,X3 .  @C@@@9         SLB   A10,4 .  VO
)@@G@@           LOAD A-REG   @D@@@9         ADD   A10,RGSWRN .        ADD REGVP
)@@G@@ NUMBER     @^@@@9         SLB   A10,4 .  @C@@@9         ADD   A10,DGXREVQ
)@@G@@G .        SET X REG    @D@@@9         STORE A10,CDINPT .        SET J,AVR
)@@G@@,X PART     @C@@@9         STORE A7,CDOP,*X10 .      SET OPCODE   @ @@@9VS
)@@G@@         GCORE 0 'LABEL',JMP .@D@@@9RGXLD    LOCAL .                   GVT
)@@G@@ET REG CONTETS    @^@@@9         LINK  GARG .   @^@@@9         USING AWDVU
)@@G@@S,X2 .@D@@@9         IF    AWRGPT,ZERO THEN,JMP . -> REGISTER AW  @G@@@9VV
)@@G@@         LA,U  A6,0400000 .  LOAD WITHOUT SIGN EXTENTION      *******   VW
)@@G@@@E@@@9         IF    A6,EQ,AWRGPT THEN,JMP . -> JUST KEEP BIT ON  @E@@@9VX
)@@G@@         EXERR EXCGLD LEVEL,2 .    AW ERROR IN CG PHASE     @E@@@9      VY
)@@G@@   LOADA X2,AGRA3-AGRX0+AGAW .   SET X REG A3 AS DUMMY@C@@@9         JMPVZ
)@@G@@ .                     -> RETURN    @ @@@9GADRX    LOCAL               .WA
)@@G@@@ @@@9         STORE X1,DXGSV5 .    @ @@@9         STORE X2,DXGSV5+1    WB
)@@G@@@ @@@9         STORE X3,DXGSV5+2    @ @@@9         STORE X4,DXGSV5+3    WC
)@@G@@@D@@@9         MOVE  GCRTCH,0,I .        NO SCRATCH REG YET @^@@@9      WD
)@@G@@   USING AWDS,X5 .@ @@@9         LOAD  A2,AWRGPT,X5 . @C@@@9         ANDWE
)@@G@@,U A2,0377777 .  MASK OUT KEEP BIT  @G@@@9         IF    A3,EQ,0,I THEN,WF
)@@G@@GADDR2 . -> X5 IS A(RGSW), OPND IN REG    @D@@@9         LOAD  A4,AWOFSTWG
)@@G@@,X5 .      ORIGINAL OFFSET    @C@@@9         LOAD  X2,A3 .             NWH
)@@G@@EXT BASE    @^@@@9         USING AWDS,A3 .@ @@@9         LOAD  A2,AWRGPTWI
)@@G@@,A3 . @C@@@9         AND,U A2,0377777 . MASK OUT KEEP BIT   @D@@@9      WJ
)@@G@@   IF    A3,EQ,0,I THEN,GADDR3 . -> FOUND REG   @ @@@9          STORE  AWK
)@@G@@4,DGSTOR .  @D@@@9         LOAD  A4,AWOFST,X2 .      SAVE DISPLACEMENT  WL
)@@G@@@^@@@9         LOAD  X2,A3 .  @ @@@9         LOAD  A2,AWRGPT,A3 . @C@@@9WM
)@@G@@         AND,U A2,0377777 . MASK OUT KEEP BIT   @B@@@9         IF    A3,WN
)@@G@@EQ,0,I THEN,GADDR4 .    @C@@@9         STORE A4,DGSTO2 .   SAVE DISPLACEWO
)@@G@@MENT  @D@@@9         LOAD  A4,AWOFST,X2 . FETCH NEXT DISPLACEMENT @A@@@9WP
)@@G@@         LOAD  X2,A3 .       NEXT AW@ @@@9         LOAD  A2,AWRGPT,A3 . WQ
)@@G@@@C@@@9         AND,U A2,0377777 . MASK OUT KEEP BIT   @B@@@9         IF WR
)@@G@@   A3,EQ,0,I THEN,GADDR5 .    @C@@@9         STORE A4,DGSTO4 .   SAVE DIWS
)@@G@@SPLACEMENT  @ @@@9         LOAD  A4,AWOFST,X2 . @C@@@9         LOAD  X2,WT
)@@G@@A3 .             CONTINUE     @ @@@9         LOAD  A2,AWRGPT,A3 . @C@@@9WU
)@@G@@         AND,U A2,0377777 . MASK OUT KEEP BIT   @E@@@9         IF    A3,WV
)@@G@@EQ,0,I THEN,GADDR6 . -> SET BASE DISP     @G@@@9         EXERR EXERCGGA WW
)@@G@@LEVEL,3 .  TOO MANY BASE DISPLACEMENT CALCULATIO@#@@@9GAEXT3    LABEL . WX
)@@G@@@ @@@9         LOAD  A4,DGSTO4 .    @H@@@9          LINK   GADDR1 .     WY
)@@G@@          ESTABLISH ADDRESSABILITY OF BASE 2    @#@@@9GAEXT2    LABEL . WZ
)@@G@@@ @@@9         LOAD  A4,DGSTO2 .    @H@@@9          LINK   GADDR1 .     XA
)@@G@@          ESTABLISH ADDRESSABILITY OF BASE 1    @#@@@9GAEXT1    LABEL . XB
)@@G@@@F@@@9         LOAD  A4,DGSTOR .         OFFSET FROM OPND FROM 1ST BASE XC
)@@G@@@D@@@9         LINK  GADDR1 .            SET BASE DISPL.    @#@@@9GAEXT0XD
)@@G@@    LABEL . @E@@@9         MOVE  DGSTOR,0,I .        CLEAR DISPLACEMENT XE
)@@G@@FIELD @ @@@9         LOAD  X1,DXGSV5 .    @ @@@9         LOAD  X2,DXGSV5XF
)@@G@@+1    @ @@@9         LOAD  X3,DXGSV5+2    @ @@@9         LOAD  X4,DXGSV5XG
)@@G@@+3    @E@@@9          JMP .                         -> RETURN TO CALLER XH
)@@G@@@#@@@9GADDR2    LABEL . @C@@@9         LOAD  X5,0,X5 .           X5=A(RGXI
)@@G@@SW) . @ @@@9         USING RGSWRD,X5 .    @D@@@9         LOAD  A3,RGSWRAXJ
)@@G@@ .   GET REGISTER NUMBERUMBER @D@@@9         AND,U A3,RGSWRR      . CHECXK
)@@G@@K FOR R-REGISTER  @E@@@9         ADD   A3,A4 .       CONVERT TO R-REGISTXL
)@@G@@ER ADDRESS  @C@@@9         STORE A3,CDUFLD .         SET U FIELD  @C@@@9XM
)@@G@@         MOVE  DGXREG,0,I .        SET NO X REG @C@@@9         GOTO  GAEXN
)@@G@@XT0 .            -> RETURN    @#@@@9GADDR3    LABEL . @G@@@9          LIXO
)@@G@@NK   GADDR0 .               ESTABLISH ADDRESSABILITY OF OPND@C@@@9      XP
)@@G@@    GOTO   GAEXT0 .               -> MERGE@#@@@9GADDR4    LABEL . @H@@@9XQ
)@@G@@          LINK   GADDR0 .               ESTABLISH ADDRESSABILITY OF BASEXR
)@@G@@ 1    @C@@@9          GOTO   GAEXT1 .               -> MERGE@#@@@9GADDR5XS
)@@G@@    LABEL . @H@@@9          LINK   GADDR0 .               ESTABLISH ADDRXT
)@@G@@ESSABILITY OF BASE 2    @C@@@9          GOTO   GAEXT2 .               MEXU
)@@G@@RGE   @#@@@9GADDR6    LABEL . @H@@@9          LINK   GADDR0 .           XV
)@@G@@    ESTABLISH ADDRESSABILITY OF BASE 3    @C@@@9          GOTO   GAEXT3 XW
)@@G@@.               -> MERGE@B@@@9.           ***  BASE IS IN REGISTER  *** XX
)@@G@@@#@@@9GADDR0   LLOC .   @B@@@9         LOAD  X2,W1,X2 .    X2 = A(RGSW) XY
)@@G@@@D@@@9         LOAD  A2,RGSWRA,X2 . GET THE REGISTER ADDRESS@F@@@9      XZ
)@@G@@   IF    A2,LT,020,I THEN,GADDR7 . -> REGISTER IS 'X' REG   @D@@@9      YA
)@@G@@   AND,U A2,RGSWRR . CHECK FOR 'R' REGISTER     @F@@@9         ADD   A2,YB
)@@G@@A3 .       ADD IN POSSIBLE 'R' REGISTER ADDRESS @E@@@9         STORE A2,YC
)@@G@@CDUFLD .   SET U-FIELD OF INSTRUCTION     @D@@@9         MOVE  DGXREG,0,YD
)@@G@@I .  SET X-REGISTER TO ZERO   @G@@@9         GOTO  GADDR1 .      USE SUBYE
)@@G@@ROUTINE FOR INSTRUCTION CREATION    @D@@@9GADDR7   LABEL .             RYF
)@@G@@EGISTER WAS 'X' REGISTER@E@@@9         STORE A4,CDUFLD .         SET U IYG
)@@G@@NTO INSTRUCTION   @ @@@9         USING RGSWRD,X2 .    @E@@@9         MOVYH
)@@G@@E  DGXREG,RGSWRA .     STORE BASE REG NUMBER    @C@@@9         LJMP .   YI
)@@G@@                 -> RETURN    @B@@@9.           ***  LOAD SECONARY BASE YJ
)@@G@@A     @#@@@9GADDR1   LLOC .   @H@@@9          IF     GCRTCH,NZERO THEN,GYK
)@@G@@ADDR10 . HAS SCRATCH REG BEEN ACQUIRED    @D@@@9          GSRTCH .      YL
)@@G@@                NO -- GET ONE @ @@@9         USING RGSWRD,X1 .    @G@@@9YM
)@@G@@          MOVE   GCRTCH,RGSWRA .        SAVE SCRATCH REGISTER NUMBER    YN
)@@G@@@G@@@9GADDR10   LABEL .                       YES -- HAVE A SCRATCH REGIYO
)@@G@@STER  @E@@@9          LOAD   A7,GCRTCH .            LOAD OPND REGISTER  YP
)@@G@@@E@@@9          SLB    A7,4 .                 SHIFT INTO POSITION @G@@@9YQ
)@@G@@          ADD    A7,DGXREG .            LOAD X-REG PART OF REAL INST    YR
)@@G@@@B@@@9         STORE A7,CDINPT .         STORE  @ @@@9         STORE A4,YS
)@@G@@CDUFLD+1 .  @C@@@9         LOAD  A7,027,I .          GET OP CODE  @ @@@9YT
)@@G@@         STORE A7,CDOP,*X10 . @#@@@9         GCORE 0 .@G@@@9          MOYU
)@@G@@VE   DGXREG,GCRTCH .        SCRATCH IS BASE REG OF ITEM     @C@@@9      YV
)@@G@@   LJMP .                    -> RETURN    @C@@@9IGGTT0   LABEL .        YW
)@@G@@           GET TEMP     @D@@@9         LINK  GARG .              GET AW YX
)@@G@@OF TEMP     @D@@@9         GETC .                    GET NUMBER OF WORDSYY
)@@G@@@^@@@9         GTMP  R,A8 .   @^@@@9         USING AWDS,X2 .@D@@@9      YZ
)@@G@@   STORE A8,AWOFST,X2 .      STORE TEMP ON AW   @A@@@9         MOVE  AWRZA
)@@G@@GPT,AGRX10,I .    @C@@@9         GOTO  GEND0 .             NEXT ICODE   ZB
)@@G@@@#@@@9IGGETGR0 LABEL .  @E@@@9         LINK  GARG .              GET AW ZC
)@@G@@TO PUT REGISTER IN@G@@@9         JN    A9,IGGETX0 .        -> GET INDEX ZD
)@@G@@REG              *******@E@@@9         IF    A10,NE,2,I THEN,IGGET3 . ONZE
)@@G@@E WORD REGISTER   @E@@@9         LINK  RGGETFPR .    -> FLOATING POINT RZF
)@@G@@EGISTER     @F@@@9         GOTO  IGGET2 .      -> MERGE AFTER FETCHING RZG
)@@G@@EGISTER     @D@@@9IGGET3   LABEL .             GET ONE WORD REGISTER    ZH
)@@G@@@E@@@9         LINK  RGGETGPR .          GET REGISTER, RSW IN X1  @#@@@9ZI
)@@G@@IGGET2   LABEL .  @ @@@9         USING RGSWRD,X5 .    @C@@@9         STOZJ
)@@G@@RE X2,RGSWUR .         POINT TO AW  @C@@@9         STORE X5,0,X2 .      ZK
)@@G@@     SETUP AW     @C@@@9         GOTO  GEND0 .             -> NEXT ICODEZL
)@@G@@@C@@@9IGGETX0  LABEL .                   GET X REG    @ @@@9         LINZM
)@@G@@K  RGGETXRG .     @C@@@9         GOTO  IGGET2 .            -> MERGE     ZN
)@@G@@@E@@@9IGSUB0   LABEL .                   GENERATE SUBROTONE CALL  @C@@@9ZO
)@@G@@         LOAD  A6,0745660,I .       SET LMJ X11,@ @@@9         STORE A6,ZP
)@@G@@CDINPT .    @E@@@9         LOAD  A7,DXGARG .         GET BUILTIN ENTRY AZQ
)@@G@@DDR   @G@@@9         TN    A9 .                -> BUILTIN .             ZR
)@@G@@     *******@D@@@9         LOAD  A7,W1H2,X1 .        GET ENTRY ADDRESS  ZS
)@@G@@@D@@@9         STORE A7,CDUFLD,*X10 .    SET ENTRY ADDRESS  @#@@@9      ZT
)@@G@@   GCORE 0 .@G@@@9         JN    A9,GEND0 .          -> BUILTIN         ZU
)@@G@@           *******@E@'@9         SETGC 6,1,X1 .            START TO READZV
)@@G@@ NEXT WORD  @E@@@'.        SETGC 6,1,X1 .            START TO READ NEXT ZW
)@@G@@WORD  @ @@@'         LOADXM  X1,W1U+1,X1 .@ @@@'         LOAD    A1,KLCHZX
)@@G@@6W .  @C@@@9         GOTO  GEND0 .             -> NEXT ICODE@D@@@9IGBR0 ZY
)@@G@@   LABEL .                   TEST FLAG AND JUMP @D@@@9         LINK  GARZZ
)@@G@@G          . GET AW POINTER IN X2   @C@@@9         LINK  GARGMK        .AA
)@@G@@ GET FLAG IN A7   @E@@@9         LOAD  X3,A10        . GET QUARTER WORD AB
)@@G@@POINTER     @E@@@9         EX    GARGTB-4,X3   .                  ******AC
)@@G@@*     @D@@@9         IF    A9,LT,0,I THEN,IGBR1 . -> TEST FOR ON  @F@@@9AD
)@@G@@         IF    A8,NE,0,I THEN,GEND1 . -> FLAGS ON, THUS OFF FAILS @C@@@9AE
)@@G@@         GOTO  IGGOTO0 .           PROCESS JUMP @#@@@9IGBR1    LABEL .  AF
)@@G@@@H@@@9         IF    A8,EQ,0,I THEN,GEND1 ELSE,IGGOTO0 . IF 0 THEN OFF, AG
)@@G@@SO FALSE    @F@@@9GARGTB   LABEL               . EX TABLE TO PROPER QUARAH
)@@G@@TER WORD    @E@@@9         AND,Q2 A7,0,X2      .                    ****AI
)@@G@@***   @E@@@9         AND,Q4 A7,0,X2      .                    *******   AJ
)@@G@@@E@@@9         AND,Q3 A7,0,X2      .                    *******   @E@@@9AK
)@@G@@         AND,Q1 A7,0,X2      .                    *******   @F@@@9IGKEEPAL
)@@G@@0  LABEL .                   PROTECT AW TEMP FROM FREEING   @B@@@9      AM
)@@G@@   LINK  GARG .              GET AW @D@@@9         LOAD  A7,W1,X2 .     AN
)@@G@@  GET TEMP TO PROTECT   @C@@@9         OR    A7,KEPBT1     . SET KEEP BIAO
)@@G@@T ON  @ @@@9         STORE A8,W1,X2 .     @C@@@9         GOTO  GEND0 .  AP
)@@G@@           -> NEXT ICODE@B@@@9/ .              UNLINK FUNCTION ROUTINE  AQ
)@@G@@@B@@@9.         X2=OFFSET OF CELL TO BE REMOVED @#@@@9RGUNLINK LLOC .   AR
)@@G@@@^@@@9         USING WORD,X2 .@G@@@9          LOAD   X3,W1H1 .          AS
)@@G@@    X3=FORWARD PTR OF OUT-GOING CELL@H@@@9          LOAD   X4,W1H2 .    AT
)@@G@@          X4=BACKWARD PTR OR OUT-GOING CELL     @F@@@9         STORE X3,AU
)@@G@@W1H1,X4 .        SET NEW FLNK OF PRECEDING CELL @F@@@9         STORE X4,AV
)@@G@@W1H2,X3 .        SET NEW BLNK OF FOLLOWING CELL @C@@@9         LJMP .   AW
)@@G@@                 -> RETURN    @B@@@9.                LINK FUNCTION ROUTIAX
)@@G@@NE    @B@@@9.         X2= OFFSET OF CELL TO BE ADDED  @G@@@9.         X3AY
)@@G@@= OFFSET OF CELL IN LIST AFTER WHICH NEW CELL IS TO BE ADDED@#@@@9RGLINKAZ
)@@G@@   LLOC .   @ @@@9         LOAD  X4,W1H1,X3 .   @ @@@9         STORE X4,BA
)@@G@@W1H1,X2 .   @F@@@9         STORE X3,W1H2,X2 .        SET FLNK AND BLNK OBB
)@@G@@F NEW CELL  @F@@@9         STORE X2,W1H2,X4 .        SET BLNK OF FOLLOWIBC
)@@G@@NG CELL     @E@@@9         STORE X2,W1H1,X3 .        SET FLNK OF PREC CEBD
)@@G@@LL    @C@@@9         LJMP .                    -> RETURN    @^@@@9. CALLBE
)@@G@@   LINK  RGFREE   @C@@@9.        X5=A(RGSW) OF REGISTER TO BE FREED     BF
)@@G@@@#@@@9. RETURN NONE     @G@@@9. ACTION REMOVES REGISTER FROM IN-USE LISTBG
)@@G@@ AND RETURNS IT TO FREE LIST  @#@@@9. DESTROY NONE    @#@@@9RGFREE    LOBH
)@@G@@CAL . @ @@@9         STORE X2,DRGSAV .    @ @@@9         STORE X3,DRGSAVBI
)@@G@@+1 .  @ @@@9         STORE X4,DRGSAV+2 .  @C@@@9         STORE A7,DRGSAVBJ
)@@G@@+3 .       SAVE A7 ALSO @ @@@9         USING RGSWRD,X5 .    @ @@@9      BK
)@@G@@   LOAD  A7,RGSWBL .    @F@@@9         IF    A7,GE,0177777,I THEN,RGXR .BL
)@@G@@ -> NOT MANAGED, RETURN @E@@@9         LOADA A7,RGSXFB .         PREPAREBM
)@@G@@ TO ADD X REG     @C@@@9         LOAD  A3,RGSWKY .         SEE IF X REG BN
)@@G@@@D@@@9         IF    A3,GE,RGSWXR,I THEN,RGFROK . -> OK FREE@C@@@9      BO
)@@G@@   LOADA A7,RGSWFB .         ADD A REG    @E@@@9         LINK  RGODD .  BP
)@@G@@           RESET ACC TO ODD REG     @#@@@9RGFROK   LABEL .  @D@@@9      BQ
)@@G@@    USING WORD,X2 .               SET WORD DSECT@E@@@9         AND,U A3,BR
)@@G@@RGSWXR .   CLEAR FLAGS EXCEPT X-REG FLAG  @G@@@9         STORE  A4,RGSWKBS
)@@G@@Y .        RESET FLAGS                   *******@E@@@9         LOAD  X2,BT
)@@G@@X5 .             POINT TO RGSW TO UNLINK  @E@@@9         LINK  RGUNLINK BU
)@@G@@.          UNLINK FROM USED LIST    @E@@@9          LOAD   X3,A7 .      BV
)@@G@@          ADD TO NEW LIST     @G@@@9          LINK   RGLINK .           BW
)@@G@@    PUT REG AT END OF FREE LIST     @B@@@9         GOTO  RGXR .         BX
)@@G@@     RETURN @ @@@9         USING RGSWRD,X5     .@#@@@9RGODD    LLOC .   BY
)@@G@@@E@@@9         LOAD  A6,RGSWIF .         GET REG NUMBER AND ADDR  @D@@@9BZ
)@@G@@         IF    A6,ODD THEN,LJMP .   -> ALREADY SET    @F@@@9         SUBCA
)@@G@@   A6,010001,I   . SUBTRACT TO MAKE ADDR AND NUM ODD  @ @@@9         STOCB
)@@G@@RE A6,RGSWIF .    @C@@@9         LJMP .                    -> RETURN    CC
)@@G@@@ @@@9          USING  WORD,X5 .    @G@@@9.         TITLE - PLUM CODE GECD
)@@G@@NERATOR - REGISTER ALLOCATOR (LEVEL 3)    @E@@@9. CALL   LINK RGGETXRG  CE
)@@G@@           TO OBTAIN X REGISTER     @F@@@9. CALL   LINK  RGGETGPR       CF
)@@G@@     TO OBTAIN GENERAL REGISTER     @ @@@9.                           ORCG
)@@G@@@F@@@9.         LINK   RGGETFPR               TO GET FLOATING POINT REG CH
)@@G@@@G@@@9. ACTION  ALLOCATES ONE REGISTER OF THE TYPE REQUESTED. IF NONE ISCI
)@@G@@ FREE @B@@@9.         THE OLDEST ONE IN USE IS STORED @F@@@9. RETURN  X5CJ
)@@G@@ POINTS TO REGISTER STATUS WORD OF ACQUIRED REGISTER  @#@@@9RGGETXRG   LCK
)@@G@@OCAL .@D@@@9         MOVE  DRGTPE,RGSWXR,I .        SET X REG     @^@@@9CL
)@@G@@         LOAD  A6,0,I . @D@@@9         GOTO  RGGETMX .           -> COMMCM
)@@G@@ON ALLOCATOR@E@@@9RGGETFPR LOCAL .                   GET FLOATING REG 2 CN
)@@G@@WORDS @D@@@9         MOVE  DRGTPE,RGSW2W,I .        SET TO 2 WORDS@C@@@9CO
)@@G@@         GOTO  RGGETM .            -> MERGE     @#@@@9RGGETGPR  LOCAL . CP
)@@G@@@F@@@9         MOVE  DRGTPE,RGSW1W,I .        SET TO 1 WORD CONTENTS    CQ
)@@G@@@C@@@9RGGETM   LABEL .                   MERGE POINT  @C@@@9         LOACR
)@@G@@D  A6,1,I .            SET TO A REG @F@@@9RGGETMX  LABEL .              CS
)@@G@@     MERGE X AND A REG ALLOCATOR    @ @@@9         STORE X2,DRGSAV .    CT
)@@G@@@ @@@9         STORE X3,DRGSAV+1 .  @ @@@9         STORE X4,DRGSAV+2 .  CU
)@@G@@@ @@@9         STORE A7,DRGSAV+3 .  @C@@@9         LOADA A3,RGSWFF .    CV
)@@G@@     ASSUME A REG @F@@@9         IF    A6,NE,0,I THEN,RGGETA .     -> COCW
)@@G@@RRECT ASSUMPTION  @C@@@9         LOADA A3,RGSXFF .         X REG PTRS   CX
)@@G@@@#@@@9RGGETA   LABEL .  @ @@@9         USING RGSWRD,A3 .    @D@@@9      CY
)@@G@@   LOAD  A7,RGSWFL .         FREE LIST FORWARD  @E@@@9         IF    A7,CZ
)@@G@@EQ,A3 THEN,RGNOFREE . -> FREE LIST EMPTY  @B@@@9         LOAD   X2,RGSWFDA
)@@G@@L .        GET REG@ @@@9         LINK  RGUNLINK .     @C@@@9         LOADB
)@@G@@D   X3,W1H2+1,A3 .     GET USED LIST@^@@@9         LINK  RGLINK . @^@@@9DC
)@@G@@         LOAD  X5,X2 .  @C@@@9         GOTO RGEXIT .             -> RETUDD
)@@G@@RN    @#@@@9RGNOFREE  LABEL . @D@@@9         LOAD  X2,W1H1+1,A3 .     GEDE
)@@G@@T FIRST USED REG  @G@@@9          LINK   RGUNLINK .             FREE 1STDF
)@@G@@ REG ON IN USE LIST     @E@@@9         LOAD   X3,W1H2+1,A3 .    ADD TO EDG
)@@G@@ND OF IN USE LIST @G@@@9          LINK   RGLINK .                 IN-USEDH
)@@G@@ LIST (FIFO ORDERING)   @ @@@9         LOAD  X5,X2         .@ @@@9      DI
)@@G@@   USING RGSWRD,X5     .@H@@@9         IF    RGSWIU,OFF,RGSWKY THEN,RGX DJ
)@@G@@. -> REG NOT IN USE, ALREADY FREE   @ @@@9         LOAD  X2,RGSWUR     .DK
)@@G@@@G@@@9         LOAD  A3,W1,X2         .  SEE IF ADDRESS WORD POINTS BACKDL
)@@G@@...   @D@@@9         AND,U A3,0377777    . GET RID OF KEEP BIT    @E@@@9DM
)@@G@@         IF     A4,NE,X5 THEN,RGX . -> REG ALREADY FREE     @ @@@9      DN
)@@G@@   LOADA X3,RGOP1 .     @ @@@9         USING RGSWRD,X5 .    @ @@@9      DO
)@@G@@   LOAD  A4,RGSWKY .    @D@@@9         LOAD  A8,1,I .            SET 1 WDP
)@@G@@ORD A REG   @C@@@9         IF    A4,LT,RGSW2W,I THEN,RGGET2 .     @D@@@9DQ
)@@G@@         LOAD  A8,2,I .            SET 2 WORD A REG   @ @@@9         LOADR
)@@G@@DA X3,RGOP2 .     @C@@@9         IF    A4,LT,RGSWXR,I THEN,RGGET2 .     DS
)@@G@@@D@@@9         LOAD  A8,1,I .            SET 1 WORD X REG   @ @@@9      DT
)@@G@@   LOADA X3,RGOP3 .     @#@@@9RGGET2   LABEL .  @E@@@9          LINK   XDU
)@@G@@GTMPA .               GET TEMP STORAGE    @ @@@9          USING  WORD,X2DV
)@@G@@ .    @^@@@9         STORE A8,W1H2 .@E@@@9         LOADA A6,AGRX10-AGRX0DW
)@@G@@+AGAW .         NORMAL BASE   @C@@@9         STORE A6,W1H1 .           SDX
)@@G@@ETUP AW     @C@@@9         LOADA A6,RGSNULL    . SET UP FAKE AW   @ @@@9DY
)@@G@@         STORE A6,RGSWUR     .@E@@@9         STORE A8,CDUFLD .   SET U-FDZ
)@@G@@IELD OF INSTRUCTION     @^@@@9         USING WORD,X3 .@C@@@9         LOAEA
)@@G@@D  A7,W1H2,X3 .           GET OP,J  @D@@@9         ADD   A7,RGSWRN .    EB
)@@G@@     GET REG NUMBER     @^@@@9         SLB   A7,4 .   @G@@@9         ADDEC
)@@G@@   A7,10,I .           PUT IN X REGISTER X10 FOR TEMPORARY  @D@@@9      ED
)@@G@@   STORE A7,CDINPT,*X10 .    SET STORE INST     @F@@@9         GCORE 0 .EE
)@@G@@                 ADVANCE AND TEST FOR OVERFLOW  @^@@@9         SRB   A7,EF
)@@G@@4 .   @G@@@9         IF    A7,NE,RGOP3 THEN,RGEXIT . -> X-REG CAN BE ODDEG
)@@G@@ OR EVEN    @E@@@9         LINK  RGODD .             MAKE SURE A-REG IS EH
)@@G@@ODD   @#@@@9RGX       LABEL . @#@@@9RGEXIT    LABEL . @ @@@9         USIEI
)@@G@@NG RGSWRD,X5 .    @C@@@9         LOAD  A7,DRGTPE .         GET REG TYPE EJ
)@@G@@@D@@@9         ADD   A7,RGSWIU,I .            SET IN USE    @ @@@9      EK
)@@G@@   STORE A7,RGSWKY .    @#@@@9RGXR     LABEL .  @B@@@9         LOAD  A7,EL
)@@G@@DRGSAV+3 .       RETURN @ @@@9         LOAD  X4,DRGSAV+2 .  @ @@@9      EM
)@@G@@   LOAD  X3,DRGSAV+1 .  @ @@@9         LOAD  X2,DRGSAV .    @C@@@9      EN
)@@G@@   JMP .                     -> RETURN    @ @@@9RGSNULL   LBLAD  RGSNULLEO
)@@G@@,0    @E@@@9RGOP1    +0400 .                   SA  OPCODE 01 TO 14 BITS EP
)@@G@@@F@@@9RGOP2    +34640 .                  DS  OPCODE 71,12 TO 14 BITS    EQ
)@@G@@@E@@@9RGOP3    +03000 .                  SX  OPCODE 06 TO 14 BITS @B@@@9ER
)@@G@@RGOP4    +01576660 .         SHIFTED DL   @E@@@9RGMASK   +0377777777777 ES
)@@G@@.    MASK TO 'AND' OUT KEEP BIT     @H@@@9RGMSK2   +0377777000000      .ET
)@@G@@ MASK TO EXAMINE H1 POINTERS WITHOUT KEEP BIT   @#@@@9KEPBT1   LABEL .  EU
)@@G@@@C@@@9KEPBIT   SAC   0400000,0     . PROTECTED AW FLAG@ @@@9/.       TEMEV
)@@G@@PORARY ALLOCATOR  @D@@@9.        +---------------------+----------------EW
)@@G@@-----+@D@@@9.        ! SIZE OF ENTRY       ! BASE ADDRESS        !@D@@@9EX
)@@G@@.        +---------------------+---------------------+@#@@@9.        ALLEY
)@@G@@OCATOR@D@@@9XGTMPA*  LLOC .                    ALLOCATE TEMPORARY @F@@@9EZ
)@@G@@         LOAD  A2,DCGTLV .         GET CURRENT TEMP STACK LEVEL   @ @@@9FA
)@@G@@         USING TGDSCT,A2 .    @D@@@9         LOAD  A3,TGFSET,A2 .       FB
)@@G@@    GET OFFSET    @D@@@9         ADD   A3,TGSIZE,A2 .           GET NEW FC
)@@G@@BASE  @A@@@9         STORE A3,TGFSET+1,A2 .     @E@@@9         STORE A8,FD
)@@G@@TGSIZE+1,A2 .         SET NEW SIZE OF TEMP@D@@@9         ADD   A8,A3 .  FE
)@@G@@           SEE IF OVERFLOW    @E@@@9         IF    A8,LT,DTGMAX THEN,TGTFF
)@@G@@ERM . -> NOPE, RETURN   @E@@@9         STORE A8,DTGMAX .         SET NEWFG
)@@G@@ MAX TEMP LEVEL   @#@@@9TGTERM   LABEL .  @^@@@9         USING WORD,X7 .FH
)@@G@@@E@@@9         IF    A2,GE,W1XU THEN,XG2FUL . -> STACK OVERFLOW   @D@@@9FI
)@@G@@         ADD   A2,1,I .            SET NEW POINTER    @ @@@9         STOFJ
)@@G@@RE A2,DCGTLV .    @D@@@9         LOAD  A8,A3 .             SET RETURNED FK
)@@G@@VALUE @C@@@9         LJMP .                    -> RETURN    @D@@@9XGTMPFFL
)@@G@@*  LLOC .                    FREE TEMPORARY     @^@@@9         LOAD  A2,FM
)@@G@@A8 .  @C@@@9         AND,U A2,0177777 .  REMOVE H AND I BITS@^@@@9      FN
)@@G@@   STORE A3,A8 .  @C@@@9         LOAD  A2,DCGTLV .         GET STACK TOPFO
)@@G@@@G@@@9         ANU,H1 A2,DCGTSK-(IN 63,H1,1,0) .                     ***FP
)@@G@@****  @C@@@9         STORE A3,R1         . SET REPEAT COUNT @ @@@9      FQ
)@@G@@   LOADXI A2,-1,I      .@G@@@9         SE,H2 A8,0,*A2 .         SEE IF BFR
)@@G@@ASE LESS THAN TEMP ADDR****** @ @@@9         GOTO  TGWIPE        .@D@@@9FS
)@@G@@         MOVE  TGSIZE+1,-1,I .       SET EMPTY SIZE   @#@@@9TGWIPE   LABFT
)@@G@@EL .  @C@@@9         LOADXM A2,DCGTLV .         POP STACK   @E@@@9      FU
)@@G@@   LOAD    R1,W1U+1,A3 .     GET PROPER REPEAT COUNT  @ @@@9         LOAFV
)@@G@@DN A3,0,I        .@ @@@9         SG    A3,0,*A2      .@F@@@9         LJMFW
)@@G@@P .              FAILURE WHEN TEMP STACK IS AT BOTTOM @F@@@9         ADDFX
)@@G@@   A2,1,I        . POINT A2 TO CURRENT TEMP IN USE    @ @@@9         STOFY
)@@G@@RE A2,DCGTLV     .@ @@@9         LJMP  . -> RETURN    @B@@@9/.       COMFZ
)@@G@@MON CODE GENERATOR SUBROUTINES@D@@@9.        CODE  GENERATOR ENTRY ROUTIGA
)@@G@@NES - GNTR MACRO  @^@@@9         USING WORD,A2  @#@@@9GNTRX*   LLOC .   GB
)@@G@@@^@@@9         STORE A1,W1 .  @ @@@9         STORED A7,W1+1 .     @ @@@9GC
)@@G@@         STORED A9,W1+3 .     @^@@@9         STORE F,W1+5 . @^@@@9      GD
)@@G@@   STORE X1,W1+6 .@^@@@9         STORE X2,W1+7 .@^@@@9         STORE X3,GE
)@@G@@W1+8 .@^@@@9         STORE X4,W1+9 .@ @@@9         STORE X5,W1+10 .     GF
)@@G@@@C@@@9         LJMP .                    -> RETURN    @D@@@9GRTNX*   LLOGG
)@@G@@C .                    RETURN - GRTN MACRO@^@@@9         LOAD  A1,W1 .  GH
)@@G@@@^@@@9         LOAD  X1,W1+6  @G@@@9GRTNXS*  LLOC .              RETURN GI
)@@G@@WITHOUT RESETTING META-CODE POINTER @^@@@9         LOAD  X2,W1+7  @^@@@9GJ
)@@G@@         LOAD  X3,W1+8  @^@@@9         LOAD  X4,W1+9  @^@@@9         LOAGK
)@@G@@D X5,W1+10 .@^@@@9         LOAD  F,W1+5 . @^@@@9         LOADD A9,W1+3 .GL
)@@G@@@^@@@9         LOADD A7,W1+1 .@D@@@9         JMP .                     -GM
)@@G@@> RETURN TO CALLER@F@@@9XGCFUL*  LOCAL .                   GENERATED CODGN
)@@G@@E FULL . QUIT     @B@@@9         EXERR EXERXGFL LEVEL,3 .  QUIT   @F@@@9GO
)@@G@@XG2FUL*  LOCAL .                   CODE GENERATOR STACK FULL .    @D@@@9GP
)@@G@@         EXERR EXERCGSF LEVEL,3 .  STACK FULL ERROR   @F@@@'/. THIS ROUTGQ
)@@G@@INE WAS DELETED FROM THE ROOT SEGMENT IN THE SWITCH   @C@@@'. TO ASCII TGR
)@@G@@O SAE SPACE IN THE ROOT SEGEMENT    @[@@@'.     @#@@@'KLCH6W   +1,$+3 . GS
)@@G@@@ @@@'         LA,S6   A8,0,*X1 .   @ @@@'         LMJ     A1,0,A1 .    GT
)@@G@@@ @@@'         LA,S1   A8,0,X1 .    @ @@@'         LA,S2   A8,0,X1 .    GU
)@@G@@@ @@@'         LA,S3   A8,0,X1 .    @ @@@'         LA,S4   A8,0,X1 .    GV
)@@G@@@ @@@'         LA,S5   A8,0,X1 .    @ @@@'         LMJ     A1,KLCH6W+1 .GW
)@@G@@@C@@@9EXCGLD   EQU   20 .                CG AW ERROR  @C@@@9EXERCGGA  EQGX
)@@G@@U  21 .                CG BD ERROR  @D@@@9EXERXGFL EQU   22 .           GY
)@@G@@     CODE TABLE OVERFLOW@E@@@9EXERCGSF EQU   23 .                CGSTK TGZ
)@@G@@ABLE OVERFLOW     @#@@@9         END .    ___   *[S@@@*SDFF*+@@@@[@F@@@@HA
)@@G@@ 0)^@)CTJE[TELDC9CE))AC9A85^[]FC)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@[@@@@HB
)@@G@@ 0)^@)@H@@@@ 0)^@)EDPC(NE-DD9IES)CTJD1#C(MD1DD1B^[OD[DES)ETCD9PD-^^[]C*)HC
)@@G@@C-DEL CTOC(^^[OD8'@[@@@@ 0)^@)@B@@@@ 0)^@)^@)^@)^[HCDME1DD0)E0,^[UC(GDTJHD
)@@G@@E9DE-U@E@@@@ 0)^@)^@)^@)^[^C(KCDME-HC(IE))D9A^[#D9HE[PE- EK)ET#DD D1#C*)HE
)@@G@@@C@@@@ 0)^@)^@)^@)^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC))@E@@@@ 0)^@)^@)^@)HF
)@@G@@^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGCDIC))AK0A84AK)^@)@[@@@@ 0)^@)@M@@@@ 0)^@)HG
)@@G@@^@)^@)^[KC(MD(DETNDDJD0)E-J^[PET ^[OD[ ET ^[GDDNE-DD1BES)CDIC))E-CC*)CTJHH
)@@G@@D(KE(OC(M^[KELJC9MCDHES)E-CC(T@I@@@@ 0)^@)EL E[MC(NC(IE))DDN^[BEL[D1OC(^HI
)@@G@@^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1B^[#D9IC-DE-DD9IES'@[@@@@ 0)^@)@L@@@@ 0)^@)HJ
)@@G@@^@)^@)^@1 0)E(ID-DD(DE- C))E(NC*)D([FC)CL ^[HCD^C*)D9A^[OD[ ^[KELJC9MCDHHK
)@@G@@ES)EL E[MC(NC(IE- C))CLT@M@@@@ 0)^@)E-CC(NC*)D-DETODDIC9N^[KELJE1DC- C))HL
)@@G@@E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JEK)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@J@@@@HM
)@@G@@ 0)^@)E[G 81^[#D9HE[DD- EK)EL D([DDIES)CDNETJCTDCDOC(^^[RDDOD@)E-CC(NC*)HN
)@@G@@E[MD9BEL[D(N 0)^@)@[@@@@ 0)^@)@K@@@@ 0)^@)^@)^@)^@2 0)D(JC-DC1DCT[E-DD9IHO
)@@G@@ES)D([FC)CL ^[HCD^C*)E-J^[OD[ ^[GDDNE-DD1BES)E[MD9QDD^C(^BK)@[@@@@ 0)^@)HP
)@@G@@@M@@@@ 0)^@)^@)^@)^@*CC(^[[D1T^[MC(NE(GE-DD1B^[KELJC9MCDH ))D9M^[MC(KD9MHQ
)@@G@@E)?^[KCDKC(M^[JEK)C-JCTPD( D1OCDODDJD0)^@)@M@@@@ 0)^@)^@)^@)^[^C(NCTMDD]HR
)@@G@@DDIC8)ETPCTC^[KELJC9MCDH^[RDDGD))CTGC([ELGFC)DDIC-DCT[E- ^[OD[[E))E-CC*)HS
)@@G@@E[MD9BEL[D*)@J@@@@ 0)^@)^@)^@)^[DES)CC)C-DCDGC(#E))D9A^[KD-PD*)D9M^[DES)HT
)@@G@@C- ELDE1 C))C1MD9H^[KD-PD*?^[[D1^^@)@[@@@@ 0)^@)@L@@@@ 0)^@)^@)^@)^@*CK(HU
)@@G@@^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DD9IES?^[JE-CC(M^[OD[[D0)E-MDDQDD[D))CTJELMHV
)@@G@@C(#E-DD9IES)@K@@@@ 0)^@)^@)^@)^[JC0)C(MELJELN^[DD0)E-CC*)ETJE(MCT ^[KELJHW
)@@G@@C9MCDHES?^[ND[[D-G^[]C*)EL E[JELOC(^^[[D1^@L@@@@ 0)^@)^@)^@)^[[^[]ELDC(AHX
)@@G@@^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)C1 CDOE(MC*)CD^C- C))ETCCDGD))CL ^[NE(]D(DHY
)@@G@@E-OC(^@F@@@@ 0)^@)^@)^@)^[OD8)E-CC*)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^ ))HZ
)@@G@@CDIC))@[@@@@ 0)^@)@L@@@@ 0)^@)^@)^@)^@*CS(^[ID8)E[MD9BEL[D(N^[^C(MDDQC(^IA
)@@G@@^[AELJD*)E-CC(NC*)D-DETODDIC9N^[ND[[D-G^[]C*)ETJD-^^@)@M@@@@ 0)^@)^@)^@)IB
)@@G@@^[RDDOD[JE(O^[RELDE-OC(I^[[E[KELJE1[D))C1MD9H^[OD[ ^[PD1DE1 ELNDDOFC)D9AIC
)@@G@@^[HCDMFDGCDIC)?^[[D1^^@)@[@@@@ 0)^@)@L@@@@ 0)^@)^@)^@)^@*C)(^[#D9KDD ES)ID
)@@G@@D9A^[OD[ ET ^[KELJC9MCDHES)D([FC)CL ^[OEL[D1ND(DE-OC(^^[OD8)D9OD[ EK)^@)IE
)@@G@@@L@@@@ 0)^@)^@)^@)^[GD9#CDODDJD1N^[KELJE1DC- C))E-CCDO^[NE(#D@)E-MCDIETHIF
)@@G@@DDOE-[D-N^[#D- CDMD-T^[DD1^DD#CDOC*)@L@@@@ 0)^@)^@)^@)^[RD[ E-CC(M^[OD[ IG
)@@G@@^[KELJC9MCDHES)CDMC*)C(SCD#E))CTJE[DC(N^[JC0)E-CC*)E(IDDQC(METDE-T^[JC0)IH
)@@G@@@J@@@@ 0)^@)^@)^@)^[HCDMFDGCDIC))E[GE(H^[#D9HE[DD- EK)D9M^[[EL ^[HD9^DDAII
)@@G@@DD#CDODDJD1N^[OD8)DDO 0)@[@@@@ 0)^@)@L@@@@ 0)^@)^@)^@)^@3 0)E-CC(NC*)CTJIJ
)@@G@@D1^DDODDJD1N^[JD1GFC)CDKE[GFC)E-J^[OD[ ^[KD-PD*)CTJD(KDDGC(M^[DE-NC(GC0?IK
)@@G@@@L@@@@ 0)^@)CDIC))CDMC*)D1JE))D( CDIE))E-J^[[E[KD-T^[OD8)CDIFC)E[MD9BEL[IL
)@@G@@D*)E9MDDOE- D0)E(NDDIC8)E[GE(H 0)^@)@J@@@@ 0)^@)E-CC*)E[PELKD9NC*)D9A^[OIM
)@@G@@D[ ET ^[#D9IC-DE-DD9IES)DDN^[OD8)CDGD-JE8)CDIFC)E(NC(M^[OD8)@L@@@@ 0)^@)IN
)@@G@@C(SE[ ELDD( D1O^[RDDOD@)E-CC*)CTJD(KDDGC(M^[[ES)D-JD1B^[[ES)E-CC*)EL ETPIO
)@@G@@D-ODDIC8)E[MD9^E(#E))^@)@M@@@@ 0)^@)DDN^[ID9O^[ND9GC))CDIC))CDN^[GD9IC8)IP
)@@G@@CDN^[DE))DDN^[FD1JE9I^[OD[[E))E-CC*)E[MD9^E(#E))C- E1 D-JE[ C))^@)@^@@@@IQ
)@@G@@ 0)^@)C1MD9H^[KD-PD*,^@)@[@@@@ 0)^@)@[@@@@ 0)^@)@[@@@@ 0)^@)@[@@@@ 0)^@)IR
)@@G@@@[@@@@ 0)^@)@[@@@@ 8,^@)@ @@@@D(NC8%^@)^@)^[KELJCS)^@%AC) 0)@C@@@@FLH K*IS
)@@G@@D(NC8*AC?AC( C)C(LE*)A)% @= (KCDME)1 C) 0)@C@@@@FLS K*D(NC8*AC?AC( C)^[ IT
)@@G@@EDP^[HETB @1 )2 C) 0)^@)@^@@@@^@)^@)^@)^@)^[ D1^^@,^@)@^@@@@E[OAK%^@)^@)IU
)@@G@@^[KELJCS) 0)@B@@@@C1H^@)^@)^@)^[AD9MD*)A0?AC2 )6 )1AK) 0)^@)@M@@@@DS)^@)IV
)@@G@@^@)^@)^[^D8)^@)^[KE)2 @1 )1 C) ))C1H^@:FLS @2 LF *2 C?FLH @2 LF *2 C?FLSIW
)@@G@@ @2 LF *1 C?FLH @2 LF *1 C) 0)@^@@@@^@)^@)^@)^@)^[ D1^^@,^@)@^@@@@^@)^@)IX
)@@G@@^@)^@)^[[F[M^)) 0)@^@@@@^@)^@)^@)^@)^[^CTGELB^@,@ @@@@D(NC9N^@)^@)^[#ET IY
)@@G@@CTO^@3^@,^@)@ @@@@D(NC85AC%^@)^@)^[GCD]C(G^@,^@)@A@@@@^@)^@)^@)^@)^@:E[[IZ
)@@G@@ELOAK?E[[ELOAC) 0)@^@@@@E[[ELOAC)^@)^[GCD]C(G^@,@ @@@@^@)^@)^@)^@)^[HETBJA
)@@G@@^@)^@0 )4^@,@D@@@@^@$ET\IL2JC-^[AG(-I-5IL>^[,H94^[(H(0H->H(>H14G(=^@$^@,JB
)@@G@@@ @@@@^@)^@)^@)^@)^[!IT$^@)^@1 )2^@)@ @@@@^@)^@)^@)^@)^[!IT$^@)^@2 )2^@)JC
)@@G@@@ @@@@^@)^@)^@)^@)^[!IT$^@)^@3 )2^@)@ @@@@^@)^@)^@)^@)^[!IT$^@)^@5 )2^@)JD
)@@G@@@ @@@@^@)^@)^@)^@)^[!IT$^@)^@6 )2^@)@ @@@@^@)^@)^@)^@)^[!IT$^@)^@7 )2^@)JE
)@@G@@@ @@@@^@)^@)^@)^@)^[!IT$^@)^@8 )2^@)@ @@@@^@)^@)^@)^@)^[!IT$^@)^@9 )2^@)JF
)@@G@@@^@@@@^@$D1\I))GD3IT(G9,G(=^@$@ @@@@^@)^@)^@)^@)^[HETB^@)^@4 )2^@,@ @@@@JG
)@@G@@^@$D(-J[(H(5H*)H95I-0I(4^@$^@,@ @@@@^@)^@)^@)^@)^[!IT$^@)^@1A@?A*)@F@@@@JH
)@@G@@^@$C1(H->^[\I1>IL&H-\I8,^[[GL3H9?I(4G*)G(?G(!G(,I))HD$H1\IL>G))^8)@ @@@@JI
)@@G@@^@)^@)^@)^@)^[!IT$^@)^@1AC?A0)@F@@@@^@$C1(H->^[>IL2H92 0)CD+IT\H-5I->^[>JJ
)@@G@@H->H(>H14^[,H94^[2G(-G))^8)^@)@ @@@@^@)^@)^@)^@)^[!IT$^@)^@1AK?A*)@C@@@@JK
)@@G@@^@$CD+IT\H-5I->^[>H->H(>H14^[,H94^[(H0)G1(H->^@$@ @@@@^@)^@)^@)^@)^[!IT$JL
)@@G@@^@)^@1AS?B@)@K@@@@^@$E[2H9$IL-H*)GT\H(0HD?G(=^[7HD4H@)G-(G1&G(2G(,I))I1>JM
)@@G@@IL3HD\H0)H9&^[KD-PD*,^[MG(<H9!I[(H->^@$^@)@^@@@@E[[ELOAK)^@)^[GCD]C(G^@,JN
)@@G@@@ @@@@^@)^@)^@)^@)^[KE)2^@)A8) 0)^@)@^@@@@^@)^@)^@)^@)^[ D1^^@,^@)___A@)JO
)@@G@@I(3G(=^@$^@,@G@@[@^@)^@)^@)^@)^[HETB^@)^@9A0?A0) 0)^@)^@)^@)^@)E9[D-FCL[JP
)@@G@@CTF^[#D9HD([D1^^@,@C@@[@*[S@@@*SDFF*@C@@@A.   COPYRIGHT 1975 BY UNIVERSIJQ
)@@G@@TY OF MARYLAND    @[@@@A.     @D@@@A.   QUESTIONS CONCERNING THIS SHOULDJR
)@@G@@ BE DIRECTED TO:  @[@@@A.     @ @@@A.        MARVIN V. ZELKOWITZ  @B@@@AJS
)@@G@@.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@A.        UNIVERSITY OF MJT
)@@G@@ARYLAND     @B@@@A.        COLLEGE PARK, MARYLAND 20742     @[@@@A.     JU
)@@G@@@G@@@A.        PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMJV
)@@G@@S THEY@E@@@A.   REPRESENT IS GRANTED UNDER THE FOLLOWING CONDITIONS:    JW
)@@G@@@[@@@A.     @G@@@A.        1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS JX
)@@G@@REPRESENTED BY    @G@@@A.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OJY
)@@G@@R UNIVERSITY OF MARYLAND@E@@@A.   PL/1 COMPILER REMAINS ASSOCIATED WITH JZ
)@@G@@THESE PROGRAMS.   @[@@@A.     @F@@@A.        2. MODIFICATIONS MAY BE MADKA
)@@G@@E TO THE LISTINGS PROVIDED:   @[@@@A.     @G@@@A.        (A) ANY RESULTIKB
)@@G@@NG PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   @G@@@A.        DESCRIBINKC
)@@G@@G SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM @E@@@A.        IS KD
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  @[@@@A.     @G@@@A.     KE
)@@G@@   (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@AKF
)@@G@@.        OF ERRORS IN THE SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@AKG
)@@G@@.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTED    KH
)@@G@@@C@@@A.        TO THE UNIVERSITY OF MARYLAND, AND     @[@@@A.     @F@@@AKI
)@@G@@.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@AKJ
)@@G@@.        WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  KK
)@@G@@@[@@@A.     @F@@@A.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTKL
)@@G@@ED TO OTHER @G@@@A.        LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEKM
)@@G@@ARLY INDICATE     @G@@@A.        WHETHER THE PROGRAMS ARE EXACT COPIES OKN
)@@G@@F THE UNIVERSITY OF     @E@@@A.        MARYLAND PLUM COMPILER OR ARE MODKO
)@@G@@IFICATIONS TO IT. @[@@@A.     @G@@@A.        3. THESE CONDITIONS ONLY APKP
)@@G@@PLY TO THE PLUM COMPILER ITSELF,    @F@@@A.   AND ARE NOT MEANT TO APPLYKQ
)@@G@@ TO ANY PROGRAM WRITTEN USING PLUM. @E@@@A.   THE PURPOSE OF THESE CONDIKR
)@@G@@TIONS IS TO ALLOW ANY USER TO @F@@@A.   EXPERIMENT WITH THE COMPILER AS KS
)@@G@@LONG AS THE RESULTING PRODUCT @G@@@A.   IS NOT SOLD AND AS LONG AS IT ISKT
)@@G@@ KNOWN THAT THE PRODUCT DEVELOPED   @#@@@A.   FROM PLUM.    @[@@@A.     KU
)@@G@@@[@@@A.     @[@@@A.     @[@@@A.     @[@@@A.     @[@@@A/.    @#@@@A      KV
)@@G@@   AXR$ .   @#@@@A         DCLRG .  @#@@@A         UNLIST . @#@@@A@ADD,PKW
)@@G@@ PLTVDS .   @#@@@A         LIST .   @#@@@A@ADD,P PLATTR .   @E@@@AXXXXXXKX
)@@G@@   CSECT   3 .               SET THE LOCATION COUNTER @^@@@ATABLE    EQUKY
)@@G@@     9 .    @C@@@ATABPTR   EQU     +(IN 9,H1,0,0) .  BCD POINTER  @E@@@AKZ
)@@G@@TBOFST   EQU     +(IN 9,XH2,0,0) . OFFSET FROM ORIGINAL MAP @I@@@ANODE  LA
)@@G@@   EQU     9 .               NODES FOR CONSTRUCTION OF TREE IN EXPRESSIOLB
)@@G@@NS    @C@@@AFLINK    EQU     +(IN 9,H1,0,0) .  FATHER LINK  @D@@@ADATA  LC
)@@G@@   EQU     +(IN 9,H2,0,0)    . POINTER TO DATA  @F@@@ALLINK    EQU     +LD
)@@G@@(IN 9,H1,0,1) .  POINTER TO LEFT SON IN TREE    @F@@@ARLINK    EQU     +LE
)@@G@@(IN 9,H2,0,1) .  POINTER TO RIGTH SON IN TREE   @#@@@A         PLWORD . LF
)@@G@@@#@@@A         PLAC .   @#@@@A         PLSD .   @F@@@A/.       THE PROCSLG
)@@G@@ NEEDED TO SET UP TABLES AND CALL SUBROUTINES   @[@@@A.     @[@@@A.     LH
)@@G@@@C@@@ATBFORM   FORM    18,9,9 .          FORM OF TABLE@#@@@ASTART*  PROCLI
)@@G@@     .@F@@@AG$SPCE*(1) EQU   5 .               INITALIZE WITH 5 WORDS ATLJ
)@@G@@ TOP  @G@@@AFUDGE*   EQU     0 .               # OF WORDS TO GO AFTER EALK
)@@G@@CH GROUP    @F@@@AG$SUM*(1) EQU    0 .               SUM OF RHS OF TABLELL
)@@G@@ STARTS AT O@#@@@A         END .    @@@@@A@^@@@ATABSET*  PROC   *1 .    LM
)@@G@@@F@@@A         ON      TABSET(1)=2 .     IS THIS A VALID FIRST CHAR?    LN
)@@G@@@G@@@A         +(TBFORM G$SPCE(1),TABSET(1,1),G$SUM(1)) . SET OUT THE COLO
)@@G@@NSTANT@E@@@AG$SPCE*(1) EQU   G$SPCE(1)+((TABSET(1,1)*TOTAL)/16)+FUDGE . LP
)@@G@@@E@@@AG$SUM*(1)        EQU               G$SUM(1)+TABSET(1,2) .   @^@@@ALQ
)@@G@@         DO 1 , END .   @#@@@A         OFF .    @A@@@A         +(TBFORM LR
)@@G@@0,0,G$SUM(1)) .   @E@@@AG$SUM*(1)        EQU               G$SUM(1)+TABSLS
)@@G@@ET(1,1) .   @#@@@A         END .    @@@@@A@#@@@ASTOP*    PROC  .  @ @@@ALT
)@@G@@         DO TOTAL>0 , END .   @ @@@ATOTAL*   EQU     G$SUM(1)+1 . @#@@@ALU
)@@G@@         END .    @@@@@A@D@@@AALTC*    PROC    *1,1 .            GENERATLV
)@@G@@E AN EX INST@C@@@A         EX      0,*X10 .          GET NEXT CHAR@#@@@ALW
)@@G@@         END .    @@@@@A@E@@@AINIT*    PROC    *1,3 .            SET POILX
)@@G@@NTERS INTO LINE   @E@@@A         LOAD    X3,FORZER .       SET CHARS IN LY
)@@G@@WORD TO ZERO@E@@@A         ON      INIT(1,1)='NAME' . SET TO FIELD FOR NLZ
)@@G@@AME   @E@@@A         LOAD    X1,NAMEST .       POINT TO WHERE NAME GOES MA
)@@G@@@E@@@A         LOAD    A13,NAMLEN .      GET SIZE OF THIS FIELD   @^@@@AMB
)@@G@@         DO 1 , END .   @#@@@A         OFF .    @G@@@A         ON      IMC
)@@G@@NIT(1,1)='DECLARE' . SET POINTERS TO PLACE FOR DCL    @ @@@A         LOAMD
)@@G@@D    X1,NUMST .   @D@@@A         LOAD    A13,NUMLEN .      GET LENGTH OFME
)@@G@@ FIELD@^@@@A         DO 1 , END .   @#@@@A         OFF .    @G@@@A      MF
)@@G@@   ON INIT(1,1)='ATTR' .     SET TO WHERE ATTRIBUTE LIST GOES     @E@@@AMG
)@@G@@         LOAD    X1,ATTBST .       POINT TO FIELD ON LINE   @D@@@A      MH
)@@G@@   LOAD    A13,ATTBLN .      GET FIELD LENGTH   @^@@@A         DO 1 , ENMI
)@@G@@D .   @]@@@A         OFF@#@@@A         END .    @@@@@A@E@@@APRTBCD*  PROMJ
)@@G@@C    *1,3 .            SET TO PRINT VAR NAME    @E@@@A         USING   SMK
)@@G@@DBCD,PRTBCD(1,1) . SET THE LOCAL USING    @D@@@A         LOAD    A1,SDBCML
)@@G@@NT .       GET THE LENGTH     @E@@@A         LOADXM  X4,SDBCPT .       GMM
)@@G@@ET POINTER TO STRING    @E@@@A         LINK    PUTBCD .          INSERT MN
)@@G@@STRING IN LINE    @#@@@A         END .    @@@@@A@E@@@APRTSD*   PROC    *MO
)@@G@@0,1 .            PROC TO PRINT OUT SD NAME@D@@@A         LINK    PUTSD .MP
)@@G@@           GO AND PRINT IT    @#@@@A         END .    @@@@@A@E@@@APRTOPRMQ
)@@G@@*  PROC    *0,3 .            PRINT OUT THE OPERATOR   @D@@@A         LOAMR
)@@G@@D    A1,OPLEN,X8 .     GET THE LENGTH     @G@@@A         LOADXM  X4,W1U,MS
)@@G@@X8 .       GET THE POINTER TO THE STRING .***** @D@@@A         LINK    PMT
)@@G@@UTBCD .          GO PRINT THE SYMBOL@#@@@A         END .    @@@@@A@F@@@AMU
)@@G@@PRTSYM*  PROC    *1,2 .            INSERT THE SYMBOL INTO THE LINE@C@@@AMV
)@@G@@         LOADXM  X4,PRTSYM(1,1),I . GET THE CHAR@C@@@A         LINK    PMW
)@@G@@UTSYM .          GOTO ROUTINE @#@@@A         END .    @@@@@A@D@@@APRTNUMMX
)@@G@@*  PROC    *1,2 .            PUT NUMBER IN LINE @D@@@A         LOAD    AMY
)@@G@@14,PRTNUM(1,1) . GET THE NUMBER     @F@@@A         LINK    PUTNUM .     MZ
)@@G@@     CONVERT TO EXTERNAL & PRINT    @#@@@A         END .    @@@@@A@E@@@ANA
)@@G@@PRTATR*  PROC    *1,3 .            SET TO PRINT AN ATTRIBUTE@E@@@A      NB
)@@G@@   LXM,U   X4,PRTATR(1,1)+1 . GET ADDRESS OF ATTR     @D@@@A         LOANC
)@@G@@D    A1,PRTATR(1,1) .  GET LENGTH IN CHARS@D@@@A         LINK    PUTBCD ND
)@@G@@.          GO PUT INTO LINE   @#@@@A         END .    @@@@@A@E@@@AFIX*  NE
)@@G@@   PROC    *1 .              SET TABLE OF ATTRIBUTES  @D@@@A         +FINF
)@@G@@X(1,1) .               DUMP OUT THE LENGTH@D@@@AK        DO FIX(1)-1 , +NG
)@@G@@FIX(1,K+1) . DUMP OUT CHARS   @#@@@A         END .    @@@@@A@^@@@ASPACE*NH
)@@G@@   PROC    *1,1 . @D@@@A         LINK    SKIP .            GO SKIP A SPANI
)@@G@@CE    @#@@@A         END .    @@@@@A@^@@@ASEPERATE* PROC   *1,1 . @G@@@ANJ
)@@G@@         LINK    SEP .             SET TO SKIP SPACE BETWEEN ATTRIBUTES NK
)@@G@@@#@@@A         END .    @@@@@A@A@@@A/.       NOW VARIOUS CONSTANTS USED NL
)@@G@@@[@@@A.     @E@@@AALLBIT   +0777777777777 .           MASK USED IN COMPANM
)@@G@@RISION@E@@@AFORTHR   -4,-3 .                   USED TO SETUP FOR JILOOP NN
)@@G@@@B@@@AFORFOR   -4,-4 .                   ''     @E@@@AFORZER   -4,0 .   NO
)@@G@@                 USED IN PRINT ROUTINES   @E@@@ANAMEST   LABEL .        NP
)@@G@@           LOCATION OF VARIABLE NAME@B@@@AFILL(1)  SAC     +1,BUFFER-(INNQ
)@@G@@ 63,0,1,0) .@E@@@ANAMLEN   36 .                      LENGTH OF NAME FIELNR
)@@G@@D     @F@@@ANUMST    LABEL .                   START STMT DECL'ED AT IN NS
)@@G@@COL 37@C@@@AFILL(1)  SAC     +1,BUFFER-(IN 63,0,1,0)+9 .    @F@@@ANUMLENNT
)@@G@@   +12 .                     12 COLS FOR STMT NUM DECL'ED IN@E@@@AATTBSTNU
)@@G@@   LABEL .                   START ATTR LIST AT COL 49@C@@@AFILL(1)  SACNV
)@@G@@     +1,BUFFER-(IN 63,0,1,0)+12 .   @D@@@AATTBLN   +84 .                NW
)@@G@@     SAY 84 COLS IN LIST@A@@@ABLANK    +1,KBLANK-(IN 63,0,1,0) .  @F@@@ANX
)@@G@@OUTSFT   +36 .                     USED TO SHIFT OUT EXTRA JUNK   @C@@@ANY
)@@G@@         +27 .                     ONE CHAR LEFT@D@@@A         +18 .    NZ
)@@G@@                 TWO CHARS LEFT     @D@@@A         +9 .                 OA
)@@G@@     THREE CHARS LEFT   @D@@@A         +0 .                      FOR CHAOB
)@@G@@RS LEFT     @[@@@A.     @B@@@A.        LOAD TABLE USED BY ALTC COMMAND  OC
)@@G@@@[@@@A.     @E@@@AALTCDA   +1,ALTC1 .                POINT TO TOP OF LOOOD
)@@G@@P     @F@@@A         LOADXM  A3,W1H2,*A2 .     GET LAST HALFWORD ON THISOE
)@@G@@ CYCLE@F@@@A         LMJ     X10,0,X10 .       RESET TO POINT TO TOP OF OF
)@@G@@TABLE @#@@@AALTC1    LABEL .  @D@@@A         LOADXM  A3,W1H1,A2 .      GOG
)@@G@@ET FIRST HALFWROD @D@@@A         LOADXM  A3,W1H2,*A2 .     GET NEXT HALFOH
)@@G@@ WORD @D@@@A         LOADXM  A3,W1H1,A2 .      GET FIRST HALFWROD @D@@@AOI
)@@G@@         LOADXM  A3,W1H2,*A2 .     GET NEXT HALF WORD @D@@@A         LOAOJ
)@@G@@DXM  A3,W1H1,A2 .      GET FIRST HALFWROD @D@@@A         LOADXM  A3,W1H2OK
)@@G@@,*A2 .     GET NEXT HALF WORD @D@@@A         LOADXM  A3,W1H1,A2 .      GOL
)@@G@@ET FIRST HALFWROD @D@@@A         LOADXM  A3,W1H2,*A2 .     GET NEXT HALFOM
)@@G@@ WORD @ @@@A         LOADXM  A3,W1H1,A2 . @D@@@A         LMJ     X10,ALTON
)@@G@@CDA+1 .    GOTO TOP OF LOOP   @B@@@A/.       THE TABLE OF ATTRIBUTES NEEOO
)@@G@@DED   @[@@@A.     @[@@@A.     @F@@@ASTARS    FIX     4,'****' .        UOP
)@@G@@SED IF VAR WASNT DECLARED     @F@@@ASTAR     FIX     1,'*   ' .        UOQ
)@@G@@SED IF STRING LENGTH NOT GIVEN@E@@@AINSTR    FIX     10,'MEMB','ER O','FOR
)@@G@@   ' . STRUCTURE LEAD   @B@@@AAUTO     FIX     9,'AUTO','MATI','C   ' . OS
)@@G@@@A@@@ASTAT     FIX     6,'STAT','IC  ' .  @B@@@ACONTR    FIX     10,'CONOT
)@@G@@T','ROLL','ED  ' .@A@@@ABASED    FIX     5,'BASE','D   ' .  @A@@@APOINT OU
)@@G@@   FIX     7,'POIN','TER ' .  @A@@@AOFFSET   FIX     6,'OFFS','ET  ' .  OV
)@@G@@@ @@@AAREA     FIX     4,'AREA' .   @D@@@AFILE     FIX     13,'FILE',' EOW
)@@G@@XT','ERNA','L   '  .    @A@@@AINPUTF   FIX     5,'INPU','T   ' .  @A@@@AOX
)@@G@@OUTPUT   FIX     6,'OUTP','UT  ' .  @A@@@APRINTF   FIX     5,'PRIN','T  OY
)@@G@@ ' .  @A@@@AKEYED    FIX     5,'KEYE','D   ' .  @A@@@ARECORD   FIX     6OZ
)@@G@@,'RECO','RD  ' .  @A@@@ASTREAM   FIX     6,'STRE','AM   ' . @A@@@AFORMATPA
)@@G@@   FIX     7,'FORM','AT  ' .  @B@@@ASTMT     FIX     10,'STAT','EMEN','TPB
)@@G@@   ' .@A@@@ALABE     FIX     5,'LABE','L   '    @B@@@ASTRUC    FIX     9PC
)@@G@@,'STRU','CTUR','E   ' . @B@@@APROC     FIX     9,'PROC','EDUR','E   ' . PD
)@@G@@@A@@@AENTR     FIX     5,'ENTR','Y   ' .  @A@@@AFLOAT    FIX     5,'FLOAPE
)@@G@@','T   ' .  @A@@@AFIXE     FIX     5,'FIXE','D   ' .  @A@@@ABIN      FIXPF
)@@G@@     6,'BINA','RY  ' .  @A@@@ADECI     FIX     7,'DECI','MAL ' .  @ @@@APG
)@@G@@REAL     FIX     4,'REAL' .   @A@@@ACOMPL    FIX     7,'COMP','LEX ' .  PH
)@@G@@@B@@@ACHAR     FIX     9,'CHAR','ACTE','R   ' . @ @@@ABITS     FIX     3PI
)@@G@@,'BIT ' .   @A@@@AVARY     FIX     7,'VARY','ING ' .  @B@@@ANONVAR   FIXPJ
)@@G@@     10,'NONV','ARYI','NG  ' .@E@@@ABUILT    FIX     17,'BUIL','T-IN',' PK
)@@G@@FUN','CTIO','N   ' .    @D@@@APSEUD    FIX     15,'PSEU','DO V','ARIA','PL
)@@G@@BLE ' .     @B@@@APARM     FIX     9,'PARA','METE','R   ' . @A@@@AINITIAPM
)@@G@@   FIX     7,'INIT','IAL ' .  @A@E@AARRAY    FIX     5,'ARRA','Y   ' .  PN
)@@G@@@B@@@EARRAY    FIX     9,'DIME','NSIO','N   ' . @G@@@AMSG      '**** WARPO
)@@G@@NING - THIS IDENTIFIER IS NOT EXPLICITLY USED ****' . @F@@@AMSGSIZ   EQUPP
)@@G@@     $-MSG .           THE SIZE OF THE ABOVE MESSAGE  @F@@@AHEADNG   'VAPQ
)@@G@@RIABLE NAME                       DCL''ED IN   ' .    @C@@@A         'ATPR
)@@G@@TRIBUTES AND CROSS REFERENCE' .     @E@@@AHEADSZ   EQU     $-HEADNG .   PS
)@@G@@     SIZE OF COLUMN HEADINGS  @F@@@AUNDER    '-------- ----             PT
)@@G@@          ------ --   ' .     @C@@@A         '---------- --- ----- -----PU
)@@G@@----' .     @E@@@AUNDSIZ   EQU     $-UNDER .         SIZE OF UNDER LININPV
)@@G@@G     @G@@@ATOPPER   '         PLUM        ATTRIBUTES AND CROSS REFERENCPW
)@@G@@E LISTING' .@A@@@A         DO 33-($-TOPPER) , '    ' .@E@@@A/.       TABPX
)@@G@@LE TO PRODUCE THE MAPPING ON THE FIRST TWO CHARS@A@@@A.        IN THE SOPY
)@@G@@RTING ROUTINE     @[@@@A.     @C@@@A         START . SET THE VARIABLES TPZ
)@@G@@O BE USED   @E@@@AMAPCH1   EQU     +(IN 0,H1,0,$-' ') . MAP FOR THE FIRSQA
)@@G@@T CHAR@F@@@AMAPCH2   EQU     +(IN 0,Q4,0,$-' ') . MAP FOR THE SECOND CHAQB
)@@G@@R     @E@@@AFACCH1   EQU     +(IN 0,Q3,0,$-' ') . ADJUSTMENT FACTOR     QC
)@@G@@@E@@@A         DO 4 , TABSET 0 .         MAP IN FOR ' ' THRU '$'  @E@@@AQD
)@@G@@         TABSET  2,0 .             ALLOW A MAP SPACE FOR $  @E@@@A      QE
)@@G@@   DO 060-045 , TABSET 0 .   ACCOUNT FOR $ THRU 0     @G@@@A         TABQF
)@@G@@SET 1 .                ALLOW A SPACE FOR THE DIGITS 0-9     @ @@@A      QG
)@@G@@   DO 9 , TABSET 0 .    @E@@@A         DO 7 , TABSET 0 .         :;<=>?@QH
)@@G@@ DON'T GET MAPS   @D@@@A         TABSET  28,2 .            A IS GOOD CHAQI
)@@G@@R     @E@@@A         DO 3 , TABSET 14,1 .      B,C,D ARE EQUAL PROB.    QJ
)@@G@@@E@@@A         TABSET  16,2 .            E IS GOOD SECOND CHAR    @E@@@AQK
)@@G@@         DO 3 , TABSET 14,1 .      F,G,H ALL EQUAL PROB     @D@@@A      QL
)@@G@@   TABSET  28,2 .            I IS GOOD LETTER   @D@@@A         TABSET  1QM
)@@G@@0,1 .            J IS LESS FREQ     @E@@@A         DO 2 , TABSET 20,1 . QN
)@@G@@     K-L FAIR FIRST LETTERS   @E@@@A         DO 2 , TABSET 21,1 .      MQO
)@@G@@,N GOOD FIRST LETTERS   @E@@@A         TABSET  16,2 .            O IS GOQP
)@@G@@OD SECOND LETTER  @E@@@A         TABSET  24,1 .            P IS GOOD FIRQQ
)@@G@@ST LETTER   @D@@@A         TABSET  2,1 .             Q IS A LOUSY LETTERQR
)@@G@@@H@@@A         DO 3 , TABSET 30,2 .      R,S,T EXECELENT FIRST AND SECONQS
)@@G@@D LETTERS   @E@@@A         TABSET  16,2 .            U  GOOD SECOND LETTQT
)@@G@@ER    @D@@@A         DO 2 , TABSET 14,1 .      V,W AVG LETTERS    @D@@@AQU
)@@G@@         DO 3 , TABSET 10,1 .      X,Y,Z POOR LETTERS @^@@@A         ON QV
)@@G@@TOTAL > 0 . @ @@@AHELP     EQU     G$SPCE(1) .  @#@@@A         OFF .    QW
)@@G@@@ @@@A         STOP .  END THIS MESS@^@@@AHELP1    EQU     TOTAL .@^@@@AQX
)@@G@@HELP2    EQU     1024 . @[@@@A.     @A@@@A.        SET UP TABLE OF OPERAQY
)@@G@@TORS  @[@@@A.     @F@@@AOPUNRY   EQU     W1S4 .            FLAG THAT OPEQZ
)@@G@@RATOR IS UNIARY   @F@@@AOPPREC   EQU     W1S5 .            PRECEDENCE LERA
)@@G@@VEL FOR OPERATOR  @F@@@AOPLEN    EQU     W1S6 .            LENGTH OF STRRB
)@@G@@ING OF OPERATOR   @E@@@AFFF      FORM    18,6,6,6 .        FORM FOR FILLRC
)@@G@@ING IN TABLE@G@@@AOPTAB    FFF     '! ',0,1,1 .      OR            BIOP RD
)@@G@@     LEVEL 1***** @F@@@A         FFF     '& ',0,2,1 .      AND          RE
)@@G@@ BIOP      LEVEL 2@F@@@A         FFF     '>=',0,3,2 .      GE           RF
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '> ',0,3,1 .      GT           RG
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '^>',0,3,2 .      NG           RH
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '^=',0,3,2 .      NE           RI
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '< ',0,3,1 .      LT           RJ
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '^<',0,3,2 .      NLT          RK
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '<=',0,3,2 .      LE           RL
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '= ',0,3,1 .      EQ           RM
)@@G@@ BIOP      LEVEL 3@F@@@A         FFF     '!!',0,4,2 .      CONCATENATE  RN
)@@G@@ BIOP      LEVEL 4@F@@@A         FFF     '+ ',0,5,1 .      BINARY ADD   RO
)@@G@@ BIOP      LEVEL 5@F@@@A         FFF     '- ',0,5,1 .      BINARY SUB   RP
)@@G@@ BIOP      LEVEL 5@F@@@A         FFF     '* ',0,6,1 .      MULTIPLY     RQ
)@@G@@ BIOP      LEVEL 6@F@@@A         FFF     '/ ',0,6,1 .      DIVIDE       RR
)@@G@@ BIOP      LEVEL 6@F@@@A         FFF     '**',0,7,2 .      EXPONENTIATE RS
)@@G@@ BIOP      LEVEL 7@F@@@A         DO 8 , FFF '><',0,0,2 .   SKIP SPACE FORT
)@@G@@R IF OPERATORS    @F@@@A         FFF     '->',0,8,2 .      POINTER      RU
)@@G@@ BIOP      LEVEL 8@F@@@A         FFF     '^ ',1,7,1 .      NOT          RV
)@@G@@ UNARYOP   LEVEL 7@F@@@A         FFF     '+ ',1,7,1 .      UNIARY PLUS  RW
)@@G@@ UNIARYOP  LEVEL 7@F@@@A         FFF     '- ',1,7,1 .      NEGATE       RX
)@@G@@ UNIARYOP  LEVEL 7@^@@@ADIMCLN   SFW     0 .    @D@@@A         FFF     'RY
)@@G@@1:',0,0,2 .      DEFAULT LOWER BOUND@A@@@A/.       START OF SORT ROUTINERZ
)@@G@@S     @[@@@A.     @[@@@A.     @E@@@APLATTR*  LOCAL .                   ESA
)@@G@@NTRY POINT TO THIS PHASE@E@@@A         LOAD    A15,0,I .         A15=0 TSB
)@@G@@HIS WHOLE PASS    @@@@@A@F@@@A         LOADXI A1,1,I .          THESE RESC
)@@G@@GISTERS MUST BE SETUP   @F@@@A         LOADXI  A2,1,I .               TOSD
)@@G@@ THESE VALUES FOR THE   @F@@@A         LOADXI  X3,-1,I .              DUSE
)@@G@@RATION OF THIS PASS     @ @@@A         LOAD    R2,ALLBIT .  @@@@@A@G@@@ASF
)@@G@@         LOAD    A8,1024,I .       SEE IF MINIMUM TABLE AREA AVALIABLE  SG
)@@G@@@D@@@A         STORE   A8,TABSIZ .       SET CURRENT SIZE   @G@@@A      SH
)@@G@@   ADD     A8,ADPCBE .       START SORT TABLE AFTER END ALPHACODE @F@@@ASI
)@@G@@         STORE   A8,TABEND .       THIS IS WHERE TABLE WILL END   @D@@@ASJ
)@@G@@         SUB     A8,ADPCND .       END OF CORE IS HERE@D@@@A         IF SK
)@@G@@A8,LT,0,I THEN,PLSORT . ->ROOM ENOUGH     @F@@@A         LOAD    A7,0,I SL
)@@G@@.          SET REGISTER FOR HIS ROUTINE   @[@@@A.     @C@@@A.        TO SM
)@@G@@GET MORE CORE A8=# OF WORDS NEEDED  @E@@@A.                        A7=0 SN
)@@G@@      THEN LINK TO ZMCORE     @[@@@A.     @E@@@A         LINK    ZMCORE SO
)@@G@@.          GET ADDITIONAL SPACE     @F@@@APLSORT   LABEL .              SP
)@@G@@     IF THE TABLE IS TO BE STRECHED @F@@@A.                             SQ
)@@G@@          IT SHOULD BE DONE HERE    @F@@@A         LOAD    A12,TABEND . SR
)@@G@@     GET END OF TABLE FOR LATER     @E@@@A         LOAD    A13,TABBEG . SS
)@@G@@     GET BEGINNING FOR LATER  @E@@@A         LOADXM  A1,TABBEG .       PST
)@@G@@OINT TO TABLE START     @E@@@A         LOADA   X11,KKD0 .        POINT TSU
)@@G@@O WORD OF ZEROS   @E@@@A         LOAD    R1,TABSIZ .       GET THE SIZE SV
)@@G@@OF THE TABLE@E@@@A         BT      A1,0,*X11 .       SET THE TABLE TO ZESW
)@@G@@RO    @F@@@A         LOAD    A14,0,I .         SET COUNT OF BCD'S TO ZERSX
)@@G@@O     @E@@@A         LOAD    X6,ADBK0S .       POINT TO BLOCK ZERO SD   SY
)@@G@@@D@@@A         LOAD    X7,X6 .           GET POINTER TO SD  @D@@@A.     SZ
)@@G@@   X6=BLOCK SD               X7=SD TO CHAIN FROM@F@@@ANEXTSD   LABEL .  TA
)@@G@@                 FOLLOW THE NEXTDC CHAIN HERE   @ @@@A         USING   STB
)@@G@@DSECT,X7 .  @D@@@A         IF SDNXDC,ZERO THEN,NEXTBK . END OF CHAIN?   TC
)@@G@@@E@@@A         LOAD    X7,SDNXDC,X7 .    GET THE NEXT SD IN CHAIN @G@@@ATD
)@@G@@         IF SDVRCN,OFF,SDCLS1 THEN,NOTCON . IF CONSTANT CHECK IF LABEL  TE
)@@G@@@G@@@A         IF SD3LCN,OFF,SDCLS3 THEN,NEXTSD . IS THIS A NUMBER CONSTTF
)@@G@@ANT?  @E@@@ANOTCON   LABEL .                   VARIABLE IS NOT A NUMBER TG
)@@G@@@[@@@A.     @D@@@A.        EXTRA CHECKS MUST BE MADE HERE TO PREVENT    TH
)@@G@@@F@@@A.                VARIABLES LIKE $$$ARITH$$$ FROM BEING LISTED     TI
)@@G@@@[@@@A.     @E@@@A         LOAD    X8,SDBCHI .       POINT TO BCD FOR THTJ
)@@G@@IS SD @E@@@A         USING   SDBCD,X8 .        X8 POINTS TO THE BCD     TK
)@@G@@@G@@@A         IF SDSORT,ON,SDBCL4 THEN,NEXTSD . HAS THIS NAME BEEN SORTTL
)@@G@@ED?   @E@@@A         ADD     A14,1,I .         ANOTHER NAME TO SORT     TM
)@@G@@@C@@@A         SET SDSORT,ON,SDBCL4 .    SET FLAG ON  @E@@@A         LOATN
)@@G@@D    A3,SDBCC1 .       GET FIRST CHAR IN NAME   @E@@@A         LOAD    XTO
)@@G@@1,MAPCH1,A3 .    GET MAP FOR FIRST CHAR   @D@@@A         LOAD    A4,FACCTP
)@@G@@H1,A3 .    GET PACKING FACTOR @D@@@A         LOAD    A3,SDBCC2 .       GTQ
)@@G@@ET SECOND CHAR    @E@@@A         MPYS    A4,MAPCH2,A3 .    GET FACTOR TITR
)@@G@@MES OFFSET  @G@@@A         SRB     A4,4 .            DIVIDE BY SIXTEEN FTS
)@@G@@OR TRUE FACTOR    @F@@@A         ADD     X1,A4 .           ADD IN MAP FOTT
)@@G@@R SECOND CHAR     @[@@@A.     @F@@@A.        EXPANDED TABLE SIZE COULD BTU
)@@G@@E ACCOUNTED FOR HERE TOO.     @[@@@A.     @E@@@A         ADD     X1,TABBTV
)@@G@@EG .       POINT TO PLACE IN TABLE .@ @@@A         USING   TABLE,X1 .   TW
)@@G@@@H@@@A         ADD     X1,TBOFST,X1 .    ADD IN MAGIC OFFSET TO GET TO PTX
)@@G@@ROPER PLACE @D@@@A         LOAD    A5,0,I .          CLEAR UP/DOWN FLAG TY
)@@G@@@E@@@A         LOAD    A10,0,I .         CLEAR LAST MOVE FLAG     @E@@@ATZ
)@@G@@SORTRY   LABEL . TRY AGAIN HERE AFTER MOVING FROM COLLISION @D@@@A      UA
)@@G@@   IF TABPTR,NZERO THEN,SORCOL . ->COLLISION    @F@@@A         STORE   XUB
)@@G@@8,TABPTR .       SET SORTED POINTER IN PLACE    @D@@@A         STORE   AUC
)@@G@@10,TBOFST .     WHAT WAS LAST MOVE  @D@@@A         GOTO    NEXTSD .     UD
)@@G@@     GET NEXT SD TO SORT@E@@@ASORCOL   LABEL .                   COLLISIUE
)@@G@@ONS HANDELED HERE @D@@@A.                                  X8=BCDPTR TO UF
)@@G@@INSERT@E@@@A.                                  X1= PLACE TO TEST AGAINSTUG
)@@G@@@[@@@A.     @C@@@A.        SEE ROUTINE EXCOMP IN ELT EXST FOR     @E@@@AUH
)@@G@@.                EXPLANATION OF THIS COMPARISION METHOD     @E@@@A.     UI
)@@G@@           X8=LHS            X9=RHS IN COMPARISION    @[@@@A.     @[@@@AUJ
)@@G@@.     @E@@@A         LOAD    X9,TABPTR .       GET BCD PTR FROM TABLE   UK
)@@G@@@F@@@A         LOAD    A10,1,I .         ASSUME LHS ">" RHS,->MOVE DOWN UL
)@@G@@@D@@@A         LOAD    A3,SDBCNT,X8 .    GET LHS LENGTH     @D@@@A      UM
)@@G@@   LOADXM  A1,SDBCPT,X8 .    POINT TO LHS STRING@D@@@A         LOADXM  AUN
)@@G@@2,SDBCPT,X9 .    POINT TO RHS STRING@ @@@A         USING   SDBCD,X9 .   UO
)@@G@@@D@@@A         IF A3,LE,SDBCNT THEN,SORT01 . IS LHS SHORTER?@E@@@A      UP
)@@G@@   LOAD    A3,SDBCNT .       GET LENGTH OF SHORTER    @D@@@A         LDSUQ
)@@G@@C    A1,36 .           SWITCH POINTERS    @E@@@A         LOAD    A10,-1,UR
)@@G@@I .        SWITCH COMPARISION VALUE @F@@@ASORT01   LABEL .              US
)@@G@@     NOW A3=LEN OF SHORTER NAME     @[@@@A.     @F@@@A.                 UT
)@@G@@                 A1 POINTS TO SHORTER STRING    @G@@@A.                 UU
)@@G@@            AND A10 WILL =1 IF X8 POINTS TO ">" STRING@[@@@A.     @D@@@AUV
)@@G@@         AH      A3,FORFOR .        SETUP FOR JILOOP  @D@@@ASORT02   LABUW
)@@G@@EL . AT LEAST ONE CHARS LEFT TO COMPARE   @E@@@A         LOAD    A7,W1,*UX
)@@G@@A1 .       GET NEXT WORD OF LHS     @D@@@A         LOAD    A8,W1,*A2 .  UY
)@@G@@     NEXT WORD OF RHS   @E@@@A         IF      A7,NE,A8 THEN,SORT03 . NEUZ
)@@G@@,THIS WILL TELL   @C@@@A         JILOOP  A3,SORT02 .       TRY AGAIN    VA
)@@G@@@D@@@A         LOADN   A10,A10 .         LHS=RHS,MOVE UP    @D@@@A      VB
)@@G@@   GOTO    TRYUP .           DONE THIS HALF     @D@@@ASORT03   LABEL .  VC
)@@G@@                 HERE WHEN A7 ^= A8 @D@@@A         LOAD    R1,1,I .     VD
)@@G@@     SET REPEAT COUNT   @D@@@A         MASG    A8,A7 .           IS LHS VE
)@@G@@">" RHS?    @D@@@A         LOADN   A10,A10 .         SET RHS ">" LHS    VF
)@@G@@@[@@@A.     @C@@@A.        NOW A10=1 IF X8'S STRING > X9'S STRING @[@@@AVG
)@@G@@.     @E@@@ATRYUP    LABEL .                   SEE WHICH WAY TO MOVE    VH
)@@G@@@E@@@A         IF A10,GE,0,I THEN,TRYDWN . MOVE DOWN TO TRY NOW?  @D@@@AVI
)@@G@@         SUB     X1,1,I .          MOVE POINTER UP    @E@@@A         IF VJ
)@@G@@A5,GE,1,I THEN,AFTER . X8 GOES AFTER CURRENT    @G@@@A         AU,XH2  AVK
)@@G@@10,0+1,X1 .      ADD IN CORECTION FACTOR         **** @E@@@A         STOVL
)@@G@@RE   A11,TBOFST+1,X1 . SET NEW CORRECTION FACTOR@D@@@A         SUB     AVM
)@@G@@5,1,I .          SET UP FLAG HIGHER @F@@@A         IF A13,LE,X1 THEN,SORVN
)@@G@@TRY ELSE,AFTER . IF ROOM TRY AGAIN  @E@@@ATRYDWN   LABEL .              VO
)@@G@@     LHS WAS ">" THAN RHS     @E@@@A         IF A5,LT,0,I THEN,AFTER . XVP
)@@G@@8 GOES AFTER CURRENT    @G@@@A         AU,XH2  A10,0,X1 .        ADD IN VQ
)@@G@@CORECTION FACTOR         **** @E@@@A         STORE   A11,TBOFST,X1 .   SVR
)@@G@@ET NEW CORRECTION FACTOR@D@@@A         ADD     A5,1,I .          SET DOWVS
)@@G@@N FLAG LOWER@D@@@A         ADD     X1,1,I .          MOVE DOWN IN TABLE VT
)@@G@@@D@@@A         IF A12,GE,X1 THEN,SORTRY . IF ROOM TRY AGAIN @D@@@A      VU
)@@G@@   SUB     X1,1,I .          ELSE PLANT AT END  @B@@@A/.       INSERT X8VV
)@@G@@ AFTER CURRENT LOCATION @D@@@A.                IF AT END OF TABLE,FORCE VW
)@@G@@PROPER MOVE @[@@@A.     @E@@@AAFTER    LABEL .                   X8 GOESVX
)@@G@@ AFTER CURRENT    @E@@@A         LOAD    A8,X1 .           GET CURRENT PVY
)@@G@@OSITION     @F@@@A         SUB     A8,A13 .          SEE HOW FAR TO TOP VZ
)@@G@@OF TABLE    @D@@@A         IF A8,LE,0,I THEN,AFTER1 . NOT ROOM IN TABLE WA
)@@G@@@D@@@A         LOAD    R1,A8 .           SET REPEAT COUNT   @E@@@A      WB
)@@G@@   LOADXM  X3,X1 .           SET TO LOOK BACKWARDS    @E@@@A         SE WC
)@@G@@     A15,0,*X3 .       LOOK FOR ZERO IN TABLE   @F@@@AAFTER1   LABEL .  WD
)@@G@@                 HERE IF NO FIND OR NOT ROOM    @F@@@A         LOAD    RWE
)@@G@@1,-0100000,I .   SAY WENT PAST END OF TABLE     @D@@@A         SUB     AWF
)@@G@@8,R1 .           GET DIST TO ZERO   @G@@@A         SUB     A8,1,I .     WG
)@@G@@     MOVE ONE FEWER THAN DIST TO ZERO     @E@@@A         LOAD    A9,A12 WH
)@@G@@.          NOW LOOK DOWN FOR A ZERO @E@@@A         SUB     A9,W1U+1,X1 .WI
)@@G@@     SEE HOW FAR TO BOTTOM    @C@@@A         IF A9,LE,0,I THEN,AFTER2 . WJ
)@@G@@NO ROOM     @D@@@A         LOAD    R1,A9 .           SET REPEAT COUNT   WK
)@@G@@@F@@@A         LOADXM  A1,X1 .           SET PLACE TO START IN TABLE    WL
)@@G@@@D@@@A         SE      A15,1,*A1 .       LOOK DOWN FOR ZERO @C@@@AAFTER2WM
)@@G@@   LABEL . HERE IN NO ROOM OR NO FIND     @F@@@A         LOAD    R1,-010WN
)@@G@@0000,I .   SAY WENT PAST END OF TABLE     @D@@@A         SUB     A9,R1 .WO
)@@G@@           SEE HOW FAR TO ZERO@H@@@A         SUB     A9,1,I  .         MWP
)@@G@@OVE ONE FEWER THAN COUNT BECAUSE AFTER    @D@@@A         IF A8,GE,A9 THEWQ
)@@G@@N,MOVEDN . WHICH IS CLOSER?   @D@@@A         LOAD    X4,W1U+1,X3 .     GWR
)@@G@@ET ADDR OF ZERO   @F@@@A         LOAD    X5,W1U+2,X3 .     GET ADDR OF FWS
)@@G@@IRST BCD TO MOVE  @E@@@A         LOADXI  X4,1,I .          SET TO MOVE DWT
)@@G@@OWN IN TABLE@B@@@A         LOADXI  X5,1,I .          ''     @F@@@A      WU
)@@G@@   LOAD    A9,-1,I .         GET CORRECTION FOR OFFSETS     @B@@@A      WV
)@@G@@   LOOP    A8,MOVALL .       MERGE  @F@@@AMOVEDN   LABEL .              WW
)@@G@@     SET TO MOVE PART OF TABLE DOWN @C@@@A         LOAD    A8,A9 .      WX
)@@G@@     GET COUNT    @E@@@A         LOAD    X4,W1U,A1 .       GET POSITION WY
)@@G@@OF ZERO     @F@@@A         SUB     A1,1,I .          POINT TO BCD POINTEWZ
)@@G@@R TO MOVE   @E@@@A         LOAD    X5,W1U,A1 .       GET IN PROPER REGISXA
)@@G@@TER   @E@@@A         LOADXI  X4,-1,I .         SET TO MOVE UP IN TABLE  XB
)@@G@@@B@@@A         LOADXI  X5,-1,I .         ''     @E@@@A         LOAD    AXC
)@@G@@9,1,I .          GET CORRECTION FOR OFSETS@ @@@A         LOOP    A8,MOVAXD
)@@G@@LL .  @E@@@AMOVALL   LABEL .                   HERE TO MOVE SDS AROUND  XE
)@@G@@@E@@@A         AU,XH2  A9,0,X4 .         FIX OFSET OF ''CURRENT'' @D@@@AXF
)@@G@@         STORE   A10,TBOFST,X4 .   SET NEW OFFSET     @C@@@A         LOAXG
)@@G@@D    A7,TABPTR,*X5 .   GET POINTER  @D@@@A         STORE   A7,TABPTR,*X4XH
)@@G@@ .   MOVE POINTER AROUND@E@@@A         LOOP    A8,MOVALL .       MOVE ALXI
)@@G@@L THAT ARE NEEDED @A@@@A         STORE   X8,TABPTR,X4 .     @E@@@A      XJ
)@@G@@   GOTO    NEXTSD .          GO GET NEXT SD TO SORT   @F@@@ANEXTBK   LABXK
)@@G@@EL .                   HERE TO MOVE TO NEXT BLOCK     @ @@@A         USIXL
)@@G@@NG   SDSECT,X6 .  @C@@@A         IF SDNXBK,ZERO THEN,PACK . ALL DONE?   XM
)@@G@@@E@@@A         LOAD    X6,SDNXBK .       GET POINTER TO NEXT BLOCK@F@@@AXN
)@@G@@         LOAD    X7,X6 .           WHERE TO GET NEXTDEC CHAIN FROM@ @@@AXO
)@@G@@         GOTO    NEXTSD .     @[@@@A/.    @G@@@APACK     LABEL .        XP
)@@G@@           HERE WHEN FINISHED SORT,BEFORE SCAN  @[@@@A.     @E@@@A      XQ
)@@G@@   MOVE    STORAGE,0,I .     SAY ON ORIGIONAL STORAGE @E@@@A         STOXR
)@@G@@RE   A14,VARNUM .      SET COUNT OF BCDS FOUND  @D@@@A         LOADA   AXS
)@@G@@1,PKAREA .       POINT TO PACK AREA @C@@@A         LOADXI  A1,1,I .     XT
)@@G@@     RESET INDEX  @D@@@A         LOAD    A9,0,I .          SET COUNT TO XU
)@@G@@ZERO  @F@@@A         LOADXM  A2,TABBEG .       POINT TO START OF SORT TAXV
)@@G@@BLE   @C@@@A         SUB     A2,1,I .          SET TO SEARCH@D@@@A      XW
)@@G@@   LOAD    R1,TABSIZ .       GET SIZE TO SEARCH @D@@@A         LOAD    RXX
)@@G@@3,STRSIZ,I .     GET STORAGE SIZE   @C@@@ASEARCH   LABEL . TOP OF LOOP TXY
)@@G@@O FIND SORTED BCDS@F@@@A         SNE     A15,1,*A2 .       LOOK FOR NONZXZ
)@@G@@ERO ENTRY IN TABLE@C@@@A         GOTO    SRCHEN .          END OF SEARCHYA
)@@G@@@C@@@A         LOAD    A8,W1,A2 .        GET POINTER  @D@@@A         SLBYB
)@@G@@D    A7,18 .           PACK IN NEW BCD    @D@@@A         ADD     A9,1,I YC
)@@G@@.          ADD ONE TO COUNT   @D@@@A         IF A9,ODD THEN,SEARCH .   CYD
)@@G@@ONTINUE SEARCH    @G@@@A         STORE   A7,W1,*A1 .       SET BCD PRTS YE
)@@G@@FOUND INTO PACKED AREA  @C@@@A         LOOP    R3,SEARCH .       LOOK FOYF
)@@G@@R MORE@E@@@A         LINK    OUTSTR .          FIRST TABLE OUT OF SPACE YG
)@@G@@@E@@@A         GOTO SEARCH .             MORE ROOM HERE .  *****  @B@@@AYH
)@@G@@SRCHEN   LABEL . END OF TABLE REACHED     @D@@@A         IF A9,EVEN THENYI
)@@G@@,SCAN .    NOW SCAN ALPHA CODE@F@@@A         SLB     A7,18 .           PYJ
)@@G@@UT LAST BCD PTR INTO PACK AREA@ @@@A         STORE   A7,W1,*A1 .  @D@@@AYK
)@@G@@         LOOP    R3,SCAN .         OUT OF STORAGE YET?@D@@@A         LINYL
)@@G@@K OUTSTR .             GET NEXT TABLE     @E@@@A         GOTO    SCAN . YM
)@@G@@           START SCAN OF ALPHACODE  @[@@@A/.    @C@@@AOUTSTR   LLOC .  RYN
)@@G@@OUTINE TO FIND MORE STORAGE   @[@@@A.     @F@@@A         IF STORAGE,NZERYO
)@@G@@O THEN,GETMOR . FIRST TIME OUT OF STORAGE?@E@@@A         MOVE    STORAGEYP
)@@G@@,1,I .     SAY STORAGE GOTTEN ONCE  @D@@@A         LOAD    A8,ADPCND .  YQ
)@@G@@     GET END OF CORE    @D@@@A         SUB     A8,ADPCBE .       SEE HOWYR
)@@G@@ MUCH LEFT  @D@@@A         LOAD    R3,A8 .           SET LOOP COUNTER   YS
)@@G@@@E@@@A         LOADXM  A1,ADPCBE .       POINT TO FREE STORAGE    @B@@@AYT
)@@G@@         LJMP .                    RETURN @E@@@AGETMOR   LOCAL .        YU
)@@G@@           MUST GET MORE STORAGE    @C@@@A         LOAD    A4,STORAGE . YV
)@@G@@     GET COUNT    @C@@@A         ADD     A4,1,I .          UP COUNT     YW
)@@G@@@E@@@A         STORE   A4,STORAGE .      SAVE NUMBER OF REQUESTS  @C@@@AYX
)@@G@@.        IF A4,GT,?,I THEN,ERROR***********     @D@@@A         LOAD    AYY
)@@G@@8,512,I .        GET 512 MORE WORDS @E@@@A         LOAD    A7,0,I .     YZ
)@@G@@     SET TO ZERO AS NEEDED    @D@@@A         LINK    ZMCORE .          GZA
)@@G@@ET MORE STORAGE   @C@@@A         LOAD    R3,511,I .        SET COUNTER  ZB
)@@G@@@D@@@A         JMP .                     RETURN TO ROUTINE  @E@@@A/.    ZC
)@@G@@   SCAN IS THE SECOND PART OF THE ATTRIBUTE LISTER    @F@@@A.           ZD
)@@G@@     IT WILL SCAN THE ALPHA CODE AND BUILD A CROSS    @D@@@A.           ZE
)@@G@@     REFERENCE TABLE CHAINED FROM THE SDS @[@@@A.     @F@@@ASCAN     LABZF
)@@G@@EL .                   START OF THE SCANNER OF ACODE  @E@@@A.           ZG
)@@G@@                       A1=START OF FREE STRAGE  @E@@@A.                 ZH
)@@G@@                 R3=AMOUNT OF STORAGE LEFT@F@@@A         LOADXM  A2,ADPCZI
)@@G@@BC .      POINT TO START OF ALPHACODE     @E@@@A         LOAD    X10,ALTZJ
)@@G@@CDA .      POINT TO ALTC ROUTINE    @D@@@ACONTIN   LABEL . SCAN FOR NEXTZK
)@@G@@ RECOGINIZED TOKEN HERE @A@@@A         ALTC .  GET NEXT TOKEN     @C@@@AZL
)@@G@@         SRB     A3,9 .            DROP FLAGS   @F@@@A         IF A3,EQ,ZM
)@@G@@ACSTEX/IC,I THEN,STARTX . IS THIS AN EXPRESSION?@F@@@A         IF A3,NE,ZN
)@@G@@ACSTXI/IC,I THEN,TOKEN1 . THIS ISN'T AN EXPR    @F@@@A         ALTC .   ZO
)@@G@@                 SKIP REPRESENTIVE SD POINTER   @E@@@ASTARTX   LABEL .  ZP
)@@G@@                 SCAN AN EXPRESSION HERE  @D@@@A         ALTC .         ZQ
)@@G@@           GET NEXT TOKEN     @D@@@A         IF A3,EQ,ACENEX,I THEN,CONTZR
)@@G@@IN . END OF EXPR? @F@@@A         IF A3,EQ,ACENEX+1,I THEN,CONTIN . TRY EZS
)@@G@@NDEX WITH FLAG    @E@@@A         IF A3,GE,0200000,I THEN,STARTX . NOT ANZT
)@@G@@ SD POINTER @E@@@A         USING   SDSECT,A3 .       A3 MUST BE AN SD POZU
)@@G@@INTER @E@@@A         LOAD    A8,SDXREF .       GET OLD XFER POINTER     ZV
)@@G@@@E@@@A         STORE   A1,SDXREF .       SAVE POINTER TO NEW XFER @D@@@AZW
)@@G@@         STORE   R11,W1H1,A1 .     SET STMT # IN XREF @C@@@A         STOZX
)@@G@@RE   A8,W1H2,*A1 .     CHAIN REFS   @D@@@A         LOOP    R3,STARTX .  ZY
)@@G@@     LOOK FOR MORE SDS  @D@@@A         LINK    OUTSTR .          GET MORZZ
)@@G@@E STORAGE   @D@@@A         GOTO    STARTX .          NOW HAVE MORE ROOM AA
)@@G@@@D@@@ATOKEN1   LABEL .                   TEST IF STMT START @E@@@A      AB
)@@G@@   IF A3,NE,ACSTMT/IC,I THEN,TOKEN2 . NOT STMT START? @D@@@A         ALTAC
)@@G@@C .                    GET STMT NUMBER    @D@@@A         LOAD    R11,A3 AD
)@@G@@.          GET STMT NUMBER    @D@@@A         GOTO    CONTIN .          LAE
)@@G@@OOK FOR NEXT TOKEN@A@@@ATOKEN2   LABEL . SEE IF LABEL OR END@G@@@A      AF
)@@G@@   IF A3,NE,ACEND/IC,I THEN,TOKEN3 . IT ONE OF THE SPECIAL CASES? @C@@@AAG
)@@G@@.          IF A3,EQ,ACLABC/IC,I THEN,TYPE2 .    @C@@@A.          IF A3,NAH
)@@G@@E,ACLABS/IC,I THEN,TOKEN3 .   @F@@@A. TYPE2    LABEL .                  AI
)@@G@@ NEXT TOKEN IS SD OR ZERO     @D@@@A         ALTC .                    GAJ
)@@G@@ET NEXT TOKEN     @C@@@A         IF A3,EQ,0,I THEN,CONTIN . OH WELL...  AK
)@@G@@@C@@@A         LOAD    A8,SDXREF .       GET LAST REF @C@@@A         STOAL
)@@G@@RE   A1,SDXREF .       SET NEW CHAIN@C@@@A         STORE   A8,W1H2,A1 . AM
)@@G@@     CHAIN NEW REF@D@@@A         STORE   R11,W1H1,*A1 .    SET STMT NUMBAN
)@@G@@ER    @B@@@A         LOOP    R3,CONTIN .       GO ON  @D@@@A         LINAO
)@@G@@K    OUTSTR .          GET MORE STORAGE   @ @@@A         GOTO    CONTIN AP
)@@G@@.     @E@@@ATOKEN3   LABEL .                   SEE IF END ALPHA CODE    AQ
)@@G@@@E@@@A         IF A3,NE,ACEAC/IC,I THEN,CONTIN . NOT END ALPHACODE@[@@@AAR
)@@G@@.     @B@@@A.        SET UP NODES FOR EXPR TO WORK ON @[@@@A.     @F@@@AAS
)@@G@@         LOADXI  A1,2,I .          SAY NODES ARE TWO WORDS LONG   @E@@@AAT
)@@G@@         LOAD    X7,0,I .          SET END OF LIST POINTER  @F@@@A      AU
)@@G@@   SETL    X9,300,I .        SAY TO GET 300 NODES    *******@F@@@AGETONEAV
)@@G@@   LABEL .                   HERE TO GET SECOND WORD OF NODE@F@@@A      AW
)@@G@@   LOOP    R3,GOTTWO .       -> GOT ENOUGH SPACE FOR NODE   @D@@@AOUTTWOAX
)@@G@@   LABEL .                   NOT FULL NODE HERE @E@@@A         LINK    OAY
)@@G@@UTSTR .          TRY TO GET MORE STORAGE  @F@@@A         GOTO    GETTWO AZ
)@@G@@.          NOW TRY FOR TWO FULL WORDS     @E@@@AGOTTWO   LABEL .        BA
)@@G@@           HERE WE HAVE A FULL NODE @E@@@A         STORE   X7,FLINK,A1 .BB
)@@G@@     SET POINTER TO LAST NODE @H@@@A         LOAD    X7,W1U,*A1 .      GBC
)@@G@@ET POINTER TO CURRENT TOP OF FREE LIST    @E@@@A         LOOP    X9,GETTBD
)@@G@@WO .       -> GO GET ANOTHER NODE   @E@@@A         LOAD    X9,0,I .     BE
)@@G@@     SET TOP OF STACK POINTER @G@@@A         GOTO    ATTR .            RBF
)@@G@@EACHED ENDALPHACODE,GO MAKE LISTING @I@@@AGETTWO   LABEL .              BG
)@@G@@     HERE TO LOOK FOR TWO FREE WODS FOR NEXT NODE     @D@@@A         LOOBH
)@@G@@P    R3,GETONE .       -> GOT ONE OF THEM @H@@@A         GOTO    OUTTWO BI
)@@G@@.          HERE WE NEED TO TRY ANOTHER STORAGE POOL   @D@@@A/.       SOMBJ
)@@G@@E ROUTINES NEEDED TO HELP PRINT OUT THINGS@[@@@A.     @[@@@A.     @[@@@ABK
)@@G@@.     @E@@@A.        PUTSD LOOPS UP TO THE FATHER OF THE SD POINTED TO  BL
)@@G@@@H@@@A.                BY X8 AND THEN RETURNS TO THE CURRENT NODE, PRINTBM
)@@G@@ING THE     @C@@@A.                NAMES OF THE SONS ALONG THE WAY@[@@@ABN
)@@G@@.     @F@B@APUTSD    LOCAL .                   ENTRY TO PRINT QUALIFIED BO
)@@G@@NAME  @F@@@BPUTSD    LOCAL .                   ENTRY TO PRINT QUALIFIED BP
)@@G@@NAME  @F@B@A         IF SDVRCN,ON,SDCLS1 THEN,PUTCON . -> IT IS A CONSTABQ
)@@G@@NT    @ @@@A         USING   SDSECT,X8 .  @F@@@B         IF SDVRCN,ON,SDBR
)@@G@@CLS1 THEN,PUTCON . -> IT IS A CONSTANT    @F@@@A         MOVE    SDKID,0BS
)@@G@@,I .       SET THIS TO BE END OF SON CHAIN@B@@@APUTSD1   LABEL . HERE TOBT
)@@G@@ RISE TO FATHER   @D@@@A         LOAD    A1,X8 .           GET POSSIBLE BU
)@@G@@KID   @F@@@A         IF SDMEMS,OFF,SDCLS2 THEN,PUTSD2 .      IS THIS A SBV
)@@G@@ON?   @D@@@A         LOAD    X8,SDDAD .        MOVE UP TO FATHER  @E@@@ABW
)@@G@@         STORE   A1,SDKID .        AND SET POINTER TO KID   @E@@@A      BX
)@@G@@   GOTO    PUTSD1 .          TRY FOR FATHER'S FATHERS @E@@@APUTSD2   LABBY
)@@G@@EL .                   X8 = OUTER FATHER'S SD   @F@@@A         LOAD    ABZ
)@@G@@3,SDBCHI .       POINT TO THE BCD FOR THE NAME  @F@@@A         PRTBCD  ACA
)@@G@@3 .              PUT OUT THE BCD FOR THIS FATHER@E@@@A         IF SDKID,CB
)@@G@@ZERO THEN,JMP .  ARE WE AT ORIGIONAL SD?  @E@@@A         PRTSYM  '.' .  CC
)@@G@@           INSERT NAME SEPERATOR    @E@@@A         LOAD    X8,SDKID .   CD
)@@G@@     MOVE BACK DOWN TO SON    @E@@@A         GOTO    PUTSD2 .          PCE
)@@G@@RINT OUT SON'S NAME NOW @[@@@A.     @B@@@A.        PUT OUT THE NAME OF ACF
)@@G@@ CONSTANT   @[@@@A.     @#@@@APUTCON   LABEL .  @E@B@A         IF SDARSTCG
)@@G@@,ON,SDCLS1 THEN,PUTCOS . -> IT IS A STRING@F@@@B         IF SDARST,OFF,SCH
)@@G@@DCLS1 THEN,PUTCOA . -> IT IS NOT A STRING @E@@@B         PRTSYM  '''' . CI
)@@G@@           PUT OUT LEADING QUOTE    @D@@@B         LOAD    A3,SDBCHI .  CJ
)@@G@@     GET BCD POINTER    @D@@@B         PRTBCD  A3 .              DUMP OUCK
)@@G@@T STRING    @H@@@B         JMP .                     RETURN TO CALLER OFCL
)@@G@@ NAME PUTTER OUTTER     @G@@@BPUTCOA   LABEL .                   HERE TOCM
)@@G@@ PUT OUT A CONSTANT NUMBER    @D@@@A         LOAD    A3,SDBCHI .       GCN
)@@G@@ET BCD POINTER    @F@@@A         LOAD    A4,SDBBCD,A3 .    GET FIRST WORCO
)@@G@@D OF THE STRING   @E@@@A         LOAD    A6,4,I .          ASSUME NO LEACP
)@@G@@DING BLANKS @G@@@AARITHL   LABEL .                   TOP OF 'LOOK FOR LECQ
)@@G@@ADING BLANKS' LOOP@D@@@A         LOAD    A3,0,I .          GET CLEAR FORCR
)@@G@@ SHIFT@C@@@A         SLBD    A3,9 .            GET NEXT CHAR@D@@@A      CS
)@@G@@   IF A3,NE,' ',I THEN,ARITH2 . -> NOT BLANK    @E@@@A         LOOP    ACT
)@@G@@6,ARITHL .       -> RAISE SHIFT OUT COUNT @E@B@APUTCOS   LABEL .        CU
)@@G@@           HERE FOR STRING CONSTANT @E@B@A         PRTSYM  '''' .       CV
)@@G@@     INSERT LEADING QUOTE     @E@B@A         LOAD    A6,4,I .          SCW
)@@G@@ET TO SHIFT OUT NOTHING @F@@@AARITH2   LABEL .                   HERE FOCX
)@@G@@R TO MERGE WITH STRING  @D@@@A         LOAD    A3,SDBCHI .       GET BCDCY
)@@G@@ POINTER    @D@@@A         LOAD    A1,SDBCNT,A3 .    GET CHAR COUNT     CZ
)@@G@@@E@@@A         LOADXM  X4,SDBCPT,A3 .    GET POINTER TO STRING    @D@@@ADA
)@@G@@         LOAD    A3,A6 .           GET SHIFT OUT COUNT@E@@@B         ADDDB
)@@G@@     A1,A6 .           ADD CHARS LEFT IN WORD   @F@@@B         SUB     ADC
)@@G@@1,4,I .          REMOVE COUNT OF FIRST WORD     @E@@@B         IF A6,NE,DD
)@@G@@4,I THEN,ARITHM . -> NO TRAILING BLANKS   @E@@@B         SUB     A1,4,I DE
)@@G@@.          DROP BLANKS AT THE  END  @F@@@BARITHM   LABEL .              DF
)@@G@@     HERE TO FINISH ARITH CONSTANT  @E@@@B         UNSTK   X11 .        DG
)@@G@@     POP OFF RETURN ADDRESS   @E@@@A         GOTO    PUTBC5 .          -DH
)@@G@@> MERGE WITH PRTBCD     @[@@@A.     @E@@@A.        PUTBCD EXPECTS X4 TO DI
)@@G@@POINT TO THE STRING, AND A1 TO@D@@@A.                CONTAIN THE LENGTH DJ
)@@G@@OF THE STRING     @[@@@A.     @D@@@APUTBCD   LLOC .                    XDK
)@@G@@4 POINTS TO STRING@D@@@A.                                  A1=LENGTH OF DL
)@@G@@STRING@F@@@A         LOAD    A3,4,I .          SET SHIFT OUT COUNT TO ZEDM
)@@G@@RO    @B@@@APUTBC5   LABEL . COME HERE FROM CONSTANTS @D@@@A         LOADN
)@@G@@D    A6,A1 .           SAVE FOR LATER     @D@@@A         AH      A1,FORFDO
)@@G@@OR .       SET FOR JILOOP     @D@@@A         SUB     A13,A6 .          SDP
)@@G@@EE IF ROOM LEFT   @E@@@A         IF A13,GE,3,I THEN,PUTBC1 . LEAVE A 3 CDQ
)@@G@@HAR MARGIN  @D@@@APUTBC4   LABEL .                   OUT OF SPACE HERE  DR
)@@G@@@D@@@A         LOCAL .                   SAVE RETURN ADDRESS@E@@@A      DS
)@@G@@   LINK    OUTLIN .          OUT OF SPACE IN LINE     @E@@@A         UNSDT
)@@G@@TK   X11 .             GET BACK RETURN ADDRESS  @E@@@A         INIT    'DU
)@@G@@ATTR' .          SET POINTERS TO CONTINUE @C@@@A         SUB     A13,A6 DV
)@@G@@.          SUB LENGTH   @D@@@APUTBC1   LABEL .                   ROOM ENDW
)@@G@@OUGH HERE   @E@@@A         LOAD    A14,W1,X1 .       GET LAST WORD OF LIDX
)@@G@@NE    @E@@@APUTBC3   LABEL .                   LOOP COMES BACK HERE     DY
)@@G@@@E@@@A         LOADD   A15,W1,*X4 .      GET NEXT WORD OF INSERT  @F@@@ADZ
)@@G@@         SLBD    A15,*OUTSFT,A3 .  SET TO JUSTIFY NUMBER CONSTANTS@D@@@AEA
)@@G@@         SRB     A14,*OUTSFT,X3 .  SHIFT OUT JUNK .   @D@@@A         SLBEB
)@@G@@D    A14,*OUTSFT,X3 .  ALIGN NEW STUFF    @D@@@A         STORED  A14,W1,EC
)@@G@@*X1 .      SAVE NEW STUFF     @E@@@A         LOAD    A14,A15 .         GED
)@@G@@ET NEW LEFT OVER STUFF  @E@@@A         JILOOP  A1,PUTBC3 .       GO UNTIEE
)@@G@@L END OF INSERT   @F@@@A         LOAD    A6,W1U+8,A1 .     GET ''EXTRA''EF
)@@G@@ CHARS IN ITEM    @F@@@A         ADD     A6,W1U,X3 .       ADD IN LEFT OEG
)@@G@@VER IN BUFFER     @E@@@A         LOADXM  X3,A6 .           GET CURRENT LEH
)@@G@@EFT OVER    @E@@@A         IF A6,GE,5,I THEN,PUTBC2 . GO OVER WORD BOUNDEI
)@@G@@RY?   @E@@@A         SUB     X1,1,I .          NO,POINT TO CURRENT WORD EJ
)@@G@@@B@@@A         LJMP .                    RETURN @E@@@APUTBC2   LABEL .  EK
)@@G@@                 EXTRA CHARS FILLED A WORD@D@@@A         JILOOP  X3,LJMPEL
)@@G@@ .         SUB FOUR AND RETURN@[@@@A.     @C@@@A.        PUTNUM CONVERTSEM
)@@G@@ A NUMBER TO EXTERNAL   @C@@@A.                AND THEN INSERTS IT IN THEN
)@@G@@E LINE@[@@@A.     @C@@@APUTNUM   LLOC .                    A14=NUMBER   EO
)@@G@@@E@@@A         LOAD    A1,0,I .          SET LENGTH OF NUMBER     @C@@@AEP
)@@G@@PUTNU1   LABEL . LOOP TO HERE FOR NEXT CHAR     @D@@@A         SRBD    AEQ
)@@G@@14,36 .          PREPARE TO DIVIDE  @D@@@A         DIV     A14,10,I .   ER
)@@G@@     FIND REMAINDER     @C@@@A         ADD     A15,'0',I .       ADD IN ES
)@@G@@ZONE  @D@@@A         SRBD    A15,9 .           PUT DIGIT INTO A16 @D@@@AET
)@@G@@         ADD     A1,1,I .          INCREASE CHAR COUNT@D@@@A         IF EU
)@@G@@A14,NE,0,I THEN,PUTNU1 . GO UNTIL ZERO    @E@@@A         LOADXM  X4,A15+EV
)@@G@@1,I .      POINT TO DIGITS STRING   @D@@@A         GOTO    PUTBCD .     EW
)@@G@@     GO PRINT OUT NUMBER@[@@@A.     @D@@@A.        PUTSYM WILL SETUP TO EX
)@@G@@PRINT A SINGLE CHAR     @[@@@A.     @C@@@APUTSYM   LLOC .               EY
)@@G@@     CHAR IS IN X4@C@B@A         LOAD    A1,1,I .          SET LENGTH   EZ
)@@G@@@C@@@B         LOAD    A1,FORTHR .       SET LENGTH   @E@@@A         LOAFA
)@@G@@D    A6,1,I .          SET AS NEEDED IN PUTBCD  @C@B@A         AH      AFB
)@@G@@1,FORFOR .       SET TO JILOOP@C@B@A         STORE   X4,CHARSA .       SFC
)@@G@@AVE CHAR    @C@@@B         STORE   X4,CHARSA .       SAVE CHAR    @E@@@BFD
)@@G@@         LOADXM  X4,CHARSA,I .     POINT TO WHERE CHAR IS   @E@@@B      FE
)@@G@@   LOAD    A3,4,I .          SAY FIRST CHAR IS GOOD   @C@B@A         LOAFF
)@@G@@DXM  X4,CHARSA,I .     POINT TO IT  @D@@@A         LOOP    A13,PUTBC1 . FG
)@@G@@     PRINT CHAR IF ROOM @F@@@A         GOTO    PUTBC4 .          NO MOREFH
)@@G@@ ROOM,DUMP LINE FIRST   @[@@@A.     @C@@@A.        OUTLIN WILL DUMP OUT FI
)@@G@@A LINE AND RETURN @[@@@A.     @F@@@AOUTLIN   LOCAL .                   PFJ
)@@G@@RINT OUT THE CURRENT BUFFER   @F@@@A         LINK    CLOSE .           CFK
)@@G@@LOSE OUT THE CURRENT AREA     @C@@@A         LOADA   X1,BUFFER .       PFL
)@@G@@RINT LINE   @D@B@A         STACK   A6 .              GOPRTL DESTROYS A6 FM
)@@G@@@D@@@B         STORE   A6,SAVA6 .        GOPRTL DESTROYS A6 @B@@@B      FN
)@@G@@   STORE   A3,SAVA3 .        AND A3 @D@@@A         LINK    GOPRTL .     FO
)@@G@@     GO PRINT OUT LINE  @E@B@A         UNSTK   A6 .              GET BACFP
)@@G@@K FROM SAVE AREA  @E@@@B         LOAD    A6,SAVA6 .        GET BACK FROMFQ
)@@G@@ SAVE AREA  @B@@@B         LOAD    A3,SAVA3 .        RELOAD @D@@@A      FR
)@@G@@   JMP .                     RETURN TO CALLER   @[@@@A.     @C@@@A.     FS
)@@G@@   CLOSE WILL PAD THE CURRENT AREA OUT    @[@@@A.     @#@@@ACLOSE    LLOFT
)@@G@@C .   @E@@@A         LOAD    A14,W1,X1 .       GET LAST WORD OF LINE    FU
)@@G@@@D@@@A         LOAD    A15,KBLANK .      GET BLANK PADDING  @F@@@A      FV
)@@G@@   STORE   A15,W1+1,X1 .     BLANK OUT NEXT WORD IN LINE    @C@@@A      FW
)@@G@@   SRB     A14,*OUTSFT,X3 .  DUMP JUNK    @D@@@A         SLBD    A14,*OUFX
)@@G@@TSFT,X3 .  PAD WITH BLANKS    @E@@@A         STORE   A14,W1,X1 .       SFY
)@@G@@ET PADDED WORD IN LINE  @#@@@A         LJMP .   @[@@@A.     @D@@@A.     FZ
)@@G@@   SKIP WILL SET THE POINTERS TO SKIP A SPACE   @[@@@A.     @#@@@ASKIP  GA
)@@G@@   LLOC .   @D@@@A         LOOP    A13,SKIP1 .       IS THERE ROOM?     GB
)@@G@@@E@@@A         LOCAL .                   NO ROOM,GO TO NEXT LINE  @D@@@AGC
)@@G@@         LINK    OUTLIN .         DROP TO NEXT LINE   @D@@@A         INIGD
)@@G@@T    'ATTR' .          SET NEW POINTERS   @B@@@A         JMP .          GE
)@@G@@           RETURN @B@@@ASKIP1    LABEL . ROOM FOR BLANK HERE...   @D@@@AGF
)@@G@@         LOAD    X4,BLANK .        POINT TO BLANKS    @C@@@A         LOAGG
)@@G@@D    A1,FORTHR .       SAY ONE CHAR @E@@@B         LOAD    A3,4,I .     GH
)@@G@@     SAY FIRST CHAR IS GOOD   @F@@@A         GOTO    PUTBC1 .          IGI
)@@G@@NSERT A BLANK IN THE LINE     @[@@@A.     @D@@@A.        THE SEPERATE PRGJ
)@@G@@OC GETS YOU HERE FOR A ', '   @[@@@A.     @D@@@ASEP      LOCAL .        GK
)@@G@@           SAVE RETURN ADDRESS@F@@@A         PRTSYM  ',' .             AGL
)@@G@@ COMMA TO SEPERATE ATTRIBUTES @F@@@A         SPACE .                   AGM
)@@G@@ND THEN A SPACE BETWEEN THEM  @E@@@A         JMP .                     RGN
)@@G@@ETURN NOW TO OUR SPONSOR@ @@@A/.       NOW START THE LISTER @[@@@A.     GO
)@@G@@@[@@@A.     @F@@@AATTR     LABEL .                   LISTS ATTRIBUTES ANGP
)@@G@@D REFERENCES@D@@@A         MOVE    BUFFER,TOPPER,33 . SET FIRST LINE    GQ
)@@G@@@C@@@A         LOADA   X1,BUFFER .       POINT TO IT  @D@@@A         LOAGR
)@@G@@D    X2,4,I .          SAY TO SKIP 3 LINES@D@@@A         LINK    GOPRNT GS
)@@G@@.          GO PRINT OUT LINE  @F@@@A         MOVE    BUFFER,HEADNG,HEADSGT
)@@G@@Z . SET HEADING IN BUFFER     @C@@@A         LOADA   X1,BUFFER .       SGU
)@@G@@ET TO PRINT @D@@@A         LOAD    X2,3,I .          SET TO SKIP 2 LINESGV
)@@G@@@D@@@A         LINK    GOPRNT .          GO SKIP AND PRINT  @F@@@A      GW
)@@G@@   MOVE    BUFFER,UNDER,UNDSIZ . UNDER LINE COLUMN HEADINGS @D@@@A      GX
)@@G@@   LOADA   X1,BUFFER .       POINT TO IT AGAIN  @E@@@A         LINK    GGY
)@@G@@OPRTL .          GO PRINT OUT THIS LINE   @E@@@A         LOADXI  X4,1,I GZ
)@@G@@.          SET AS NEEDED IN ROUTINE @E@@@A         LOAD    X10,ALTCDA . HA
)@@G@@     SET FOR ALTC ROUTINE     @F@@@A         LOAD    A3,STRSIZ*2,I .   GHB
)@@G@@ET POSSIBLE SIZE OF TABLE     @E@@@A         LOAD    R3,VARNUM .       GHC
)@@G@@ET NUMBER OF VARIABLES  @F@@@A         SUB     A3,R3 .            IS PACHD
)@@G@@KED LIST IN ONE PLACE?  @E@@@A         STOREN  A3,VARNUM .       SAVE NUHE
)@@G@@MBER IN OTHER AREA@F@@@A         IF      A3,GT,0,I THEN,ATTR1 . ARE THEYHF
)@@G@@ IN FIRST TABLE?  @E@@@A         LOAD    R3,STRSIZ*2,I .   GET NUMBER INHG
)@@G@@ FIRST TABLE@#@@@AATTR1    LABEL .  @E@@@A         MOVE    STORAGE,0,I .HH
)@@G@@     SAY ON ORIGIONAL STORAGE @E@@@A         LOADA   A2,PKAREA .       PHI
)@@G@@OINT TO WHERE VARS START@B@@@A         LOADXI  A2,1,I .          SET INCHJ
)@@G@@@E@@@AGETBCD   LABEL . COME HERE TO GET NEXT BCD FROM PACKED TABLE@D@@@AHK
)@@G@@         LOOP    R3,GETBC1 .       COUNT OFF VARS DONE@D@@@A         LOAHL
)@@G@@D    R3,VARNUM-FH2+FXH2 . SEE HOWMANY LEFT@E@@@A         MOVE    VARNUM,HM
)@@G@@0,I .      SAY NONE LEFT THIS TIME  @F@@@A         LOADXM  A2,ADPCBE .  HN
)@@G@@     POINT TO OTHER STORAGE AREA    @E@@@A         LOOP    R3,GETBC1 .  HO
)@@G@@     COUNT OFF REST OF VARS   @E@@@A         LOADA   X1,BUFFER .       PHP
)@@G@@OINT TO BLANK BUFFER    @E@@@A         LOAD    X2,3,I .          PRINT THQ
)@@G@@HREE BLANK LINES  @D@@@A         LINK    GOPRNT .          SKIP THOSE LIHR
)@@G@@NES   @E@@@A         GOTO    PLATND .          OUT OF VARS,ALL DONE     HS
)@@G@@@E@@@AGETBC1   LABEL .                   HERE FOR NEXT VARIABLE   @B@@@AHT
)@@G@@         ALTC .  GET NEXT NAME FROM LIST  @D@@@A         STORE   A3,CURBHU
)@@G@@CD .       SAVE BCDPOINTER    @F@@@A         LOAD    X5,A3 .           SHV
)@@G@@ET TO FOLLOW SDBDLK CHAIN     @G@@@ACHAIN    LABEL .                   SHW
)@@G@@EE IF ANY OTHER VARS WITH SAME NAME @ @@@A         USING   SDSECT,X5 .  HX
)@@G@@@F@@@A         IF SDBDLK,ZERO THEN,GETBCD . NO MORE SD'S WITH SAME BCD  HY
)@@G@@@E@@@A         LOAD    X5,SDBDLK .       GET NEXT SD WITH SAME BCD@G@@@AHZ
)@@G@@         LOAD    F,SDCLS3 .        GET INTO F REG FOR E-Z REFERENCE     IA
)@@G@@@E@@@A         IF SDATTR,ON THEN,NOTOK . IS THIS A COMPILER SD?   @E@@@AIB
)@@G@@         IF SD3CLR,ON THEN,OK .    WAS THIS VAR DECLARED?   @#@@@ANOTOK IC
)@@G@@   LABEL .  @D@@@A         IF SDXREF,ZERO THEN,CHAIN . SKIP IF NO REFS  ID
)@@G@@@E@@@AOK       LABEL .                   OK TO PRINT VARIABLE HERE@D@@@AIE
)@@G@@         LOADA   X1,BUFFER .       SET TO SKIP LINE   @C@@@A         LINIF
)@@G@@K    GOPRTL .          GO PRINT LINE@D@@@A         INIT    'NAME' .     IG
)@@G@@     SET TO FILL IN NAME@D@@@A         LOAD    A3,CURBCD .       GET THIIH
)@@G@@S VAR'S NAME@E@@@A         PRTBCD  A3 .              INSERT THIS NAME INII
)@@G@@ LINE @E@@@A         LINK    CLOSE .           CLOSE OUT NAME FIELD     IJ
)@@G@@@F@@@A         INIT    'DECLARE' .       MOVE TO PLACE FOR STMT NUMBER  IK
)@@G@@@D@@@A         IF SD3LCN,ON THEN,NUM .   IS THIS A LABEL?   @E@@@A      IL
)@@G@@   IF SD3CLR,OFF THEN,NONUM . SAY VAR WASN'T DECLARED @E@@@ANUM      LABIM
)@@G@@EL .                   PRINT OUT STMT DECL'ED IN@E@@@A         PRTNUM  SIN
)@@G@@DDCNM .          PRINT THE STMT DECL'ED IN@E@@@A         GOTO    LISTST IO
)@@G@@.          GO PRINT THE ATTRIBUTES  @G@@@ANONUM    LABEL .              IP
)@@G@@     THIS VARIABLE WASN'T DECLARED BY USER@D@@@A         PRTATR  STARS .IQ
)@@G@@           PUT OUT SOME STARS @C@@@A/.       NOW LIST OUT THIS VARIABLESIR
)@@G@@ ATTRIBUTES @[@@@A.     @[@@@A.     @D@@@ALISTST   LABEL .              IS
)@@G@@     START OF ATTR LIST @E@@@A         LINK    CLOSE .           CLOSE OIT
)@@G@@UT NUMBER FIELD   @G@@@A         INIT    'ATTR' .          SET TO START IU
)@@G@@AT PLACE FOR ATTRIBUTES @D@@@A         LOAD    F,SDCLS2 .        GET CLAIV
)@@G@@SS 2 BITS   @F@@@A         IF SDMEMS,OFF THEN,NOTSTR . IS IT MEMBER OF SIW
)@@G@@TRUCTURE    @C@@@A         PRTATR  INSTR .           SAY '(IN '   @E@@@AIX
)@@G@@         MOVE    SDKID,0,I .       SET CHAIN END TO ZERO    @G@@@ALISTS1IY
)@@G@@   LABEL .                   FOLLOW FATERS TO TOP OF STRUCTURE    @D@@@AIZ
)@@G@@         LOAD    X8,X5 .           SET TO FOLLOW CHAIN@D@@@A         LOAJA
)@@G@@D    X5,SDDAD .        POINT TO FATHER    @D@@@A         STORE   X8,SDKIJB
)@@G@@D .        SET POINTER TO KID @F@@@A         IF SDMEMS,ON,SDCLS2 THEN,LIJC
)@@G@@STS1 . DOES THIS HAVE A FATHER@F@@@ALISTS2   LABEL .                   NJD
)@@G@@OW FOLLOW CHAIN BACK DOWN     @D@@@A         LOAD    X8,SDBCHI .       GJE
)@@G@@ET POINTER TO NAME@D@@@A         PRTBCD  X8 .              PRINT THIS NAJF
)@@G@@ME    @F@@@A         IF SDARRY,OFF,SDCLS2 THEN,NEXFAT . IS THIS AN ARRAYJG
)@@G@@?     @D@@@A         LOAD    R1,SDNDIM .       GET NUMBER OF DIMS @C@@@AJH
)@@G@@         PRTSYM  '(' .             PUT LEADING (@C@@@A         LOOP    RJI
)@@G@@1,FIRSTA .       CORRECT COUNT@E@@@AFIRSTA   LABEL .                   PJJ
)@@G@@RT STAR FOR NEXT DIM    @C@@@A         PRTATR  STAR .            PRINT AJK
)@@G@@ STAR @C@@@A         LOOP    R1,NEXTAR .       MORE DIMS?   @C@@@A      JL
)@@G@@   PRTSYM  ')' .             PUT CLOSING )@D@@@A         GOTO    NEXFAT JM
)@@G@@.          GO DO NEXT FATHER  @A@@@ANEXTAR   LABEL . MORE DIMS HERE     JN
)@@G@@@D@@@A         PRTSYM  ',' .             SEPERATE BY A COMMA@F@@@A      JO
)@@G@@   GOTO    FIRSTA .          GO PRINT STAR FOR THIS DIM     @E@@@ANEXFATJP
)@@G@@ LABEL .                     GO ON TO NEXT FATHER     @C@@@A         LOAJQ
)@@G@@D    X5,SDKID .        POINT TO KID @E@@@A         IF SDKID,ZERO THEN,ENJR
)@@G@@DSTR . IS THIS THE ORIGIONAL? @C@@@A         PRTSYM  '.' .             PJS
)@@G@@RINT OUT A .@E@@@A         GOTO    LISTS2 .          CONTINUE ON TO NEXTJT
)@@G@@ NAME @C@@@AENDSTR   LABEL .                   END OF NAMES @D@@@A      JU
)@@G@@   SEPERATE .                SEPERATE ATTRIBUTES@D@@@ANOTSTR   LABEL .  JV
)@@G@@                 NOW CHECK IF ARRAY @D@@@A         IF SDARRY,OFF THEN,NOJW
)@@G@@TARR . IS THIS AN ARRAY?@C@D@A         PRTATR  ARRAY .           SAY ARRJX
)@@G@@AY    @G@@@A         LOAD    X6,SDSTRB .       GET ADDRESS OF META CODE JY
)@@G@@POINTER     @H@@@A         IF SDSTRU,ON,SDCLS4 THEN,LIST1 . MCODE POINTEJZ
)@@G@@R IS IN DIFFERENT PLACE @G@D@A         LOAD    A3,SDDVA .        MCODE PKA
)@@G@@OINTER IS IN D.V. TEMPLATE    @F@D@A         LOAD    X6,SDDVBM,A3 .    GKB
)@@G@@ET POINTER TO BOUNDS META CODE@F@@@D         LOAD    X6,SDDVBM,X6 .    GKC
)@@G@@ET POINTER TO BOUNDS META CODE@G@@@ALIST1    LABEL .                   MKD
)@@G@@ERGE WITH POINTER TO CODE IN X6     @E@D@A         LOAD    A3,X6 .      KE
)@@G@@     GET INTO CORRECT REGISTER@^@@@D         LOAD    A3,X6 .@H@@@D      KF
)@@G@@   IF      A3,EQ,0,I  THEN,NOTARR . ROOT IS ARRAY IMPLIED MEEMBER IS    KG
)@@G@@@C@@@D         PRTATR  ARRAY .           SAY ARRAY    @E@@@D         LOAKH
)@@G@@D    A3,X6 .           GET INTO CORRECT REGISTER@C@@@A         LINK    LKI
)@@G@@MCP .            GO SET REGS  @E@@@A         PRTSYM  '(' .             OKJ
)@@G@@PEN ARRAY REFERENCE     @E@@@A         SETL    R4,SDNDIM .       SET TO KK
)@@G@@COUNT OFF THE DIMS@E@@@ATOPDIM   LABEL . TOP OF LOOP TO LOOK FOR NEXT DIKL
)@@G@@MENSION     @A@@@A         ALTC .  GET NEXT SYMBOL    @H@E@D. IF ROOT OFKM
)@@G@@ STRUCTURE AND THIS MEMBER ARE ARRAYS THEN MEMBER IS ACTUALLY     @G@E@DKN
)@@G@@. A MULTIDIMENSIONAL ARRAY. BUT ONLY DIMENSIONS OF THE MEMBER ARRAY     KO
)@@G@@@E@E@D. ARE PRESENT IN THIS PART OF THE BETA CODE WHICH MEANS WE  @F@E@DKP
)@@G@@. MIGHT SEE A RIGHT PAREN BEFORE THE NUMBER OF DIMENSIONS FOR THIS@^@E@DKQ
)@@G@@. MEMBER IS EXHAUSTED   @C@E@D         IF      A3,EQ,ACRPAR,I  THEN,RIGHKR
)@@G@@TPAR .@F@B@A         IF A3,NE,ACSTAR,I THEN,DIMPRE . -> ISN'T A STAR TO KS
)@@G@@START @D@B@A         PRTSYM  '*' .             STAR FOR THIS BOUND@E@B@AKT
)@@G@@         GOTO    ENDDIMS .         MOVE TO NEXT DIMENSION   @G@B@ADIMPREKU
)@@G@@   LABEL .                   HERE TO SEE IF LOWER BOUND PRESENT   @G@@@AKV
)@@G@@         IF A3,EQ,ACDMUB,I THEN,NOLOWER . -> STARTS WITH UPPER BOUND    KW
)@@G@@@F@@@A         IF A3,NE,ACDMLB,I THEN,TOPDIM . -> NO LOWER BOUND PRESENTKX
)@@G@@@E@@@A         LINK    EXPR .            UNDO THE BOUND EXPRESSION@F@@@AKY
)@@G@@         PRTSYM  ':' .             SEPERATE LOWER AND UPPER BOUNDS@E@@@AKZ
)@@G@@         GOTO    GETUPR .          GET NEXT UPPER BOUND     @E@@@ANOLOWELA
)@@G@@R  LABEL .                   NO LOWER BOUND SPECIFIED @D@@@B         LOALB
)@@G@@D    R8,A2 .           SAVE ALTC REGS     @ @@@B         LOAD    R9,X10 LC
)@@G@@.     @C@@@B         ALTC .                    SEE IF '*'   @F@@@B      LD
)@@G@@   IF A3,NE,ACSTAR,I THEN,DIMPRE . -> ISN'T A STAR TO START @D@@@B      LE
)@@G@@   PRTSYM  '*' .             STAR FOR THIS BOUND@E@@@B         GOTO    ELF
)@@G@@NDDIMS .         MOVE TO NEXT DIMENSION   @G@@@BDIMPRE   LABEL .        LG
)@@G@@           HERE TO SEE IF LOWER BOUND PRESENT   @D@@@B         LOAD    ALH
)@@G@@2,R8 .           RESTORE ALTC REGS  @ @@@B         LOAD    X10,R9 .     LI
)@@G@@@D@@@A         LOAD    A1,2,I .          INSERT DEFAULT '1:'@D@@@A      LJ
)@@G@@   LOADXM  X4,DIMCLN,I .     POINT TO STRING    @D@@@A         LINK    PLK
)@@G@@UTBCD .          -> GO INSERT IT    @F@@@AGETUPR   LABEL .              LL
)@@G@@     HERE TO OUTPUT UPPER BOUND     @F@@@A         LINK    EXPR .       LM
)@@G@@     GO DROP OUT UPPER BOUND EXPR   @F@@@AENDDIMS  LABEL .              LN
)@@G@@     MERGE HERE FROM STAR IN BOUNDS @E@@@A         LOOP    R4,NXTDIM .  LO
)@@G@@     -> ANOTHER DIM TO GO THRU@#@@@DRIGHTPAR LABEL .  @E@@@A         PRTLP
)@@G@@SYM  ')' .             CLOSE BOUNDS EXPRESSIONS @F@@@A         LOADXM  XLQ
)@@G@@10,SAVX10 .      RESET TO LOOK THRU BCD LIST    @B@@@A         LOADXM  ALR
)@@G@@2,SAVA2 .        ''     @D@@@A         SEPERATE .                SEPERATLS
)@@G@@E ATTRIBUTES@F@@@A         GOTO    NOTARR .          MERGE WITH NON-ARRALT
)@@G@@Y PROCESSING@G@@@ANXTDIM   LABEL .                   HERE TO ISERT COMMALU
)@@G@@ BETWEEN DIMS     @F@@@E         LOAD    R8,A2 .           SAVE ALTC REGLV
)@@G@@S FOR LOOKAHEAD   @ @@@E         LOAD    R9,X10 .     @B@@@E         ALTLW
)@@G@@C .  LOOKAHEAD TO SEE IF ')'  @H@@@E. IF ROOT OF STRUCTURE AND THIS MEMBLX
)@@G@@ER ARE ARRAYS THEN MEMBER IS ACTUALLY     @G@@@E. A MULTIDIMENSIONAL ARRLY
)@@G@@AY. BUT ONLY DIMENSIONS OF THE MEMBER ARRAY     @E@@@E. ARE PRESENT IN TLZ
)@@G@@HIS PART OF THE BETA CODE WHICH MEANS WE  @F@@@E. MIGHT SEE A RIGHT PAREMA
)@@G@@N BEFORE THE NUMBER OF DIMENSIONS FOR THIS@^@@@E. MEMBER IS EXHAUSTED   MB
)@@G@@@C@@@E         IF      A3,EQ,ACRPAR,I  THEN,RIGHTPAR .@D@@@E         LOAMC
)@@G@@D    A2,R8 .           RESTORE ALTC REGS  @ @@@E         LOAD    X10,R9 MD
)@@G@@.     @E@@@A         PRTSYM  ',' .             SEPERATE BOUNDS PAIRS    ME
)@@G@@@F@@@A         GOTO    TOPDIM .          GO AND EXAMINE NEXT BOUNDS PAIRMF
)@@G@@@F@@@ANOTARR   LABEL .                   NOW PRINT OUT REST OF ATTR'S   MG
)@@G@@@E@C@A         IF SDPARM,OFF  THEN,NOTPAR . IS THIS A PARAMETER?  @F@@@CMH
)@@G@@         IF SDPARM,OFF,SDCLS2  THEN,NOTPAR . IS THIS A PARAMETER? @C@@@AMI
)@@G@@         PRTATR  PARM .            SAY PATAMETER@D@@@A         SEPERATE MJ
)@@G@@.                SEPERATE ATTRIBUTES@#@@@ANOTPAR   LABEL .  @F@@@A      MK
)@@G@@   LOAD    F,SDCLS0 .        GET FLAGS OF STORAGE CLASS     @D@@@A      ML
)@@G@@   IF SD0AUT,OFF THEN,NOTAUT . IS THIS AUTOMATIC@F@@@A         PRTATR  AMM
)@@G@@UTO .            PUT STORAGE CLASS INTO LISTING @E@@@A         GOTO    TMN
)@@G@@YPE .            GO GET VARIABLE TYPE NEXT@C@@@ANOTAUT   LABEL .        MO
)@@G@@           VAR NOT AUTO @E@@@A         IF      SD0STA,OFF THEN,NOTSTA . MP
)@@G@@IS IT STATIC?     @D@@@A         PRTATR  STAT .            PUT ATTR IN LMQ
)@@G@@IST   @C@@@A         GOTO    TYPE .            CONTINUE     @E@@@ANOTSTAMR
)@@G@@   LABEL .                   VAR IS NOT STATIC...     @D@@@A         IF MS
)@@G@@SD0CNT,OFF THEN,NOTCNT . IS IT CONTROLLED?@E@@@A         PRTATR  CONTR .MT
)@@G@@           SAY IT IS CONTROLLED     @E@@@A         GOTO    TYPE .       MU
)@@G@@     CONTINUE WITH OTHER ATTR @B@@@ANOTCNT   LABEL . VAR IS NOT CONTROLLMV
)@@G@@ED... @D@@@A         IF SD0BSD,OFF THEN,NOCOMA . MAYBE IT IS BASED@D@@@AMW
)@@G@@         PRTATR  BASED .           SAY IT IS BASED    @G@@@ATYPE     LABMX
)@@G@@EL .                   PRINT A COMMA BEFORE OTHER ATTRS     @D@@@A      MY
)@@G@@   SEPERATE .                SEPERATE ATTRIBUTES@E@@@ANOCOMA   LABEL .  MZ
)@@G@@                 NO STORAGE CLASS KNOWN   @E@@@A         IF SD0ARE,ISNTONA
)@@G@@N THEN,NOTAREA . IS THIS AN AREA    @E@@@A         PRTATR  AREA .       NB
)@@G@@     SAY THAT THIS IS AN AREA @[@@@A.     @G@@@A.        SHOULD SAY SIZENC
)@@G@@ IN HERE                                  ***** @[@@@A.     @E@@@A      ND
)@@G@@   GOTO    REFFER .          GO PRINT CROSS REFERENCES@A@@@ANOTAREA  LABNE
)@@G@@EL . NOT A LABEL HERE   @C@@@A         AND,U   F,SD0PTR .        GET TYPNF
)@@G@@E BITS@E@@@A         IF A6,NE,SD0PTR,I THEN,NOTPTR . IS THIS POINTER?   NG
)@@G@@@E@@@A         IF SDPTOF,ON,SDCLS1 THEN,NOTAR1 . -> THIS IS OFFSET@D@@@ANH
)@@G@@         PRTATR  POINT .           SAY IT IS POINTER  @E@@@A         GOTNI
)@@G@@O    REFFER .          GO DO REFERENCE LIST     @F@@@ANOTAR1   LABEL .  NJ
)@@G@@                 HERE WE HAVE AN OFFSET VARIABLE@C@@@A         PRTATR  ONK
)@@G@@FFSET .          SAY OFFSET   @H@@@A         IF SD5OFA,OFF,SDCLS5 THEN,RNL
)@@G@@EFFER . -> NO AREA DECLARED WITH OFFSET   @F@@@A         LOAD    X8,SDOFNM
)@@G@@PA .       GET AREA DECLARED WITH OFFSET  @C@@@A         PRTSYM  '(' .  NN
)@@G@@           OPEN PARENS  @E@@@A         PRTSD   X8 .              PUT OUTNO
)@@G@@ NAME OF AREA     @C@@@A         PRTSYM  ')' .             CLOSE PARENS NP
)@@G@@@F@@@A         GOTO    REFFER .          GO FINISH CROSS REFERENCES     NQ
)@@G@@@A@@@ANOTPTR   LABEL . NOT POINTER HERE   @D@@@A         IF A6,NE,SD0FLENR
)@@G@@,I THEN,NOTFIL . IS IT FILE?  @D@@@A         PRTATR  FILE .            SNS
)@@G@@AY IT IS FILE...  @D@@@A         SEPERATE .                SEPERATE ATTRNT
)@@G@@IBUTES@F@@@A         IF SDFLRC,OFF,SDCLS1 THEN,STFILE . IS THE FILE RECONU
)@@G@@RD?   @D@@@A         PRTATR  RECORD .          SAY IT IS RECORD   @H@@@ANV
)@@G@@         IF SDFLKY,OFF,SDCLS1 THEN,INOUT . IF NOT KEYED,SEE IF INPUT OR NW
)@@G@@OUTPUT@D@@@A         SEPERATE .                SEPERATE ATTRIBUTES@D@@@ANX
)@@G@@         PRTATR  KEYED .           SAY IT IS KEYED    @F@@@A         GOTNY
)@@G@@O    REFFER .          CONTINUE WITH CROSS REFERENCE  @E@@@ASTFILE   LABNZ
)@@G@@EL .                   STREAM FILES COME HERE   @D@@@A         PRTATR  SOA
)@@G@@TREAM .          SAY IT IS STREAM . @E@@@AINOUT    LABEL .              OB
)@@G@@     RECORD FILES MERGE HERE  @E@@@A         LOAD    F,SDIOAT .        GOC
)@@G@@ET FOR E-Z REFERENCE    @G@@@A         IF SDIOIN,OFF THEN,STFOUT . IF NOOD
)@@G@@T INPUT THEN MAYBE OUTPUT     @D@@@A         SEPERATE .                SOE
)@@G@@EPERATE ATTRIBUTES@D@@@A         PRTATR  INPUTF .          SAY IT IS INPOF
)@@G@@UT    @B@@@A         GOTO    REFFER .          FINISH @G@@@ASTFOUT   LABOG
)@@G@@EL .                   SEE IF IT IS OUTPUT AND/OR PRINT     @E@@@A      OH
)@@G@@   IF SDIOOT,OFF THEN,STFPNT . NOT OUTPUT,SEE IF PRINT@D@@@A         SEPOI
)@@G@@ERATE .                SEPERATE ATTRIBUTES@D@@@A         PRTATR  OUTPUT OJ
)@@G@@.          SAY IT IS OUTPUT   @E@@@ASTFPNT   LABEL .                   SOK
)@@G@@EE IF FILE IS PRINTFILE @G@@@A         IF SDIOPR,OFF THEN,REFFER . NOT POL
)@@G@@RINT-> GET CROSS REFERENCE    @D@@@A         SEPERATE .                SOM
)@@G@@EPERATE ATTRIBUTES@D@@@A         PRTATR  PRINTF .          SAY FILE IS PON
)@@G@@RINT  @C@@@A         GOTO    REFFER .          GO FINISH UP @C@@@ANOTFILOO
)@@G@@   LABEL .                   IT ISN'T FILE@D@@@A         IF A6,NE,SD0LABOP
)@@G@@,I THEN,NOTLAB . IS IT LABEL ?@F@@@A         IF SD4FLB,OFF,SDCLS4 THEN,NOQ
)@@G@@OTFOR . IS IT A FORMAT LABEL? @C@@@A         PRTATR  FORMAT .          SOR
)@@G@@AY 'FORMAT '@E@@@A         GOTO    LAB .             MERGE WITH OTHER LAOS
)@@G@@BEL   @D@@@ANOTFOR   LABEL .                   NOT A FORMAT LABEL @F@@@AOT
)@@G@@         IF SD3LCN,OFF,SDCLS3 THEN,LAB . IS IT A LABEL VARIABLE?  @D@@@AOU
)@@G@@         PRTATR  STMT .            SAY 'STATEMENT '   @D@@@ALAB      LABOV
)@@G@@EL .                   NOW PRINT 'LABEL'  @C@@@A         PRTATR  LABE . OW
)@@G@@           SAY 'LABEL'  @E@@@A         GOTO    REFFER .          GO DO ROX
)@@G@@EFERENCE LIST     @D@@@ANOTLAB   LABEL .                   VAR ISN'T LABOY
)@@G@@EL    @E@@@A         IF A6,NE,SD0STU,I THEN,SCALAR . IS IT STURCTURE?   OZ
)@@G@@@D@@@A         PRTATR  STRUC .           SAY 'STRUCTURE'    @E@@@A      PA
)@@G@@   GOTO    REFFER .          GO DO REFERENCE LIST     @C@@@ASCALAR   LABPB
)@@G@@EL . THRU ALL OF THE TWO BIT CHECKS @D@@@A         IF A6,NE,SD0ENT,I THEPC
)@@G@@N,NOTENT . IS IT ENTRY? @E@@@A         IF SDPREN,ON,SDCLS1 THEN,ENTRY . PD
)@@G@@IS IT A PROC?     @D@@@A         IF SDBLUS,OFF,SDCLS1 THEN,NOTUSE . BUILPE
)@@G@@T IN? @D@@@A         PRTATR  PROC .            SAY 'PROCEDURE'    @D@@@APF
)@@G@@         SEPERATE .                SEPERATE ATTRIBUTES@G@@@A         GOTPG
)@@G@@O    CLASS1 .          GO PRINT OUT ATTRIBUTES OF RETURN    @F@@@ANOTUSEPH
)@@G@@   LABEL .                   THIS IS A BUILT IN FUNCTION    @F@@@A      PI
)@@G@@   IF SD4PVA,ON,SDCLS4 THEN,PSEU . IS THIS A PSEUDO VAR?    @C@@@A      PJ
)@@G@@   PRTATR  BUILT .           SAY BUILTIN  @G@@@A         GOTO    REFFER PK
)@@G@@.          IF BUILT IN THEN ATTR NOT KNOWN...   @F@@@APSEU     LABEL .  PL
)@@G@@                 THIS IS A PSEUDO VARIABLE...   @C@@@A         PRTATR  PPM
)@@G@@SEUD .           SAY PSEUDO   @D@@@A         GOTO    REFFER .          GPN
)@@G@@O PRINT OUT REFS  @D@@@AENTRY    LABEL .                   THIS IS AN ENPO
)@@G@@TRY   @D@@@A         PRTATR  ENTR .            SAY IT IS ENTRY    @D@@@APP
)@@G@@         SEPERATE .                SEPERATE ATTRIBUTES@E@@@A         GOTPQ
)@@G@@O    CLASS1 .          GO CHECK CLASS 1 BITS    @ @@@ANOTENT   LABEL . NPR
)@@G@@OT ENTRY    @D@@@A         IF A6,EQ,SD0STR,I THEN,CLASS1 . IS IT STRING?PS
)@@G@@@D@@@A         IF A6,NE,SD0ART,I THEN,REFFER . IS IT ARITH? @F@@@ACLASS1PT
)@@G@@   LABEL .                   LOOK THRU CLASS ONE BITS HERE  @G@@@A      PU
)@@G@@   LOAD    F,SDCLS1 .        GET CLASS1 BITS FOR E-Z REFERENCE    @D@@@APV
)@@G@@         IF SDARST,ON THEN,STRING . IS IT STRING?     @D@@@A         IF PW
)@@G@@SDRLCX,ON THEN,COMP .  CHECK REAL/COMPLEX @C@@@A         PRTATR  REAL . PX
)@@G@@           SAY REAL     @B@@@A         GOTO    FXFL .            MERGE  PY
)@@G@@@D@@@ACOMP     LABEL .                   VAR IS COMPLEX     @C@@@A      PZ
)@@G@@   PRTATR  COMPL .            SAY COMPLEX @C@@@AFXFL     LABEL .        QA
)@@G@@           NOW PRINT ','@D@@@A         SEPERATE .                SEPERATQB
)@@G@@E ATTRIBUTES@E@@@A         IF SDFXFL,OFF THEN,FIXED . IS IT FIXED OR FLOQC
)@@G@@AT?   @C@@@A         PRTATR  FLOAT .           SAY FLOAT    @D@@@A      QD
)@@G@@   GOTO    BASE .            NOW CHECK BASE     @C@@@AFIXED    LABEL .  QE
)@@G@@                 VAR IS FIXED @C@@@A         PRTATR  FIXE .            SQF
)@@G@@AY FIXED    @C@@@ABASE     LABEL .                   CHECK BASE   @D@@@AQG
)@@G@@         SEPERATE .                SEPERATE ATTRIBUTES@E@@@A         IF QH
)@@G@@SDDCBN,OFF THEN,DECIM . IS IT BINARY OR DECIMAL?@C@@@A         PRTATR  BQI
)@@G@@IN .             SAY BINARY   @E@@@A         GOTO    PREC .            GQJ
)@@G@@O PRINT OUT THE PREC    @D@@@ADECIM    LABEL .                   IT IS DQK
)@@G@@ECIMAL HERE @C@@@A         PRTATR  DECI .            SAY DECIMAL  @#@@@AQL
)@@G@@PREC     LABEL .  @F@@@A         IF A13,GE,10,I THEN,SCAL . IS THERE ROOQM
)@@G@@M IN THE LINE?    @E@@@A         LINK    OUTLIN .          DUMP THE CURRQN
)@@G@@ENT LINE    @C@@@A         INIT    'ATTR' .          SET POINTERS @H@@@AQO
)@@G@@SCAL     LABEL .                   HERE IF ROOM IN LINE FOR SCALE AND PRQP
)@@G@@E     @^@@@A         PRTSYM  '(' .  @E@@@A         PRTNUM  SDPREC .     QQ
)@@G@@     PUT PRECISION INTO LINE  @^@@@A         PRTSYM  ',' .  @E@@@A      QR
)@@G@@   LOAD    A4,SD2SP-FH2+FXH2 . GET SIGN EXTENDED SCALE@F@@@A         SSAQS
)@@G@@     A4,9 .            GET SCALE IN CORRECT PLACE     @C@@@A         IF QT
)@@G@@A4,GE,0,I THEN,NONNEG . IS SCALE <0?@D@@@A         LOADN   A4,A4 .      QU
)@@G@@     GET POSITIVE SCALE @E@@@A         PRTSYM  '-' .             PUT OUTQV
)@@G@@ A MINUS SIGN     @D@@@ANONNEG   LABEL .                   SCALE IN A4 IQW
)@@G@@S >0  @E@@@A         PRTNUM  A4 .              INSERT SCALE IN LINE     QX
)@@G@@@D@@@A         PRTSYM  ')' .             CLOSE SCALE,PRE    @E@@@A      QY
)@@G@@   GOTO    REFFER .          GO DO REFERENCE LIST     @A@@@ASTRING   LABQZ
)@@G@@EL . VARIABLE IS STRING @D@@@A         IF SDCHBT,ON THEN,BIT .   IS IT BRA
)@@G@@IT OR CHAR  @C@@@A         PRTATR  CHAR .            SAY CHAR     @G@@@ARB
)@@G@@         GOTO    SIZE .            GO PRINT EXPR FOR SIZE OF STRING     RC
)@@G@@@A@@@ABIT      LABEL . HERE IF VAR IS BIT @B@@@A         PRTATR  BITS . RD
)@@G@@           SAY BIT@F@@@ASIZE     LABEL .                   HERE TO PRINTRE
)@@G@@ SIZE OF STRING   @D@@@A         LOAD    A3,SDDVA .        GET D.V. ADDRRF
)@@G@@ESS   @F@@@A         LOAD    A3,SDDVSM,A3 .    GET MCODE PTR FOR MAX LENRG
)@@G@@GTH   @D@@@A         LINK    LMCP .            SET UP FOR EXPR    @C@@@ARH
)@@G@@         PRTSYM  '(' .             OPEN PARENS  @D@@@B         LOAD    RRI
)@@G@@8,A2 .           SAVE ALTC REGS     @ @@@B         LOAD    R9,X10 .     RJ
)@@G@@@B@@@B         ALTC .                    '('    @C@@@B         ALTC .   RK
)@@G@@                 SEE IF '*'   @E@@@B         IF      A3,EQ,ACSTAR,I  THERL
)@@G@@N,SIZE1 . IT'S A '*'    @D@@@B         LOAD    A2,R8 .           RESTORERM
)@@G@@ ALTC REGS  @ @@@B         LOAD    X10,R9 .     @D@@@A         LINK    ERN
)@@G@@XPR .            PUT OUT EXPRESSION @^@@@B         GOTO    SIZE2 .@D@@@BRO
)@@G@@SIZE1    LABEL .                   HER TO PUT OUT '*' @^@@@B         PRTRP
)@@G@@SYM  '*' .  @E@@@BSIZE2    LABEL .                   MERGE HERE TO FINISRQ
)@@G@@H     @C@@@A         PRTSYM  ')' .             CLOSE PARENS @F@@@A      RR
)@@G@@   LOADXM  A2,SAVA2 .        RESET TO POINT TO BCD TABLE    @B@@@A      RS
)@@G@@   LOADXM  X10,SAVX10 .      ''     @D@@@A         SEPERATE .           RT
)@@G@@     SEPERATE ATTRIBUTES@E@C@A         IF SDFXVR,ON THEN,VAR .   IS IT ARU
)@@G@@ VARYING STRING?  @F@@@C         IF SDFXVR,ON,SDCLS1 THEN,VAR .   IS IT RV
)@@G@@A VARYING STRING? @D@@@A         PRTATR  NONVAR .          SAY NON-VARYIRW
)@@G@@NG    @D@@@A         GOTO    REFFER .          GO DO CROSS REF    @A@@@ARX
)@@G@@VAR      LABEL . STRING IS VARYING  @C@@@A         PRTATR  VARY .       RY
)@@G@@     SAY VARYING  @C@@@A/.       NOW PRINT THE CROSS REFERENCE LIST     RZ
)@@G@@@[@@@A.     @[@@@A.     @#@@@AREFFER   LABEL .  @F@@@A         IF SDINTLSA
)@@G@@,OFF,SDCLS3 THEN,STRTRE . IS IT INITALIZED?     @D@@@A         SEPERATE SB
)@@G@@.                SEPERATE ATTRIBUTES@D@@@A         PRTATR  INITIA .     SC
)@@G@@     SAY INITALIZED     @E@@@A         LOAD    A3,SDINTM .       POINT TSD
)@@G@@O INITAL MCODE    @E@@@A         LINK    LMCP .            GO SET TO REASE
)@@G@@D THE EXPR  @F@@@A         LOAD    A12,-1,I .        SET PAREN/LISTST COSF
)@@G@@UNT TO ZERO @C@@@AINIT0    LABEL . HERE TO LOOK FOR ANOTHER LIST  @A@@@ASG
)@@G@@         ALTC .  GET NEXT TOKEN     @D@@@A         IF A3,EQ,ACLPAR,I THESH
)@@G@@N,INIT1 . IT IS A '('   @E@@@A         IF A3,NE,ACLLST,I THEN,INIT2 . ->SI
)@@G@@ NOT A LIST START @C@@@AINIT1    LABEL .                   HERE FOR '(' SJ
)@@G@@@D@@@A         ADD     A12,1,I .         ADD TO PAREN COUNT @D@@@A      SK
)@@G@@   PRTSYM  '(' .             PRINT LIST START   @D@@@A         GOTO    ISL
)@@G@@NIT0 .           GO READ NEXT TOKEN @D@@@AINIT2    LABEL .              SM
)@@G@@     HERE IF NOT '('    @D@@@A         IF A3,EQ,ACRPAR,I THEN,INIT3 . ->SN
)@@G@@ IT IS ')'  @E@@@A         IF A3,NE,ACRLST,I THEN,INIT4 . -> IT ISN'T ')SO
)@@G@@'     @C@@@AINIT3    LABEL .                   HERE IF ')'  @E@@@A      SP
)@@G@@   PRTSYM  ')' .             PUT OUT CLOSING PAREN    @F@@@A         LOOSQ
)@@G@@P    A12,INIT0 .       ONE FEWER PARENS TO WORRY ABOUT@G@@@A         LOASR
)@@G@@DXM  X10,SAVX10 .      GET SET TO LOOK AT BCD TABLE AGAIN   @B@@@A      SS
)@@G@@   LOADXM  A2,SAVA2 .        ''     @F@@@A         GOTO    STRTRE .     ST
)@@G@@     MERGE WITH NON-INITIALIZED SD'S@H@@@AINIT4    LABEL .              SU
)@@G@@     HERE IF NEITHER LEFT OR RIGHT PAREN/LIST   @D@@@A         IF A3,NE,SV
)@@G@@ACCOMA,I THEN,INIT5 . -> NOT COMMA  @E@@@A         PRTSYM  ',' .        SW
)@@G@@     SEPERATE ITEMS IN LIST   @E@@@A         GOTO    INIT0 .           LSX
)@@G@@OOK FOR MORE TOKENS     @G@@@AINIT5    LABEL .                   HERE EISY
)@@G@@THER STAR,NIL,START EXPR OR?  @D@@@A         IF A3,NE,ACSTAR,I THEN,INITSZ
)@@G@@6 . -> NOT STAR   @F@@@A         PRTSYM  '*' .             PRINT THE STATA
)@@G@@R OF THE LIST     @E@@@A         GOTO    INIT0 .           LOOK ON IN THTB
)@@G@@E MCODE     @F@@@AINIT6    LABEL .                   HERE IT IS START EXTC
)@@G@@PR OR ?     @D@@@A         AND,U   A3,0777000 .      DUMP THE EXTRA BITSTD
)@@G@@@F@@@A         IF A4,NE,ACSTEX,I THEN,INIT0 . -> THROW IT AWAY FOR NOW  TE
)@@G@@@E@@@A         LINK    EXPR .            UNDO THE EXPRESSION THERE@F@@@ATF
)@@G@@         GOTO    INIT0 .           LOOK ON THRU THE INIT CODE     @C@@@ATG
)@@G@@STRTRE   LABEL . START REFERENCE LISTING HERE   @D@@@A         LINK    OTH
)@@G@@UTLIN .          DUMP OUT THE LINE  @E@@@A         INIT    'ATTR' .     TI
)@@G@@     SET TO PLACE IN LINE     @D@@@A         LOADA   X6,SDXREF-FXH2 .  PTJ
)@@G@@OINT TO WORKSPACE @ @@@A         USING   WORD,X6 .    @D@@@A         LOATK
)@@G@@D    A1,W1H2 .         GET XREF CHAIN     @C@@@A         MOVE    W1H2,0,TL
)@@G@@I .        CLEAR TO ZERO@E@@@A         IF A1,EQ,0,I THEN,NOREF . ARE THETM
)@@G@@RE ANY REFERENCES?@#@@@AREVERS   LABEL .  @E@@@A         LOAD    A3,W1H2TN
)@@G@@,A1 .      GET NEXT PART OF CHAIN   @D@@@A         STORE   X6,W1H2,A1 . TO
)@@G@@     REVERSE THE CHAIN  @F@@@A         LOAD    X6,A1 .           REMEMBETP
)@@G@@R THE CURRENT POSITION  @E@@@A         LOAD    A1,A3 .           MOVE ONTQ
)@@G@@ TO THE NEXT LINK @D@@@A         IF A1,NE,0,I THEN,REVERS . CONTINUE IF TR
)@@G@@MORE  @[@@@A.     @C@@@A.        X6 NOW POINTS TO THE FIRST REFERENCE   TS
)@@G@@@[@@@A.     @A@@@AMORREF   LABEL . HERE FOR MORE REFS @D@@@A         PRTTT
)@@G@@NUM  W1H1 .            PRINT THE REFERENCE@E@@@A         LOAD    X6,W1H2TU
)@@G@@ .         SET TO MOVE BACK UP CHAIN@C@@@A         IF W1H2,ZERO THEN,ENDTV
)@@G@@REF . OUT OF REFS?@D@@@A         SEPERATE .                SEPERATE ATTRTW
)@@G@@IBUTES@D@@@A         GOTO    MORREF .          GO ON TO NEXT REF  @E@@@ATX
)@@G@@NOREF    LABEL .                   NO EXPLICIT REFERENCES   @E@@@A      TY
)@@G@@   SUB     X1,1,I .          MAKE MESSAGE EASY TO FIND@F@@@A         LOATZ
)@@G@@D    R1,MSGSIZ,I .     GET THE SIZE OF THE MESSAGE    @D@@@A         LOAUA
)@@G@@DA   A1,MSG .          POINT TO MESSAGE   @B@@@A         LOADXI  A1,1,I UB
)@@G@@.          SET INC@E@@@A         BT      X1,0,*A1 .        MOVE MESSAGE UC
)@@G@@INTO BUFFER @E@@@A         LOADXM  X3,4,I .          SAY LAST WORD IS FUUD
)@@G@@LL    @E@@@AENDREF   LABEL .                   END OF REFERENCE LIST    UE
)@@G@@@E@@@A         LINK    OUTLIN .          DUMP OUT CURRENT LINE    @G@@@AUF
)@@G@@         GOTO    CHAIN .           GO ON TO NEXT VAR WITH SAME NAME     UG
)@@G@@@#@@@A/.       LMCP -   @H@@@A.                SET UP THE POINTERS FOR AUH
)@@G@@LTC ROUTINE,REMEMBERING TO SAVE     @A@@@A.                REGS AS NECESUI
)@@G@@SARY  @[@@@A.     @F@@@ALMCP     LLOC .                    HERE TO TAKE UJ
)@@G@@MCODEPTR IN A3    @D@@@A         STORE   X10,SAVX10 .      SAVE CHAR POIUK
)@@G@@NTER  @D@@@A         STORE   A2,SAVA2 .        SAVE WORD POINTER  @E@@@AUL
)@@G@@         LOAD    X10,ALTCDA .      SET UP FOR START OF SCAN @F@@@A      UM
)@@G@@   SLBD    A2,36-1 .         GET MODIFIER FORM META CODE    @E@@@A      UN
)@@G@@   LOADXI  A2,1,I .          SET TO WALK THRU WORDS   @D@@@A         TP UO
)@@G@@     A3 .              IF POSITIVE THEN H1@D@@@A         ADD     X10,1,IUP
)@@G@@ .         IF NEG THEN H2     @E@@@A         LOAD    A3,0,I .          CUQ
)@@G@@LEAR OUT UPPER PORTION  @B@@@A         LJMP .                    RETURN UR
)@@G@@@F@@@A/.       EXPR .  UNDO THE POLISH STRING POINTED TO BY X10,A2..    US
)@@G@@@G@@@A.                FIRST BUILD THE TREE NEEDED, THEN SCAN THE TREE IUT
)@@G@@N     @B@@@A.                'POST ORDER' (SEE KNUTH) @F@@@A.        EXPUU
)@@G@@R BUILDS THE TREE, THEN CALLS PRINTE TO SCAN THE TREE @B@@@A.        ANDUV
)@@G@@ PRINT OUT THE EXPRESSION...  @E@@@A.        PRINTE WILL RECURSE TO EXPRUW
)@@G@@ TO HANDLE ARRAY BOUNDS!@[@@@A.     @G@@@AEXPR     LOCAL .              UX
)@@G@@     COME WITH X10,A2 SET UP CORRECTLY    @F@@@ANEXT     LABEL .        UY
)@@G@@           HERE TO LOOK AT NEXT TOKEN     @D@@@A         ALTC .         UZ
)@@G@@           GET THE NEXT TOKEN @G@@@ANEXT0    LABEL .                   HVA
)@@G@@ERE IF NEXT TOKEN ALREADY IN A3     @D@@@A         IF A3,LT,ACOPER,I THEVB
)@@G@@N,SDFOUN . -> FOUND SD  @H@@@A         IF A3,EQ,ACRBRK,I THEN,FRCPRT1 . VC
)@@G@@-> END OF SUBSCRIPT SUBEXPRESSION   @H@@@A         IF A3,EQ,ACCOMA,I THEVD
)@@G@@N,FRCPRT2 . -> END OF SUBSCRIPT SUBEXPRESSION   @F@@@A         IF A3,EQ,VE
)@@G@@ACENEX,I THEN,FRCPRT3 . -> END OF EXPRESSION    @D@@@A         AND,U   AVF
)@@G@@3,0777000 .      SEE IF OPERATOR    @H@@@A         IF      A4,NE,ACOPER,VG
)@@G@@I THEN,NEXT . -> NOT OPERATOR , IGNORE FOR NOW  @D@@@A         AND,U   AVH
)@@G@@3,0777 .         GET OPERATOR NUMBER@D@@@A         LOAD    A1,A4 .      VI
)@@G@@     GET INTO INDEX REG @G@@@A         LX,U    X8,OPTAB,A1 .     GET OPEVJ
)@@G@@RATOR TABLE ENTRY ADDRES***** @D@@@A         USING   NODE,X7 .         PVK
)@@G@@OINT TO FREE NODE @F@@@A         STORE   X8,DATA,X7 .      INSERT ADDRESVL
)@@G@@S INTO STACK NODE @E@@@A         STORE   X9,RLINK .        SET POINTER TVM
)@@G@@O RIGHT ARG @G@@@A         LOAD    A3,FLINK,X9 .     GET POINTER TO NEXTVN
)@@G@@ NODE ON STACK    @F@@@A         STORE   X7,FLINK,X9 .     SET FATHER POVO
)@@G@@INTER IN STACK    @C@@@A         LOAD    X9,A3 .           POP STACK    VP
)@@G@@@G@@@A         MOVE    LLINK,0,I .       SET LEFT LINK TO ZERO INCASE UNVQ
)@@G@@IARY  @D@@@A         LOAD    A4,OPUNRY,X8 .    GET UNARY FLAG     @D@@@AVR
)@@G@@         IF A4,NE,0,I THEN,ADDTOSTAK . -> IT IS UNIARY@E@@@A         STOVS
)@@G@@RE   X9,LLINK .        POINT TO LEFT OPERAND    @E@@@A         LOAD    AVT
)@@G@@3,FLINK,X9 .     SAVE NEXT NODE ON STACK  @F@@@A         STORE   X7,FLINVU
)@@G@@K,X9 .     SET FATHER OF LEFT HAND SIDE   @E@@@A         LOAD    X9,A3 .VV
)@@G@@           POINT TO NEXT STACK ELT  @F@@@AADDTOSTAK        LABEL .      VW
)@@G@@      HERE TO ADD NEW NODE TO STACK @F@@@A         LOAD    A3,FLINK,X7 .VX
)@@G@@     GET POINTER TO NEXT 'FREE' NODE@F@@@A         STORE   X9,FLINK,X7 .VY
)@@G@@     SET POINTER THRU STACK ELEMENTS@E@@@A         LOAD    X9,X7 .      VZ
)@@G@@     POINT TO NEW STACK TOP   @G@@@A         LOAD    X7,A3 .           PWA
)@@G@@OINT TO WHAT'S LEFT OF FREE LIST    @D@@@A         GOTO    NEXT .       WB
)@@G@@     SCAN NEXT TOKEN    @[@@@A.     @[@@@A.     @[@@@A.     @D@@@ASDFOUNWC
)@@G@@   LABEL .                   HERE WITH SD IN A3 @E@@@A         MOVE    LWD
)@@G@@LINK-FH1,0,I .   CLEAR SUBTREE POINTERS   @E@@@A         STORE   A3,DATAWE
)@@G@@ .         SET SD POINTER INTO NODE @E@@@A         LOAD    A3,FLINK,X7 .WF
)@@G@@     POINT TO NEXT FREE NODE  @D@@@A         STORE   X9,FLINK .        PWG
)@@G@@USH ONTO STACK    @D@@@A         LOAD    X9,X7 .           FINISH PUSHINWH
)@@G@@G     @D@@@A         LOAD    X7,A3 .           POINT TO FREE LIST @D@@@AWI
)@@G@@         ALTC .                    GET NEXT TOKEN     @F@@@A         IF WJ
)@@G@@A3,NE,ACLBRK,I THEN,NEXT0 . IS THIS AN ARRAY REFERENCE@[@@@A.     @E@@@AWK
)@@G@@.        HERE BECAUSE OF FUNCTION CALL OR ARRAY REFERECNE   @[@@@A.     WL
)@@G@@@D@B@A         STORE   X10,LLINK .       SAVE MCODE POSITION@D@@@B      WM
)@@G@@   STORE   X10,LLINK,X9 .    SAVE MCODE POSITION@B@B@A         STORE   AWN
)@@G@@2,RLINK .        ''     @B@@@B         STORE   A2,RLINK,X9 .     ''     WO
)@@G@@@D@@@A         LOAD    A4,0,I .          SET PAREN COUNT    @F@@@ASKIPTOWP
)@@G@@P  LABEL .                   HERE LOOKING FOR NEXT TOKEN    @B@@@A      WQ
)@@G@@   ALTC .                    GET IT @D@@@A         IF A3,NE,ACLBRK,I THEWR
)@@G@@N,SKIPT1 . -> NOT (     @E@@@A         ADD     A4,1,I .          INCREASWS
)@@G@@E NESTING LEVEL   @E@@@A         GOTO    SKIPTOP .         MOVE THRU NEXWT
)@@G@@T TOKENS    @E@@@ASKIPT1   LABEL .                   HERE TO CHECK FOR 'WU
)@@G@@)'    @F@@@A         IF A3,NE,ACRBRK,I THEN,SKIPTOP . DON'T COUNT NONPARWV
)@@G@@ENS   @E@@@A         LOOP    A4,SKIPTOP .      -> STILL NESTED TOO DEEP WW
)@@G@@@E@@@A         GOTO    NEXT .            AT END OF SUBSCRIPTS     @[@@@AWX
)@@G@@.     @F@@@A.        FRCPRT ROUTINES - CALL THE PRINTE ROUTINE TO PRINT WY
)@@G@@OUT   @F@@@A.                THE TOP TREE AND THEN TAKE THE APPROIATE ACWZ
)@@G@@TION  @[@@@A.     @A@@@AFRCPRT1  LABEL . ')' ENCOUNTERED    @E@@@A      XA
)@@G@@   LINK    PRINTE .          PRINT OUT LAST SUBSRCRIPT@E@@@A         PRTXB
)@@G@@SYM  ')' .             CLOSE SUBSCRIPT LIST     @H@@@A         JMP .   (XC
)@@G@@GOTO ?) .        RETURN TO PRINT ROUTINE FOR OUTER LEVEL    @D@@@AFRCPRTXD
)@@G@@2  LABEL .                   ',' ENCOUNTERED    @E@@@A         LINK    PXE
)@@G@@RINTE .          PRINT THIS SUBSCRIPT     @E@@@A         PRTSYM  ',' .  XF
)@@G@@           SEPERATE FROM NEXT ONE   @E@@@A         GOTO    NEXT .       XG
)@@G@@     LOOK FOR NEXT SUBSCRIPT  @D@@@AFRCPRT3  LABEL .                   EXH
)@@G@@ND EXPR FOUND     @E@@@A         LINK    PRINTE .          PRINT OUT TREXI
)@@G@@E FOR EXPR  @D@@@A         JMP .   RETURN TO CROSS REFERENCE LISTER     XJ
)@@G@@@I@@@A/.       PRINTE .                  TRANSVERSE TREE, VISITING NODESXK
)@@G@@ TO PRINT THEM    @[@@@A.     @[@@@A.     @A@@@A.        X9 -> TREE FOR XL
)@@G@@PRINTING    @^@@@A.        X7 -> FREE LIST@B@@@A.        X10,A2 ALTC REGXM
)@@G@@S (SAVE IF USED)  @[@@@A.     @F@@@APRINTE   LOCAL .                   EXN
)@@G@@NTRY POINT TO PRINT TOP TREE  @H@@@A         LOAD    X6,X9 .           XXO
)@@G@@6 WILL POINT TO CURRENT POSITION IN TREE  @E@@@A         LOAD    X9,FLINXP
)@@G@@K,X6 .     POP TOP TREE FROM STACK  @ @@@A         USING   NODE,X6 .    XQ
)@@G@@@D@@@A         MOVE    FLINK,0,I .       MARK AS TOP NODE   @F@@@A      XR
)@@G@@   LOAD    A5,0,I .          SAY STARTING AT LOWEST PRIORITY@E@@@AAPPROCXS
)@@G@@   LABEL .                   APPROACH NODE FROM ABOVE @G@@@A         LOAXT
)@@G@@D    X8,DATA .         GET POINTER TO SD OR OPERATOR TABLE  @ @@@A      XU
)@@G@@   USING   SDSECT,X8 .  @G@@@A         IF SDBCSD,OFF,SDCLS4 THEN,APPROO XV
)@@G@@. -> THIS NODE IS AN OPERATOR @E@@@A         PRTSD .                   HXW
)@@G@@ERE WE HAVE AN SD IN X8 @F@@@A         IF LLINK,ZERO THEN,APPRO1 . IS THXX
)@@G@@IS AN ARRAY REFERENCE?  @[@@@A.     @C@@@A.        SAVE CURRENT POSITIONXY
)@@G@@ IN META CODE     @A@@@A.        SAVE CURRENT TREE POSITION @[@@@A.     XZ
)@@G@@@D@@@A         STORE   X10,LLINK,X7 .    SAVE ALTC POINTER  @B@@@A      YA
)@@G@@   STORE   A2,RLINK,X7 .     ''     @E@@@A         LOAD    A3,FLINK,X7 .YB
)@@G@@     SAVE POINTER TO FREE LIST@D@@@A         STORE   X9,FLINK,X7 .     SYC
)@@G@@TACK THIS NODE    @E@@@A         LOAD    X9,X7 .           FINISH ACT OFYD
)@@G@@ STACKING   @E@@@A         LOAD    X7,A3 .           POINT BACK AT FREE YE
)@@G@@LIST  @D@@@A         STORE   X6,DATA,X9 .      SAVE TREE POSITION @E@@@AYF
)@@G@@         LOADXM  X10,LLINK,X6 .    GET POINTER TO SUBSCRIPTS@B@@@A      YG
)@@G@@   LOADXM  A2,RLINK,X6 .     ''     @D@@@A         PRTSYM  '(' .        YH
)@@G@@     OPEN EXPRESSION    @^@@@A         LINK    EXPR . @E@@@A         LOAYI
)@@G@@D    X6,DATA,X9 .      GET BACK POSITION IN TREE@G@@@A         LOADXM  XYJ
)@@G@@10,LLINK,X9 .    GET BACK TO CORRECT POSITION IN MCODE@B@@@A         LOAYK
)@@G@@DXM  A2,RLINK,X9 .     ''     @E@@@A         LOAD    A3,FLINK,X9 .     GYL
)@@G@@ET POINTER TO STACK TOP @E@@@A         STORE   X7,FLINK,X9 .     PUT BACYM
)@@G@@K ON FREE LIST    @E@@@A         LOAD    X7,X9 .           POINT TO NEWLYN
)@@G@@Y FREED NODE@D@@@A         LOAD    X9,A3 .           GET TOP OF STACK   YO
)@@G@@@G@@@AAPPRO1   LABEL .                   HERE WHEN READY TO MOVE UP FROMYP
)@@G@@ SD   @E@@@A         LOAD    A5,9,I .          GET SIMULATED PRECEDENCE YQ
)@@G@@@F@@@AGOUP     LABEL .                   HERE TO MOVE UP IN THE TREE    YR
)@@G@@@E@@@A         LOAD    A3,FLINK .        GET POINTER TO FATHER    @E@@@AYS
)@@G@@         STORE   X7,FLINK .        PUT NODE ONTO FREE LIST  @D@@@A      YT
)@@G@@   LOAD    X7,X6 .           POINT TO FREE LIST @E@@@A         LOAD    XYU
)@@G@@6,A3 .           MOVE UP IN TREE TO FATHER@E@@@A         IF      A3,EQ,0YV
)@@G@@,I THEN,JMP . DONE WITH THIS TREE?  @F@@@A         LOAD    X8,DATA .    YW
)@@G@@     GET POINTER TO SD FOR FATHER   @E@@@A         IF LLINK,ZERO THEN,PUYX
)@@G@@TPAR . -> UP FROM UNIARY OP   @F@@@A         LOAD    A4,OPPREC,X8 .    GYY
)@@G@@ET PRECEDENCE AT NEW LEVEL    @E@@@A         IF A5,GE,A4 THEN,GOUP1 . COYZ
)@@G@@MING UP FROM LOWER?     @G@@@APUTPAR   LABEL .                   HERE IFZA
)@@G@@ UNIARY OR IF UP FROM LOWER   @D@@@A         PRTSYM  ')' .             EZB
)@@G@@ND SUBEXPRESSION  @G@@@AGOUP1    LABEL .                   HERE TO TRY TZC
)@@G@@O GO DOWN RIGHT SIDE    @F@@@A         LOAD    A5,OPPREC,X8 .    GET PREZD
)@@G@@CEDENCE OF THIS OPERATOR@E@@@A         IF RLINK,ZERO THEN,GOUP . -> JUSTZE
)@@G@@ UP FROM LEFT SIDE@[@@@A.     @B@@@A.        HERE IF JUST COMING UP FROMZF
)@@G@@ RIGHT@[@@@A.     @C@@@AGOUP2    LABEL . ENTRY FOR UNIARY OPERATORS     ZG
)@@G@@@E@@@A         PRTOPR  .                 PRINT OUT THE OPERATOR   @F@@@AZH
)@@G@@         LOAD    A3,RLINK .        SET TO MOVE DOWN TO LOWER LEVEL@E@@@AZI
)@@G@@         MOVE    RLINK,0,I .       SAY GOING DOWN RIGHT SIDE@D@@@A      ZJ
)@@G@@   LOAD    X6,A3 .           POINT TO NEW NODE  @E@@@A         GOTO    AZK
)@@G@@PPROC .          TRY TO GO DOWN SOME MORE @[@@@A.     @D@@@A.        HERZL
)@@G@@E TO APPROACH AN OPERATOR FROM THE TOP    @[@@@A.     @#@@@AAPPROO   LABZM
)@@G@@EL .  @D@@@A         LOAD    A4,OPPREC,X8 .    GET NEXT PRECEDENCE@F@@@AZN
)@@G@@         IF A5,LE,A4 THEN,GODOWN . -> GOING DOWN TO HIGHER PREC   @F@@@AZO
)@@G@@         PRTSYM  '(' .             HERE GOING DOWN TO LOWER PREC  @F@@@AZP
)@@G@@GODOWN   LABEL .                   READY TO TRY LEFT HAND SIDE    @E@@@AZQ
)@@G@@         LOAD    A5,OPPREC,X8 .    GET CURRENT PRECEDENCE   @E@@@A      ZR
)@@G@@   IF LLINK,NZERO THEN,NOTUNI . -> NOT UNIARY OPERATOR@[@@@A.     @B@@@AZS
)@@G@@.        HERE WE HAVE AN UNIARY OPERATOR  @[@@@A.     @E@@@A         PRTZT
)@@G@@SYM  '(' .             STICK OUT LEADING PAREN  @G@@@A         GOTO    GZU
)@@G@@OUP2 .           NOW PRINT OPERATOR AND GO DOWN LEFT  @F@@@ANOTUNI   LABZV
)@@G@@EL .                   NOT UNIARY OP, GO DOWN TO LEFT @C@@@A         LOAZW
)@@G@@D    X6,LLINK .        MOVE DOWN    @D@@@A         GOTO    APPROC .     ZX
)@@G@@     SEE ABOUT SUBTREE  @D@@@A         END .                     THAT'S ZY
)@@G@@ALL FOLKS   ___LIST     @H@@@A         JMP .   (*[S@@@*SDFF*@C@@@W.   COZZ
)@@G@@PYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@W.     @D@@@W.   QUESTIONAA
)@@G@@S CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@W.     @ @@@W.        MARAB
)@@G@@VIN V. ZELKOWITZ  @B@@@W.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@WAC
)@@G@@.        UNIVERSITY OF MARYLAND     @B@@@W.        COLLEGE PARK, MARYLANAD
)@@G@@D 20742     @[@@@W.     @G@@@W.        PERMISSION TO USE THESE LISTINGS AE
)@@G@@AND THE COMPUTER PROGRAMS THEY@E@@@W.   REPRESENT IS GRANTED UNDER THE FAF
)@@G@@OLLOWING CONDITIONS:    @[@@@W.     @G@@@W.        1. UNLIMITED USE MAY AG
)@@G@@BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@W.   THESE LISTINGS PROVIAH
)@@G@@DED THAT THE NAME PLUM OR UNIVERSITY OF MARYLAND@E@@@W.   PL/1 COMPILER AI
)@@G@@REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@W.     @F@@@W.        2. AJ
)@@G@@MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDED:   @[@@@W.     @G@@@WAK
)@@G@@.        (A) ANY RESULTING PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   AL
)@@G@@@G@@@W.        DESCRIBING SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PRAM
)@@G@@OGRAM @E@@@W.        IS A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  AN
)@@G@@@[@@@W.     @G@@@W.        (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAAO
)@@G@@L CORRECTIONS     @F@@@W.        OF ERRORS IN THE SOURCE PROGRAMS, SHALLAP
)@@G@@ BE REPORTED AND  @G@@@W.        A BRIEF DESCRIPTION OF THE FEATURE ADDEAQ
)@@G@@D SHALL BE SUBMITTED    @C@@@W.        TO THE UNIVERSITY OF MARYLAND, ANAR
)@@G@@D     @[@@@W.     @F@@@W.        (C) NO PROGRAMS DERIVED FROM THESE LISTAS
)@@G@@INGS SHALL BE SOLD@G@@@W.        WITHOUT WRITTEN APPROVAL FROM THE UNIVEAT
)@@G@@RSITY OF MARYLAND, AND  @[@@@W.     @F@@@W.        (D) COPIES OF THESE PAU
)@@G@@ROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@W.        LOCATIONS PROVIDED THAV
)@@G@@AT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@W.        WHETHER THE PROAW
)@@G@@GRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     @E@@@W.        MARYLAND AX
)@@G@@PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@W.     @G@@@W.        3. AY
)@@G@@THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILER ITSELF,    @F@@@W.   ANAZ
)@@G@@D ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN USING PLUM. @E@@@W.   THBA
)@@G@@E PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USER TO @F@@@W.   EXPERIMEBB
)@@G@@NT WITH THE COMPILER AS LONG AS THE RESULTING PRODUCT @G@@@W.   IS NOT SBC
)@@G@@OLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DEVELOPED   @#@@@W.   FRBD
)@@G@@OM PLUM.    @[@@@W.     @[@@@W.     @[@@@W.     @[@@@W.     @[@@@W.     BE
)@@G@@@[@@@W/.    @#@@@V/        AXR$ .   @#@@@V         DCLRG .  @#@@@V      BF
)@@G@@   UNLIST . @#@@@V@ADD,P PLTVDS .   @#@@@V@ADD,P PLCGST .   @#@@@V@ADD,PBG
)@@G@@ PLDSAW .   @#@@@V          LIST .  @#@@@V          PLWORD .@#@@@V      BH
)@@G@@    PLCGD . @#@@@V          PLSD .  @#@@@V         PLAC .   @#@@@W      BI
)@@G@@   PLAR .   @#@@@V          PLIG .  @#@@@VCGBF     CSECT 3. @[@@@V.     BJ
)@@G@@@D@@@VFGPANO* .                          PAGE NUMBER BIF    @D@@@VFGLINOBK
)@@G@@* .                          LINE NUMBER BIF    @[@@@V.     @[@@@V.     BL
)@@G@@@ @@@VFILL(1)  SAC     GGTNOP,CBFILE@ @@@VFILL(1)  SAC     CBBNOP,0     BM
)@@G@@@[@@@V.     @[@@@V.     @E@@@VFGPNPV* .                           PAGE NBN
)@@G@@UMBER PSEUDO VAR  @[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     GGTNOP,BO
)@@G@@CBPAGE .    @ @@@VFILL(1)  SAC     CBBNOP,0     @[@@@V.     @[@@@V.     BP
)@@G@@@C@W@VFGENDT* .                          ENDFILE BIF  @[@W@V.     @[@W@VBQ
)@@G@@.     @ @W@VFILL(1)  SAC     CBSMLM,FGENFX@ @W@VFILL(1)  SAC          0,BR
)@@G@@FGENFY@[@W@V.     @^@W@V.        VALUE MODE     @[@W@V.     @[@W@VFGENFXBS
)@@G@@@[@W@V.     @[@W@V.     @ @W@VFILL(1)  SAC     GGTNOP,CSENDV@ @W@VFILL(1BT
)@@G@@)  SAC     CBDATX,0     @[@W@V.     @^@W@V.        MAX LEN MODE   @[@W@VBU
)@@G@@.     @[@W@VFGENFY@[@W@V.     @[@W@V.     @ @W@VFILL(1)  SAC     GGTNOP,BV
)@@G@@CSENDM@ @W@VFILL(1)  SAC     CBBTIM,0     @[@W@V.     @[@@@V.     @C@@@VBW
)@@G@@FGINDX* .                          INDEX BIF    @C@@@VFGVERY*  LABEL .  BX
)@@G@@                 VERIFY BIF   @[@@@V.     @[@@@V.     @ @@@VFILL(1)  SACBY
)@@G@@     GGTIDX,CBBORL@ @@@VFILL(1)  SAC     CBBNOP,0     @[@@@V.     @[@@@VBZ
)@@G@@.     @C@@@VFGLNTH*  .                         LENGTH BIF   @[@@@V.     CA
)@@G@@@[@@@V.     @A@@@VFILL(1)  SAC     GGTSME,CBBORL .    @ @@@VFILL(1)  SACCB
)@@G@@     CBBNOP,0 .   @[@@@V.     @[@@@V.     @C@@@VFGTIME*  .              CC
)@@G@@           TIME BIF     @C@@@VFGDATE*  .                         DATE BICD
)@@G@@F     @[@@@V.     @[@@@V.     @C@@@VFILL(1)  SAC   CBSMLM,FGTIMX .     VCE
)@@G@@ALUE MODE   @D@@@VFILL(1)  SAC   0,FGTIMY .          MAX LENGTH MODE    CF
)@@G@@@[@@@V.     @A@@@V.        TIME - DATE IN VALUE MODE  @[@@@V.     @[@@@VCG
)@@G@@FGTIMX@[@@@V.     @[@@@V.     @ @@@VFILL(1)   SAC   GGTNOP,CBDATE @ @@@VCH
)@@G@@FILL(1)  SAC   CBDATX,0 .     @[@@@V.     @B@@@V.        TIME - DATE IN CI
)@@G@@MAX LENGTH MODE   @[@@@V.     @[@@@VFGTIMY@[@@@V.     @[@@@V.     @A@@@VCJ
)@@G@@FILL(1)   SAC   GGTNOP,CSDATM .     @ @@@VFILL(1)  SAC   CBBTIM,0 .     CK
)@@G@@@[@@@V.     @[@@@V.     @D@@@VFGCLPV*  .                         CLOCK PCL
)@@G@@SEUDO VAR   @[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC   GGTNOP,CBCLPV  CM
)@@G@@@^@@@VFILL(1)  SAC   CBBNOP,0 @[@@@V.     @[@@@V.     @C@@@WFGONCD* .   CN
)@@G@@                       ONCODE BIF   @[@@@W.     @[@@@W.     @ @@@WFILL(1CO
)@@G@@)  SAC     GGTNOP,CBONCD@ @@@WFILL(1)  SAC     CBBNOP,0     @[@@@W.     CP
)@@G@@@[@@@W.     @C@@@WFGONST* .                          ONSTMT BIF   @[@@@WCQ
)@@G@@.     @[@@@W.     @ @@@WFILL(1)  SAC     GGTNOP,CBONST@ @@@WFILL(1)  SACCR
)@@G@@     CBBNOP,0     @[@@@X.     @[@@@X.     @C@@@XFGONCB* .               CS
)@@G@@           ONCHAR BIF   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SAC     CCT
)@@G@@BSMLM,FGONCX .    @ @@@XFILL(1)  SAC     0,FGONCY .   @[@@@X.     @[@@@XCU
)@@G@@.     @ @@@XFGONCX .         VALUE MODE   @[@@@X.     @[@@@X.     @A@@@XCV
)@@G@@FILL(1)  SAC     GGTNOP,CBONCB .    @ @@@XFILL(1)  SAC     CBBNOP,0 .   CW
)@@G@@@[@@@X.     @[@@@X.     @ @@@XFGONCY .         MAX LENGTH   @[@@@X.     CX
)@@G@@@[@@@X.     @A@@@XFILL(1)  SAC     GGTNOP,CBONCM .    @ @@@XFILL(1)  SACCY
)@@G@@     CBBTIM,0 .   @[@@@X.     @[@@@X.     @C@@@XFGONSB* .               CZ
)@@G@@           ONSOURCE BIF @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SAC     CDA
)@@G@@BSMLM,FGONSX .    @ @@@XFILL(1)  SAC     0,FGONSY .   @[@@@X.     @[@@@XDB
)@@G@@.     @ @@@XFGONSX .         VALUE MODE   @[@@@X.     @[@@@X.     @A@@@XDC
)@@G@@FILL(1)  SAC     GGTNOP,CBONSB .    @ @@@XFILL(1)  SAC     CBBNOP,0 .   DD
)@@G@@@[@@@X.     @[@@@X.     @ @@@XFGONSY .         MAX LENGTH   @[@@@X.     DE
)@@G@@@[@@@X.     @A@@@XFILL(1)  SAC     GGTNOP,CBONSM .    @ @@@XFILL(1)  SACDF
)@@G@@     CBBTIM,0 .   @[@@@X.     @[@@@X.     @C@@@XFGONLC* .               DG
)@@G@@           ONLOC BIF    @[@@@X.     @[@@@X.     @A@Y@XFILL(1)  SAC     CDH
)@@G@@BMSLM,FGONLX .    @A@@@YFILL(1)  SAC     CBSMLM,FGONLX .    @ @@@XFILL(1DI
)@@G@@)  SAC     0,FGONLY .   @[@@@X.     @[@@@X.     @ @@@XFGONLX .         VDJ
)@@G@@ALUE MODE   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SAC     GGTNOP,CBONLCDK
)@@G@@ .    @ @@@XFILL(1)  SAC     CBBNOP,0 .   @[@@@X.     @[@@@X.     @ @@@XDL
)@@G@@FGONLY .         MAX LENGTH   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SACDM
)@@G@@     GGTNOP,CBONLM .    @ @@@XFILL(1)  SAC     CBBTIM,0 .   @[@@@X.     DN
)@@G@@@[@@@X.     @C@@@XFGONFL* .                          ONFILE BIF   @[@@@XDO
)@@G@@.     @[@@@X.     @A@@@XFILL(1)  SAC     CBSMLM,FGONFX .    @ @@@XFILL(1DP
)@@G@@)  SAC     0,FGONFY .   @[@@@X.     @[@@@X.     @ @@@XFGONFX .         VDQ
)@@G@@ALUE MODE   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SAC     GGTNOP,CBONFLDR
)@@G@@ .    @ @@@XFILL(1)  SAC     CBBNOP,0 .   @[@@@X.     @[@@@X.     @ @@@XDS
)@@G@@FGONFY .         MAX LENGTH   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SACDT
)@@G@@     GGTNOP,CBONFM .    @ @@@XFILL(1)  SAC     CBBTIM,0 .   @[@@@X.     DU
)@@G@@@[@@@X.     @C@@@XFGONFD* .                          ONFIELD BIF  @[@@@XDV
)@@G@@.     @[@@@X.     @A@@@XFILL(1)  SAC     CBSMLM,FGONDX .    @ @@@XFILL(1DW
)@@G@@)  SAC     0,FGONLY .   @[@@@X.     @[@@@X.     @ @@@XFGONDX .         VDX
)@@G@@ALUE MODE   @[@@@X.     @[@@@X.     @A@@@XFILL(1)  SAC     GGTNOP,CBONFDDY
)@@G@@ .    @ @Y@XFILL(1)SAC       CBBNOP,0 .   @ @@@YFILL(1)  SAC     CBBNOP,DZ
)@@G@@0 .   @[@@@W.     @[@@@W.     @C@@@VFGCLCK*  .                         CEA
)@@G@@LOCK BIF    @[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC   GGTNOP,CBCLBF  EB
)@@G@@@^@@@VFILL(1)  SAC   CBBNOP,0 @[@@@V.     @[@@@V.     @C@@@VFGAFTR*  .  EC
)@@G@@                       AFTER BIF    @C@@@VFGBFOR*  .                    ED
)@@G@@     BEFORE BIF   @[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,EE
)@@G@@CBAFTR .    @A@W@VFILL(1)  SAC          0,CMAFTR .    @A@@@WFILL(1)  SACEF
)@@G@@          0,CMREVS .    @[@@@V.     @B@@@V.        VALUE MODE FOR BEFOREEG
)@@G@@ AND AFTER  @[@@@V.     @[@@@VCBAFTR@[@@@V.     @[@@@V.     @A@@@VFILL(1EH
)@@G@@)  SAC     GGTIDX,CBDATE .    @ @@@VFILL(1)  SAC     CBDATX,0 .   @[@W@VEI
)@@G@@.     @B@W@V.        MAX LEN MODE FOR BEFORE AND AFTER@[@W@V.     @[@W@VEJ
)@@G@@CMAFTR@[@W@V.     @[@W@V.     @A@W@VFILL(1)  SAC     GGTNOP,CMAFT1 .    EK
)@@G@@@ @W@VFILL(1)  SAC     CBBNOP,0 .   @[@@@V.     @[@@@V.     @C@@@VFGHIGHEL
)@@G@@*  .                         HIGH BIF     @B@@@VFGLOWT*  .              EM
)@@G@@           LOW BIF@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,EN
)@@G@@CBLOWX .    @A@@@VFILL(1)  SAC          0,CBLOWY .    @[@@@V.     @A@@@VEO
)@@G@@.        VALUE MODE FOR HIGH AND LOW@[@@@V.     @[@@@VCBLOWX@[@@@V.     EP
)@@G@@@[@@@V.     @A@@@VFILL(1)  SAC     GGTLOW,CBDATE .    @ @@@VFILL(1)  SACEQ
)@@G@@     CBDATX,0 .   @[@@@V.     @B@@@V.        MAX LEN MODE FOR HIGH AND LER
)@@G@@OW    @[@@@V.     @[@@@VCBLOWY@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SACES
)@@G@@     GGTNOP,CBLOWM .    @ @@@VFILL(1)  SAC     CBBNOP,0 .   @[@@@V.     ET
)@@G@@@[@@@V.     @C@@@VFGCLAT*  .                         COLLATE BIF  @[@@@VEU
)@@G@@.     @[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,CSCLAT .    @A@@@VFILL(1EV
)@@G@@)  SAC          0,CMCLAT .    @[@@@V.     @^@@@V.        VALUE MODE     EW
)@@G@@@[@@@V.     @[@@@VCSCLAT@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     GEX
)@@G@@GTNOP,CSBCLA .    @ @@@VFILL(1)  SAC     CBNOPXX,0 .  @[@@@V.     @^@@@VEY
)@@G@@.        MAX LEN MODE   @[@@@V.     @[@@@VCMCLAT@[@@@V.     @[@@@V.     EZ
)@@G@@@A@@@VFILL(1)  SAC     GGTNOP,CBCLAT .    @ @@@VFILL(1)  SAC     CBBTIM,FA
)@@G@@0 .   @[@@@V.     @[@@@V.     @C@@@VFGEVRY*  .                         EFB
)@@G@@VERY BIF    @C@@@VFGSOME*  .                         SOME BIF     @[@@@VFC
)@@G@@.     @[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,CBSOME .    @ @@@VFILL(1FD
)@@G@@)  SAC     0,CMSOME .   @[@@@V.     @^@@@V.        VALUE MODE     @[@@@VFE
)@@G@@.     @[@@@VCBSOME@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     GGSTME,FF
)@@G@@CBBBOL .    @ @@@VFILL(1)  SAC     CBDATX,0 .   @[@@@V.     @^@@@V.     FG
)@@G@@   MAX LEN MODE   @[@@@V.     @[@@@VCMSOME@[@@@V.     @[@@@V.     @A@@@VFH
)@@G@@FILL(1)  SAC     GGTNOP,CMSSOM .    @ @@@VFILL(1)  SAC     CBBTIM,0 .   FI
)@@G@@@[@@@V.     @[@@@V.     @C@@@VFGTRNS*  .                         TRANSLAFJ
)@@G@@TE BIF@C@@@VFGDCAT* .                          DECAT BIF    @[@@@V.     FK
)@@G@@@[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,CTRNSX .    @A@W@VFILL(1)  SACFL
)@@G@@          0,CTRNSY .    @A@@@WFILL(1)  SAC          0,CMREVS .    @[@@@VFM
)@@G@@.     @^@@@V.        VALUE MODE     @[@@@V.     @[@@@VCTRNSX@[@@@V.     FN
)@@G@@@[@@@V.     @A@@@VFILL(1)  SAC     CBTRNS,CBDATE .    @A@@@VFILL(1)  SACFO
)@@G@@     CBDATX,0      .    @[@W@V.     @^@W@V.        MAX LEN MODE   @[@W@VFP
)@@G@@.     @[@W@VCTRNSY@[@W@V.     @[@W@V.     @A@W@VFILL(1)  SAC     CTTRNS,FQ
)@@G@@CMAFT1 .    @A@W@VFILL(1)  SAC     CBBNOP,0      .    @[@@@V.     @[@@@VFR
)@@G@@.     @C@@@VFGRVSE*  .                         REVERSE BIF  @[@@@V.     FS
)@@G@@@[@@@V.     @A@@@VFILL(1)  SAC     CBSMLM,CBRVSE .    @A@@@VFILL(1)  SACFT
)@@G@@          0,CMREVS .    @[@@@V.     @A@@@V.        VALUE MODE FOR REVERSFU
)@@G@@E     @[@@@V.     @[@@@VCBRVSE@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SACFV
)@@G@@     GGTSME,CBDATE .    @ @@@VFILL(1)  SAC     CBDATX,0 .   @[@@@V.     FW
)@@G@@@^@@@V.        MAX LEN MODE   @[@@@V.     @[@W@VCMREVS@F@@@WCMREVS .    FX
)@@G@@                       MOVE S1 ONTO BIF ARG,RETURN    @[@@@V.     @[@@@VFY
)@@G@@.     @A@@@VFILL(1)  SAC     GGTNOP,CBREVM .    @A@@@VFILL(1)  SAC     CFZ
)@@G@@BBNOP,0      .    @[@@@V.     @[@@@V.     @C@@@VFGCOPY*  .              GA
)@@G@@           COPY BIF     @[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     CGB
)@@G@@BSMLM,CVCOPY .    @A@@@VFILL(1)  SAC          0,CMCOPY .    @[@@@V.     GC
)@@G@@@^@@@V.        VALUE MODE     @[@@@V.     @[@@@VCVCOPY@[@@@V.     @[@@@VGD
)@@G@@.     @A@@@VFILL(1)  SAC     CBCOPY,CBDATE .    @A@@@VFILL(1)  SAC     CGE
)@@G@@BDATX,0      .    @[@@@V.     @^@@@V.        MAX LEN MODE   @[@@@V.     GF
)@@G@@@[@@@VCMCOPY@[@@@V.     @[@@@V.     @A@@@VFILL(1)  SAC     GGTNOP,CSCOPYGG
)@@G@@ .    @A@@@VFILL(1)  SAC     CBBNOP,0      .    @[@@@V.     @[@@@V.     GH
)@@G@@@C@@@VFGBOOL*  .                         BOOL BIF     @[@@@V.     @[@@@VGI
)@@G@@.     @ @@@VFILL(1)  SAC     CBSMLM,CBBOOL@ @@@VFILL(1)  SAC          0,GJ
)@@G@@CMBOOL@[@@@V.     @^@@@V.        VALUE MODE     @[@@@V.     @[@@@VCBBOOLGK
)@@G@@@[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC     CB3STR,CBBBOL@ @@@VFILL(1GL
)@@G@@)  SAC     CBDATX,0     @[@@@V.     @^@@@V.        MAX LEN MODE   @[@@@VGM
)@@G@@.     @[@@@VCMBOOL@[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC     GGTNOP,GN
)@@G@@CMBOLX@ @@@VFILL(1)  SAC     CBBNOP,0     @[@@@V.     @[@@@V.     @C@@@VGO
)@@G@@FGSBST*  .                         SUBSTR BIF   @[@@@V.     @[@@@V.     GP
)@@G@@@A@@@VFILL(1)  SAC     CBSMLM,CSSBTR .    @A@W@VFILL(1)  SAC          0,GQ
)@@G@@CMSBTR .    @A@@@WFILL(1)  SAC          0,CMREVS .    @[@@@V.     @ @@@VGR
)@@G@@.        VALUE MODE SUBSTR    @[@@@V.     @[@@@VCSSBTR@[@@@V.     @[@@@VGS
)@@G@@.     @A@@@VFILL(1)  SAC     GGTNOP,CSTSTR .    @ @@@VFILL(1)  SAC     CGT
)@@G@@BBNOP,0 .   @[@W@V.     @^@W@V.        MAX LEN MODE   @[@W@V.     @[@W@VGU
)@@G@@CMSBTR@[@W@V.     @[@W@V.     @A@W@VFILL(1)  SAC     GGTNOP,CMSSTR .    GV
)@@G@@@ @W@VFILL(1)  SAC     CBBNOP,0 .   @[@@@V.     @[@@@V.     @D@@@VFGSBPVGW
)@@G@@*  .                         SUBSTR PSEUDO VAR  @[@@@V.     @[@@@V.     GX
)@@G@@@A@@@VFILL(1)  SAC     GGTNOP,CSBTRP .    @ @@@VFILL(1)  SAC     CBBNOP,GY
)@@G@@0 .   @[@@@V.     @[@@@V.     @[@@@V.     @^@@@V.        CSF$ SUBROUTINEGZ
)@@G@@@]@@@VFGCSF$*     @[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC   CBSMLM,CBHA
)@@G@@CSF$ .@ @@@VFILL(1)  SAC   0,CMCSF$ .     @[@@@V.     @ @@@V.        VALHB
)@@G@@UE MODE FOR CSF$  @[@@@V.     @]@@@VCBCSF$ .    @[@@@V.     @[@@@V.     HC
)@@G@@@A@@@VFILL(1)  SAC     GGTCSF,CBBBOL .    @ @@@VFILL(1)  SAC     CBDATX,HD
)@@G@@0 .   @[@@@V.     @A@@@V.        MAX LENGTH MODE FOR CSF$   @[@@@VCMCSF$HE
)@@G@@@[@@@V.     @[@@@V.     @ @@@VFILL(1)  SAC   GGTNOP,CSCSF$ .@ @@@VFILL(1HF
)@@G@@)  SAC   CBBTIM,0 .     @[@@@V.     @[@@@V.     @C@@@VFGTRIM* .         HG
)@@G@@                 TRIM BIF     @[@@@V.     @[@@@V.     @A@@@VFILL(1)  SACHH
)@@G@@     CBSMLM,CBTRIM .    @A@@@VFILL(1)  SAC          0,CMREVS .    @[@@@VHI
)@@G@@.     @^@@@V.        VALUE MODE     @[@@@V.     @]@@@VCBTRIM .    @[@@@VHJ
)@@G@@.     @[@@@V.     @A@@@VFILL(1)  SAC     GGTSME,CBTRMX .    @ @@@VFILL(1HK
)@@G@@)  SAC     CBDATX,0 .   @[@@@V.     @[@@@V.     @C@@@VFGUNSP* .         HL
)@@G@@                 UNSPEC BIF   @[@@@V.     @[@@@V.     @A@@@VFILL(1)  SACHM
)@@G@@     CBSMLM,CBUNSP .    @A@@@VFILL(1)  SAC          0,CMUNSP .    @[@@@VHN
)@@G@@.     @B@@@V.                VALUE MODE FOR UNSPEC    @[@@@V.     @]@@@VHO
)@@G@@CBUNSP .    @[@@@V.     @[@@@V.     @G@@@VFILL(1)  SAC     GGTNOP,CBUNSXHP
)@@G@@ .   EVERYTHING GETS DONE AT STAGEING     @ @@@VFILL(1)  SAC     CBBNOP,HQ
)@@G@@0 .   @[@@@V.     @A@@@V.        MAXLENGTH MODE FOR UNSPEC  @[@@@V.     HR
)@@G@@@]@@@VCMUNSP .    @[@@@V.     @[@@@V.     @F@@@VFILL(1)  SAC     GGTNOP,HS
)@@G@@CMUNSX .   IT IS ALL DONE AT STAGEING     @ @@@VFILL(1)  SAC     CBBNOP,HT
)@@G@@0 .   @[@@@W.     @[@@@W.     @C@@@WFGUNPV* .                          UHU
)@@G@@NSPEC PV    @[@@@W.     @[@@@W.     @F@@@WFILL(1)  SAC     GGTNOP,CSUNPVHV
)@@G@@ .   IT IS ALL DONE AT STAGEING     @ @@@WFILL(1)  SAC     CBBNOP,0 .   HW
)@@G@@@ @@@V         USING SGDSCT,X7 .    @C@@@V/ .              FILE RELATED HX
)@@G@@BUILTIN FUNCTIONS @[@@@V.     @ @@@V.                PAGENO(FILE) @ @@@VHY
)@@G@@.                LINENO(FILE) @[@@@V.     @E@@@VCBFILE   LABEL .  STAGGIHZ
)@@G@@NG FOR FILE BIFS RETURNING INTEGER  @^@@@V         GNTR    2 .    @D@@@VIA
)@@G@@         LOAD    X2,SGDRSD .        LOAD UP SD OF FILE@G@@@V         STOIB
)@@G@@RE   X2,AGX0OF .        LOAD FILE SD TO WHERE IGEN CAN GET  @E@@@V      IC
)@@G@@   XGPOP .                    POP OFF FILE STACK ENTRY@E@@@V         MOVID
)@@G@@E    SGDAID,DCBCLN .    SET FIXED BIN RESULT    @#@@@V         GENM .   IE
)@@G@@@E@@@V         GINST   OPLA,AGRA3,AGXR0,U .  LOAD FILE SD INTO A3 @ @@@VIF
)@@G@@         GSUB    'BILTN' .    @ @@@V         GGETGR  AGRL1,1 .    @F@@@VIG
)@@G@@         GINST   OPSA,AGRA3,AGRL1 'NO' . SAVE RESULT FROM BIF     @#@@@VIH
)@@G@@CBNOPXX  GLBL .   @#@@@V         GFIN .   @B@@@V         GOTO    CBBRL4 II
)@@G@@.           EXIT  @[@@@V.     @A@W@V.                ENDFILE(FILE)  BIF IJ
)@@G@@@[@W@V.     @E@W@VCSENDV   LABEL .  STAGING FOR ENDFILE BIF IN VALUE MODIK
)@@G@@E     @^@W@V         GNTR    2 .    @C@W@V         NONPL1 XGFENF,DCBENF,IL
)@@G@@CBFILF .   ENDFILE@#@W@VCBFILF   LABEL .  @F@W@V         SET 04,ON,DGOPTIM
)@@G@@4 .        SET ENDFILE FUNCTION PRESENT...@C@W@V         LOAD    X2,SGDRIN
)@@G@@SD .        GET FILE SD @B@W@V         XGPOP .  POP OFF FILE STACK ENTRYIO
)@@G@@@D@W@V         MOVE    SGDAID,CBTSTR,2 .  SET STRING TEMP   @E@W@V      IP
)@@G@@   STORE   X2,AGX0OF .        STORE FILE SD FOR IGEN  @#@W@V         GENIQ
)@@G@@ .    @E@W@V         GINST   OPLA,AGRA3,AGXR0,U .  LOAD FILE SD INTO A3 IR
)@@G@@@G@W@V         GOTO    GGTRE0 .           EXIT, FINISH WITH ICODE FROM XIS
)@@G@@GEN   @[@W@V.     @[@W@V.     @[@W@V.     @E@W@VCSENDM   LABEL .  MAX LEIT
)@@G@@N MODE FOR ENDFILE BIF IS CONSTANT 1@F@W@V         XGPOP .              IU
)@@G@@      POP OFF FILE SD NOT NEEDED    @D@W@V         LOAD    A7,1,I .     IV
)@@G@@      SET THE CONSTANT 1@G@W@V         GOTO    CBSLLA .           MERGE IW
)@@G@@WITH OTHER CONSTANT MAX LENS  @[@@@V.     @B@@@V.                PAGENUMIX
)@@G@@BER PSEUDO VAR    @[@@@V.     @G@@@VCBPAGE   LLOC .                    SIY
)@@G@@TAGEING FOR PAGENUMBER PSEUDO VAR   @^@@@V         GNTR    2 .    @D@@@VIZ
)@@G@@         MOVE    SGDRSD+DCGSLT,SGDRSD . SAVE FILE SD  @F@@@V         XGPJA
)@@G@@OP .                   POP OFF STACK ELT FOR FILE     @D@@@V         MOVJB
)@@G@@E    SGDID,15,I .      SET TO PAGENO PV   @B@@@V         GOTO    CBBR4L JC
)@@G@@.          RETURN @E@@@V/.       INITIALIZATION OF FUNCTIONS THAT WORK OJD
)@@G@@N STRUCTURES@G@@@VINEVRY*  LLOC .                    GENERATE INITIALIZAJE
)@@G@@TION FOR EVERY BIF@C@@@V         LOAD    A3,'1',I .        ASSUME TRUE  JF
)@@G@@@E@@@V         GOTO    INITAI .          MERGE WITH INIT FOR SOME @F@@@VJG
)@@G@@INSOME*  LLOC .                    GENREATE CODE TO START SOME    @C@@@VJH
)@@G@@         LOAD    A3,'0',I .        ASSUME FALSE @#@@@VINITAI   LABEL .  JI
)@@G@@@^@@@V         GNTR    2 .    @D@@@V         STORE   A3,AGX0OF .       SJJ
)@@G@@AVE ASSUMED VALUE @C@@@V         MOVE    SGDAID,CBSBIT,2 . SET STACK    JK
)@@G@@@D@@@V         GTMP    3 .               GET ROOM FOR RESULT@E@@@V      JL
)@@G@@   STORE   A8,SGDRDS .       SET DISPLACEMENT TO TEMP @F@@@V         ADDJM
)@@G@@     A8,2,I .          POINT TO WHERE STRING GOES     @D@@@V         STOJN
)@@G@@RE   A8,AGR10D .       SET ADDRESS,X10    @D@@@V         GENM .         JO
)@@G@@           BUILT DV RIGHT HERE@[@@@V.     @F@@@V.                NOTE: TJP
)@@G@@HIS COULD EASILY BE DONE IN A SUBROUTINE  @[@@@V.     @^@@@V         GLIJQ
)@@G@@T    1 .    @D@@@V         DL      A3,BFINIT .       GET FLAGS AND SIZE JR
)@@G@@@D@@@V         GDBLE   OPDS,AGRA3,AGRL1 'NO' . SET INTO DV  @G@@@V      JS
)@@G@@   GINST   OPLA,AGRA3,AGXR10,U 'NO' . POINT TO WHERE STRING GOES  @E@@@VJT
)@@G@@         GINST   OPLA,AGRA1,AGXR0,U 'NO' . GET START CHAR   @^@@@V      JU
)@@G@@   GLIT    1 .    @D@@@V         SA,S1   A1,0,A3 .         INITIALIZE STJV
)@@G@@RING  @F@@@V         GINST   OPSA,AGRA3,AGRL1,H2 'NO' . POINT DV TO STRIJW
)@@G@@NG    @C@@@VCBBNOP   GLBL .                    NOP CODE GEN @#@@@V      JX
)@@G@@   GFIN .   @G@@@VINFUDG   LABEL .                   MERGE HERE TO POINTJY
)@@G@@ TO ACTION TABLE  @[@@@V.     @A@@@V.        CHECK IF MAX LENGTH MODE?  JZ
)@@G@@@[@@@V.     @D@@@V         LOAD    A3,SGDACT+DCGSLT . GET CURRENT OFFSETKA
)@@G@@@D@@@V         LA,H2   A8,XGTBL2,A3 .    GET NEW OFFSET     @D@@@V      KB
)@@G@@   STORE   A8,SGDACT+DCGSLT . SET NEW OFFSET    @D@@@V         GRTN    2KC
)@@G@@ .               RETURN TO XGEN     @[@@@V.     @D@@@V.                AKD
)@@G@@ND NOW THE MATH INITALIZED FUNCTIONS@[@@@V.     @#@@@VINSUMT*  LLOC .   KE
)@@G@@@C@@@V         LOADA   X5,SDA0 .         POINT TO ZERO@C@@@V         LOAKF
)@@G@@D    A3,SUMIN .        GET ATTR     @D@@@V         GOTO    INPRO1 .     KG
)@@G@@     MERGE WITH PROD    @#@@@VINPROD*  LLOC .   @D@@@V         LOADA   XKH
)@@G@@5,SDA1 .         START WITH A ONE   @C@@@V         LOAD    A3,PRODIN .  KI
)@@G@@     GET ATTR     @^@@@VINPRO1   GNTR    2 .    @C@@@V         STORE   AKJ
)@@G@@3,SGDAID .       SET ATTR     @B@@@V         STORE   X5,SGDRSD .       SKK
)@@G@@ET SD @ @@@V         USING   SDSECT,X5 .  @E@@@V         MOVE    SGDRDS,KL
)@@G@@SDLCOF .   GET ADDRESS OF CONSTANT  @D@@@V         MOVE    SGDRBS,AGXR0+KM
)@@G@@FH1 . SET BASE REG = X0 @G@@@V         GOTO    INFUDG .          MERGE WKN
)@@G@@ITH STRING INIT FUNCTIONS     @C@@@V/ .      STRING FUNCTIONS RETURNING KO
)@@G@@INTEGER     @[@@@V.     @A@@@V.        INDEX(STRING1,STRING2)     @A@@@VKP
)@@G@@.        VERIFY(STRING1,STRING2)    @^@@@V.        LENGTH(STRING) @[@@@VKQ
)@@G@@.     @D@@@VGGTIDX   LABEL . TARGETING FOR TW0(2) STRING ARGUMENTS@#@@@VKR
)@@G@@         GNTR    2@#@@@V         GENM .   @E@@@V         GINST   OPLA,AGKS
)@@G@@RA2,AGRL2,U . GET DV OF 1ST STRING  @E@@@V         GINST   OPLA,AGRA3,AGKT
)@@G@@RL1,U . GET DV OF 2ND STRING  @^@@@V         GFIN     .     @D@@@V      KU
)@@G@@   XGPOP   'SIZE',2*DCGSLT .  POP OFF BOTH ARGS @B@@@V         GRTN    2KV
)@@G@@ .               EXIT   @ @@@V/ .      STRING FUNCTIONS     @[@@@V.     KW
)@@G@@@#@@@V.        TIME     @#@@@V.        DATE     @[@@@V.     @ @@@V.     KX
)@@G@@   TIME AND DATE STAGING@[@@@V.     @#@@@VCBDATE   LABEL .  @#@@@V      KY
)@@G@@   GNTR  2 .@B@@@VCBDAT1   LABEL . ENTRY POINT FOR TRIM BIF @E@@@V      KZ
)@@G@@   MOVE  SGDAID,CBTSTR,2 .   SET TEMP STRING RESULT   @F@@@V         GOTLA
)@@G@@O  GGTRE0 .            RETURN TO XGEN WITH CLEAR CODE @[@@@V.     @^@@@VLB
)@@G@@.        TRIM STAGEING  @[@@@V.     @#@@@VCBTRMX   LABEL .  @^@@@V      LC
)@@G@@   GNTR    2 .    @F@@@V         NONPL1  XGTRIM,DCBTRM,CBDAT1 . SAY TRIMLD
)@@G@@ IS NONSTANDARD   @ @@@V         GOTO    CBDAT1 .     @[@@@V.     @^@@@VLE
)@@G@@.        CSF$ STAGING   @[@@@V.     @#@@@VCSCSF$   LABEL .  @D@@@V      LF
)@@G@@   LOAD  A7,36,I .           SET LENGTH OF REPLY@H@@@V         GOTO  CBSLG
)@@G@@LLA .            ->SET LENGTH OF REPLY FOR MAX LENGTH MODE  @[@@@V.     LH
)@@G@@@ @@@V.        STAGEING FOR BOOL    @[@@@V.     @#@@@VCBBBOL   LABEL .  LI
)@@G@@@^@@@V         GNTR    2 .    @E@@@V         MOVE    SGDAID,CBTBIT,2 . SLJ
)@@G@@ET RESULT TO BE BIT     @F@@@V         GOTO    GGTRE0 .          RETURN LK
)@@G@@TO XGEN WITH CLEAR CODE @[@@@V.     @B@@@V.        TIME AND DATE - MAX LLL
)@@G@@ENGTH MODE  @[@@@V.     @#@@@VCSDATM   LABEL .  @E@@@V         LOAD  A7,LM
)@@G@@6,I .            SET LENGTH OF RESULT TO 6@[@@@V.     @F@@@VCBSLLA*  LABLN
)@@G@@EL .                   SET L,U REG,SIZE OF RESULT     @#@@@V         GNTLO
)@@G@@R  2 .@D@@@V         MOVE  SGDIBS,AGXR0+FH1 .      SET X0 BASE    @F@@@VLP
)@@G@@         STORE A7,SGDIDS .         SET OFFSET (SIZE OF RESULT)    @D@@@VLQ
)@@G@@CBBR4L   LABEL .                   MERGE HERE TO EXIT @D@@@V         MOVLR
)@@G@@E  DCGSV2+9,0,I .      SET RETURN VALUE   @D@@@V         GRTN 2 .       LS
)@@G@@           RETURN TO ICDE     @[@@@V.     @ @@@V.        CLOCK PSEUDO VALT
)@@G@@RIABLE@[@@@V.     @#@@@VCBCLPV   LLOC .   @#@@@V         GNTR  2 .@B@@@VLU
)@@G@@         NONPL1 XGFCLK,DCBCLK,CBCL01 .    @#@@@VCBCL01   LABEL .  @D@@@VLV
)@@G@@         MOVE  SGDID,14,I .        SET PSEUDOVAR TYPE @C@@@V         GOTLW
)@@G@@O  CBBR4L .            ->RETURN     @[@@@V.     @[@@@V.     @#@@@VCBCLBFLX
)@@G@@   LLOC .   @#@@@V         GNTR  2 .@B@@@V         NONPL1 XGFCLK,DCBCLK,LY
)@@G@@CBCL02 .    @^@@@V         GOTO  CBCL02 . @[@@@V.     @H@@@VCBBORL   LABLZ
)@@G@@EL .                   STAGING FOR BIF RETURNING FIXED BINARY     @#@@@VMA
)@@G@@         GNTR  2 .@#@@@VCBCL02   LABEL .  @C@@@V         MOVE  SGDAID,DCMB
)@@G@@BCLN .     SET STACK    @#@@@V         GENM     @^@@@V         GSUB  'BIMC
)@@G@@LTN'  @F@@@V         GGETGR  AGRL1,1 .         GET A REGISTER FOR THE REMD
)@@G@@SULT  @B@@@V         GINST OPSA,AGRA3,AGRL1 'NO' .    @#@@@V         GFIME
)@@G@@N .   @C@@@V         GOTO  CBBRL4 .            -> RETURN    @[@W@V.     MF
)@@G@@@F@W@V.        AFTER(STRING1,STRING2) AND BEFORE(STRING1,STRING2) BIFS  MG
)@@G@@@[@W@V.     @C@W@VCMAFT1   LABEL . MAX LEN MODE  FROM STRING1     @^@W@VMH
)@@G@@         GNTR    2 .    @C@W@V         MOVE    AGRL1+2*DCGSLT,AGRL1+DCGSMI
)@@G@@LT .  @D@W@V         XGPOP   'SIZE',2*DCGSLT . POP OFF BOTH ARGS  @E@W@VMJ
)@@G@@         SET     SGDHLF,ON,SGDID .  SET DV HALF FLAG ON     @F@W@V      MK
)@@G@@   GOTO    GGTRE0 .          RETURN TO XGEN WITH CLEAR CODE @[@@@V.     ML
)@@G@@@A@@@V.        HIGH(N) AND LOW(N) BIFS    @[@@@V.     @B@@@VGGTLOW   LABMM
)@@G@@EL . 1 ARG TO BIN FIXED(35,0) @^@@@V         GNTR    2 .    @F@@@V      MN
)@@G@@   CGCONV  DCBCSM  R,X7 .    CONVERT FO FIXED BIN(17,0)     @#@@@V      MO
)@@G@@   GEN .    @D@@@V         GINST   OPLA,AGRA3,AGRL1 . LOAD INTO REG     MP
)@@G@@@#@@@V         XGPOP .  @B@@@V         GRTN    2 .               EXIT   MQ
)@@G@@@[@@@V.     @B@@@V.        MAX LEN MODE FOR HIGH AND LOW    @[@@@V.     MR
)@@G@@@#@@@VCBLOWM   LABEL .  @^@@@V         GNTR    2 .    @F@@@V         CGCMS
)@@G@@ONV  DCBCSM  R,X7 .    CONVERT FO FIXED BIN(17,0)     @F@W@V         MOVMT
)@@G@@E    AGRL1+DCGSLT,AGRL1 . SET AW OF MAX LEN TO ARG    @#@@@W         GENMU
)@@G@@M .   @E@@@W         GIFR    CBLOWN,AGRL1 .    SEE IF LENGTH IS IN A REGMV
)@@G@@@E@@@W         GLOAD   AGRL1,1 .         LOAD IT INTO A REGISTER  @E@@@WMW
)@@G@@CBLOWN   GLBL .                    LENGTH NOW IN REGISTER   @C@@@W      MX
)@@G@@   GGETT   AGRL2,2 .         GET A FAKE DV@F@@@W         GINST   OPSA,AGMY
)@@G@@RL1,AGRL2,H1 . MAKE FAKE STORE INTO DV    @E@@@W         GAPPN   MAXLEN MZ
)@@G@@.          GO FIX TO LOOK LIKE A DV @#@@@W         GFIN .   @A@@@V      NA
)@@G@@   XGPOP .  POP OFF ARGUMENT  @F@@@V         GOTO    GGTRE0 .          RNB
)@@G@@ETURN TO XGEN WITH CLEAR CODE @[@@@V.     @^@@@V.        COLLATE BIF    NC
)@@G@@@[@@@V.     @D@@@VCSBCLA   LABEL .  STAGING FOR COLLATE IN VALUE MODE   ND
)@@G@@@^@@@V         GNTR    2 .    @F@@@V         MOVE    SGDAID,CBTCLT,2 . SNE
)@@G@@ET TO THE COLLATE SEQUENCE    @F@@@V         GOTO    GGTRE0 .          RNF
)@@G@@ETURN TO XGEN WITH CLEAR CODE @[@@@V.     @E@@@VCBCLAT   LABEL .  MAX LENG
)@@G@@N MODE STAGGING FOR COLLATE BIF     @D@W@V         LOAD    A7,64,I .    NH
)@@G@@     SET THE LENGTH     @D@@@W         LOAD    A7,256,I .        SET THENI
)@@G@@ LENGTH     @H@@@V         GOTO    CBSLLA .          MERGE WITH KNOWN MANJ
)@@G@@X LENGTH MODE ROUTINE   @[@@@V.     @ @@@V.        TARGETING FOR CSF BIFNK
)@@G@@@[@@@V.     @#@@@VGGTCSF   LLOC .   @^@@@V         GNTR    2 .    @E@@@VNL
)@@G@@         NONPL1  XGFCSF,DCCSF$,GGTSC1 . SAY NON-STANDARD PL1@G@@@V      NM
)@@G@@   GOTO    GGTSC1 .          MERGE WITH SINGLE STRING TARGETING   @[@@@VNN
)@@G@@.     @E@@@V.        SOME AND EVERY NEED TWO ARGS,ONLY ONE GETS POPPED  NO
)@@G@@@[@@@V.     @#@@@VGGSTME   LLOC .   @^@@@V         GNTR    2 .    @#@@@VNP
)@@G@@         GEN .    @G@@@V         GINST   OPLA,AGRA2,AGRL2,U 'NO' . POINTNQ
)@@G@@ TO PLACE FOR RESULT    @C@@@V         GOTO    GGTSC1 .          MERGE TNR
)@@G@@HERE  @[@@@V.     @A@@@V.        REVERSE AND LENGTH BIFS    @[@@@V.     NS
)@@G@@@#@@@VGGTSME   LABEL .  @^@@@V         GNTR    2 .    @F@@@VGGTSC1   LABNT
)@@G@@EL .                   HERE TO DO SINGLE STRING WORK  @#@@@V         GENNU
)@@G@@ .    @D@@@V         GINST   OPLA,AGRA3,AGRL1,U .  GET ADDR(DV)   @A@@@VNV
)@@G@@         XGPOP .  POP OFF ARGUMENT  @^@@@V         GRTN    2 .    @[@@@VNW
)@@G@@.     @E@@@VCMSSOM   LABEL . MAX LEN MODE OF STRINGS RETURNING LEN=1    NX
)@@G@@@C@@@V         LOAD    A7,1,I . SET THE KNOWN LENGTH .@H@@@V         GOTNY
)@@G@@O    CBSLLA .           MERGE WITH CONSTANT MAX LENGTH ROUTINE.   @[@W@VNZ
)@@G@@.     @[@@@W/.    @D@@@V.        TRANSLATE(STRING1,STRING2[,STRING3])  BOA
)@@G@@IF    @C@@@V.        DECAT(STRING1,STRING2,STRING3) BIF     @[@W@V.     OB
)@@G@@@E@W@VCTTRNS   LABEL .  TARGETING FOR TRANSLATE IN MAX LEN MODE   @^@W@VOC
)@@G@@         GNTR    2 .    @D@W@V         LOAD    A7,DXGNAR .        GET NUOD
)@@G@@MBER OF ARGS@E@W@V         IF A7,EQ,2*DCGSLT,I THEN,CTTRN1 .  ONLY 2 ARGOE
)@@G@@S     @A@W@V         XGPOP .  POP OFF THIRD ARG @B@W@VCTTRN1   LABEL .  OF
)@@G@@MERGE FROM 3 AND 2 ARGS @^@W@V         GRTN    2 .    @[@W@V.     @[@@@VOG
)@@G@@.     @[@W@V.     @D@@@VCBTRNS   LABEL .  VALUE MODE TARGETING FOR TRANSOH
)@@G@@LATE  @^@@@V         GNTR    2 .    @D@@@V         LOAD    A7,DXGNAR .  OI
)@@G@@      GET NUMBER OF ARGS@D@@@V         IF A7,NE,3*DCGSLT,I THEN,CBTRN1 .OJ
)@@G@@  ON 2 ARGS @#@@@V         GEN .    @E@@@V         GINST   OPLA,AGRA3,AGOK
)@@G@@RL1,U .  GET ADDR(3RD DV)     @#@@@V         XGPOP .  @B@@@V         GOTOL
)@@G@@O    CBTRN2 .           MERGE @D@@@VCBTRN1   LABEL .  NO THIRD ARG, USE OM
)@@G@@THE COLLATE SEQ   @E@W@V         LOADA   A7,BFCLAT .        GET ADDR OF ON
)@@G@@COLLATE     @#@@@W         GEN .    @D@W@V         STORE   A7,AGX0OF .  OO
)@@G@@      STORE FOR IGEN    @#@@@W         GLIT 1 . @#@W@V         GEN .    OP
)@@G@@@E@W@V         GINST   OPLA,AGRA3,AGXR0,U .  GET ADDR(COLLATE)    @F@@@WOQ
)@@G@@         LOADA   A3,BFCLAT .       LOAD ADDRESS OF COLLATE SEQ    @B@@@VOR
)@@G@@CBTRN2   LABEL .  MERGE FROM 2 AND 3 ARGS @#@@@V         GENM .   @D@@@VOS
)@@G@@         GINST   OPLA,AGRA2,AGRL1,U .  DV OF 2ND ARG  @G@@@V         GINOT
)@@G@@ST   OPLA,AGRA1,AGRL2,U .  DV OF INPUTED(1ST ARG) STRING    @#@@@V      OU
)@@G@@   GFIN .   @A@@@V         XGPOP   'SIZE',2*DCGSLT .  @^@@@V         GRTOV
)@@G@@N    2 .    @[@@@V.     @^@@@V.        REVERSE(STRING)@[@@@V.     @D@@@VOW
)@@G@@CBREVM   LABEL .  STAGGING FOR  REVERSE IN MAX LEN    @^@@@V         GNTOX
)@@G@@R    2 .    @H@@@WCMUNS2   LABEL .                   ENTRY TO RETURN THEOY
)@@G@@ STRING AS THE MAXLEN   @D@W@V         MOVE    AGRL1+DCGSLT,AGRL1 .  SETOZ
)@@G@@ AW OF ARG  @E@W@V         SET     SGDHLF,ON,SGDID+DCGSLT .  SET DV FLAGPA
)@@G@@ ON   @#@@@W         GEN .    @G@@@W         GMOVE   +2,1 .            MPB
)@@G@@OVE THE ARG DOWN ONTO THE RESULT    @#@@@W         XGPOP .  @F@@@V      PC
)@@G@@   GOTO    GGTRE0 .          RETURN TO XGEN WITH CLEAR CODE @[@@@V.     PD
)@@G@@@A@@@V.        COPY(STRING,COUNT) BIF     @[@@@V.     @D@@@VCBCOPY   LABPE
)@@G@@EL .  TARGETING FOR COPY BIF IN VALUE     @^@@@V         GNTR    2 .    PF
)@@G@@@F@W@V         CGCONV  DCBCSM  R,X7 .    CONVERT FO FIXED BIN(17,0)     PG
)@@G@@@F@@@W         CGCONV  DCBCSM  R,X7 .    CONVERT TO FIXED BIN(17,0)     PH
)@@G@@@#@@@V         GENM .   @E@@@V         GINST   OPLA,AGRA3,AGRL2,U .  GETPI
)@@G@@ DV OF STRING     @D@@@V         GINST   OPLA,AGRA1,AGRL1 .  GET THE COUPJ
)@@G@@NT    @#@@@V         GFIN .   @D@@@V         XGPOP   'SIZE',2*DCGSLT .  PK
)@@G@@POP OFF BOTH ARGS @^@@@V         GRTN    2 .    @[@@@V.     @[@@@V.     PL
)@@G@@@[@@@V.     @F@@@VCSCOPY   LABEL .  STAGGING AND CODE GEN FOR MAX LEN MOPM
)@@G@@DE COPY     @^@@@V         GNTR    2 .    @F@@@V         CGCONV  DCBCSM PN
)@@G@@ R,X7 .    CONVERT FO FIXED BIN(17,0)     @D@W@V         MOVE    AGX0OF,PO
)@@G@@0,I .       CLEAR FUDGE FIELD @F@@@W         MOVE    SGDAID+2*DCGSLT,SGDPP
)@@G@@AID+DCGSLT . SET RETURN VALUE @#@@@V         GENM .   @D@@@W         GIFPQ
)@@G@@R    CSCOP1,AGRL1 .    IS LENGTH IN A REG?@D@@@W         GLOAD   AGRL1,1PR
)@@G@@ .         LOAD IT INTO A REG @E@@@WCSCOP1   GLBL .                    LPS
)@@G@@ENGTH NOW IN REGISTER   @ @W@V         GGETGR  AGXTMP,1 .   @C@W@V      PT
)@@G@@   GINST   OPLA,AGXTMP,AGRL1 .  GET COUNT @E@W@V         GINST   OPLA,AGPU
)@@G@@RA3,AGRL2,U .  GET DV ADDR OF STRING@E@W@V         GINST   OPMSI,AGXTMP,PV
)@@G@@AGXR0,H1 .  LEN(STRING)*COUNT @E@@@W         GINST   OPMSI,AGRL1,AGRL2,HPW
)@@G@@1 . COUNT*LENGTH(STRING)@D@W@V         GAPPN   GARBGE .           FIX UPPX
)@@G@@  U FIELD   @D@@@W         GAPPN   MAXLEN .           FIX UP  U FIELD   PY
)@@G@@@E@W@V         GSET    AGRL2+DCGSLT,AGXTMP .  SET RESULT AW IN BIF@C@@@WPZ
)@@G@@         GGETT   AGRL2+DCGSLT,2 .  GET FAKE DV  @F@@@W         GINST   OQA
)@@G@@PSA,AGRL1,AGRL2+DCGSLT,H1 . SET LENGTH INTO FAKE@E@@@W         GAPPN   MQB
)@@G@@AXLEN .          GET ADDRESS SET CORRECTLY@#@@@V         GFIN .   @D@@@VQC
)@@G@@         XGPOP   'SIZE',2*DCGSLT .  POP OFF BOTH ARGS @F@@@V         GOTQD
)@@G@@O    GGTRE0 .          RETURN TO XGEN WITH CLEAR CODE @[@@@V.     @E@W@VQE
)@@G@@GARBGE   LLOC .   APPENDAGE TO FIX U FIELD IN COPY ICODE    @E@W@V      QF
)@@G@@   LOAD    A7,GARBG1 .        GET THE RIGHT U BITS    @ @W@V         LOAQG
)@@G@@D    A3,X10 .     @D@W@V         SUB     A3,1,I .           A3-> LAST INQH
)@@G@@ST    @E@W@V         OR      A7,0,A3 .          ADD IN THE NEW BITS     QI
)@@G@@@E@W@V         STORE   A8,0,A3 .          PLACE BACK INTO INST    @#@W@VQJ
)@@G@@         LJMP .   @[@W@V.     @C@@@V.        BOOL(STRING1,STRING2,STRINGQK
)@@G@@3)  BIF     @[@@@V.     @D@@@VCB3STR   LABEL .  TARGETING FOR 3 ARGUMENTQL
)@@G@@ STRINGS    @^@@@V         GNTR    2 .    @#@@@V         GENM .   @F@@@VQM
)@@G@@         GINST   OPLA,AGRA3,AGRL2+DCGSLT,U .  ADDR(DV OF 1ST ARG) @E@@@VQN
)@@G@@         GINST   OPLA,AGRA2,AGRL2,U .  ADDR(DV OF 2ND ARG)  @E@@@V      QO
)@@G@@   GINST   OPLA,AGRA1,AGRL1,U .  ADDR(DV OF 3RD ARG)  @#@@@V         GFIQP
)@@G@@N .   @D@@@V         XGPOP   'SIZE',3*DCGSLT .  POP OFF 3 ARGS    @^@@@VQQ
)@@G@@         GRTN    2 .    @[@@@V.     @[@@@V.     @[@@@V.     @C@@@VCMBOLXQR
)@@G@@   LABEL .  STAGGING FOR BOOL MAX LENGTH  @[@@@V.     @E@@@V.         MAQS
)@@G@@X LEN OF BOOL IS MAX LEN OF LARGEST INPUT STRING@[@@@V.     @^@@@V      QT
)@@G@@   GNTR    2 .    @C@W@V         XGPOP .  THIRD ARGUMENT NOT NEEDED     QU
)@@G@@@#@@@V         GENM .   @H@@@WGGMMAX*  GLBL .                    ENTRY PQV
)@@G@@OINT FOR CODE TO FIND MAX LEN OF TWO@F@@@W         GINST   OPLA,AGRA1,AGQW
)@@G@@RL1,H1 . GET LENGTH OF FIRST ARG    @D@@@W         GAPPN   MAXLEN .     QX
)@@G@@     FIX ADD RESSING    @E@@@W         GINST   OPLA,AGRA2,AGRL2,H1 . GETQY
)@@G@@ LENGTH OF SECOND @B@@@W         GAPPN   MAXLEN .          FIX UP @D@@@WQZ
)@@G@@         GINST   OPTG,AGRA1,AGRA2 'NO' . SEE IF A2>A1 @F@@@W         GINRA
)@@G@@ST   OPLA,AGRA2,AGRA1 'NO' . NOW A2 HAS LONGER LENGTH @D@@@W         GGERB
)@@G@@TT   AGRL2,2 .         GET A TWO WORD TEMP@E@@@W         GINST   OPSA,AGRC
)@@G@@RA2,AGRL2,H1 'NO' . SET INTO FAKE DV@D@@@W         GAPPN   MAXLEN .     RD
)@@G@@     FIX TO LOOK LIKE DV@D@W@V         GGETGR  AGXTMP 'X' .       GET ANRE
)@@G@@ X REGISTER @D@W@V         GINST   OPLA,AGRA1,AGRL1,U .  GET ADDR(DV2)  RF
)@@G@@@D@W@V         GINST   OPLA,AGRA3,AGRL2,U .  GET ADDR(DV1)  @D@W@V      RG
)@@G@@   GINST   OPLX,AGXTMP,AGRA3 .  STORE PRT-> DV1 @^@W@V         GLIT    2RH
)@@G@@ .    @D@W@V         LA,H1   A2,1,A1 .          GET SIZE OF DV 2  @E@W@VRI
)@@G@@         TG,H1   A2,1,A3 .          IS LEN(STR1)>LEN(STR2)? @E@W@V      RJ
)@@G@@   GINST   OPLX,AGXTMP,AGRA1 .  NO STORE PRT -> DV2   @F@W@V         GSERK
)@@G@@T    AGRL2+DCGSLT,AGXTMP .  FIX AW IN BOOL STACK ENTRY@#@W@V         GFIRL
)@@G@@N .   @G@@@W         GFIN    'POP' .           END OF CODE FOR '&' & '!'RM
)@@G@@ OPERATORS  @G@@@W         GEN .                     FOR BOOL, NEED TO PRN
)@@G@@OP OFF EXTRA DEALY@F@@@W         GSET    AGRL2,AGRL1 .     MOVE ADDRESSIRO
)@@G@@NG DOWN IN STACK  @D@W@V         XGPOP   'SIZE',2*DCGSLT .  POP OF ARGUMRP
)@@G@@ENTS  @D@@@W         XGPOP    .                 POP OFF ARGUMENT  @D@W@VRQ
)@@G@@         MOVE    SGDAID,CBTSTR,1 .  SET STRING RESULT @D@@@W         MOVRR
)@@G@@E    SGDAID,CBTSTR .    SET STRING RESULT @C@W@V         SET     SGDHLF,RS
)@@G@@ON,SGDID .  SET DV ON   @E@W@V         GOTO    CMSTR2 .           EXIT FRT
)@@G@@ROM THIS MESS     @E@@@W         GOTO    GGTRE0 .           EXIT FROM THRU
)@@G@@IS MESS     @^@@@W/.       ONCODE BIF     @[@@@W.     @#@@@WCBONCD   LLORV
)@@G@@C .   @^@@@W         GNTR    2 .    @E@@@W         MOVE    SGDAID,SUMIN RW
)@@G@@.    SAY CONST,FIXED BIN(35,0)@E@@@W         LINK    ONUNOK .          SRX
)@@G@@EE IF IN AN ON UNIT     @B@@@W         GOTO    CBONNP .          NOPE   RY
)@@G@@@E@@@W         LOADA   A6,SGDRAB .       GET ADDR TO REAL AUW A   @^@@@WRZ
)@@G@@         SLB     A6,18 .@G@Z@W         ADD     A6,ARSTSZ+23,I .  FIXED ASA
)@@G@@R SIZE + OFFSET OF ARMCRO     @H@@@Z         ADD     A6,ARSTSZ+10+23,I .SB
)@@G@@  FIXED AR +D.V.'S + OFFSET OF ARMCRO     @G@@@W         ADD     A6,SDBKSC
)@@G@@DP,X5 .       ADD IN ROOM TAKEN BY STATIC LINKS @G@@@W         STORE   ASD
)@@G@@6,AGRL1 .        STORE OOFFSET OF ONUNIT MACRO INFO   @E@@@W         MOVSE
)@@G@@E    SGDRAB,AGRX10,I .   X10 FOR CURRENT A.R.   @E@@@W         STORE   ASF
)@@G@@3,SGDRAD .       OFFSET IN STATIC LINKS   @#@@@W         GENM .   @ @@@WSG
)@@G@@         GGETGR  AGXTMP .     @F@@@W         GINST   OPLA,AGXTMP,AGRL1,QSH
)@@G@@1 .  ]LLA REG,ARCDER,XREG     @E@@@W         GSET    AGRL1,AGXTMP .    SSI
)@@G@@AY VALUE OF BIF IN REG  @#@@@W         GFIN .   @^@@@W         GRTN    2SJ
)@@G@@ .    @C@@@WCBONNP   LABEL . HERE TO RETURN VALUE OF ZERO   @A@@@W      SK
)@@G@@   MOVE    SGDRBS,AGRX0,I .   @C@@@W         MOVE    SGDRDS,KKD0,I .   SSL
)@@G@@ET ZERO     @^@@@W         GRTN    2 .    @^@@@W/.       ONSTMT BIF     SM
)@@G@@@#@@@WCBONST   LLOC .   @^@@@W         GNTR    2 .    @B@Y@X         NONSN
)@@G@@PL1  XGONST,DCONST,CBONSX .   @B@@@Y         NONPL1  XGONST,ONSTMG,CBONSSO
)@@G@@X .   @#@@@XCBONSX   LABEL .  @E@@@W         MOVE    SGDAID,SUMIN .    SSP
)@@G@@AY CONST,FIXED BIN(35,0)@D@@@W         LINK    ONUNOK .          SEE IF SQ
)@@G@@IN ON UNIT  @B@@@W         GOTO    CBONNP .          NOPE   @E@@@W      SR
)@@G@@   LOADA   A6,SGDRAB .       GET PTR TO REAL AUX A.W. @^@@@W         SLBSS
)@@G@@     A6,18 .@E@@@W         ADD     A6,ARSTMT-FH2,I . OFFSET IN A.R. OF AST
)@@G@@RSTMT @C@@@W         STORE   A6,AGRL1 .        FILL IN A.W. @E@@@W      SU
)@@G@@   MOVE    SGDRAB,AGRX10,I .   X10 FOR CURRENT A.R.   @F@@@W         STOSV
)@@G@@RE   A3,SGDRAD .       OFFSET OF STATIC LINK TO USE   @#@@@W         GENSW
)@@G@@M .   @ @@@W         GGETGR  AGXTMP .     @E@@@W         GINST   OPLA,AGSX
)@@G@@XTMP,AGRL1,H2 . LA REG,ARSTMT,XREG  @E@@@W         GSET    AGRL1,AGXTMP SY
)@@G@@.    SET A.W. TO POOINT TO REG@#@@@W         GFIN .   @^@@@W         GRTSZ
)@@G@@N    2 .    @F@@@X/.       ROUTINES FOR ONFILE,ONLOC,ONFIELD,ONSOURCE ANTA
)@@G@@D ONCHAR    @D@@@XCBONLC   LLOC .                    ENTRY FOR ONLOC    TB
)@@G@@@H@@@X         LOAD    A8,0,I .          GET OFFSET OF DV IN DV AREA IN TC
)@@G@@AUX BLOCK   @ @@@X         GOTO    CBONS1 .     @D@@@XCBONFL   LLOC .   TD
)@@G@@                 ENTRY FOR ONFILE   @ @@@X         LOAD    A8,2,I .     TE
)@@G@@@ @@@X         GOTO    CBONS1 .     @D@@@XCBONCB   LLOC .               TF
)@@G@@     ENTRY FOR ONCHAR   @ @@@X         LOAD    A8,4,I .     @ @@@X      TG
)@@G@@   GOTO    CBONS1 .     @D@@@XCBONSB   LLOC .                    ENTRY FTH
)@@G@@OR ONSOURCE @ @@@X         LOAD    A8,6,I .     @ @@@X         GOTO    CTI
)@@G@@BONS1 .     @D@@@XCBONFD   LLOC .                    ENTRY FOR ONFIELD  TJ
)@@G@@@ @@@X         LOAD    A8,8,I .     @G@@@XCBONS1   LABEL .              TK
)@@G@@     MERGE HERE FOR COMMON PROCESSING     @^@@@X         GNTR    2 .    TL
)@@G@@@D@@@X         MOVE    SGDAID,CBONFS,2 . SET ATTRIBUTES     @F@@@X      TM
)@@G@@   LINK    ONUNOK .          SEE IF WE'RE IN AN ON UNIT     @C@@@X      TN
)@@G@@   GOTO    CBONNO .          NO WE'RE NOT @ @@@X         LOADA   A6,SGDRTO
)@@G@@AB .  @^@@@X         SLB     A6,18 .@E@@@X         ADD     A6,ARSTSZ,I .TP
)@@G@@     GET TO END OF FIXED AR   @E@@@X         ADD     A6,SDBKDP,X5 .    GTQ
)@@G@@ET PAST STATIC LINKS    @F@@@X         ADD     A6,A8 .           ADD OFFTR
)@@G@@SET FOR CORRECT D.V.    @C@@@X         STORE   A6,AGRL1 .        STORE ITS
)@@G@@N A.W.@E@@@X         MOVE    SGDRAB,AGRX10,I . X10 FOR CURRENT A.R.     TT
)@@G@@@G@@@X         STORE   A3,SGDRAD .       OFFSET OF AUX BLOCK IN STATIC LTU
)@@G@@INKS  @^@@@X         GRTN    2.     @G@@@XCBONNO   LABEL .  HERE TO RETUTV
)@@G@@RN ' ' FOR ONCHAR AND '' FOR THE OTHERS   @D@@@X         IF      A8,EQ,4TW
)@@G@@,I  THEN,CBONN1 . ONCHAR?     @C@@@X         GTMP    2 .               GTX
)@@G@@ET TEMP D.V.@E@@@X         STORE   A8,SGDRDS .       SET DISPLACEMENT TOTY
)@@G@@ D.V. @#@@@X         GENM .   @^@@@X         GLIT    1 .    @ @Y@X      TZ
)@@G@@   DL      A3,KKD0 .    @ @@@Y         LOADD   A3,KKD0 .    @C@@@X      UA
)@@G@@   GDBLE   OPDS,AGRA3,AGRL1 . CLEAR D.V.  @#@@@X         GFIN .   @^@@@XUB
)@@G@@         GRTN    2 .    @C@@@XCBONN1   LABEL . HERE TO RETURN ' ' FOR ONUC
)@@G@@CHAR  @D@@@X         LOAD    A3,' ',I .        GET BLANK CHAR     @C@@@XUD
)@@G@@         STORE   A3,AGX0OF .       SAVE VALUE   @E@@@X         GTMP    3UE
)@@G@@ .               GET TEMP FOR D.V.+CHAR   @D@@@X         STORE   A8,SGDRUF
)@@G@@DS .       SET DISPL. TO D.V. @E@@@X         ADD     A8,2,I .          PUG
)@@G@@OINT TO WHERE CHAR GOES @D@@@X         STORE   A8,AGR10D .       SET ADDUH
)@@G@@RESS,X10    @#@@@X         GENM .   @^@@@X         GLIT    1 .    @D@@@XUI
)@@G@@         DL      A3,BFINIT .       SET FLAGS+SIZES    @B@@@X         GDBUJ
)@@G@@LE   OPDS,AGRA3,AGRL1  'NO' . @G@@@X         GINST   OPLA,AGRA3,AGXR10,UUK
)@@G@@  'NO' . POINT TO WHERE STRING GOES @D@@@X         GINST   OPLA,AGRA1,AGUL
)@@G@@XR0,U  'NO' . GET ' '   @^@@@X         GLIT    1 .    @E@@@X         SA,UM
)@@G@@S1   A1,0,A3 .         MOVE ' ' INTO STRING     @F@@@X         GINST   OUN
)@@G@@PSA,AGRA3,AGRL1,H2  'NO' . POINT D.V. TO STRING @#@@@X         GFIN .   UO
)@@G@@@^@@@X         GRTN    2 .    @C@@@X/.       MAX LENGTH ROUTINES FOR ON UP
)@@G@@UNIT BIFS   @^@@@XCBONCM   LABEL . ONCHAR @C@@@X         LOAD    A7,1,I UQ
)@@G@@.          MAX LENGTH=1 @ @@@X         GOTO    CBSLLA .     @C@@@XCBONSMUR
)@@G@@   LABEL .                   ONSOURCE     @F@@@X         LOAD    A7,80,IUS
)@@G@@ .         ASSUME MAX LENGTH=CARD IMAGE   @ @@@X         GOTO    CBSLLA UT
)@@G@@.     @B@@@XCBONLM   LABEL .                   ONLOC  @G@@@X         LOAUU
)@@G@@D    A7,64,I .         MAX LENGTH FOR A VARIABLE NAME=64    @ @@@X      UV
)@@G@@   GOTO    CBSLLA .     @B@@@XCBONFM   LABEL .                   ONFILE UW
)@@G@@@D@@@X         LOAD    A7,12,I .         FILENAME=12 CHARS  @ @@@X      UX
)@@G@@   GOTO    CBSLLA .     @G@@@W/.       ROUTINE TO FIND ON UNIT BLOCK(IF UY
)@@G@@ANY) CONTAINING ON UNIT BIF   @#@@@WONUNOK   LABEL .  @ @@@W         USIUZ
)@@G@@NG   SDSECT,X5 .  @E@@@W         LOAD    X5,X9 .           GEE CURRENT BVA
)@@G@@LOCK SD     @C@@@WONUNLP   LABEL . LOOP HERE BACK THROUGH BLOCKS  @F@@@WVB
)@@G@@         IF      SD3OBK,ON,SDCLS3  THEN,ONHVBK . ON UNIT BLOCK?   @D@@@WVC
)@@G@@         LOAD    X5,SDBKLK .       GO OUT ONE LEVEL   @D@@@W         IF VD
)@@G@@     X5,NZERO THEN,ONUNLP  ELSE,LJMP .    @F@@@WONHVBK   LABEL .        VE
)@@G@@           HERE IF FOUND AN ON UNIT BLOCK @F@@@W         LOAD    A3,SDBKVF
)@@G@@DP .       GET DEPTH OF ON UNIT BLOCK     @F@@@W         SUB     A3,1,I VG
)@@G@@.          DEPTH OF AUX ON UNIT BLOCK     @G@@@W         ADD     A3,AQSTVH
)@@G@@LK,I .     GET ADDR OF STATIC LINK FOO AUX BLOCK@B@@@W         LJMP    1VI
)@@G@@ .               RETURN @[@W@V.     @C@@@V/ .              SUBSTR(STRINGVJ
)@@G@@1,INDEX,LENGTH)OR @B@@@V.                SUBSTR(SRTING1,INDEX)    @^@@@VVK
)@@G@@.                BIF    @[@@@V.     @C@@@VCSTSTR   LABEL . STAGGING FOR VL
)@@G@@VALUE MODE SUBSTR @^@@@V         GNTR    2 .    @C@@@V         LOAD    AVM
)@@G@@8,0,I .          CLEAR FLAGS  @F@@@V         LOAD    A7,DXGNAR .       GVN
)@@G@@ET NUMBER OF ARGUMENT*DCGSLT  @E@@@V         IF      A7,EQ,2*DCGSLT,I  TVO
)@@G@@HEN,CBSTR1 . 2 ARGUMENTS@G@@@V         CGCONV  DCBCSM  R,X7 .    CONVERTVP
)@@G@@ 3RD ARG TO FIXED BIN(17,0)   @D@@@V         LOAD    A8,1,I .           VQ
)@@G@@SET 3 ARG FLAG ON @E@@@V         XGPOP .                   POP OFF THIRDVR
)@@G@@ ARG FOR NOW@B@@@VCBSTR1   LABEL . MERGE WITH 2 ARG SUBSTR  @F@@@V      VS
)@@G@@   CGCONV  DCBCSM  R,X7 .    CONVERT FO FIXED BIN(17,0)     @E@@@V      VT
)@@G@@   IF A8,EQ,0,I THEN,CBSTR2 . THIRD ARG. PRESENT?     @E@@@V         SUBVU
)@@G@@     X7,DCGSLT,I .     GET ARG THREE BACK AGAIN @#@@@V         GEN .    VV
)@@G@@@F@@@V         GINST   OPLA,AGRA1,AGRL1 . LOAD UP KNOWN LENGTH TO MOVE  VW
)@@G@@@A@@@V         XGPOP .  POP OFF 3RD ARG   @C@@@VCBSTR2   LABEL .        VX
)@@G@@           MERGE HERE   @F@@@V         MOVE    SGDAID+2*DCGSLT,CBTSTR,2 VY
)@@G@@.  SET STRING RESULT    @#@@@V         GENM .   @D@@@V         GINST   OVZ
)@@G@@PLA,AGRA3,AGRL2,U .  GET ADDR(DV)   @C@@@V         GINST   OPLA,AGRA2,AGWA
)@@G@@RL1 .  GET INDEX  @ @@@V         GSUB    'BILTN' .    @D@@@V         GLIWB
)@@G@@TRG  A8 .              FIX 2/3 ARG FLAG   @F@@@V         GFIN     .     WC
)@@G@@            POP OFF INDEX STACK ELEMENT   @E@@@V         XGPOP   'SIZE',WD
)@@G@@2*DCGSLT . POP OFF INDEX AND STRING @F@@@V         GOTO GGTRE0 .        WE
)@@G@@     RETURN TO XGEN WITH CLEAR CODE @[@W@V.     @[@W@V.     @D@W@VCMSSTRWF
)@@G@@   LABEL .  MAX LEN MODE STAGGING FOR SUBSTR BIF@^@W@V         GNTR    2WG
)@@G@@ .    @E@W@V         LOAD    A7,DXGNAR .        GET #OF ARGS*DCGSLT .   WH
)@@G@@@E@W@V         IF      A7,EQ,2*DCGSLT,I THEN,CMSTR1 . 2 ARG SUBSTR@[@W@VWI
)@@G@@.     @A@W@V.        LENGTH IS GIVEN BY 3RD ARG @[@W@V.     @F@W@V      WJ
)@@G@@   CGCONV  DCBCSM  R,X7 .    CONVERT FO FIXED BIN(17,0)     @F@W@V      WK
)@@G@@   MOVE    AGRL1+3*DCGSLT,AGRL1 . SET AW TO AW FROM LENGTH  @D@W@V      WL
)@@G@@   XGPOP   'SIZE',3*DCGSLT . POP OFF ALL ARGS   @B@W@V         GOTO CMSTWM
)@@G@@R2 . MERGE FOR EXIT     @A@W@VCMSTR1   LABEL . 2 ARG SUBSTR FOUND @A@W@VWN
)@@G@@.         LENGTH IS THAT OF 1ST ARG @[@W@V.     @G@W@V         MOVE    AWO
)@@G@@GRL1+2*DCGSLT,AGRL1+DCGSLT . SET AW TO THAT OF 1ST ARG@D@W@V         XGPWP
)@@G@@OP   'SIZE',2*DCGSLT . POP OFF 2 ARGS     @E@W@V         SET     SGDHLF,WQ
)@@G@@ON,SGDID . SET HALF FLAG ON (DV ON )@E@W@VCMSTR2   LABEL . MERGE FOR EXIWR
)@@G@@T FROM 2 AND 3 ARG SUBSTR     @F@W@V         GOTO    GGTRE0 .          RWS
)@@G@@ETURN TO XGEN WITH CLEAR CODE @[@@@V/ .   @F@@@V.                PSEUDO-WT
)@@G@@VARIABLE SUBSTR(STRING1,INDEX,[LENGTH])   @[@@@V.     @C@@@VCSBTRP   LABWU
)@@G@@EL . STAGGING FOR PSEUDO-SUBSTR     @^@@@V         GNTR    2 .    @E@@@VWV
)@@G@@         LOAD    A7,DXGNAR .       GET # OF ARGS * DCGSLT   @D@@@V      WW
)@@G@@   LOAD    F,1,I .           ASSUME TWO ARGS    @D@@@V         LOADA   XWX
)@@G@@2,DCBCSM .       POINT TO FIX BIN   @E@@@V         IF A7,EQ,2*DCGSLT,I TWY
)@@G@@HEN,CSBTR1 . IS IT TWO ARGS?  @E@@@V         LOAD    F,0,I .           TWZ
)@@G@@HIS IS THREE ARG SUBSTR @E@@@V         CGCONV  R,X2  R,X7 .      MAKE INXA
)@@G@@TO FIXED BIN(17,0)@G@@@V         GENM .                    PUT LENGTH ADXB
)@@G@@DRESS WDS INTO SUBSTR   @F@@@V         GMOVE   +4,3 .            MOVE COXC
)@@G@@PY OF STRING ONTO SUBSTR@D@@@V         GIFR    CBPSEU,AGRL1 .    IS IT IXD
)@@G@@N A REG?    @D@@@V         GLOAD   AGRL1,1 .         GET IT INTO A REG  XE
)@@G@@@#@@@VCBPSEU   GLBL .   @G@@@V         GSET    AGRL1+3*DCGSLT+3,AGRL1 . XF
)@@G@@SET ADDR WD INTO AUX IM PLACE @#@@@V         GFIN .   @D@@@V         XGPXG
)@@G@@OP .                   POP OFF LENGTH     @ @@@V         GOTO    CSBTR2 XH
)@@G@@.     @D@@@VCSBTR1   LABEL .                   ONLY TWO ARGS HERE @#@@@VXI
)@@G@@         GEN .    @F@@@V         GMOVE   +3,2 .            MOVE COPY OF XJ
)@@G@@STRING ONTO SUBSTR@F@@@VCSBTR2   LABEL .                   MERGE TWO ANDXK
)@@G@@ THREE SUBSTR     @E@@@V         CGCONV  R,X2  R,X7 .      CONVERT STARTXL
)@@G@@ TO FIXED   @F@@@V         GENM .                    PUT START ADDR WDS XM
)@@G@@INTO SUBSTR @D@@@V         GIFR    CBPSE1,AGRL1 .    IS IT IN A REG?    XN
)@@G@@@D@@@V         GLOAD   AGRL1,1 .         PUT IT INTO ONE    @E@@@VCBPSE1XO
)@@G@@   GLBL .                    START IS NOW IN A REG    @F@@@V         GSEXP
)@@G@@T    AGIM1+2*DCGSLT,AGRL1 . PUT ADDRESS WD INTO SUBSTR@#@@@V         GFIXQ
)@@G@@N .   @E@@@V         XGPOP   'SIZE',2*DCGSLT . POP START AND STRING     XR
)@@G@@@E@@@V         STORE   F,SGDISD .        SAVE FLAG FOR # OF ARGS  @D@@@VXS
)@@G@@         SET 12,ON,SGDID .         SAY PSEUDO VAR     @F@@@V         GOTXT
)@@G@@O    GGTRE0 .          RETURN TO XGEN WITH CLEAR CODE @^@@@V/.       UNSXU
)@@G@@PEC BIF     @[@@@V.     @#@@@VCBUNSX   LABEL .  @G@W@V         GNTR    2XV
)@@G@@ .               ENTRY POINT FOR VALUEMODE UNSPEC     @G@@@W         GNTXW
)@@G@@R    2 .               ENTRY POINT FOR VALUE MODE UNSPEC    @D@@@V      XX
)@@G@@   IF SD0ART,ON,SGDID THEN,CBUNS1 . ARITHMETIC? @#@@@V         GENM .   XY
)@@G@@@E@@@V         GINST   OPLA,AGRA3,AGRL1,U . GET ADDRESS OF ARG    @#@@@VXZ
)@@G@@         GLIT 1 . @E@@@V         LMJ     X11,BFUNSP .      CALL CHAR UNSYA
)@@G@@PEC ROUTINE @#@@@V         GFIN .   @F@W@V         GOTO    CBUNS3 .     YB
)@@G@@     MERGE WITH ARITH PROCESSING    @F@@@W         GOTO    CBUNS4 .     YC
)@@G@@     MERGE WITH ARITH PROCESSING    @#@@@VCBUNS1   LABEL .  @E@@@V      YD
)@@G@@   CGCONV  SGDAID SGDAID .   TAKE CARE OF CONSTANTS   @C@@@W         GASYE
)@@G@@GN   'TEMP'  R,X3 'COND','IFREG' .  @E@@@W         LINK    CNTBIT .     YF
)@@G@@     FIGURE OUT SIZE IN A7    @D@W@V         IF SDDCBN,OFF,SGDCLS THEN,CYG
)@@G@@BUNS2 . DECIMAL?  @D@W@V         IF SDFXFL,ON,SGDCLS THEN,CBUNS2 . FLOATYH
)@@G@@?     @E@W@V         GENM .                    HERE IT'S FIXED BINARY . YI
)@@G@@@C@W@V         GINST   OPLA,AGRA3,AGRL1 . GET ARG     @#@W@V         GLIYJ
)@@G@@T 1 . @D@W@V         LMJ     X11,BFUNSI .      IT IS AN INTEGER   @#@W@VYK
)@@G@@         GFIN .   @C@W@V         GOTO    CBUNS3 .          -> MERGE     YL
)@@G@@@E@W@VCBUNS2   LABEL .                   DOUBLE PRESCISION HERE   @#@W@VYM
)@@G@@         GENM .   @C@W@V         GDBLE   OPDL,AGRA3,AGRL1 . GET ARG     YN
)@@G@@@#@W@V         GLIT 1 . @E@W@V         LMJ     X11,BFUNSD .      CALL ROYO
)@@G@@UTINE FOR DOUBLE  @#@W@V         GFIN .   @#@W@VCBUNS3   LABEL .  @E@@@WYP
)@@G@@         OR      A7,GARBG3 .       GET LA,U A4,SIZE INST    @#@@@W      YQ
)@@G@@   GENM .   @^@@@W         GLITRG  A8 .   @D@@@W         GINST   OPLA,AGYR
)@@G@@RA3,AGRL1,U . POINT TO ARG    @^@@@W         GLIT    1 .    @C@@@W      YS
)@@G@@   LMJ     X11,BFUNSI .      CALL UNSPEC  @#@@@W         GFIN .   @E@@@WYT
)@@G@@CBUNS4   LABEL .                   MERGE HERE WITH STRINGS  @C@@@V      YU
)@@G@@   XGPOP .                   REMOVE ARG   @D@W@V         MOVE    SGDAID,YV
)@@G@@CBTSTR,2 . SET TEMP RESULT    @D@@@W         MOVE    SGDAID,CBTBIT,2 . SYW
)@@G@@ET TEMP RESULT    @D@@@VGGTRE0*  LABEL . COME HERE TO RETURN ZERO FOR GEYX
)@@G@@N CODE@A@@@V         MOVE    DCGSV2+9,0,I .     @^@@@V         GRTN    2YY
)@@G@@ .    @[@@@W.     @D@@@W.        FIGURE OUT LENGTH OF NUMERIC NUMBER IN YZ
)@@G@@A7    @[@@@W.     @E@@@WCNTBIT   LLOC .                    GET LENGTH OFZA
)@@G@@ NUMBER     @D@@@W         LOAD    A7,72,I .         ASSUME FLOAT OR DECZB
)@@G@@@D@@@W         IF SDDCBN,OFF,SGDCLS THEN,CBUNS2 . DECIMAL?  @D@@@W      ZC
)@@G@@   IF SDFXFL,ON,SGDCLS THEN,CBUNS2 . FLOAT?     @E@@@W         LOAD    AZD
)@@G@@7,36,I .         GET SIZE OF FIXED BIN    @E@@@WCBUNS2   LABEL .        ZE
)@@G@@           SIZE IN A7 IF REAL HERE  @D@@@W         IF SDRLCX,OFF,SGDCLS ZF
)@@G@@THEN,LJMP . IS IT REAL? @E@@@W         ADD     A7,A7 .           DOUBLE ZG
)@@G@@SIZE IF COMPLEX   @#@@@W         LJMP     @[@@@V.     @ @@@V.        MAXZH
)@@G@@ LENGTH FOR UNSPEC@[@@@V.     @#@@@VCMUNSX   LABEL .  @^@@@W         GNTZI
)@@G@@R    2 .    @E@@@W         MOVE    SGDAID+DCGSLT,CBTBIT . SET RETURN TO ZJ
)@@G@@BE BIT@F@@@W         IF      SD0ART,OFF,SGDAID THEN,CMUNS1 . IS IT STRINZK
)@@G@@G?    @F@@@W         LINK    CNTBIT .          GET LENTGH OF NUMBER INTOZL
)@@G@@ A7   @C@@@W         XGPOP .                   DROP ARG     @F@@@W      ZM
)@@G@@   GOTO    CBSLLA .          MAX LENGTH WITH A CONSTANT     @D@@@WCMUNS1ZN
)@@G@@   LABEL .                   STRING DATA HERE   @E@@@W         IF      SZO
)@@G@@DCHBT,ON,SGDCLS THEN,CMUNS2 . IS ARG BIT? @G@@@W         GENM .         ZP
)@@G@@           STRINGS RETURN NINE TMES THEIR LENGTH@D@@@W         GINST   OZQ
)@@G@@PLA,AGRA2,AGRL1,H1 . GET LENGTH     @C@@@W         GAPPN   MAXLEN .     ZR
)@@G@@     FIX FOR DV   @E@@@W         GGETT   AGRL2,2 .         GET SPACE FORZS
)@@G@@ A FAKE DV  @^@@@W         GLIT    1 .    @D@@@W         MSI,U   A2,9 . ZT
)@@G@@           GET RETURN LENGTH  @E@@@W         GINST   OPSA,AGRA2,AGRL2,H1ZU
)@@G@@ 'NO' . PUT INTO FAKE DV@C@@@W         GAPPN   MAXLEN .          FIX FORZV
)@@G@@ DV   @#@@@W         GFIN .   @C@@@W         XGPOP .                   DZW
)@@G@@ROP ARG     @D@@@W         GOTO    GGTRE0 .          RETURN CLEAR CODE  ZX
)@@G@@@^@W@V         GNTR    2 .    @F@W@V         GOTO    GGTRE0 .          HZY
)@@G@@AVEN'T FIGURED IT OUT YET     @A@@@W/.               CODE FOR UNSPEC PV ZZ
)@@G@@@[@@@W.     @[@@@W.     @#@@@WCSUNPV   LABEL .  @^@@@W         GNTR    2AA
)@@G@@ .    @#@@@W         GEN .    @D@@@W         GMOVE   +2,1 .            MAB
)@@G@@OVE THE STACK DOWN@F@@@W         XGPOP .                   AND THEN REMOAC
)@@G@@VE THE EXTRA ELT  @E@@@W         IF SD0ART,ON,SGDID THEN,CBUNP1 . IS IT AD
)@@G@@A STRING?   @B@@@W         LOADA   A7,BFUNPV .       YES    @E@@@W      AE
)@@G@@   MOVE    SGDID,010,I .     SET UNSPEC FOR STRING    @D@@@W         GOTAF
)@@G@@O    CBUNP4 .          MERGE WITH NUMBERS @A@@@WCBUNP1   LABEL . ARITHMEAG
)@@G@@TIC HERE    @E@@@W         LINK    CNTBIT .          GET COUNT OF SIZE IAH
)@@G@@NTO A7@D@@@W         STORE   A7,SGDCLS .       SET SIZE FOR LATER @E@@@WAI
)@@G@@         MOVE    SGDID,030,I .     SAY UNSPEC FOR NUMBERS   @E@@@W      AJ
)@@G@@   LOADA   A7,BFUNPI .       POINT TO NUMBERS ROUTINE @D@@@WCBUNP4   LABAK
)@@G@@EL .                   ALL MERGE HERE     @E@@@W         STORE   A7,SGDIAL
)@@G@@DS .       SAVE ADDRESS TO GO TO    @C@@@W         MOVE    SGDIBS,GARBG2AM
)@@G@@+FH1 . SET LMJ... @E@@@W         GOTO    GGTRE0 .          RETURN WITH CAN
)@@G@@LEAR CODE   @[@@@V/.    @A@@@V.        ICODE FOR TIME AND DATE    @[@@@VAO
)@@G@@.     @#@@@V         GMODE 'M'@#@@@VCBDATX   GLBL .   @^@@@V         GSUAP
)@@G@@B  'BILTN'  @#@@@V         GFIN     @[@@@V.     @[@@@V.     @[@@@V.     AQ
)@@G@@@E@@@VCBBTIM   GLBL .  MAX LENGTH MODE    ICODE FOR TIME AND DATE @ @W@VAR
)@@G@@         GGETGR AGRL1,1 .     @A@W@V         GINST OPLA,AGRL1,AGIM1,XU  AS
)@@G@@@A@@@W         GINST OPLA,AGRA3,AGIM1,U . @C@@@W         GGETT   AGRL1,2AT
)@@G@@ .         GET FAKE DV  @D@@@W         GINST   OPSA,AGRA3,AGRL1,H1 . PUTAU
)@@G@@ INTO DV    @C@@@W         GAPPN   MAXLEN .          FUDGE FOR DV @#@@@VAV
)@@G@@         GFIN .   @[@@@W.     @D@@@W.        CODE FOR CATENATE TO RETURNAW
)@@G@@ SUM OF LENGTHS   @[@@@W.     @#@@@WGGMSUM*  GLBL .   @D@@@W         GINAX
)@@G@@ST   OPLA,AGRA1,AGRL1,H1 . GET LENGTH     @C@@@W         GAPPN   MAXLEN AY
)@@G@@.          FIX TO BE DV @F@@@W         GINST   OPAA,AGRA1,AGRL2,H1 . ADDAZ
)@@G@@ LENGTH OF SECOND STRIN @C@@@W         GAPPN   MAXLEN .          FIX TO BA
)@@G@@BE DV @C@@@W         GGETT   AGRL2,2 .         GET A FAKE DV@F@@@W      BB
)@@G@@   GINST   OPSA,AGRA1,AGRL2,H1 . PUT LENGTH INTO FAKE DV    @D@@@W      BC
)@@G@@   GAPPN   MAXLEN .          FIX TO BE A DV     @^@@@W         GFIN    'BD
)@@G@@POP' .@[@@@W.     @B@@@W.        CODE TO FIX ADDRESSING FOR DV    @[@@@WBE
)@@G@@.     @#@@@WMAXLEN   LLOC .   @D@@@W         GMARK   A3 .              GBF
)@@G@@ET POINTER TO CODE@E@@@W         SUB     A3,1 .            POINT TO LASTBG
)@@G@@ INSTRUCTION@D@@@W         LOAD    A7,W1H2,A3 .      GET OFFSET FIELD   BH
)@@G@@@E@@@W         ADD     A7,1,I .          POINT TO SECOND WORD     @F@@@WBI
)@@G@@         STORE   A7,W1H2,A3 .      SET POINTER TO LENGTH FIELD    @#@@@WBJ
)@@G@@         LJMP .   @ @@@V/.       CONSTANTS NEEDED     @[@@@V.     @[@@@VBK
)@@G@@.     @F@@@V.                ADDRESS IN CGOS TO TAKE CARE OF VALUE/MAX MBL
)@@G@@ODE   @[@@@V.     @^@@@VCBSMLM   EQU   XGCMCC . @[@@@V.     @F@@@V.     BM
)@@G@@           THESE TWO WORD PACKETS ARE TO SET STACK ELTS     @E@@@V.     BN
)@@G@@                     TO HAVE THE PROPER ADDRESSES     @[@@@V.     @#@@@VBO
)@@G@@CBTSTR   SFW   0 .@ @@@V         +SD0STR,SDARST,0,0   @A@@@V         +AGBP
)@@G@@RX0-(IN 63,0,1,0),0     @E@@@VCBTBIT   SFW     0 .                RESULTBQ
)@@G@@ IS BIT STRING    @B@@@V         +SD0STR,SDARST++SDCHBT,0,0 .     @A@@@VBR
)@@G@@         +AGRX0-(IN 63,0,1,0),0     @^@@@VCBTCLT   SFW     0 .    @B@@@VBS
)@@G@@         +SD0STR,SDARST++SDVRCN,0,64 .    @B@@@V         +AGRX0-(IN 63,0BT
)@@G@@,1,0),BFCLAT .    @^@@@XCBONFS   SFW     0 .    @C@@@X         +SGDEXP++BU
)@@G@@SD0STR,SDARST++SDVRCN,0,0 .   @A@@@X         +AGRX10-(IN 63,0,1,0),0 .  BV
)@@G@@@F@@@VCBSBIT   SFW     0 .               STACK TOP FOR SOME AND EVERY   BW
)@@G@@@B@@@V         +SD0STR,SDARST++SDCHBT,0,0 .     @D@@@V         +AGRX10-(BX
)@@G@@IN 63,0,1,0),0 . SAY OFF OF X10     @[@@@V.     @B@@@V.        ATTRIBUTEBY
)@@G@@S FOR STACK ENTRIES     @[@@@V.     @D@@@VSUMIN    SFW     0 .          BZ
)@@G@@     ATTR FOR SUM BIF   @E@@@V         +SDVRCN++SD0ART,SDDCBN,0,35 . FIXCA
)@@G@@ED BIN CONSTANT   @D@@@VPRODIN   SFW     0 .               ATTR FOR PRODCB
)@@G@@ BIF  @E@@@V         +SDVRCN++SD0ART,SDFXFL,0,18 . SET TO FLOAT DEC?    CC
)@@G@@@^@@@VDCBCSM   SFW     0 .    @B@@@V         +SGDEXP++SD0ART,SDDCBN,0,17CD
)@@G@@ .    @A@@@VDCBCLN   SFW 0 . STACK ELT FOR 35,0 @D@@@V         +SGDEXP++CE
)@@G@@SD0ART,SDDCBN,0,35 . WHY SGDEXP?    @[@@@V.     @ @@@V.        WORDS FORCF
)@@G@@ NONPL1 MSGS@[@@@V.     @E@W@VGARBG1   SF      +015000001 .       PROPERCG
)@@G@@ U FIELD FUDGE    @F@@@WGARBG2   LMJ     X11,0 .           INSTRUCTION FCH
)@@G@@OR UNSPEC PV.     @F@@@WGARBG3*  LA,U    A4,0 .            INST FOR FUDGCI
)@@G@@E IN UNSPEC BIF   @D@@@VDCCSF$   INSERT  3,'CSF' .         CSF FUNCTION CJ
)@@G@@USED  @A@@@VDCBENF   INSERT  7,'END','FILE' .   @A@W@VDCBCLK   INSERT  1CK
)@@G@@0,'CLO','CK  ' .  @A@@@WDCBCLK   INSERT  5,'CLO','CK  ' .   @A@@@VDCBTRMCL
)@@G@@   INSERT  4,'TRI','M   ' .   @A@Y@XDCONST   INSERT  6,'ONS','TMT ' .   CM
)@@G@@@A@@@YONSTMG   INSERT  6,'ONS','TMT ' .   @C@@@VERXGRN    EQU  52 .     CN
)@@G@@   NON STANDARD PL1 USED@#@@@V         CEND .   @#@@@V          END .   CO
)@@G@@___      GGETT   AGRL2,2 .         GET SPACE FOR A FAKE DV  @^@@@W      CP
)@@G@@*[S@@@*SDFF*@C@@@L.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@LCQ
)@@G@@.     @D@@@L.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@LCR
)@@G@@.     @ @@@L.        MARVIN V. ZELKOWITZ  @B@@@L.        DEPARTMENT OF CCS
)@@G@@OMPUTER SCIENCE   @A@@@L.        UNIVERSITY OF MARYLAND     @B@@@L.     CT
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@L.     @G@@@L.        PERMISSIOCU
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@L.   REPRESENCV
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@L.     @G@@@L.     CW
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@LCX
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDCY
)@@G@@@E@@@L.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@LCZ
)@@G@@.     @F@@@L.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDDA
)@@G@@ED:   @[@@@L.     @G@@@L.        (A) ANY RESULTING PROGRAM, OR REPORT, PDB
)@@G@@APER OR DOCUMENTATION   @G@@@L.        DESCRIBING SUCH PROGRAM WILL CLEADC
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@L.        IS A DIALECT OF PLUM OR IS DD
)@@G@@DERIVED FROM PLUM, AND  @[@@@L.     @G@@@L.        (B) ALL SUCH MODIFICADE
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@L.        OF ERRORS IN THDF
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@L.        A BRIEF DESCRIPDG
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@L.        TO THE UNDH
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@L.     @F@@@L.        (C) NO PROGRAMSDI
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@L.        WITHOUT WRITTENDJ
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@L.     @F@@@L.     DK
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@L.     DL
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@LDM
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     DN
)@@G@@@E@@@L.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@LDO
)@@G@@.     @G@@@L.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERDP
)@@G@@ ITSELF,    @F@@@L.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN DQ
)@@G@@USING PLUM. @E@@@L.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USDR
)@@G@@ER TO @F@@@L.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRDS
)@@G@@ODUCT @G@@@L.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DT
)@@G@@DEVELOPED   @#@@@L.   FROM PLUM.    @[@@@L.     @[@@@L.     @[@@@L.     DU
)@@G@@@[@@@L.     @[@@@L.     @[@@@L/.    @#@@@L/        AXR$ .   @#@@@L      DV
)@@G@@   DCLRG .  @#@@@L@ADD,P PLTVDS     @#@@@L@ADD,P PLCGST     @#@@@L@ADD,PDW
)@@G@@ PLDSAW     @#@@@L         LIST .   @#@@@L         PLWORD . @#@@@L      DX
)@@G@@   PLAC .   @#@@@L         PLCGD .  @#@@@L         PLSD .   @#@@@L      DY
)@@G@@   PLIG .   @#@@@L         CEND .   @^@@@L/XGCG     CSECT 3 .     @ @@@MDZ
)@@G@@SUBSCR   EQU     DCONSU .     @D@@@MXGBSDU*  LABEL . UNARY RESOLVE, RESOEA
)@@G@@LVES TOP OF STACK @B@@@M                 . ASSUMES X7 PTS TO TOP  @ @@@MEB
)@@G@@         USING SGDSCT,X7 .    @E@@@M         IF SGDRES,OFF,SGDID THEN,LJEC
)@@G@@MP . VARIABLE NOT BSD   @#@@@M         LOCAL .  @E@@@M         SET     SED
)@@G@@GDRES,OFF,SGDID . TURN RESOLUTION BIT OFF @H@@@M         IF SGDPTR,OFF,SEE
)@@G@@GDID THEN,XGBSD2 .  -> IF NO EXPLICIT PTR PRESENT     @F@@@M         SETEF
)@@G@@     SGDPTR,OFF,SGDID .  TURN PTR PRESENT BIT OFF     @E@@@M         GENEG
)@@G@@ .                     PTR IS SECOND STACK ENTRY@D@@@M         GINST   OEH
)@@G@@PLA,AGRA3,AGRL2,U .  LA,U A3,PTRADDR@F@@@M         MOVE    SGDAID+DCGSLTEI
)@@G@@,SGDAID,DCGSLT . COLLAPSE STACK     @#@@@M         XGPOP .  @ @@@M      EJ
)@@G@@   GOTO    XGBSD3 .     @D@@@MXGBSD2   LABEL .                   GET IMPEK
)@@G@@LIED PTR    @ @@@M         LINK    XGBSDP .     @H@@@MXGBSD3   LABEL .  EL
)@@G@@                 GEN OTHER REQUIRED INSTRS, AND SET UP AWS  @ @@@M      EM
)@@G@@   LINK    XGBSAW .     @#@@@M         JMP .    @[@@@M .    @[@@@M .    EN
)@@G@@@[@@@M .    @I@@@MXGBSDP   LOCAL .                   GET IMPLIED PTR ANDEO
)@@G@@ USE TEMP AWS TO GEN INSTR    @D@@@M         LOAD    X6,SGDRSD .       LEP
)@@G@@OAD SD OF OPERAND @F@@@M        LINK    XGBSGS .          GET ROOT SD IFEQ
)@@G@@ STRUC MEMBER     @ @@@M         USING   SDSECT,X6    @E@@@M         LOAER
)@@G@@D    X6,SDBPTR .       GET SD OF IMPLIED PTR    @G@@@M         IF SDMEMSES
)@@G@@,ON,SDCLS2 THEN,XGBSP1 . IF MEM OF STRUCT NEED 2 AWS  @F@@@M         MOVET
)@@G@@E    AGXTMP,SDA1BS-FH1 . MOVE AW FROM SD TO TEMP AW   @ @@@M         GOTEU
)@@G@@O    XGBSP2 .     @C@@@MXGBSP1   LABEL .                    SET UP 2 AWSEV
)@@G@@@E@@@M         LOADA   A3,AGTMP2 . SET ONE TO PT TO THE OTHER     @^@@@MEW
)@@G@@         SLB     A3,18 .@ @@@M         STORE   A3,AGXTMP .  @C@@@M      EX
)@@G@@   MOVE    AGTMP2,SDA1BS-FH1 . AW FROM SD @#@@@MXGBSP2   LABEL .  @#@@@MEY
)@@G@@         GEN .    @B@@@M         GINST   OPLA,AGRA3,AGXTMP,U .    @#@@@MEZ
)@@G@@         JMP .    @[@@@M/.    @G@@@MXGBSAW   LOCAL .                   AFA
)@@G@@SSUMES X7-> ITEM BEING RESOLVED     @ @@@M         LOAD    X6,SGDRSD .  FB
)@@G@@@F@@@M         LINK    XGBSGS . GET SD OF VAR OR SD OF STRUCTURE NAME   FC
)@@G@@@#@@@M         GENM .   @D@@@M         GINST   OPLA,AGRA2,AGXR0,U .  LA,FD
)@@G@@U A2,SDADDR @D@@@M         GSUB    PTRVER .           LMJ X11,PTRVER    FE
)@@G@@@G@@@M         GGETGR  AGARL1 'X' .      GET XREG FOR RUNTIME ADDR RETURFF
)@@G@@NED   @E@@@M         GINST   OPLX,AGARL1,AGRA3 .  LOAD ADDR OF BSD ITEM FG
)@@G@@@#@@@M         GFIN .   @ @@@M         LOAD    X6,SGDRSD .  @ @@@M      FH
)@@G@@   USING   SDSECT,X6 .  @B@@@M         IF SDMEMS,ON,SDCLS2 THEN,XGBSW3 .FI
)@@G@@@A@@@MXGBSW1   LABEL . ENTRY FROM BELOW   @H@@@M         MOVE    SGDRDS,FJ
)@@G@@SDPROF .   0 IF SCALER, DISPL IF STRING IN STRUCT     @#@@@MXGBSW2   LABFK
)@@G@@EL .  @ @@@M         LOADA   A7,AGARL1 .  @F@@@M         STORE   A7,SGDRFL
)@@G@@BS        . SET THIS AW TO PT TO AUXIL AW @F@@@M         IF SDRLCX,OFF,SFM
)@@G@@DCLS1 THEN,JMP . IF REAL THEN FINISHED    @D@@@M         LOAD    A3,SDRTFN
)@@G@@C          . GET SIZE OF ITEM @D@@@M         SRB     A3,1 .            HFO
)@@G@@ALVE FOR IMAG SIZE@^@@@M         SLB     A7,18 .@D@@@M         ADD     AFP
)@@G@@7,A3 .           SET UP IMAG AW     @ @@@M         STORE   A7,AGIM1 .   FQ
)@@G@@@#@@@M         JMP .    @E@@@MXGBSW3   LABEL .                   SCALER FR
)@@G@@MEM OF STRUCT     @F@@@M         IF SDARST,ON,SDCLS1 THEN,XGBSW1 . STRINFS
)@@G@@G IN STRUC HAS DV @C@@@M         GEN .                     NEED 3RD AW  FT
)@@G@@@E@@@M         GSET    AGAIM1,AGARL1 .   USE AUXIL IMAG FOR RAW   @ @@@MFU
)@@G@@         LOADA   A3,AGAIM1 .  @E@@@M         STORE   A3,SGDRAB .       SFV
)@@G@@ET 2ND TO PT TO 3RD     @F@@@M         MOVE    SGDRAD,SDPROF .   DISPL FFW
)@@G@@ROM START OF STRUC DV   @ @@@M         MOVE    SGDRDS,0,I . @ @@@M      FX
)@@G@@   GOTO    XGBSW2 .     @E@@@M/. BINARY RESOLVE - RESOLVES TWO OPERANDS FY
)@@G@@ON TOP OF STACK   @#@@@MXGBSDB*  LOCAL .  @ @@@M         USING   SGDSCT,FZ
)@@G@@X7 .  @D@@@M         LINK    XGBSDU .          RESOLVE TOP OF STK @G@@@MGA
)@@G@@         IF SGDRES,OFF,SGDID+DCGSLT THEN,JMP . RETURN IF SECOND NOT BSD GB
)@@G@@@F@@@M         SET     SGDRES,OFF,SGDID+DCGSLT . TURN RESOLVE BIT OFF   GC
)@@G@@@ @@@M         STORE   X7,DXGSX7 .  @F@@@M         ADD     X7,DCGSLT,I .GD
)@@G@@     SET X7 TO PT TO 2ND STACK ENTRY@E@@@M         IF SGDPTR,OFF,SGDID TGE
)@@G@@HEN,XGBSB1 . IS PTR PRESENT   @E@@@M         SET     SGDPTR,OFF,SGDID . GF
)@@G@@SET PTR PRESENT BIT OFF @G@@@M         GEN .                     USE EXPGG
)@@G@@LICIT PTR AND COLLAPSE STACK  @D@@@M         GINST   OPLA,AGRA3,AGRL2,U GH
)@@G@@. LA,U A3,PTRADDR @D@@@M         LINK    XGBSPP .          DO THE COLLAPGI
)@@G@@SING  @ @@@M         GOTO    XGBSB2 .     @#@@@MXGBSB1   LABEL .  @D@@@MGJ
)@@G@@         LINK    XGBSDP .          GET IMPLIED PTR    @#@@@MXGBSB2   LABGK
)@@G@@EL .  @C@@@M         LINK    XGBSAW .          SET UP AWS   @ @@@M      GL
)@@G@@   LOAD    X7,DXGSX7 .  @D@@@M         JMP .                     RETURN GM
)@@G@@TO XGEN     @[@@@M .    @[@@@M .    @[@@@M .    @#@@@MXGBSPP     LOCAL .GN
)@@G@@@G@@@M          SUB    X7,DCGSLT,I .     POINT TO TOP OF STK FOR COLLAPSGO
)@@G@@ING   @D@@@M          MOVE    SGDAID+2*DCGSLT,SGDAID+DCGSLT,DCGSLT@C@@@MGP
)@@G@@          MOVE    SGDAID+DCGSLT,SGDAID,DCGSLT . @D@@@M          GENM .  GQ
)@@G@@THERE MIGHT BE A RAW IN TOP ENTRY   @B@@@M         GSET    AGARL2,AGARL1GR
)@@G@@  .  ?????  @A@@@M         GSET    AGAIM2,AGAIM1 .    @^@@@M         GFIGS
)@@G@@N 'POP' .   @ @@@M         STORE   X7,DXGSX7 .  @E@@@M         ADD     XGT
)@@G@@7,DCGSLT,I .     SET X7 TO PT TO 2ND ENTRY@#@@@M         JMP .    @A@@@MGU
)@@G@@/. ENTRY WHEN XGEN SEES AN OPERATOR @#@@@MXGBSDO*  LABEL .  @G@@@M      GV
)@@G@@   IF A8,EQ,ACPTQ,I THEN,LJMP .  CANT RESOLVE WHEN WE SEE '->'    @#@@@MGW
)@@G@@         LOCAL .  @G@@@M         IF A8,GE,ACNOT,I THEN,XGBSO1 .  SEE WHEGX
)@@G@@THER UNARY OR BINARY OP @C@@@M         LINK    XGBSDB .          BINARY GY
)@@G@@OP    @#@@@M         JMP .    @#@@@MXGBSO1   LABEL .  @C@@@M         LINGZ
)@@G@@K    XGBSDU .          UNARY OP     @#@@@M         JMP .    @H@@@M/. MULHA
)@@G@@TIPLE ASG-- X2 PTS INTO STACK OF LHSIDES. IT MAY PT TO AN OPERAND,OR AN HB
)@@G@@@G@@@M . EXPLICIT PTR IN WHICH CASE X2 MUST BE ADJUSTED TO PT TO THE OPEHC
)@@G@@RAND  @[@@@M .    @#@@@MXGBSDA*  LOCAL .  @ @@@M         STORE   X7,DXGSHD
)@@G@@X7 .  @ @@@M         USING   SGDSCT,X2 .  @E@@@M         . CHK IF STACK HE
)@@G@@ENTRY ABOVE HAS PTR PRESENT BIT ON  @E@@@M         SUB     X2,DCGSLT,I .HF
)@@G@@PT X2 ONE STACK ENTRY ABOVE   @F@@@M         IF SGDPTR,OFF,SGDID THEN,XGHG
)@@G@@BAS1 . -> IF NO PTR PRESENT   @D@@@M         SET     SGDPTR,OFF,SGDID . HH
)@@G@@TURN PTR BIT OFF  @^@@@M         LOAD    X7,X2 .@#@@@M         GEN .    HI
)@@G@@@D@@@M         GINST   OPLA,AGRA3,AGRL2,U . LA,U A3,PTRADDR @ @@@M      HJ
)@@G@@   GOTO    XGBAS2 .     @D@@@MXGBAS1   LABEL .                   NO PTR HK
)@@G@@PRESENT     @D@@@M         ADD     X2,DCGSLT,I .     UNDO ABOVE SUBT    HL
)@@G@@@E@@@M         IF SGDRES,OFF,SGDID THEN,XGBAS3 .  VAR NOT BSD     @^@@@MHM
)@@G@@         LOAD    X7,X2 .@D@@@M         LINK    XGBSDP .          GET IMPHN
)@@G@@LIED PTR    @#@@@MXGBAS2   LABEL .  @C@@@M         LINK    XGBSAW .     HO
)@@G@@     SET UP AWS   @E@@@M         SET     SGDRES,OFF,SGDID . TURN RESOLVEHP
)@@G@@ BIT OFF    @#@@@MXGBAS3   LABEL .  @B@@@M         LOAD    X7,DXGSX7 . RHQ
)@@G@@ESTORE X7   @E@@@M         JMP .                     RETURN TO XGEN TO DHR
)@@G@@O ASG @G@@@M/. ARRAYS WITH RUNTIME SUBSCRIPTING ARE RESOLVED HERE WHEN THS
)@@G@@HE RIGHT    @E@@@M . BRACKET IS SEEN IN XGEN. THERE MAY BE A PTR OPERATOHT
)@@G@@R     @E@@@M .  STILL UNSEEN IN THE BCODE WHICH MUST BE CHECKED FOR HEREHU
)@@G@@@#@@@MXGBSA1*  LOCAL .  @G@@@M         IF SUBSCR,ON,DCGONF THEN,XGBDA1 .HV
)@@G@@ -> IF ARRAY HAS SSC ENABLED  @C@@@M         GETC .                    LHW
)@@G@@OOK FOR '->'@A@@@M         IF A8,EQ,ACPTQ,I THEN,JMP .@ @@@M         LINHX
)@@G@@K    BCKPGC .     @#@@@M         JMP .    @ @@@MXGBDA1   LABEL . RESOLVEHY
)@@G@@ ARRAY@ @@@M         USING   SGDSCT,X7 .  @C@@@M         IF SGDRES,OFF,SHZ
)@@G@@GDID+DCGSLT THEN,JMP .  @B@@@M         SET     SGDRES,OFF,SGDID+DCGSLT .IA
)@@G@@@ @@@M         STORE   X7,DXGSX7 .  @G@@@M         ADD     X7,DCGSLT,I .IB
)@@G@@      ARRAY STACK ENTRY IS 2* REGULAR     @D@@@M         GETC .         IC
)@@G@@           LOOK FOR A '->'    @B@@@M         IF A8,EQ,ACPTQ,I THEN,XGBDAID
)@@G@@2 .   @ @@@M         LINK    BCKPGC .     @B@@@M         LINK    XGBSDP IE
)@@G@@. GET IMPLIED PTR @ @@@M         GOTO    XGBDA5 .     @B@@@MXGBDA2   LABIF
)@@G@@EL . EXPLICIT PTR PRESENT     @A@@@M         SET     SGDPTR,OFF,SGDID . IG
)@@G@@@#@@@M         GEN .    @B@@@M         GINST   OPLA,AGRA3,AGRL2,U .     IH
)@@G@@@ @@@M         SUB     X7,DCGSLT,I .@E@@@M         MOVE    SGDAID+2*DCGSII
)@@G@@LT,SGDAID+DCGSLT,DCGSLT .     @C@@@M         MOVE    SGDAID+DCGSLT,SGDAIIJ
)@@G@@D,DCGSLT .  @#@@@M         XGPOP .  @ @@@M         STORE   X7,DXGSX7 .  IK
)@@G@@@ @@@M         GOTO    XGBDA3 .     @#@@@MXGBDA5   LABEL .  @D@@@M      IL
)@@G@@   SUB     X7,DCGSLT,I . PT X7 TO TOP OF STK    @#@@@MXGBDA3   LABEL .  IM
)@@G@@@D@@@M         LOAD    X6,SGDRSD+DCGSLT . GET SD OF ARRAY   @ @@@M      IN
)@@G@@   LINK    XGBSGS .     @#@@@M         GENM .   @B@@@M         GINST   OIO
)@@G@@PLA,AGRA2,AGXR0,U .     @ @@@M         GSUB    PTRVER .     @ @@@M      IP
)@@G@@   GGETGR  AGARL1 'X' . @A@@@M         GINST   OPLX,AGARL1,AGRA3 .@#@@@MIQ
)@@G@@         GFIN .   @#@@@MXGBDA6   LABEL .  @ @@@M         LOADA   A3,SGDMIR
)@@G@@LR .  @^@@@M         SLB     A3,18 .@ @@@M         ADD A3,SDPROF,X6 .   IS
)@@G@@@D@@@M         STORE   A3,SGDDV .        STORE THE DV AW    @ @@@M      IT
)@@G@@   LOAD X7,DXGSX7 .     @#@@@M         JMP .    @[@@@M/.    @E@@@MXGBSA2IU
)@@G@@*  LABEL . ARRAYS WITH INLINE SUBSCRIPTING RESOLVE DVA@ @@@M         USIIV
)@@G@@NG   SGDSCT,X7 .  @F@@@M         IF SGDRES,OFF,SGDID+DCGSLT THEN,LJMP . IW
)@@G@@VAR NOT BASED     @B@@@M         SET     SGDRES,OFF,SGDID+DCGSLT .@#@@@MIX
)@@G@@         LOCAL .  @F@N@M         IF SD0PTR,OFF,SGDID+2*DCGSLT THEN,XGBRAIY
)@@G@@2 . NO PTR PRESENT@G@@@N         LOAD    A3,SGDID+2*DCGSLT . GET CLASS BIZ
)@@G@@ITS OF THING BELOW ARRAY@B@O@N         AND     A3,7,I . ISOLATE PTR BITSJA
)@@G@@@B@@@O         AND,U     A3,7 . ISOLATE PTR BITS@E@@@N         IF A4,NE,JB
)@@G@@7,I THEN,XGBRA2   . -> IF ITS NOT A PTR   @[@@@N.     @#@@@N. **********JC
)@@G@@***   @H@@@M . DO SOMETHING HERE TO FIND OUT IF THE PTR BEFORE THE ARRAYJD
)@@G@@ IS A QUALIFIER   @[@@@N.     @[@@@N.     @#@@@MXGBRA2   LABEL .  @F@@@MJE
)@@G@@         ADD     X7,DCGSLT,I . PT X7 TO 2ND HALF FOR NEXT ROUTINE @B@@@MJF
)@@G@@         LINK    XGBSDP .  GET IMPLIED PTR@ @@@M         SUB     X7,DCGSJG
)@@G@@LT,I .@A@@@M         LOAD    X6,SGDRSD+DCGSLT . @H@@@M         LINK    XJH
)@@G@@GBSGS .          GET SD OF VARIABLE OR OF STRUCTURE ROOT    @#@@@M      JI
)@@G@@   GENM .   @A@@@M         GINST,OPLA,AGRA2,AGXR0,U . @ @@@M         GSUJJ
)@@G@@B    PTRVER .     @ @@@M         GGETGR  AGRL1 'X' .  @A@@@M         GINJK
)@@G@@ST   OPLX,AGRL1,AGRA3 . @#@@@M         GFIN .   @ @@@M         LOADA   AJL
)@@G@@3,AGRL1 .   @^@@@M         SLB     A3,18 .@ @@@M         ADD     A3,SDPRJM
)@@G@@OF,X6 @ @@@M         STORE   A3,SGDDV .   @#@@@M         JMP .    @F@@@MJN
)@@G@@/. THIS GETS THE SD OF THE STRUCTURE NAME IF VAR IS  IN STRUCT .  @^@@@MJO
)@@G@@ . X6 HAS THE VAR SD.   @#@@@MXGBSGS   LLOC .   @ @@@M         USING   SJP
)@@G@@DSECT,X6 .  @C@@@M         IF SDMEMS,OFF,SDCLS2 THEN,XGBSG2 .     @#@@@MJQ
)@@G@@XGBSG1   LABEL .  @ @@@M         LOAD    A3,SDDAD .   @A@P@M         IF JR
)@@G@@A3,EQ,0 THEN,XGBSG2 .   @A@@@P         IF A3,EQ,0,I THEN,XGBSG2 . @^@@@MJS
)@@G@@         LOAD    X6,A3 .@ @@@M         GOTO    XGBSG1 .     @#@@@MXGBSG2JT
)@@G@@   LABEL .  @ @@@M         STORE   X6,AGX0OF .  @#@@@M         LJMP  .  JU
)@@G@@@[@@@M END .___LINK    XGBSDB .          BINARY OP    @#@@@M         JMPJV
)@@G@@ .    @#@@@MXGBSO1   LABEL .  @C@@@M         LINK    XGBSDU .          UJW
)@@G@@*[S@@@*SDFF*@C@@@F.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@FJX
)@@G@@.     @D@@@F.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@FJY
)@@G@@.     @ @@@F.        MARVIN V. ZELKOWITZ  @B@@@F.        DEPARTMENT OF CJZ
)@@G@@OMPUTER SCIENCE   @A@@@F.        UNIVERSITY OF MARYLAND     @B@@@F.     KA
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@F.     @G@@@F.        PERMISSIOKB
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@F.   REPRESENKC
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@F.     @G@@@F.     KD
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@FKE
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDKF
)@@G@@@E@@@F.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@FKG
)@@G@@.     @F@@@F.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDKH
)@@G@@ED:   @[@@@F.     @G@@@F.        (A) ANY RESULTING PROGRAM, OR REPORT, PKI
)@@G@@APER OR DOCUMENTATION   @G@@@F.        DESCRIBING SUCH PROGRAM WILL CLEAKJ
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@F.        IS A DIALECT OF PLUM OR IS KK
)@@G@@DERIVED FROM PLUM, AND  @[@@@F.     @G@@@F.        (B) ALL SUCH MODIFICAKL
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@F.        OF ERRORS IN THKM
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@F.        A BRIEF DESCRIPKN
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@F.        TO THE UNKO
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@F.     @F@@@F.        (C) NO PROGRAMSKP
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@F.        WITHOUT WRITTENKQ
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@F.     @F@@@F.     KR
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@F.     KS
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@FKT
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     KU
)@@G@@@E@@@F.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@FKV
)@@G@@.     @G@@@F.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERKW
)@@G@@ ITSELF,    @F@@@F.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN KX
)@@G@@USING PLUM. @E@@@F.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USKY
)@@G@@ER TO @F@@@F.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRKZ
)@@G@@ODUCT @G@@@F.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT LA
)@@G@@DEVELOPED   @#@@@F.   FROM PLUM.    @[@@@F.     @[@@@F.     @[@@@F.     LB
)@@G@@@[@@@F.     @[@@@F.     @[@@@F/.    @#@@@E         AXR$ .   @#@@@E      LC
)@@G@@   DCLRG .  @#@@@E         UNLIST . @#@@@E@ADD,P PLTVDS .   @#@@@E@ADD,PLD
)@@G@@ PLCGST .   @#@@@E@ADD,P PLDSAW .   @#@@@E          LIST .  @#@@@E      LE
)@@G@@    PLWORD .@#@@@E          PLCGD . @#@@@E          PLSD .  @#@@@E      LF
)@@G@@   PLAC .   @#@@@E          PLIG .  @#@@@ECGBF     CSECT 3. @[@@@E.     LG
)@@G@@@]@@@EFGLOG1*     @]@@@EFGLOG2*     @]@@@EFGSIND*     @]@@@EFGCOSD*     LH
)@@G@@@]@@@EFGTAND*     @[@@@E.     @[@@@E.     @ @@@EFILL(1)  SAC   GGTNOP,CBLI
)@@G@@B1RL .@^@@@EFILL(1)  SAC   CBBNOP,0 @[@@@E.     @C@@@E.        RAND FUNCLJ
)@@G@@TION - NON- PL/1 STANDARD     @[@@@E.     @[@@@E.     @ @@@EFGRAND*  SACLK
)@@G@@ GGTNOP,CBRAND    @^@@@EFILL(1)  SAC CBBNOP,0 . @[@@@E.     @[@@@E.     LL
)@@G@@@[@@@E.     @]@@@EFGEXPT*     @]@@@EFGLOGT*     @]@@@EFGTANT*     @]@@@ELM
)@@G@@FGSINT*     @]@@@EFGCOST*     @]@@@EFGSQRT*     @[@@@E.     @[@@@E.     LN
)@@G@@@[@@@E.     @ @@@EFILL(1)  SAC GGTNOP,CBB1RC    @^@@@EFILL(1)  SAC CBBNOLO
)@@G@@P,0   @[@@@E.     @[@@@E.     @B@@@EFGATAN* .                          ALP
)@@G@@RC TAN@[@@@E.     @[@@@E.     @ @@@EFILL(1)  SAC   GGTNOP,CBBATN  @^@@@ELQ
)@@G@@FILL(1)  SAC   CBBNOP,0 @[@@@E.     @[@@@E.     @D@@@EFGATND* .         LR
)@@G@@                 ARC TAN DEGREES    @[@@@E.     @[@@@E.     @ @@@EFILL(1LS
)@@G@@)  SAC   GGTNOP,CBBATD  @^@@@EFILL(1)  SAC   CBBNOP,0 @[@@@E.     @B@@@ELT
)@@G@@.                                  FLOOR  @[@@@E.     @]@@@EFGFLRT*     LU
)@@G@@@ @@@EFILL(1)  SAC   CBSIGN,CBSFLR  @D@@@EFILL(1)  SAC   CBXFLF,CBXFNP  LV
)@@G@@   . FLOAT , FIXED Q = 0@D@@@EFILL(1)  SAC   CBXFLQ,CBXFDQ     . FB Q<0,LW
)@@G@@ FD Q<0     @D@@@EFILL(1)  SAC   CBXFLR,CBXFFF     . FB Q>0, FD Q>0     LX
)@@G@@@[@@@E.     @[@@@E.     @B@@@E.                                  CEIL   LY
)@@G@@@[@@@E.     @]@@@EFGCEIL*     @ @@@EFILL(1)  SAC   CBSIGN,CBSCEL  @ @@@ELZ
)@@G@@FILL(1)  SAC   CBXFLC,CBXFNP  @ @@@EFILL(1)  SAC   CBXFLQ,CBXFDQ  @ @@@EMA
)@@G@@FILL(1)  SAC   CBXCEL,CBXFFC  @[@@@E.     @[@@@E.     @B@@@E.           MB
)@@G@@                       TRUNC  @]@@@EFGTRUN*     @ @@@EFILL(1)  SAC   CBSMC
)@@G@@IGN,CBSTRN  @ @@@EFILL(1)  SAC   CBXFTQ,CBXFNP  @ @@@EFILL(1)  SAC   CBXMD
)@@G@@FLQ,CBXFDQ  @ @@@EFILL(1)  SAC   CBXTRN,CBXFDP  @[@@@E.     @[@@@E.     ME
)@@G@@@[@@@E.     @B@@@EFGROUN* .                           ROUND @G@@@EFILL(1MF
)@@G@@)  SAC     GGTNOP,CBSRON .   ALL OF THE WORK IS DONE AT STAGEING  @ @@@EMG
)@@G@@FILL(1)  SAC     CBBNOP,0 .   @[@@@E.     @[@@@E.     @[@@@E.     @B@@@EMH
)@@G@@FGMAXT*  .                         MAX    @[@@@E.     @[@@@E.     @ @@@EMI
)@@G@@FILL(1)  SAC   GGTARI,BFSMAX .@ @@@EFILL(1)  SAC   BFFMIN,CBBNOP  @ @@@EMJ
)@@G@@FILL(1)  SAC   BFBMIN,CBBNOP  @[@@@E.     @[@@@E.     @B@@@EFGMINT*  .  MK
)@@G@@                       MIN    @[@@@E.     @[@@@E.     @ @@@EFILL(1)  SACML
)@@G@@   GGTARI,BFSMIN  @ @@@EFILL(1)  SAC   BFFMIN,CBBNOP  @ @@@EFILL(1)  SACMM
)@@G@@   BFBMIN,CBBNOP  @[@@@E.     @[@@@E.     @B@@@EFGMODT*  .              MN
)@@G@@           MOD BIF@[@@@E.     @[@@@E.     @ @@@EFILL(1)  SAC   BFTMOD,BFMO
)@@G@@SMOD  @ @@@EFILL(1)  SAC   BFMODF,CBBNOP  @ @@@EFILL(1)  SAC   BFMODB,CBMP
)@@G@@BNOP  @[@@@E.     @[@@@E.     @C@@@EFGABST* .                          AMQ
)@@G@@BSOLUTE VAL @[@@@E.     @[@@@E.     @ @@@EFILL(1)  SAC   CBTABS,CBSABS  MR
)@@G@@@ @@@EFILL(1)  SAC   CBABFR,CBBNOP .@H@@@EFILL(1)  SAC   CBABBR,CBBNOP .MS
)@@G@@     REAL ARE CODE, COMPLEX DONE AT STAGING     @[@@@E.     @[@@@E.     MT
)@@G@@@C@@@EFGSIGN* .                          SIGN BIF     @[@@@E.     @[@@@EMU
)@@G@@.     @A@@@EFILL(1)  SAC     CBSIGN,CSSIGN .    @A@@@EFILL(1)  SAC     CMV
)@@G@@BSGFR,CBBNOP .    @A@@@EFILL(1)  SAC     CBSGBR,CBBNOP .    @[@@@E.     MW
)@@G@@@[@@@E.     @E@@@E.                                  INLINE DATA TYPE BIMX
)@@G@@F'S   @B@@@EFGBINT*  .                         BINARY @B@@@EFGDECT*  .  MY
)@@G@@                       DECIMAL@B@@@EFGFIXD*  .                         FMZ
)@@G@@IXED  @B@@@EFGFLTT*  .                         FLOAT  @C@@@EFGPREC*  .  NA
)@@G@@                       PRECISION    @[@@@E.     @[@@@E.     @ @@@EFILL(1NB
)@@G@@)  SAC   CBCONV,GGSNOP .@ @@@EFILL(1)  SAC   CBBNOP,0 .     @[@@@E.     NC
)@@G@@@[@@@E.     @E@@@E.                                  REAL IMAG BIFS AND ND
)@@G@@P.V.  @[@@@E.     @]@@@EFGCPLE*     @[@@@E.     @[@@@E.     @C@@@EFILL(1NE
)@@G@@)  SAC   BFTMOD,GGSADS .     COMPLEX BIF  @ @G@EFILL(1)  SAC   CBCPLX,CBNF
)@@G@@CPLX .@ @@@GFILL(1)  SAC   CBCPLF,CBCPLF .@ @G@EFILL(1)  SAC   CBCPLX,CBNG
)@@G@@CPLX .@ @@@GFILL(1)  SAC   CBCPLB,CBCPLB .@[@@@E.     @[@@@E.     @C@@@ENH
)@@G@@FGCONJ* .                          CONJUGATE    @[@@@E.     @[@@@E.     NI
)@@G@@@ @@@EFILL(1)  SAC   CBTABS,GGSNOP .@ @@@EFILL(1)  SAC   CBCJGR,CBCJGF  NJ
)@@G@@@ @@@EFILL(1)  SAC   CBCJGR,CBCJGB  @[@@@E.     @[@@@E.     @C@@@EFGIMAGNK
)@@G@@* .                          IMAG BIF     @[@@@E.     @[@@@E.     @ @@@ENL
)@@G@@FILL(1)  SAC   CBTREL,GGSNOP .@^@@@EFILL(1)  SAC   CBIMG,0 .@[@@@E.     NM
)@@G@@@[@@@E.     @B@@@EFGRLPV* .                          REAL PV@C@@@EFGREALNN
)@@G@@* .                          REAL BIF     @[@@@E.     @[@@@E.     @ @@@ENO
)@@G@@FILL(1)  SAC   CBTREL,GGSNOP .@^@@@EFILL(1)  SAC   CBREL,0 .@[@@@E.     NP
)@@G@@@[@@@E.     @B@@@EFGIMPV*  .                         IMAG PV@[@@@E.     NQ
)@@G@@@[@@@E.     @ @@@EFILL(1)  SAC   CBTREL,GGSNOP .@ @@@EFILL(1)  SAC   CBINR
)@@G@@MAG,0 .     @[@@@E.     @[@@@E.     @A@@@E.         HBOUND, LBOUND AND DNS
)@@G@@IM    @]@@@EFGDIMT*     @]@@@EFGHBND*     @]@@@EFGLBND*     @[@@@E.     NT
)@@G@@@[@@@E.     @ @@@EFILL(1)   SAC   CBTDIM,GGSNOP @^@@@EFILL(1)   SAC   CBNU
)@@G@@DIM,0 @[@@@E.     @[@@@E.     @A@@@E/ .      MATHEMATICAL FUNCTIONS     NV
)@@G@@@[@@@E.     @B@@@E.        FUNCTIONS WITH 1 REAL ARGUMENT   @[@@@E.     NW
)@@G@@@[@@@E.     @^@@@E.        GENERATED CODE @[@@@E.     @A@@@E.        DL NX
)@@G@@   A3,REAL ARGUMENT     @ @@@E.        LMJ   X11,FUNCTION   @B@@@E.     NY
)@@G@@   DS    A3,TEMPORARY FOR RESULT    @[@@@E.     @[@@@E.     @D@@@E.     NZ
)@@G@@   STAGING (TARGETING AND CODE GEN ARE NO-OPS)  @[@@@E.     @[@@@E.     OA
)@@G@@@#@@@ECBRAND   LABEL .  @D@@@E         GNTR   2.                 RAND ENOB
)@@G@@TRY POINT   @E@@@E         NONPL1 XGFRND,DCBRND,CBBRL1 .   RAND NOT STANOC
)@@G@@DARD  @F@@@E         GOTO  CBBRL1 .            MERGE WITH REAL ARG ROUTIOD
)@@G@@NES   @#@@@ECBB1RL   LABEL .  @#@@@E         GNTR  2 .@#@@@ECBBRL1   LABOE
)@@G@@EL .  @F@@@E         IF    SDRLCX,OFF,SGDCLS THEN,CBBRL2 . -> REAL ARGUMOF
)@@G@@ENT   @D@@@E         SET   SDRLCX,OFF,SGDCLS . USE REAL PART ONLY @C@@@EOG
)@@G@@         EXERR EXERB1 LEVEL,2 . 'REAL PART USED'@]@@@E         GEN@^@@@EOH
)@@G@@         GFREE AGIM1    @#@@@ECBBRL2   LABEL .  @#@@@ECBBRL3   LABEL .  OI
)@@G@@@D@@@E         LOADA X2,SGDAID+DCGSLT .  POINT TO RESULT    @D@@@E      OJ
)@@G@@   MOVE  SGDAID+DCGSLT,SGDAID . SET RESULT AIDC @G@@@I         SET     SOK
)@@G@@GDSGN,OFF,SGDAID+DCGSLT . TURN OFF UNARY MINUS IN OPND@D@@@E         LINOL
)@@G@@K  CBSFLT .            SET RESULT TO FLOAT@#@@@ECBBRL5   LABEL .  @E@@@EOM
)@@G@@         IF    SDRLCX,OFF,SGDCLS THEN,CBBRL6 . ->REAL ARG.  @#@@@E      ON
)@@G@@   GEN .    @C@@@E         GDBLE OPDL,AGRA1,AGIM1 . LOAD IMAG PART@#@@@EOO
)@@G@@CBBRL6   LABEL .  @#@@@E         GENM .   @A@@@E         GDBLE OPDL,AGRAOP
)@@G@@3,AGRL1 .   @#@@@ECBBRL7   GLBL .   @^@@@E         GSUB  'BILTN'  @E@@@EOQ
)@@G@@CBBNOP   GLBL .                    USED FOR NO-OP ICODE     @#@@@E      OR
)@@G@@   GFIN .   @E@@@E         IF    SDRLCX,OFF,SGDCLS THEN,CBBRL8 . RESULT OS
)@@G@@REAL  @#@@@E         GENM     @E@@@E         GGETGR  AGIM2,2 .         GOT
)@@G@@ET REGISTERS FOR RESULT @B@@@E         GDBLE OPDS,AGRA1,AGIM2 'NO' .    OU
)@@G@@@#@@@E         GFIN .   @#@@@ECBBRL8   LABEL .  @#@@@E         GENM     OV
)@@G@@@E@@@E         GGETGR  AGRL2,2 .         GET A TWO WORD REGISTER  @B@@@EOW
)@@G@@         GDBLE OPDS,AGRA3,AGRL2 'NO' .    @#@@@E         GFIN .   @D@@@EOX
)@@G@@         XGPOP .                   POP OFF STACK ELT  @#@@@ECBBRL4*  LABOY
)@@G@@EL .  @A@@@E         MOVE  SGDID,SD0ART+SGDEXP,I@C@@@E         LOAD  X4,OZ
)@@G@@0,I .            SET ICODE    @^@@@E         GOTO  GGTRET . @[@@@E/.    PA
)@@G@@@E@@@E.        MATHEMATICAL FUNCTIONS WITH 1 ARG (REAL OR COMPLEX)@[@@@EPB
)@@G@@.     @[@@@E.     @^@@@E.        CODE GENERATED @[@@@E.     @ @@@E.     PC
)@@G@@   DL    A1,COMPLEX RG  @ @@@E.        DL    A3,REAL ARG    @B@@@E.     PD
)@@G@@   LMJ   X11,FUNCTION (REAL ARG)    @C@@@E.        LMJ   X11,FUNCTION+1 PE
)@@G@@(COMPLEX ARG)     @ @@@E.        DS    A3,REAL RESULT @A@@@E.        DS PF
)@@G@@   A1,COMPLEX RESULT    @[@@@E.     @H@@@ECBB1RC   LABEL .              PG
)@@G@@     STAGEING FOR ONE ARG (REAL OR COMPLEX)     @#@@@E         GNTR  2 .PH
)@@G@@@#@@@ECBBRC1   LABEL .  @E@@@E         IF    SDRLCX,OFF,SGDCLS THEN,CBBRPI
)@@G@@L2 . -> REAL ARG  @C@@@E         LOAD  A7,DXGARG .         COMPLEX ARG  PJ
)@@G@@@^@@@E         ADD   A7,1,I . @ @@@E         STORE A7,DXGARG .    @E@@@EPK
)@@G@@         GOTO  CBBRL3 .            PROCESS AS IN REAL PART  @[@@@E.     PL
)@@G@@@B@@@E.        FUNCTION TO CONVRT ARG TO FLOAT  @[@@@E.     @#@@@ECBSFLTPM
)@@G@@   LLOC .   @ @@@E         USING SGDSCT,X2 .    @D@@@E         MOVE  SGDPN
)@@G@@SCL,0,I .        NO SCALE FOR FLOAT @ @F@E         USING SGDSCT,X7 .    PO
)@@G@@@C@@@E         LOAD    A3,SGDCLS,X7 .    GET CLASS    @D@@@E         OR,PP
)@@G@@U    A3,SDFXFL .       TURN ON FLOAT BIT  @ @@@E         STORE A4,SGDCLSPQ
)@@G@@,X2 . @E@@@ECBSFL2   LOCAL .                   ALTERNATE ENTZY POINT    PR
)@@G@@@D@@@E         CGCONV  R,X2  R,X7 .      CONVERT TO FLOAT   @D@@@F      PS
)@@G@@   SET   SGDSGN,OFF,SGDCLS .  RESULT NOT NEG.   @ @@@F         USING SGDPT
)@@G@@SCT,X7 .    @#@@@E         JMP .    @[@@@E.     @^@@@E.        ARC TANGEPU
)@@G@@NT    @[@@@E.     @D@@@E.        ATAN 1 REAL OR COMPLEX ARG OR 2 REAL ARPV
)@@G@@GS    @[@@@E.     @ @@@E.        ENTRY POINT 1 = 1 ARG@ @@@E.        ENTPW
)@@G@@RY POINT 2 = 2 ARG@[@@@E.     @C@@@ECBBATD   LABEL .                   APX
)@@G@@TAND ENTRY  @#@@@E         GNTR  2 .@C@@@E         LOAD  A7,DXGNAR .    PY
)@@G@@     SEE IF 2 ARGS@E@@@E         IF    A7,EQ,DCGSLT,I THEN,CBBRL1 . -> IPZ
)@@G@@ REAL ARG   @D@@@E         LOAD  A7,DXGARG .         SET ENTRY POINT 2  QA
)@@G@@@^@@@E         ADD   A7,1,I . @#@@@ECBATD1   LABEL .  @ @@@E         STOQB
)@@G@@RE A7,DXGARG .    @E@@@E         IF    SDRLCX,OFF,SGDCLS THEN,CBATD2 . -QC
)@@G@@> ARG 2 REAL@A@@@E         SET   SDRLCX,OFF,SGDCLS .  @C@@@E         EXEQD
)@@G@@RR EXERB1 LEVEL,2 . 'REALPART USED' @]@@@E         GEN@^@@@E         GFRQE
)@@G@@EE AGIM1    @#@@@ECBATD2   LABEL .  @F@@@E         IF    SDRLCX,OFF,SGDCQF
)@@G@@LS+DCGSLT THEN,CBATD3 . ->ARG 1 REAL@B@@@E         SET   SDRLCX,OFF,SGDCQG
)@@G@@LS+DCGSLT . @C@@@E         EXERR EXERB1 LEVEL,2 . 'REAL PART USED'@#@@@EQH
)@@G@@         GEN .    @^@@@E         GFREE AGIM2 .  @#@@@ECBATD3   LABEL .  QI
)@@G@@@F@@@E         MOVE  SGDPRE+2*DCGSLT,SGDPRE . ARG 2 IS RESULTING PREC   QJ
)@@G@@@I@@@E         LOADA X2,SGDAID+2*DCGSLT .                    CONVERT ARGQK
)@@G@@ TO RESULTING     @^@@@E         LINK  CBSFLT . @D@@@E         XGPOP .  QL
)@@G@@                 POP ARG 2 FOR NOW  @C@@@E         LOADA X2,SGDAID+DCGSLQM
)@@G@@T .  CONVERT ARG 1@^@@@E         LINK  CBSFL2 . @D@@@E         SUB   X7,QN
)@@G@@DCGSLT,I .       GET ARG 2 BACK     @#@@@E         GENM .   @A@@@E      QO
)@@G@@   GDBLE  OPDL,AGRA3,AGRL2 .  @A@@@E         GDBLE  OPDL,AGRA1,AGRL1 .  QP
)@@G@@@^@@@E         GSUB  'BILTN'  @D@@@E         GGETGR  AGRL2+DCGSLT,2 .  GQQ
)@@G@@ET REAL REGISTER  @F@@@E         GDBLE  OPDS,AGRA3,AGRL2+DCGSLT 'NO' .  QR
)@@G@@       SET RESULT @#@@@E         GFIN .   @D@@@E         XGPOP   'SIZE',QS
)@@G@@2*DCGSLT . POP OFF TWO ARGS.  @C@@@E         GOTO  CBBRL4 .            -QT
)@@G@@>RETURN     @[@@@E.     @#@@@E.        ARCTAN   @^@@@E.        EP1=1 REAQU
)@@G@@L     @^@@@E.        EP2=1 COMPLEX  @^@@@E.        EP3=2 REAL     @[@@@EQV
)@@G@@.     @#@@@ECBBATN   LABEL .  @#@@@E         GNTR  2 .@D@@@E         LOAQW
)@@G@@D  A7,DXGNAR .         SEE HOW MANY ARGS  @D@@@E         IF    A7,EQ,DCGQX
)@@G@@SLT,I THEN,CBBRC1 . -> 1 ARG  @ @@@E         LOAD  A7,DXGARG .    @C@@@EQY
)@@G@@         ADD   A7,2,I .            ENTRY POINT 3@D@@@E         GOTO  CBAQZ
)@@G@@TD1 .            ->MERGE WITH ATAND @ @@@E/ .               INLINE BIF'SRA
)@@G@@@[@@@E.     @^@@@E.        ABSOLUTE VALUE @[@@@E.     @C@@@ECBTABS   LABRB
)@@G@@EL .                   TARGETING    @#@@@E         GNTR 2 . @A@@@E      RC
)@@G@@   CGCONV R,X7 R,X7 . SET X4  @I@@@E         MOVE  SGDAID+DCGSLT,SGDAID RD
)@@G@@.                 RESULTING TYPE IS TYPE OF     @^@@@E         GOTO  GGTRE
)@@G@@RET . @[@@@E.     @[@@@E.     @[@@@E.     @C@@@ECBSABS   LLOC .         RF
)@@G@@           STAGEING     @D@@@E         IF    SDRLCX,OFF,SGDCLS THEN,LJMPRG
)@@G@@ . -> REAL  @^@@@E         GNTR    2 .    @E@@@E         LOADA   X2,SGDARH
)@@G@@ID+DCGSLT . POINT TO ELT. FOR BIF   @E@@@E         MOVE    SGDAID+DCGSLTRI
)@@G@@,SGDAID . COPY ATTRIBUTES     @D@@@E         LINK    CBSFLT .          CRJ
)@@G@@ONVERT TO FLOAT   @E@@@E         GENM .                    COMPUTE (X**2RK
)@@G@@+Y**2)**1/2 @D@@@E         GIFR    CBSAB1,AGRL1 .    IS REAL IN REG?    RL
)@@G@@@D@@@E         GIFR    CBSAB2,AGIM1 .    IS IMAG IN REG?    @C@@@E      RM
)@@G@@   GLOAD   AGIM1,2 .         GET INTO REG @D@@@ECBSAB2   GLBL .         RN
)@@G@@           IMAG IN REG HERE   @D@@@E         GFLOAT  OPDFM,AGIM1,AGIM1 'RO
)@@G@@NO' . GET Y**2    @E@@@E         GDBLE   OPDL,AGRA3,AGRL1 . GET REAL INTRP
)@@G@@O A3-A4     @D@@@E         GFLOAT OPDFM,AGRA3,AGRA3 'NO' . GET X**2     RQ
)@@G@@@C@@@E         GFLOAT  OPDFA,AGRA3,AGIM1 . GET SUM    @C@@@E         GGORR
)@@G@@TO   CBSAB3 .          GO CALL SQRT @D@@@ECBSAB1   GLBL .               RS
)@@G@@     REAL PART IS IN REG@D@@@E         GFLOAT  OPDFM,AGRL1,AGRL1 'NO' . RT
)@@G@@GET X**2    @E@@@E         GDBLE   OPDL,AGRA3,AGIM1 . GET IMAG INTO A3-ARU
)@@G@@4     @D@@@E         GFLOAT  OPDFM,AGRA3,AGRA3 'NO' . GET Y**2    @C@@@ERV
)@@G@@         GFLOAT  OPDFA,AGRA3,AGRL1 . GET SUM    @D@@@ECBSAB3   GLBL .   RW
)@@G@@                 HERE TO CALL SQRT  @C@@@E         GSUB    BFSQRT .     RX
)@@G@@     COMPUTE SQRT @D@@@E         GGETGR  AGRL2,2 .         GET REG FOR RRY
)@@G@@ESULT @C@@@E         GDBLE   OPDS,AGRA3,AGRL2 . SAVE RESULT @#@@@E      RZ
)@@G@@   GFIN .   @D@@@E         XGPOP .                   POP OFF ARGUEMENT  SA
)@@G@@@E@F@E         SET     SDRLCX,OFF,SGDCLS . SAY RESULT IS REAL     @F@@@FSB
)@@G@@         SET     SDRLCX+SGDSGN,OFF,SGDCLS . SAY RESULT IS REAL    @D@@@ESC
)@@G@@         GOTO    GGTRET .          RETURN TO XGEN     @[@@@E.     @^@@@ESD
)@@G@@.        SIGN(N) BIF    @[@@@E.     @B@@@ECBSIGN   LABEL .  TARGETING FOSE
)@@G@@R SIGN BIF  @#@@@E         GNTR  2 .@F@@@E         LINK  CBRLCX .       SF
)@@G@@     CONVERT ARG TO REAL, IF IMAG   @#@@@ECBSGN2   LABEL .  @B@@@E      SG
)@@G@@   CGCONV R,X7 R,X7 .        SET X4 @#@@@ECBSGN3   LABEL .  @H@F@E      SH
)@@G@@   MOVE  SGDAID+DCGSLT,SGDAID .                  SET RESULTING DATA TYPESI
)@@G@@@B@@@E         GOTO  GGTRET .            DONE   @[@@@E.     @F@@@E.     SJ
)@@G@@    COMPLEX INPUT TO SIGN, GIVE ERROR AND USE ONLY REAL PART@[@@@E.     SK
)@@G@@@#@@@ECBRLCX   LLOC .   @E@@@E         IF    SDRLCX,OFF,SGDCLS THEN,LJMPSL
)@@G@@ . ->REAL ALREADY @#@@@E         LOCAL .  @E@@@E         SET     SDRLCX,SM
)@@G@@OFF,SGDCLS .  USE ONLY REAL PART    @#@@@E         GEN .    @^@@@E      SN
)@@G@@   GFREE   AGIM1 .@D@@@E         EXERR   EXERB1 LEVEL,2 .   'REAL PART USO
)@@G@@SED'  @C@@@E         JMP     .                 ->RETURN     @[@@@E.     SP
)@@G@@@[@@@E.     @[@@@E.     @B@@@ECSSIGN   LABEL .  STAGGING FOR SIGN BIF   SQ
)@@G@@@^@@@E         GNTR    2 .    @G@@@E         MOVE    SGDAID+DCGSLT,DCBCLSR
)@@G@@N .  SET RESULT TO FIXED BIN 35,0   @B@@@E         GOTO    GGTRET .     SS
)@@G@@      EXIT  @ @@@E/ .      HBOUND LBOUND AND DIM@[@@@E.     @[@@@E.     ST
)@@G@@@#@@@ECBTDIM   LLOC .   @#@@@E         GNTR  2. @F@@@E         CGCONV DCSU
)@@G@@BCSM R,X7 .         CONVERTT TO FIXED BIN(17,0) @E@@@E         LOADA X3,SV
)@@G@@SGDRBS .            SAVE ADDR OF ARG. 2   @E@@@E         STORE   X3,DCGSSW
)@@G@@V2+8 .     SAVE FOR RETURN TO XGEN  @#@@@E         XGPOP .  @D@@@E      SX
)@@G@@   LOAD  X2,SGDIBS+1 .          DIMENSIONALITY  @E@@@E         STORE   XSY
)@@G@@2,DCGSV2+3 .     SAVE FOR RETURN TO XGEN  @E@@@E         MOVE  SGDAID+DCSZ
)@@G@@GSLT,DCBCSM . SET RESULT DATA TYPE  @^@@@E         LOAD  X4,0,I . @C@@@ETA
)@@G@@         GOTO  GGTRET .               RETURN    @A@@@E/ .            MAXTB
)@@G@@ MIN AND MOD BIF'S@[@@@E.     @D@@@EBFSMAX   LLOC .                    STC
)@@G@@TAGING FOR MAX    @F@@@E         SET   IGPLUS,ON,DGFLGZ . SET FLAG FOR 'TD
)@@G@@JP' INSTRUCTION   @D@@@E         GOTO  BFSMNG .           CONTINUE STAGITE
)@@G@@NG    @F@@@EBFSMIN   LLOC .                   ENTRY POINT FOR STAGING FOTF
)@@G@@R MIN @F@@@E         SET   IGPLUS,OFF,DGFLGZ . SET FLAG FOR 'JN' INSTRUCTG
)@@G@@TION  @#@@@EBFSMNG   LABEL .  @#@@@E         GNTR  2 .@C@@@E         LOATH
)@@G@@D  X4,0,I .            CLEAR X4     @D@@@E         MOVE  AGLBL,0,I .    TI
)@@G@@     CLEAR AW FOR JUMPS @C@@@E         LOADA X3,AGLBL .          SET AW TJ
)@@G@@TO USE@D@@@E         STORE X3,DCGSV2+8 .       SET ICODE REG X3   @C@@@ETK
)@@G@@         LINK  CBRLCX .            MAKE ARG REAL@F@@@E         ADD   X7,TL
)@@G@@DCGSLT,I .       MOVE DOWN ONE STACK ELEMENT    @D@@@E         LINK  CBRTM
)@@G@@LCX .            MAKE ARG 2 REAL    @C@@@E         SUB   X7,DCGSLT,I .  TN
)@@G@@     RECOVER STACK@D@@@E         IF    SDFXFL,ON,SGDCLS THEN,GGSAD5 . ->TO
)@@G@@FLOAT @^@@@E         LOAD  X2,SGDPRE@F@@@E         SUB   X2,1,I .       TP
)@@G@@     STAGING PREC 1 LESS THAN + PREC@ @@@E         STORE X2,SGDPRE .    TQ
)@@G@@@A@@@E         LOAD  X2,SGDPRE+DCGSLT .   @^@@@E         SUB   X2,1,I . TR
)@@G@@@A@@@E         STORE X2,SGDPRE+DCGSLT .   @ @@@E         STORE X2,DGGPRETS
)@@G@@ .    @^@@@E         GOTO  GGSAD5 . @^@@@E/.       MOD TARGETTING @[@@@ETT
)@@G@@.     @[@@@E.     @[@@@E.     @#@@@EBFTMOD   LLOC .   @#@@@E         GNTTU
)@@G@@R  2 .@C@@@E         LINK  CBRLCX .            MAKE ARG REAL@F@@@E      TV
)@@G@@   ADD   X7,DCGSLT,I .       MOVE DOWN ONE STACK ELEMENT    @D@@@E      TW
)@@G@@   LINK  CBRLCX .            MAKE ARG 2 REAL    @C@@@E         SUB   X7,TX
)@@G@@DCGSLT,I .       RECOVER STACK@B@@@E         GOTO  GGTAR2 .            -TY
)@@G@@>MERGE@[@@@E.     @[@@@E.     @[@@@E.     @^@@@E.        MOD STAGING    TZ
)@@G@@@#@@@EBFSMOD   LLOC .   @#@@@E         GNTR  2 .@C@@@E         LOAD    AUA
)@@G@@8,0,I .          ASSUME FLOAT @C@@@E         IF    SDFXFL,ON THEN,BFSMO1UB
)@@G@@ . ->FLOAT  @D@@@E         LINK    GGSSCL .          SCALE TO SAME SCALEUC
)@@G@@@D@@@E         LOAD    A8,DGGSCP .       GET SCALE AND PRE  @D@@@E      UD
)@@G@@   SSA     A8,9 .            GET SIGNED SCALE   @D@@@EBFSMO1   LABEL .  UE
)@@G@@                 MERGE WITH FLOAT   @D@@@E         ADD     A8,SGDPRE .  UF
)@@G@@     GET P2+MAX(Q1,Q2)  @D@@@E         LOAD    A9,18,I .         ASSUME UG
)@@G@@DECIMAL     @D@@@E         IF SDDCBN,OFF THEN,BFSMO2 . IS IT DECIMAL    UH
)@@G@@@D@@@E         LOAD    A9,60,I .         ASSUME FLOAT BIN   @D@@@E      UI
)@@G@@   IF SDFXFL,ON THEN,BFSMO2 . IS IT FLOAT BIN   @D@@@E         LOAD    AUJ
)@@G@@9,35,I .         IT IS FIXED BIN    @F@@@EBFSMO2   LABEL .              UK
)@@G@@     MERGE HERE WITH MAX PRE IN A9  @E@@@E         IF A9,GE,A8 THEN,BFSMUL
)@@G@@O3 . IS COMPUTED PRE TOO BIG? @D@@@E         LOAD    A8,A9 .           YUM
)@@G@@ES,USE MAX PRE    @#@@@EBFSMO3   LABEL .  @E@@@E         MOVE    SGDAID+UN
)@@G@@2*DCGSLT,SGDAID+DCGSLT . SET RESULT @D@@@E         STORE   A8,SGDPRE+2*DUO
)@@G@@CGSLT . SET NEW PRE     @D@@@E         MOVE    SGDSCL+2*DCGSLT,DGGSCL . UP
)@@G@@SET SCALE   @E@@@E         MOVE    AGLBL,0,I .       CLEAR WORD FOR JUMPUQ
)@@G@@S     @D@@@E         GRTN    2 .               RETURN TO XGEN     @E@@@EUR
)@@G@@/ .            CONVERSION BIF'S (BIN, DEC, FIX, FLT, PREC)  @#@@@ECBCONVUS
)@@G@@   LABEL .  @#@@@E         GNTR  2 .@D@@@E         LOAD  A2,0,I .       UT
)@@G@@     SET PRECISION TO 0 @B@@@E         STORE A2,DGGSCP .         Q=0    UU
)@@G@@@D@@@E         LOAD  A3,DXGNAR .         GET NUMBER OF ARGS @E@@@E      UV
)@@G@@   DIV   A2,DCGSLT,I .       DIVIDE BY STACK SIZE     @D@@@E         LOAUW
)@@G@@D  X5,A2 .             SAVE NUMBER OF ARGS@D@@@E         GOTO  *$,A2 .  UX
)@@G@@           A2 IS AT LEAST 1   @C@@@E         +CBCNV1 .                 1UY
)@@G@@ ARG (X)    @C@@@E         +CBCNV2 .                 2 ARGS (X,P) @D@@@EUZ
)@@G@@         +CBCNV3 .                 3 ARGS (X,P,Q)     @[@@@E.     @[@@@EVA
)@@G@@.     @#@@@ECBCNV3   LABEL .  @D@@@E         LINK  CBCNST .            GVB
)@@G@@ET CONSTANT Q     @ @@@E         STORE A8,DGGSCL .    @#@@@ECBCNV2   LABVC
)@@G@@EL .  @D@@@E         LINK  CBCNST .            GET CONSTANTT P    @B@@@EVD
)@@G@@         STORE A8,DGGPRE .         SET P  @#@@@ECBCNV1   LABEL .  @D@@@EVE
)@@G@@         MOVE  DGGCLS,SGDCLS .     GET ATTR. OF X     @D@@@E         LOAVF
)@@G@@D  X4,X5 .             SAVE NUMBER OF ARGS@F@@@E         ADD   X5,DXGARGVG
)@@G@@ .         GET ADDRESS OF BRANCH  TABLE   @ @@@E         LOAD  X11,0,X5 VH
)@@G@@.     @^@@@E         LINK  0,X11 .  @I@@@E.                             VI
)@@G@@     RETURN FROM SETTING PROPER DATA TYPE FOR RESU    @D@@@E         CGCVJ
)@@G@@ONV DGGSTK R,X7 .      CONVERT ARGUMENT   @#@@@E         GEN .    @^@@@EVK
)@@G@@         GMOVE  2,1 .   @#@@@E         XGPOP .  @D@@@E         LOAD  X4,VL
)@@G@@0,I .            SET NO ICODE TOGEN @E@@@E         GOTO  GGTRET .       VM
)@@G@@     SET RESULT STACK ENTRY   @[@@@E.     @[@@@E.     @[@@@E.     @[@@@EVN
)@@G@@.     @[@@@E.     @D@@@EBFDECT*  EQU   $-1 .               DECIMAL ROUTIVO
)@@G@@NES   @C@@@E         +FGDEC1  .                DECIMAL (X)  @C@@@E      VP
)@@G@@   +FGDEC1  .                DECIMAL(X,P) @D@@@E         +FGDEC1  .     VQ
)@@G@@           DECIMAL(X,P,Q)     @[@@@E.     @^@@@EBFBINT*  EQU   $-1 .    VR
)@@G@@@C@@@E         +FGBIN1 .                 BINARY (X)   @C@@@E         +FGVS
)@@G@@BIN1 .                 BINARY (X,P) @C@@@E         +FGBIN1 .            VT
)@@G@@     BINARY(X,P,Q)@[@@@E.     @^@@@EBFFLTT*  EQU   $-1 .    @C@@@E      VU
)@@G@@   +FGFLT1 .                 FLOAT (X)    @C@@@E         +FGFLT2 .      VV
)@@G@@           FLOAT (X,P)  @E@@@E.        +FGFLT3 .                 FLOAT(XVW
)@@G@@,P,Q) ILLEGAL     @[@@@E.     @^@@@EBFFIXD*  EQU   $-1 .    @C@@@E      VX
)@@G@@   +FGFIX1 .                 FIXED (X)    @C@@@E         +FGFIX2 .      VY
)@@G@@           FIXED (X,P)  @C@@@E         +FGFIX2 .                 FIXED (VZ
)@@G@@X,P,Q)@[@@@E.     @^@@@EBFPREC*  EQU   $-1 .    @C@@@E         +FGPRC1 .WA
)@@G@@                 PRECISION(X) @D@@@E         +FGPRC2 .                 PWB
)@@G@@RECISION(X,P)     @D@@@E         +FGPRC3 .                 PRECISION(X,PWC
)@@G@@,Q)   @[@@@E.     @#@@@EFGDEC1   LABEL .  @E@@@E         SET   SDDCBN,OFWD
)@@G@@F,DGGCLS . SET RESULT TO DECIMAL    @D@@@E         GOTO  *BFPREC,X4 .   WE
)@@G@@     DO PRECISION PART  @[@@@E.     @#@@@EFGBIN1   LABEL .  @E@@@E      WF
)@@G@@   SET   SDDCBN,ON,DGGCLS .  SET RESULT TO BINARY     @C@@@E         GOTWG
)@@G@@O  *BFPREC,X4 .        DO PRECISION @[@@@E.     @#@@@EFGFLT1   LABEL .  WH
)@@G@@@B@@@E         LOAD  A7,6,I .            SET P=6@E@@@E         IF    SDDWI
)@@G@@CBN,OFF,DGGCLS THEN,FGFLT1X . ->NOT BINARY@F@@@E         LOAD  A7,27,I .WJ
)@@G@@           SET FLOAT BINARY PRECCSION     @#@@@EFGFLT1X  LABEL .  @B@@@EWK
)@@G@@         STORE A7,DGGPRE .         SET P  @#@@@EFGFLT2   LABEL .  @A@@@EWL
)@@G@@         SET   SDFXFL,ON,DGGCLS .   @C@@@E         LJMP .               WM
)@@G@@     ->RETURN     @[@@@E.     @[@@@E.     @#@@@EFGFIX1   LABEL .  @D@@@EWN
)@@G@@         LOAD  A7,5,I .            SET FIXED DEC P    @C@@@E         IF WO
)@@G@@   SDDCBN,OFF,DGGCLS THEN,FGTFX2 .  @D@@@E         LOAD  A7,35,I .      WP
)@@G@@     SET FIXED BIN PP   @#@@@EFGTFX2   LABEL .  @ @@@E         STORE A7,WQ
)@@G@@DGGPRE .    @#@@@EFGFIX2   LABEL .  @A@@@E         SET   SDFXFL,OFF,DGGCWR
)@@G@@LS .  @C@@@E         LJMP .                    ->RETURN     @[@@@E.     WS
)@@G@@@#@@@EFGPRC3   LABEL .  @E@@@E         IF    SDFXFL,OFF,DGGCLS THEN,LJMPWT
)@@G@@ . ->FIXED RESULT @[@@@E.     @F@@@E. Q SHOULD NOT BE EXPRESSED FOR FLOAWU
)@@G@@T (EXCEPT IF ZERO)!  ERROR?   @[@@@E.     @D@@@E         MOVE  DGGSCL,0,WV
)@@G@@I .      IGNORE Q FOR FLOAT   @#@@@EFGPRC2   LABEL .  @#@@@EFGPRC1   LABWW
)@@G@@EL .  @#@@@E         LJMP .   @[@@@E.     @[@@@E.     @[@@@E.     @E@@@EWX
)@@G@@.              ROUTINE TO GET CONSTANT VALUE FROM STACK     @[@@@E.     WY
)@@G@@@#@@@ECBCNST   LOCAL .  @G@@@E         IF    SDVRCN,ON,SGDCLS THEN,CBCNSWZ
)@@G@@8 . -> CONSTANT, SO FAR OK    @E@@@E         EXERR ERRG08 LEVEL,2 . ARG XA
)@@G@@SHOULD BE CONSTANTT     @B@@@E.                                  10 USEDXB
)@@G@@@#@@@ECBCNS6   LABEL .  @D@@@E         LOAD  A8,10,I .           SET DEFXC
)@@G@@AULT OF 10  @^@@@E         GOTO  CBCNS7 . @F@@@ECBCNS8   LABEL .        XD
)@@G@@           SET IS SMALL INTEGER CONSTANT  @F@@@E         IF    SDRLCX,OFXE
)@@G@@F,SGDCLS THEN,CBCNS1 . ->REAL CONSTTNT    @C@@@E         EXERR ERRG10 LEXF
)@@G@@VEL,1 . USE REAL PART   @]@@@E         GEN@ @@@E         GSET  AGRL1,AGIXG
)@@G@@M1 .  @#@@@ECBCNS1   LABEL .  @ @@@E         USING SDSECT,X4 .    @ @@@EXH
)@@G@@         LSDP  X4,SGDRSD .    @ @@@E         LOAD  A2,SDLCOF,X4 . @^@@@EXI
)@@G@@         USING WORD,A2 .@E@@@E         IF    SDFXFL,ON,SDCLS1 THEN,CBCNSXJ
)@@G@@9 . -> FLOAT CONST@^@@@E         SUB   A2,2,I . @F@@@E         IF    W1,XK
)@@G@@NZERO THEN,CBCNS9 . -> NOT FIXED BINARYCONST    @E@@@E         ADD   A2,XL
)@@G@@1,I .            POINT TO FIXED BINARY    @G@@@E         IF    SGDSCL,NZXM
)@@G@@ERO THEN,CBCNS3 . ->NOT INTEGER FIXED BINARY    @F@@@E         LOAD  A8,XN
)@@G@@W1 .             FINALLY GET FIXEDDBINARY VALUE @^@@@E         GOTO  CBCXO
)@@G@@NS4 . @#@@@ECBCNS9   LABEL .  @D@@@E         EXERR ERRG09 LEVEL,2 . NON XP
)@@G@@INTEGER VALUE     @D@@@E         GOTO  CBCNS6 ,            SET DEFAULT OXQ
)@@G@@F 10  @#@@@ECBCNS3   LABEL .  @C@@@E         LOAD  A8,W1 .             GXR
)@@G@@ET VALUE    @C@@@E         LOAD  A3,SGDSCL .         SET SCALE    @D@@@EXS
)@@G@@         SSA   A8,0,A3 .           SCALE TO INTEGER   @D@@@ECBCNS4   LABXT
)@@G@@EL .                   CHECK VALID VALUE  @E@@@E         IF    A8,GT,017XU
)@@G@@7777,I THEN,CBCNS9 . ->NO GOOD VALUE@E@@@E         IF    SGDSGN,OFF,SGDCXV
)@@G@@LS THEN,CBCNS7 . ->NOT COMPL. @C@@@E         LOADN   A8,A8 .           SXW
)@@G@@WITCH SIGN  @D@@@ECBCNS7   LABEL .                   SET RETURN VALUE   XX
)@@G@@@#@@@E         GENM     @^@@@E         GFREE AGRL1 .  @^@@@E         GFIXY
)@@G@@N  'POP'    @G@@@E         JMP .                     ->RETURN, VALUE IN XZ
)@@G@@A8, STACK POPPED  @B@@@E/ .      REAL AND IMAGINARY BIF'S AND PV'S@[@@@EYA
)@@G@@.     @[@@@E.     @#@@@ECBTREL   LABEL .  @#@@@E         GNTR 2.  @E@@@EYB
)@@G@@         MOVE  DGFLGZ,SGDCLS .     SET FLAGS FOR ICODER     @A@@@E      YC
)@@G@@   SET   SDRLCX,OFF,SGDCLS    @D@@@E         LOAD  X4,0,I .            SYD
)@@G@@ET ICODE TYPE     @^@@@E         GOTO  GGTRET . @#@@@E/.       ROUND    YE
)@@G@@@[@@@E.     @[@@@E.     @#@@@ECBSRON   LABEL .  @^@@@E         GNTR    2YF
)@@G@@ .    @E@@@E         LINK    CBRLCX .          SET CONSTANT TO REAL     YG
)@@G@@@D@@@E         LINK    CBCNST .          GET THE CONSTANT   @E@@@E      YH
)@@G@@   CGCONV  R,X7 R,X7 .       SET CONSTANTS STRAIGHT   @C@@@E         LOAYI
)@@G@@D    A7,SGDSCP .       GET SCALE,PRE@E@@@E         SSA     A7,9 .       YJ
)@@G@@     GET SIGN EXTENDED SCALE  @G@@@E         ANU     A8,A7 .           GYK
)@@G@@ET N-Q INTO A9         ************ @C@@@E         LOADM   A8,A8 .      YL
)@@G@@     GET ABS(N)   @D@@@E         LOAD    A6,SGDPRE .       GET PRE FOR TYM
)@@G@@ESTING@D@@@E         ADD     A6,1,I .          ROUND UPS THE PRE  @G@@@EYN
)@@G@@         SET IGPLUS++IGRLCX++IGMPDV,OFF,DGFLGZ . ASSUME REAL AND SCALINGYO
)@@G@@@E@@@E         IF SDRLCX,OFF,SGDCLS THEN,CBSRO1 . IS IT REAL?     @C@@@EYP
)@@G@@         SET     IGRLCX,ON,DGFLGZ . SAY COMPLEX @#@@@ECBSRO1   LABEL .  YQ
)@@G@@@E@@@E         IF SDDCBN,OFF,SGDCLS THEN,RONDF1 . IS IT DECIMAL?  @E@@@EYR
)@@G@@         IF SDFXFL,ON,SGDCLS THEN,RONBF1 . IS IT FLOAT BIN? @[@@@E.     YS
)@@G@@@^@@@E.        BIN FIXED HERE @G@@@E.                COMPUTE:          TYT
)@@G@@RUNC(A*2^(N-Q-1)+1/2)/2^(N-Q-1)     @F@@@E.                             YU
)@@G@@     =TRUNC(A*2^(N-Q)+1)/2^(N-Q)    @[@@@E.     @D@@@E         LOAD    AYV
)@@G@@3,34,I .         SET UP FOR CHECKING@D@@@E         LINK    RONCHK .     YW
)@@G@@     CHECK IF ARG OK    @C@@@E         LOADN   A9,A9 .           GET -(NYX
)@@G@@-Q)   @E@@@E         IF A9,LT,0,I THEN,RONEND . ROUND AT EXISTING DIGIT?YY
)@@G@@@F@@@E         IF A9,NE,0,I THEN,RONBX3 . INITIAL SHIFTING TO BE DONE   YZ
)@@G@@@E@@@E         SET     IGPLUS,ON,DGFLGZ . SAY NO INITIAL SHIFT    @D@@@EZA
)@@G@@RONBX3   LABEL .                   SET UP SHIFT COUNTS@E@@@E         STOZB
)@@G@@RE   A9,AGX0OF .       SET INITIAL SHIFT COUNT  @E@@@E         MOVE    AZC
)@@G@@GXTMP,AGXR0 .    SET TEMP ADDRESS WORD    @E@@@E         ADD     A9,1,I ZD
)@@G@@.          SHIFT BACK ONE EXTRA     @E@@@E         STORE   A9,AGX0OF .  ZE
)@@G@@     SET SHIFT BACK COUNT     @#@@@E         GENM .   @D@@@E         GBOZF
)@@G@@FF   RONBX6,IGRLCX .   IS IT COMPLEX?     @D@@@E         GIFR    RONBX4,ZG
)@@G@@AGIM1 .    IS IMAG IN REG?    @D@@@E         GLOAD   AGIM1,I .         GZH
)@@G@@ET IMAG INTO REG  @#@@@ERONBX4   GLBL .   @E@@@E         GBON    RONBX5,ZI
)@@G@@IGPLUS .   INITIAL SHIFT TO BE DONE?@E@@@E         GSHIN   OPSSA,AGIM1,AZJ
)@@G@@GXTMP 'NO' . SHIFT TO SCALE   @E@@@ERONBX5   GLBL .                    HZK
)@@G@@ERE IF NO INITIAL SHIFT @D@@@E         GINST   OPLA,AGRA3,AGRR12 'NO' . ZL
)@@G@@GET A ONE   @D@@@E         GINST   OPTP,AGRX0,AGIM1 'NO' .SEE IF POS    ZM
)@@G@@@E@@@E         GINST   OPLNA,AGRA3,AGRA3 'NO' . GET -1 IF NEG     @D@@@EZN
)@@G@@         GINST   OPAA,AGIM1,AGRA3 'NO' . ADD IN +- 1/2@C@@@E         GSHZO
)@@G@@IN   OPSSA,AGIM1,1,I 'NO' . TRUNCATE@D@@@E         GSHIN   OPLSSC,AGIM1,ZP
)@@G@@AGXR0 'NO' . RESCALE    @A@@@ERONBX6   GLBL .  HERE FOR REAL PART @D@@@EZQ
)@@G@@         GIFR    RONBX7,AGRL1 .    IS REAL PART IN REG@D@@@E         GLOZR
)@@G@@AD   AGRL1,1 .         GET IT INTO REG    @B@@@ERONBX7   GLBL .  REAL PAZS
)@@G@@RT NOW IN REG     @G@@@E         GBON    RONBX8,IGPLUS .   INITIAL SHIFTZT
)@@G@@ NEEDED FOR REAL PART?  @C@@@E         GSHIN   OPSSA,AGRL1,AGXTMP 'NO' .ZU
)@@G@@ SCALE@#@@@ERONBX8   GLBL .   @D@@@E         GINST   OPLA,AGRA3,AGRR12 'ZV
)@@G@@NO' . GET A ONE   @E@@@E         GINST   OPTP,AGRX0,AGRL1 'NO' . IS REALZW
)@@G@@ PART POS   @C@@@E         GINST   OPLNA,AGRA3,AGRA3 'NO' . GET -1@C@@@EZX
)@@G@@         GINST   OPAA,AGRL1,AGRA3 'NO' . ADD +-1@C@@@E         GSHIN   OZY
)@@G@@PSSA,AGRL1,1,I 'NO' . TRUNCATE@D@@@E         GSHIN   OPLSSC,AGRL1,AGXR0 ZZ
)@@G@@'NO' . RESCALE    @#@@@E         GFIN .   @A@@@ERONEND   LABEL . HERE TOAA
)@@G@@ FINISH UP  @#@@@E         GEN .    @E@@@E         GMOVE   +2,1 .       AB
)@@G@@     MOVE ARG ONTO BIF SGD    @A@@@E         XGPOP . POP OFF STACK TOP  AC
)@@G@@@D@@@E         LOAD    X4,0,I .          SET TO ONLY ICODE  @B@@@E      AD
)@@G@@   GOTO    GGTRET .          RETURN @D@@@ERONBF1   LABEL .              AE
)@@G@@     FLOAT BIN HERE     @[@@@E.     @G@@@E.        COMPUTE:             AF
)@@G@@     TRUNC(A*2^(N-Q-1)+1/2)/2^(N-Q-1)     @[@@@E.     @C@@@E         LOAAG
)@@G@@D    A3,59,I .         SET FOR CHECK@C@@@E         LINK    RONCHK .     AH
)@@G@@     GO CHECK ARG @C@F@E         SUB     A9,1,I .          GET N-Q-1    AI
)@@G@@@E@@@E         IF A9,EQ,0,I THEN,RONDF4 . IS ANY SHIFTING NEEDED  @F@@@EAJ
)@@G@@         ADD     A9,02000,I .      GET EXPONENT FOR FLOAT NUMBER  @D@@@EAK
)@@G@@         SLB     A9,1 .            MAKE ROOM FOR 1    @D@@@E         ADDAL
)@@G@@     A9,1,I .          GET SET FOR 020004 @F@@@E         STORE   A9,AGX0AM
)@@G@@OF .       PUT IT WHERE IT CAN BE GOTTEN  @#@@@E         GENM .   @F@@@EAN
)@@G@@         GINST   OPLA,AGRA2,AGXR0,U 'NO' . GET EXPONENT INTO REG  @F@@@EAO
)@@G@@         GSHIN   OPLDSL,AGRA1,59,I 'NO' . SHIFT TO PROPER POSITION@E@@@EAP
)@@G@@         GFIN .                    SCALING CONSTANT SET UP  @C@@@E      AQ
)@@G@@   LOADA   A3,A1 .           POINT TO A1  @E@@@E         STORE   A3,AGX0AR
)@@G@@OF .       SET TO POINT TO CONSTANT @E@@@E         GOTO    RONDF5 .     AS
)@@G@@     GO MERGE WITH DECIMAL    @E@@@ERONDF1   LABEL .                   HAT
)@@G@@ERE FOR DECIMAL ROUNDING@[@@@E.     @G@@@E.        COMPUTE:         TRUNAU
)@@G@@C(A*10^(N-Q-1)+SIGN(A)*.5)/10^(N-Q-1)     @[@@@E.     @D@@@E         LOAAV
)@@G@@D    A3,17,I .         SET FOR CHECK .    @C@@@E         LINK    RONCHK AW
)@@G@@.          CHECK PRE,ARG@C@F@E         SUB     A9,1,I .          COMPUTEAX
)@@G@@ N-Q-1@D@@@E         LOADM   A3,A9 .           GET MAG OF N-Q-1   @G@@@EAY
)@@G@@         ADD     A3,A3 .           GET 2*N-Q-1 FOR INDEX INTO TABLE     AZ
)@@G@@@E@@@E         LOADA   A8,KKPW10-2,A3 .  POINT TO POWER OF 10     @C@@@EBA
)@@G@@         STORE   A8,AGX0OF .       SET FOR ICODE@D@@@E         IF A9,NE,BB
)@@G@@0,I THEN,RONDF5 . NEED SCALING?     @D@@@ERONDF4   LABEL .              BC
)@@G@@     HERE IF NO SCALING @D@@@E         SET     IGPLUS,ON,DGFLGZ . SAY NOBD
)@@G@@ SCALING    @B@@@E         GOTO    RONDF6 .          MERGE  @E@@@ERONDF5BE
)@@G@@   LABEL .                   CHOOSE DIVIDE OR MULT    @D@@@E         IF BF
)@@G@@A9,GE,1,I THEN,RONDF6 . MUST MULTIPLY     @D@@@E         SET     IGMPDV,BG
)@@G@@ON,DGFLGZ . SAY TO DIVIDE     @ @@@ERONDF6   LABEL . START CODEGEN@#@@@EBH
)@@G@@         GENM .   @C@@@E         GBOFF   RONDX1,IGRLCX .   IS IT REAL?  BI
)@@G@@@D@@@E         GIFR    RONDF7,AGIM1 .    IS IMAG IN REG?    @C@@@E      BJ
)@@G@@   GLOAD   AGIM1,2 .         GET INTO REG @E@@@ERONDF7   GLBL .         BK
)@@G@@           IMAG PART NOW IN REG     @D@@@E         GBON    RONDF9,IGPLUSBL
)@@G@@ .   SCALING NEEDED?    @D@@@E         GBON    RONDF8,IGMPDV .   MULTIPLBM
)@@G@@Y OR DIVIDE?@F@@@E         GFLOAT  OPDFM,AGIM1,AGXR0 'NO' . MULTIPLY BY BN
)@@G@@SCALE FACTOR@E@@@E         GGOTO   RONDF9 .          FINISHED FIRST SCALBO
)@@G@@ING   @D@@@ERONDF8   GLBL .                    HERE TO DIVIDE     @D@@@EBP
)@@G@@         GFLOAT  OPDFD,AGIM1,AGXR0 'NO' . SCALE DOWN  @D@@@ERONDF9   GLBBQ
)@@G@@L .                    HERE TO ADD .5     @^@@@E         GLIT    1 .    BR
)@@G@@@B@@@E         DL      A3,KK5000 .       GET .5 @D@@@E         GINST   OBS
)@@G@@PTP,AGRX0,AGIM1 'NO' . SEE IF POS   @D@@@E         GDBLE   OPDLN,AGRA3,ABT
)@@G@@GRA3 'NO' . GET -.5     @C@@@E         GFLOAT  OPDFA,AGIM1,AGRA3 'NO' . BU
)@@G@@ADD .5@D@@@E         GFLOAT  OPDFA,AGIM1,AGXUNZ 'NO' . TRUNCATE   @D@@@EBV
)@@G@@         GBON    RONDX1,IGPLUS .   ANY SCALING NEEDED?@D@@@E         GBOBW
)@@G@@N    RONDF0,IGMPDV .   MULT OR DIVIDE?    @D@@@E         GFLOAT  OPDFD,ABX
)@@G@@GIM1,AGXR0 'NO' . UNSCALE     @C@@@E         GGOTO   RONDX1 .          NBY
)@@G@@OW DO REAL  @B@@@ERONDF0   GLBL .  HERE TO UNDO DIVISION    @D@@@E      BZ
)@@G@@   GFLOAT  OPDFM,AGIM1,AGXR0 'NO' . UNSCALE     @D@@@ERONDX1   GLBL .   CA
)@@G@@                 HERE FOR REAL PART @D@@@E         GBAL    CDXLDR .     CB
)@@G@@     LOAD REAL INTO REG @F@@@E         GBON    RONDX3,IGPLUS .   ANY INICC
)@@G@@TIAL SCALING NEEDED?    @D@@@E         GBON    RONDX2,IGMPDV .   MULT ORCD
)@@G@@ DIVIDE     @C@@@E         GFLOAT  OPDFM,AGRL1,AGXR0 'NO' . SCALE @ @@@ECE
)@@G@@         GGOTO   RONDX3 .     @F@@@ERONDX2   GLBL .                    HCF
)@@G@@ERE TO DIVIDE FOR SCALING     @C@@@E         GFLOAT  OPDFD,AGRL1,AGXR0 'CG
)@@G@@NO' . SCALE @D@@@ERONDX3   GLBL .                    HERE TO DO TRUNC   CH
)@@G@@@^@@@E         GLIT    1 .    @B@@@E         DL      A3,KK5000 .       GCI
)@@G@@ET .5 @D@@@E         GINST   OPTP,AGRX0,AGRL1 'NO' . SEE IF POS   @D@@@ECJ
)@@G@@         GDBLE   OPDLN,AGRA3,AGRA3 'NO' . GET -.5     @D@@@E         GFLCK
)@@G@@OAT  OPDFA,AGRL1,AGRA3 'NO' . ADD +- .5   @D@@@E         GFLOAT  OPDFA,ACL
)@@G@@GRL1,AGXUNZ 'NO' . TRUNCATE   @C@@@E         GBON    RONDX5,IGPLUS .   ACM
)@@G@@LL DONE?    @D@@@E         GBON    RONDX4,IGMPDV .   MULTIPLY OR DIVIDE?CN
)@@G@@@D@@@E         GFLOAT  OPDFD,AGRL1,AGXR0 'NO' . UNSCALE     @C@@@E      CO
)@@G@@   GGOTO   RONDX5 .          ALL DONE     @E@@@ERONDX4   GLBL .         CP
)@@G@@           HERE TO UNSCALE DIVIDE   @D@@@E         GFLOAT  OPDFM,AGRL1,ACQ
)@@G@@GXR0 'NO' . UNSCALE     @E@@@ERONDX5   GLBL .                    MERGE HCR
)@@G@@ERE WHEN DONE     @#@@@E         GFIN .   @E@@@E         GOTO    RONEND CS
)@@G@@.          MERGE WITH BIN FIXED     @F@@@ERONCHK   LLOC .        HERE TOCT
)@@G@@ CHECK COMPUTED PRE AND ARG SIZE    @ @@@E         USING   WORD,A3 .    CU
)@@G@@@D@@@E         IF A6,GE,W1U+2 THEN,RONCH1 . NEW PRE TOO BIG?@D@@@E      CV
)@@G@@   STORE   A6,SGDPRE .       ROUND UPS THE PRE  @#@@@ERONCH1   LABEL .  CW
)@@G@@@D@@@E         IF A8,LE,W1U THEN,LJMP .  ARG SMALL ENOUGH?  @D@@@E      CX
)@@G@@   LOCAL .                   CALL FOR ERROR MSG @F@@@E         EXERR EXRCY
)@@G@@OUN LEVEL,2 .    ARG TO ROUND TOO BIG. ONE USED @D@@@E         LOAD    ACZ
)@@G@@9,1,I .          GET REPLACEMENT ONE@C@@@E         SUB     A9,A7 .      DA
)@@G@@     GET N-Q AGAIN@B@@@E         JMP .                     RETURN @A@@@EDB
)@@G@@/ .            FLOOR, CEIL AND TRUNC@[@@@E.     @[@@@E.     @#@@@E.     DC
)@@G@@   STAGING  @[@@@E.     @D@@@E.         ON OUTPUT, X4 HAS THE FOLLOWING DD
)@@G@@VALUES:     @[@@@E.     @^@@@E.        X4  X        Q @ @@@E.        0  DE
)@@G@@ FLOAT    ANY     @^@@@E.        1   FIXED    0 @ @@@E.        2   FIXEDDF
)@@G@@ BIN <0     @ @@@E.        3   FIXED DEC <0     @ @@@E.        4   FIXEDDG
)@@G@@ BIN >0     @ @@@E.        5   FIXED DEC >0     @[@@@E.     @#@@@ECBSFLRDH
)@@G@@   LABEL .  @#@@@ECBSCEL   LABEL    @#@@@ECBSTRN   LABEL .  @#@@@E      DI
)@@G@@   GNTR  2 .@E@@@I         MOVE    SGDAID+DCGSLT,SGDAID . SET ATTR OF REDJ
)@@G@@SULT  @D@@@E         LOAD  X4,0,I .            ASSUME FLOAT RETURN@D@@@EDK
)@@G@@         IF    SDFXFL,ON,SGDCLS THEN,CBSTRX . -> FLOAT@D@@@E         STODL
)@@G@@RE X4,SGDSCL+DCGSLT .  SET RESULT Q=0     @B@@@E         ADD   X4,1,I . DM
)@@G@@           X4=1   @D@@@E         IF    SGDSCL,ZERO THEN,GGTRET . ->FIXEDDN
)@@G@@ Q=0  @[@@@E.     @B@@@E.        COMPUTE Q=MIN(N, MAX(P-Q+1,1) )  @[@@@EDO
)@@G@@.     @B@@@E         LOADN A7,SGDSCP .         -Q     @^@@@E         SSADP
)@@G@@   A7,9     @B@@@E         LOAD  A9,A7 .             SAVE -Q@B@@@E      DQ
)@@G@@   ADD   A7,SGDPRE .         P-Q    @B@@@E         IF    A7,LT,0,I THEN,DR
)@@G@@CBSCL1 .    @^@@@E         LOAD  A7,0,I . @C@@@ECBSCL1   LABEL .        DS
)@@G@@           MAX(P-Q,0)   @^@@@E         ADD   A7,1,I . @C@@@E         LOADT
)@@G@@D  A8,18,I .           SET MAX P    @C@@@E         IF    SDDCBN,OFF,SGDCDU
)@@G@@LS THEN,CBSCL2 .  @^@@@E         LOAD  A8,35,I .@#@@@ECBSCL2   LABEL .  DV
)@@G@@@B@@@E         IF    A7,LT,A8 THEN,CBSFL5 .     @^@@@E         LOAD  A7,DW
)@@G@@A8 .  @C@@@ECBSFL5   LABEL .                   A7=PRECISION @A@@@E      DX
)@@G@@   STORE A7,SGDPRE+DCGSLT .   @B@@@E         ADD   X4,1,I .            XDY
)@@G@@4=2   @C@@@E         STORE A9,AGX0OF .         ASSUME Q<0   @F@@@E      DZ
)@@G@@   IF    SDDCBN,OFF,SGDCLS THEN,CBSFL3 . ->DECIMAL DATA     @B@@@E      EA
)@@G@@   IF    A9,GE,0,I THEN,GGTRET .    @E@@@E         STOREN  A9,DCGSV2+3 .EB
)@@G@@     SET TO RETURN Q TO ICODE @B@@@E         ADD   X4,2,I .            XEC
)@@G@@4=4   @C@@@E         ADD   A9,36,I .           GET 36-Q     @D@@@E      ED
)@@G@@   STORE A9,AGX0OF .         SET SHIFT FACTOR   @^@@@E         GOTO  GGTEE
)@@G@@RET . @#@@@ECBSFL3   LABEL .  @B@@@E         ADD   X4,1,I .            XEF
)@@G@@4=3   @B@@@E         IF    A9,GE,0,I THEN,CBSFL4 . Q<0@^@@@E         LOAEG
)@@G@@DN A9,A9 .  @B@@@E         ADD   X4,2,I .            X4=5   @#@@@ECBSFL4EH
)@@G@@   LABEL .  @E@@@E         LOADA A8,KKPW10-2 .       POINT TO 10**(ABS(QEI
)@@G@@))    @^@@@E         ADD   A8,A9 .  @C@@@E         ADD   A8,A9 .        EJ
)@@G@@     2*Q IS OFFSET@ @@@E         STORE A8,AGX0OF .    @C@@@E         GOTEK
)@@G@@O  GGTRET .            ->RETURN     @D@@@ECBSTRX   LABEL .              EL
)@@G@@     FLOAT OPERATION    @ @@@E         LOADA A7,KK9999 .    @ @@@E      EM
)@@G@@   STORE A7,AGX0OF .    @^@@@E         GOTO  GGTRET . @[@@@E.     @[@@@EEN
)@@G@@.     @[@@@E/.    @^@@@E.         ICODE FOR SIGN@[@@@E.     @#@@@ECBSGFREO
)@@G@@   GLBL .   @B@@@E         GSHIN    OPDLSC,AGRA1,AGRL1 .    @^@@@E      EP
)@@G@@   GLIT    1 .    @^@@@E         SSA     A1,34 .@ @@@E         GGETGR  AEQ
)@@G@@GRL2,1 .    @A@@@E         GINST   OPLA,AGRL2,AGRA1 . @^@@@E         GFIER
)@@G@@N    'POP' .@#@@@ECBSGBR   GLBL .   @D@@@E         GIFR    CBSGB1,AGRL1 ES
)@@G@@.    IF RL1 IN REG?     @ @@@E         GGETGR  AGRL2,1 .    @B@@@E      ET
)@@G@@   GSHIN    OPLSC,AGRL2,AGRL1 .     @B@@@E         GGOTO   CBSGB2 .     EU
)@@G@@     MERGE  @C@@@ECBSGB1   GLBL .                    RL1 IS IN REG@B@@@EEV
)@@G@@         GSHIN   OPLSC,AGRL1,AGRL1 'NO' . @ @@@E         GSET    AGRL2,AEW
)@@G@@GRL1 .@#@@@ECBSGB2   GLBL .   @A@@@E         GSHIN    OPSSA,AGRL2,34,I .EX
)@@G@@@^@@@E         GFIN    'POP' .@[@@@E.     @^@@@E.        ICODES  FOR ABSEY
)@@G@@@[@@@E.     @C@@@E         GMODE 'M' .     PACK ICODES TOGETHER   @#@@@EEZ
)@@G@@CBABFR   GLBL .   @ @@@E         GIFR  CBABF2,AGRL1 . @ @@@E         GGEFA
)@@G@@TGR AGRL2,2 .     @A@@@E         GDBLE OPDLM,AGRL2,AGRL1 .  @^@@@E      FB
)@@G@@   GFIN 'POP'     @#@@@ECBABF2   GLBL .   @C@@@E         GDBLE OPDLM,AGRFC
)@@G@@L1,AGRL1 'NO' . ABS     @ @@@E         GSET  AGRL2,AGRL1 .  @^@@@E      FD
)@@G@@   GFIN  'POP'    @[@@@E.     @#@@@ECBABBR   GLBL     @ @@@E         GIFFE
)@@G@@R  CBABB2,AGRL1 . @^@@@E         GGETGR AGRL2,1 @A@@@E         GINST OPLFF
)@@G@@MA,AGRL2,AGRL1    @^@@@E         GFIN  'POP'    @#@@@ECBABB2   GLBL .   FG
)@@G@@@B@@@E         GINST OPLMA,AGRL1,AGRL1 'NO'     @ @@@E         GSET    AFH
)@@G@@GRL2,AGRL1 .@E@@@E         GFIN    'POP' .           POP STACK AND RETURFI
)@@G@@N     @[@@@E.     @F@@@E.                                  ICODE FOR HBOFJ
)@@G@@UND,LBOUND &  DIM @[@@@E.     @#@@@ECBDIM   GLBL .    @E@@@E         GINFK
)@@G@@ST OPLA,AGRA3,AGRL1,U     . DV OF ARGUMENT ARRAY@C@@@E          GINST OPFL
)@@G@@LA,AGRA2,AGPTX3 .   ARG2 ->A2 @^@@@E         GSUB  'BILTN'  @^@@@E      FM
)@@G@@   GLITRG A9 .    @^@@@E         GGETGR AGRL2   @A@@@E         GINST OPLFN
)@@G@@A,AGRL2,AGRA3 .   @^@@@E         GFIN  'POP'    @[@@@E.     @D@@@E.     FO
)@@G@@                             ICODE FOR MAX/MIN  @[@@@E.     @#@@@E      FP
)@@G@@   GMODE 'M'@#@@@EBFFMIN   GLBL     @C@@@E         GIFR BFFMX1,AGRL2 .  FQ
)@@G@@     SET IN REG   @^@@@E         GLOAD AGRL2,2  @#@@@EBFFMX1   GLBL     FR
)@@G@@@C@@@E         GDBLE OPDL,AGRA3,AGRL2 'NO' .  DL  A3,Y@C@@@E         GFLFS
)@@G@@OAT OPDFAN,AGRA3,AGRL1 'NO' . A3=Y-X@F@@@E         GBON  BFFMX5,IGPLUS .FT
)@@G@@      SHOULD IT BE A 'JP' OR A 'JN'?@H@@@E         GCJMP OPJN,AGRA3,AGPTFU
)@@G@@X3 .  GENERATE A 'JN' FOR THE 'MIN' FUNCTION    @E@@@E         GGOTO BFFFV
)@@G@@MX6 .             CONTINUE CODE GENERATION@#@@@EBFFMX5   GLBL .   @H@@@EFW
)@@G@@         GCJMP OPJP,AGRA3,AGPTX3 . GENERATE A 'JP' FOR THE 'MAX' FUNCTIOFX
)@@G@@N     @#@@@EBFFMX6   GLBL .   @D@@@E         GDBLE OPDL,AGRL2,AGRL1 .  SFY
)@@G@@WITCH X AND Y     @E@@@E         GGOTO BFFMX2 .            CONTINUE CODEFZ
)@@G@@ GENERATION @D@@@EBFBMIN   GLBL .                    BINARY MAX AND MIN GA
)@@G@@@ @@@E         GIFR  BFFMX3,AGRL2   @^@@@E         GLOAD AGRL2,1  @#@@@EGB
)@@G@@BFFMX3   GLBL     @B@@@E         GINST OPLA,AGRA3,AGRL2 'NO' .    @B@@@EGC
)@@G@@         GINST OPANA,AGRA3,AGRL1 'NO' .   @F@@@E         GBON  BFFMX7,IGGD
)@@G@@PLUS .      SHOULD IT BE A 'JP' OR A 'JN'?@H@@@E         GCJMP OPJN,AGRAGE
)@@G@@3,AGPTX3 .  GENERATE A 'JN' FOR THE 'MIN' FUNCTION    @E@@@E         GGOGF
)@@G@@TO BFFMX8 .             CONTINUE CODE GENERATION@#@@@EBFFMX7   GLBL .   GG
)@@G@@@H@@@E         GCJMP OPJP,AGRA3,AGPTX3 .  GENERATE A 'JP' FOR THE 'MAX' GH
)@@G@@FUNCTION    @#@@@EBFFMX8   GLBL .   @A@@@E         GINST OPLA,AGRL2,AGRLGI
)@@G@@1 .   @D@@@EBFFMX2   GLBL .                    CLEAN UP EVERYTHING@ @@@EGJ
)@@G@@         GLABEL  AGPTX3 .     @F@@@E         GAPPN BFMINMORE . SEE IF ANGK
)@@G@@Y MORE MAX AND MIN INNARG     @C@@@E         GSET  AGRL2,AGRL1 . MOVE ANGL
)@@G@@S TO SLOT   @#@@@EBFFMX4   GLBL .   @^@@@E         GFIN  'POP' .  @H@@@EGM
)@@G@@BFMINMORE GLBL .                                       SET IF ANY MORE IGN
)@@G@@N LST @ @@@E         LOAD  A3,DXGNAR .    @ @@@E         SUB   A3,DCGSLTGO
)@@G@@,I .  @D@@@E         IF    A3,LE,DCGSLT,I  THEN,BFMIN9 .  --> DONE@ @@@EGP
)@@G@@         STORE A3,DXGNAR .    @A@@@E         SET   DCGRPT,ON,DCGFLG .   GQ
)@@G@@@D@@@E         SETL A4,5,I .             IGNORE NEXT ICODE  @#@@@EBFMIN8GR
)@@G@@   LABEL .  @#@@@E         GETC .   @^@@@E         LOOP A4,BFMIN8 @#@@@EGS
)@@G@@         LJMP     @#@@@EBFMIN9   LABEL.   @C@@@E         XGPOP .        GT
)@@G@@           RESET STACK  @B@@@E         MOVE  SGDAID+DCGSLT,SGDAID .     GU
)@@G@@@#@@@E         LJMP .   @[@@@E.     @E@@@E.                             GV
)@@G@@     REAL AND IMAG BIFS & PV'S@[@@@E.     @#@@@E         GMODE 'M'@#@@@EGW
)@@G@@CBIMAG   GLBL     @C@@@E         GBON  CBIMG1,SDRLCX .->COMPLEX ARG     GX
)@@G@@@#@@@ECBREL    GLBL     @B@@@E         GBOFF CBREL1,SDRLCX . ->REAL     GY
)@@G@@@D@@@E         GFREE AGIM1 .             FREE IMAG PART     @#@@@ECBREL1GZ
)@@G@@   GLBL .   @^@@@E         GMOVE +2,1 .   @^@@@E         GFIN 'POP' .   HA
)@@G@@@#@@@ECBIMG    GLBL     @ @@@E         GBON  CBIMG1,SDRLCX  @C@@@E      HB
)@@G@@   GSET  AGIM1,AGDZRO .      SET IMAG TO 0@#@@@ECBIMG1   GLBL .   @^@@@EHC
)@@G@@         GFREE AGRL1 .  @ @@@E         GSET  AGRL1,AGIM1 .  @^@@@E      HD
)@@G@@   GGOTO CBREL1 . @[@@@E.     @[@@@E.     @[@@@E.     @[@@@E.     @#@G@EHE
)@@G@@CBCPLX   GLBL     @C@G@E         GSET  AGIM2,AGRL1 .       COMPLEX BIF  HF
)@@G@@@F@G@E         GAPPN CBPLXA .            SET IMAG RESULT, POP STACK     HG
)@@G@@@^@G@E         GMOVE +2,1 .   @^@G@E         GFIN  'POP' .  @#@@@GCBCPLFHH
)@@G@@   GLBL .   @D@@@G         GIFR    CBCP10,AGRL1 .    IMAG PART IN REG?  HI
)@@G@@@ @@@G         GGETGR  AGXTMP,2 .   @A@@@G         GDBLE   OPDL,AGXTMP,AHJ
)@@G@@GRL1 .@#@@@GCBCP10   GLBL .   @E@@@G         GSET    AGIM2,AGXTMP .    MHK
)@@G@@OVE RESULT TO STACK     @ @H@G         GAPPN   CBCPLXA .    @ @@@H      HL
)@@G@@   GAPPN   CBPLXA .     @^@@@G         GMOVE   +2,1 . @^@@@G         GFIHM
)@@G@@N    'POP' .@[@@@G.     @[@@@G.     @#@@@GCBCPLB   GLBL .   @A@@@G      HN
)@@G@@   GIFR    CBCP10,AGRL1 .     @ @@@G         GGETGR  AGXTMP,1 .   @A@@@GHO
)@@G@@         GINST   OPLA,AGXTMP,AGRL1 .@ @@@G         GGOTO   CBCP10 .     HP
)@@G@@@#@@@ECBPLXA   GLBL .   @ @@@E         USING SGDSCT,X7 .    @H@@@E      HQ
)@@G@@   SET   SDRLCX,ON,SGDCLS+DCGSLT .               SET COMPLEX RESULT     HR
)@@G@@@C@@@E         XGPOP .                   POP STACK    @#@@@E         LJMHS
)@@G@@P .   @[@@@E.     @[@@@E.     @[@@@E.     @C@@@ECBCJGF   GLBL .         HT
)@@G@@           CONJG BIF    @ @@@E         GIFR  CBCJ1,AGIM1    @C@@@E      HU
)@@G@@   GGETGR AGXTMP,2 .         ALLOCATE REG @A@@@E         GDBLE OPDLN,AGXHV
)@@G@@TMP,AGIM1 . @ @@@E         GSET  AGIM1,AGXTMP   @^@@@E         GGOTO CBCHW
)@@G@@JGR . @#@@@ECBCJ1    GLBL     @B@@@E         GDBLE OPDLN,AGIM1,AGIM1 'NOHX
)@@G@@'     @^@@@E         GGOTO CBCJGR . @#@@@ECBCJGB   GLBL     @C@@@E      HY
)@@G@@   GIFR  CBCJ2,AGIM1 .       BINARY CONJG @^@@@E         GGETGR AGXTMP,1HZ
)@@G@@@A@@@E         GINST OPLNA,AGXTMP,AGIM1   @ @@@E         GSET AGIM1,AGXTIA
)@@G@@MP    @^@@@E         GGOTO CBCJGR   @#@@@ECBCJ2    GLBL     @B@@@E      IB
)@@G@@   GINST OPLNA,AGIM1,AGIM1 'NO'     @#@@@ECBCJGR   GLBL     @^@@@E      IC
)@@G@@   GMOVE +2,1 .   @^@@@E         GFIN 'POP'     @[@@@E.     @[@@@E.     ID
)@@G@@@[@@@E.     @[@@@E.     @B@@@E.        ICODES FOR TRUNC, FLOOR AND CEIL IE
)@@G@@@[@@@E.     @[@@@E.     @[@@@E.     @ @@@E.        FIXED BINARY ICODES  IF
)@@G@@@[@@@E.     @D@@@ECBXFLR   GLBL .                    FIXED BIN+Q FLOOR  IG
)@@G@@@D@@@E         GIFR  CBXFL1,AGRL1 .      PUT OP 1 IN REG    @^@@@E      IH
)@@G@@   GLOAD AGRL1,1 .@#@@@ECBXFL1   GLBL .   @H@@@E         GINST OPLA,AGRAII
)@@G@@3,AGRL1 'NO' .                  GET SIGN OF ARGUMENT  @D@@@E         GSHIJ
)@@G@@IN   OPSSA,AGRA3,36,I . PROPAGATE SIGN    @C@@@E         GSHIN OPSSL,AGRIK
)@@G@@A3,AGXR0 . SHIFT BY 36-Q@C@@@E         GINST OPANA,AGRL1,AGRA3 . ADD Q 1IL
)@@G@@'S    @^@@@E         GGOTO CBXTRN   @[@@@E.     @D@@@ECBXCEL   GLBL .   IM
)@@G@@                 FIXED BIN +Q CEIL  @ @@@E         GIFR  CBXCL1,AGRL1   IN
)@@G@@@^@@@E         GLOAD AGRL1,1  @#@@@ECBXCL1   GLBL     @B@@@E         GINIO
)@@G@@ST OPLNA,AGRA3,AGRL1 'NO'     @D@@@E         GSHIN   OPSSA,AGRA3,36,I . IP
)@@G@@PROPAGATE SIGN    @A@@@E         GSHIN OPSSL,AGRA3,AGXR0    @A@@@E      IQ
)@@G@@   GINST OPAA,AGRL1,AGRA3 .   @[@@@E.     @[@@@E.     @D@@@ECBXTRN   GLBIR
)@@G@@L .                    FIXED BIN +Q TRUNC @ @@@E         GIFR  CBXTR1,AGIS
)@@G@@RL1   @^@@@E         GLOAD AGRL1,1  @#@@@ECBXTR1   GLBL     @^@@@E      IT
)@@G@@   GAPPN CBXTR    @A@@@E         GSHIN OPSSA,AGRL1,AGXR0 .  @F@@@ECBXFNPIU
)@@G@@   GLBL .                    FIXED Q=0 FLOOR,CEIL & TRUNC   @D@@@E      IV
)@@G@@   GSET  AGRL2,AGRL1 .       SET RESULT REG     @^@@@E         GFIN  'POIW
)@@G@@P'    @[@@@E.     @#@@@ECBXTR    GLBL     @E@@@E         LOAD  A3,DCGSV4IX
)@@G@@+3 .       GET Q FROM CALLING REG   @ @@@E         STORE A3,AGX0OF .    IY
)@@G@@@#@@@E         LJMP     @[@@@E.     @[@@@E.     @F@@@ECBXFLQ   GLBL .   IZ
)@@G@@                 FIXED BIN -Q FLOOR,CEIL & TRUNC@ @@@E         GIFR  CBXJA
)@@G@@FQ1,AGRL1   @^@@@E         GLOAD AGRL1,1  @#@@@ECBXFQ1   GLBL     @E@@@EJB
)@@G@@         GSHIN OPLSSC,AGRL1,AGXR0 . WATCH FOR SIGN BITS     @^@@@E      JC
)@@G@@   GGOTO CBXFNP . @[@@@E.     @[@@@E.     @D@@@E.        FLOATING ARGUMEJD
)@@G@@NTS TO FLOOR, CEIL AND TRUNC  @[@@@E.     @F@@@ECBXFDQ   GLBL .         JE
)@@G@@           FIXED DEC -Q FLOOR,CEIL & TRUNC@E@@@E         GBAL    CDXLDR JF
)@@G@@.          MAKE SURE IT IS IN REG   @H@@@E         GFLOAT OPDFM,AGRL1,AGJG
)@@G@@XR0 .                    MPY BY 10**Q (Q<0)     @A@@@E         GGOTO CBXJH
)@@G@@FNP . ->FINISH UP @[@@@E.     @[@@@E.     @D@@@ECBXFDP   GLBL .         JI
)@@G@@           FIXED DEC +Q TRUNC @D@@@E         GBAL  CDXLDR .            LJJ
)@@G@@OAD ARG INTO REG  @D@@@E         GFLOAT OPDFD,AGRL1,AGXR0 . SCALE BY 10*JK
)@@G@@*Q    @C@@@ECBXFTQ   GLBL .                    FLOAT TRUNC  @C@@@E      JL
)@@G@@   GBAL CDXLDR .             LOAD ARG     @#@@@ECBXFT1   GLBL .   @H@@@EJM
)@@G@@         GFLOAT OPDFA,AGRL1,AGXUNZ .                   TRUNCATE - ADD FUJN
)@@G@@NNY 0 @C@@@E         GGOTO CBXFNP .            ->FINISH UP  @[@@@E.     JO
)@@G@@@E@@@ECDXLDR   GLBL .                    FLOAT LOAD INTO REGS     @C@@@EJP
)@@G@@         GIFR  CBXLD1,AGRL1 . -> ALREADY IN REG @^@@@E         GLOAD AGRJQ
)@@G@@L1,2  @#@@@ECBXLD1   GLBL     @#@@@E         GRTRN .  @[@@@E.     @[@@@EJR
)@@G@@.     @[@@@E.     @C@@@ECBXFLC   GLBL .                    FLOAT CEIL   JS
)@@G@@@^@@@E         GBAL CDXLDR .  @E@@@E         GINST OPTN,AGRX0,AGRL1 'NO'JT
)@@G@@ . TEST SIGN OF NUMBER  @C@@@E         GFLOAT OPDFA,AGRL1,AGXR0 . ADD .9JU
)@@G@@9999  @^@@@E         GGOTO CBXFT1 . @[@@@E.     @C@@@ECBXFLF   GLBL .   JV
)@@G@@                 FLOAT FLOOR  @^@@@E         GBAL  CDXLDR . @A@@@E      JW
)@@G@@   GINST OPTP,AGRX0,AGRL1 'NO'@C@@@E         GFLOAT OPDFAN,AGRL1,AGXR0 .JX
)@@G@@  ADD .99999@A@@@E         GGOTO CBXFT1 . ->TRUNCATE  @[@@@E.     @[@@@EJY
)@@G@@.     @D@@@ECBXFFC   GLBL  .                   FIX DEC +Q CEIL    @C@@@EJZ
)@@G@@         GBAL CDXLDR .             LOAD ARG     @B@@@E         GDBLE OPDKA
)@@G@@L,AGRA3,AGXR0 . 10**Q   @#@@@E         GLIT 1   @E@@@E         DFAN  A3,KB
)@@G@@KKPW10-2-(IN 63,0,1,0) . 10**Q-1=9999999  @B@@@E         GINST OPTN,AGRXKC
)@@G@@0,AGRL1 'NO' .    @D@@@E         GFLOAT OPDFA,AGRL1,AGRA3 .  ADD IF POS KD
)@@G@@NUM   @B@@@E         GGOTO CBXFDP .   -> TRUNCATE     @[@@@E.     @[@@@EKE
)@@G@@.     @D@@@ECBXFFF   GLBL  .                   FIXED DEC +Q FLOOR @C@@@EKF
)@@G@@         GBAL  CDXLDR .            LOAD ARG     @A@@@E         GDBLE OPDKG
)@@G@@L,AGRA3,AGXR0 .   @#@@@E         GLIT  1 .@B@@@E         DFAN  A3,KKPW10KH
)@@G@@-2-(IN 63,0,1,0)  @A@@@E         GINST OPTP,AGRX0,AGRL1 'NO'@E@@@E      KI
)@@G@@   GFLOAT OPDFAN,AGRL1,AGRA3 .   SUB IF NUMBER NEG    @C@@@E         GGOKJ
)@@G@@TO CBXFDP .            ->FINISH UP  @[@@@E.     @C@@@E.                 KK
)@@G@@                 FIXED BIN MOD@[@@@E.     @#@@@EBFMODB   GLBL .   @D@@@EKL
)@@G@@         GIFR    BFMOB1,AGRL2 .    IS ARG1 IN REG?    @D@@@E         GLOKM
)@@G@@AD   AGRL2,1 .         GET IT INTO ONE    @D@@@EBFMOB1   GLBL .         KN
)@@G@@           ARG1 NOW IN REG    @D@@@E         GIFR    BFMOB5,AGRL1 .    IKO
)@@G@@S ARG2 IN REG?    @D@@@E         GINST   OPTNZ,AGRX0,AGRL1 'NO' . SEE IFKP
)@@G@@ ZERO @C@@@E         GJUMP   AGLBL .           JUMP AROUND  @B@@@E      KQ
)@@G@@   GGOTO   BFMOB6 .          MERGE  @E@@@EBFMOB5   GLBL .               KR
)@@G@@     HERE AGRL1 IS IN REG     @F@@@E         GCJMP   OPJZ,AGRL1,AGLBL 'NKS
)@@G@@O' . LEAVE RESULT IF ZERO     @E@@@EBFMOB6   GLBL .                    MKT
)@@G@@ERGE HERE TO CONTINUE   @D@@@E         GSHIN   OPDSA,AGRL2,36,I 'NO' . SKU
)@@G@@IGN EXTEND  @B@F@E         GINST   OPDI,AGRL2,AGRL1 . DIVIDE@C@@@F      KV
)@@G@@   GINST   OPDI,AGRL2,AGRL1 'NO' . DIVIDE @F@@@E         GSHIN   OPLDSL,KW
)@@G@@AGRL2,36,I 'NO' . PUT BACK INTO ODD REG   @F@@@F         GCJMP   OPJZ,AGKX
)@@G@@RL2,AGLBL . TEST POS. DOESN'T HDLE NEG. 0 @B@@@F         GINST   OPTP,AGKY
)@@G@@RX0,AGRL2 'NO' .  @E@@@F         GINST   OPAMA,AGRL2,AGRL1 . GET POSITIVKZ
)@@G@@E RESULT    @D@@@E         GLABEL  AGLBL .           SET JUMP TO HERE   LA
)@@G@@@C@@@E         GSET    AGRL2+DCGSLT,AGRL2 . SET RESULT@D@@@E         GAPLB
)@@G@@PN   BFMOB4 .          GO POP OFF ARGS    @D@@@E         GFIN .         LC
)@@G@@           ALL DONE ICODE     @E@@@EBFMOB4   GLBL .                    HLD
)@@G@@ERE TO POP OFF TWO ARGS @A@@@E         XGPOP   'SIZE',2*DCGSLT .  @#@@@ELE
)@@G@@         LJMP .   @[@@@E.     @F@@@E.                                  FLF
)@@G@@LOAT OR FIXED DEC MOD BIF     @[@@@E.     @#@@@EBFMODF   GLBL .   @D@@@ELG
)@@G@@         GIFR    BFMOF1,AGRL2 .    ARG ONE IN REG?    @D@@@E         GLOLH
)@@G@@AD   AGRL2,2 .         GET IT INTO ONE    @D@@@EBFMOF1   GLBL .         LI
)@@G@@           ARG ONE NOW IN REG @F@@@F         GINST   OPTNZ,AGRX0,AGRL1 'LJ
)@@G@@NO' .   SEE IF DIVISOR ZERO   @^@@@F         GJUMP   AGLBL .@F@@@F      LK
)@@G@@   GDBLE   OPDL,AGRA1,AGRL2 'NO' . LOAD INTO SCRATCH REG    @C@F@E      LL
)@@G@@   GIFR    BFMOF2,AGRL1 .    ARG 2 IN REG?@D@F@E         GINST   OPTNZ,ALM
)@@G@@GRX0,AGRL1 'NO' . SEE IF ZERO @^@F@E         GLIT    1 .    @F@F@E      LN
)@@G@@   J       $-$ .             JUMP TO BR FILLED IN BELOW     @ @F@E      LO
)@@G@@   GGOTO   BFMOF3 .     @F@F@EBFMOF2   GLBL .                    ARG 2 ILP
)@@G@@N REG - SEE IF ZERO     @D@F@E         GINST   071,AGRL1,AGRX0,016 'NO' LQ
)@@G@@. GEN DJZ   @#@F@EBFMOF3   GLBL .   @C@F@E         GAPPN   BFMOF4 .     LR
)@@G@@     FILL IN JUMP @F@F@E         GDBLE   OPDL,AGRA1,AGRL2 'NO' . LOAD INLS
)@@G@@TO SCRATCH REG    @C@@@E         GFLOAT  OPDFD,AGRA1,AGRL1 'NO' . DIVIDELT
)@@G@@@D@@@E         GINST   OPTP,AGRX0,AGRA1 'NO' . SEE IF POS   @E@@@E      LU
)@@G@@   GLIT    1 .               NEG HERE,HELP FLOOR FUNC @ @@@E         DFALV
)@@G@@N    A1,KK9999 .  @D@@@E         GFLOAT  OPDFA,AGRA1,AGXUNZ 'NO' . TRUNCLW
)@@G@@ATE   @F@F@E         GFLOAT  OPDFM,AGRA1,AGRL1 . GET FLOOR(ARG1/ARG2)*ARLX
)@@G@@G2    @G@@@F         GFLOAT  OPDFM,AGRA1,AGRL1 'NO' . GET FLOOR(ARG1/ARGLY
)@@G@@2)*ARG2     @D@@@E         GFLOAT  OPDFAN,AGRL2,AGRA1 'NO' . GET MOD    LZ
)@@G@@@C@@@E         GSET    AGRL2+DCGSLT,AGRL2 . SET RESULT@D@@@F         GCJMA
)@@G@@MP   OPJP,AGRL2,AGLBL . IS RESULT NEG.    @F@@@F         GINST   OPTP,AGMB
)@@G@@RX0,AGRL1 'NO' .    DO DBLE ADD MAGN.     @E@@@F         GFLOAT  OPDFAN,MC
)@@G@@AGRL2,AGRL1 'NO' . GET POS. RESULT  @B@@@F         GINST   OPTN,AGRX0,AGMD
)@@G@@RL1 'NO' .  @E@@@F         GFLOAT  OPDFA,AGRL2,AGRL1 .    GET POS. RESULME
)@@G@@T     @^@@@F         GLABEL  AGLBL .@C@@@E         GAPPN   BFMOB4 .     MF
)@@G@@     POP STACK    @#@@@E         GFIN .   @E@F@EBFMOF4   GLBL .         MG
)@@G@@           HERE TO FILL IN JUMPS    @D@F@E         GMARK   A3 .         MH
)@@G@@     GET ADDR OF CODE   @D@F@E         SUB     A3,1,I .          POINT TMI
)@@G@@O JUMP INST @E@F@E         LOAD    A4,W1U+8,A3 .     POINT TO AROUND CODMJ
)@@G@@E     @D@F@E         STORE   A4,W1H2,A3 .      SET ADDR FOR JUMP  @D@F@EMK
)@@G@@         LJMP .                    RETURN TO ICODE    @ @@@E/.       CONML
)@@G@@STANTS NEEDED     @[@@@E.     @[@@@E.     @^@@@EDCBCSM   SFW     0 .    MM
)@@G@@@B@@@E         +SGDEXP++SD0ART,SDDCBN,0,17 .    @A@@@EDCBCLN   SFW 0 . SMN
)@@G@@TACK ELT FOR 35,0 @D@@@E         +SGDEXP++SD0ART,SDDCBN,0,35 . WHY SGDEXMO
)@@G@@P?    @[@@@E.     @ @@@E.        WORDS FOR NONPL1 MSGS@[@@@E.     @C@F@EMP
)@@G@@DCBRND   INSERT  4,'RAN,'D   ' .   RAND USED    @C@@@FDCBRND   INSERT  4MQ
)@@G@@,'RAN','D   ' .  RAND USED    @C@@@EERXGRN    EQU  52 .        NON STANDMR
)@@G@@ARD PL1 USED@B@@@EEXERB1    EQU  51 .         REAL PART USED@G@@@EEXROUNMS
)@@G@@   EQU     0200 .            ARG TO ROUND OUT OF BOUNDS. ONE USED @D@@@EMT
)@@G@@ERRG08   EQU   41 .            NON-CONSTANT. 10 USED  @C@@@EERRG10   EQUMU
)@@G@@   42      .       REAL PART USED   @F@@@EERRG09   EQU   43    .        MV
)@@G@@ SMALL INTEGER NEEDED, NOT FOUND    @D@@@EIGPLUS   EQU   02000 .        MW
)@@G@@ FLAG FOR MIN & MAX     @F@@@EIGMPDV   EQU     01000 .           MULTIPLMX
)@@G@@Y OR DIVIDE IN ROUND    @E@@@EIGZERO   EQU     01000 .           FLAG FOMY
)@@G@@R ZERO SHIFT COUNT@#@@@E         CEND .   @#@@@E          END .   ___@@EMZ
)@@G@@         GFLOAT OPDFA,AGRL1,AGRA3 .  ADD IF POS NUM   @B@@@E         GGONA
)@@G@@TO CBXFDP .   -> TRUNCAT*[S@@[*SDFF*@F@@@D 0)^@)CTJE[TELDC9CE))AC9A85^[]NB
)@@G@@FC)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@[@@@D 0)^@)@H@@@D 0)^@)EDPC(NE-DD9INC
)@@G@@ES)CTJD1#C(MD1DD1B^[OD[DES)ETCD9PD-^^[]C*)C-DEL CTOC(^^[OD8'@[@@@D 0)^@)ND
)@@G@@@B@@@D 0)^@)^@)^@)^[HCDME1DD0)E0,^[UC(GDTJE9DE-U@E@@@D 0)^@)^@)^@)^[^C(KNE
)@@G@@CDME-HC(IE))D9A^[#D9HE[PE- EK)ET#DD D1#C*)@C@@@D 0)^@)^@)^@)^[PD1DE1 ELNNF
)@@G@@DDOFC)D9A^[HCDMFDGCDIC))@E@@@D 0)^@)^@)^@)^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGNG
)@@G@@CDIC))AK0A84AK)^@)@[@@@D 0)^@)@M@@@D 0)^@)^@)^@)^[KC(MD(DETNDDJD0)E-J^[PNH
)@@G@@ET ^[OD[ ET ^[GDDNE-DD1BES)CDIC))E-CC*)CTJD(KE(OC(M^[KELJC9MCDHES)E-CC(TNI
)@@G@@@I@@@D 0)^@)EL E[MC(NC(IE))DDN^[BEL[D1OC(^^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1BNJ
)@@G@@^[#D9IC-DE-DD9IES'@[@@@D 0)^@)@L@@@D 0)^@)^@)^@)^@1 0)E(ID-DD(DE- C))E(NNK
)@@G@@C*)D([FC)CL ^[HCD^C*)D9A^[OD[ ^[KELJC9MCDHES)EL E[MC(NC(IE- C))CLT@M@@@DNL
)@@G@@ 0)^@)E-CC(NC*)D-DETODDIC9N^[KELJE1DC- C))E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JNM
)@@G@@EK)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@J@@@D 0)^@)E[G 81^[#D9HE[DD- EK)EL NN
)@@G@@D([DDIES)CDNETJCTDCDOC(^^[RDDOD@)E-CC(NC*)E[MD9BEL[D(N 0)^@)@[@@@D 0)^@)NO
)@@G@@@K@@@D 0)^@)^@)^@)^@2 0)D(JC-DC1DCT[E-DD9IES)D([FC)CL ^[HCD^C*)E-J^[OD[ NP
)@@G@@^[GDDNE-DD1BES)E[MD9QDD^C(^BK)@[@@@D 0)^@)@M@@@D 0)^@)^@)^@)^@*CC(^[[D1TNQ
)@@G@@^[MC(NE(GE-DD1B^[KELJC9MCDH ))D9M^[MC(KD9ME)?^[KCDKC(M^[JEK)C-JCTPD( D1ONR
)@@G@@CDODDJD0)^@)@M@@@D 0)^@)^@)^@)^[^C(NCTMDD]DDIC8)ETPCTC^[KELJC9MCDH^[RDDGNS
)@@G@@D))CTGC([ELGFC)DDIC-DCT[E- ^[OD[[E))E-CC*)E[MD9BEL[D*)@J@@@D 0)^@)^@)^@)NT
)@@G@@^[DES)CC)C-DCDGC(#E))D9A^[KD-PD*)D9M^[DES)C- ELDE1 C))C1MD9H^[KD-PD*?^[[NU
)@@G@@D1^^@)@[@@@D 0)^@)@L@@@D 0)^@)^@)^@)^@*CK(^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DNV
)@@G@@D9IES?^[JE-CC(M^[OD[[D0)E-MDDQDD[D))CTJELMC(#E-DD9IES)@K@@@D 0)^@)^@)^@)NW
)@@G@@^[JC0)C(MELJELN^[DD0)E-CC*)ETJE(MCT ^[KELJC9MCDHES?^[ND[[D-G^[]C*)EL E[JNX
)@@G@@ELOC(^^[[D1^@L@@@D 0)^@)^@)^@)^[[^[]ELDC(A^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)NY
)@@G@@C1 CDOE(MC*)CD^C- C))ETCCDGD))CL ^[NE(]D(DE-OC(^@F@@@D 0)^@)^@)^@)^[OD8)NZ
)@@G@@E-CC*)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^ ))CDIC))@[@@@D 0)^@)@L@@@D 0)^@)OA
)@@G@@^@)^@)^@*CS(^[ID8)E[MD9BEL[D(N^[^C(MDDQC(^^[AELJD*)E-CC(NC*)D-DETODDIC9NOB
)@@G@@^[ND[[D-G^[]C*)ETJD-^^@)@M@@@D 0)^@)^@)^@)^[RDDOD[JE(O^[RELDE-OC(I^[[E[KOC
)@@G@@ELJE1[D))C1MD9H^[OD[ ^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC)?^[[D1^^@)@[@@@DOD
)@@G@@ 0)^@)@L@@@D 0)^@)^@)^@)^@*C)(^[#D9KDD ES)D9A^[OD[ ET ^[KELJC9MCDHES)D([OE
)@@G@@FC)CL ^[OEL[D1ND(DE-OC(^^[OD8)D9OD[ EK)^@)@L@@@D 0)^@)^@)^@)^[GD9#CDODDJOF
)@@G@@D1N^[KELJE1DC- C))E-CCDO^[NE(#D@)E-MCDIETHDDOE-[D-N^[#D- CDMD-T^[DD1^DD#OG
)@@G@@CDOC*)@L@@@D 0)^@)^@)^@)^[RD[ E-CC(M^[OD[ ^[KELJC9MCDHES)CDMC*)C(SCD#E))OH
)@@G@@CTJE[DC(N^[JC0)E-CC*)E(IDDQC(METDE-T^[JC0)@J@@@D 0)^@)^@)^@)^[HCDMFDGCDIOI
)@@G@@C))E[GE(H^[#D9HE[DD- EK)D9M^[[EL ^[HD9^DDADD#CDODDJD1N^[OD8)DDO 0)@[@@@DOJ
)@@G@@ 0)^@)@L@@@D 0)^@)^@)^@)^@3 0)E-CC(NC*)CTJD1^DDODDJD1N^[JD1GFC)CDKE[GFC)OK
)@@G@@E-J^[OD[ ^[KD-PD*)CTJD(KDDGC(M^[DE-NC(GC0?@L@@@D 0)^@)CDIC))CDMC*)D1JE))OL
)@@G@@D( CDIE))E-J^[[E[KD-T^[OD8)CDIFC)E[MD9BEL[D*)E9MDDOE- D0)E(NDDIC8)E[GE(HOM
)@@G@@ 0)^@)@J@@@D 0)^@)E-CC*)E[PELKD9NC*)D9A^[OD[ ET ^[#D9IC-DE-DD9IES)DDN^[OON
)@@G@@D8)CDGD-JE8)CDIFC)E(NC(M^[OD8)@L@@@D 0)^@)C(SE[ ELDD( D1O^[RDDOD@)E-CC*)OO
)@@G@@CTJD(KDDGC(M^[[ES)D-JD1B^[[ES)E-CC*)EL ETPD-ODDIC8)E[MD9^E(#E))^@)@M@@@DOP
)@@G@@ 0)^@)DDN^[ID9O^[ND9GC))CDIC))CDN^[GD9IC8)CDN^[DE))DDN^[FD1JE9I^[OD[[E))OQ
)@@G@@E-CC*)E[MD9^E(#E))C- E1 D-JE[ C))^@)@^@@@D 0)^@)C1MD9H^[KD-PD*,^@)@[@@@DOR
)@@G@@ 0)^@)@[@@@D 0)^@)@[@@@D 0)^@)@[@@@D 0)^@)@[@@@D 0)^@)@[@@@D 8,^@)@E@@@COS
)@@G@@D(NC8%^@)^@)^[KELJCS)^@%AC) 0)^@)^@)D1PD(]C(M -RD9MC-N^@,^@)@C@@@CFLH K*OT
)@@G@@D(NC8*AC?AC( C)C(LE*)A)% @= (KCDME)1 C) 0)@C@@@CFLS K*D(NC8*AC?AC( C)C(LOU
)@@G@@E*)^@)D(NC8*AC?AK(^@,^@)@^@@@C^@)^@)^@)^@)^[ D1^^@,^@)@^@@@CE[OAK%^@)^@)OV
)@@G@@^[KELJCS) 0)@B@@@CC1H^@)^@)^@)^[AD9MD*)^@6 )1AK?A0?AC2^@,^@)@M@@@CDS)^@)OW
)@@G@@^@)^@)^[^D8)^@)^[KE)2 @1 )1 C) ))C1H^@:FLS @2 LF *2 C?FLH @2 LF *2 C?FLSOX
)@@G@@ @2 LF *1 C?FLH @2 LF *1 C) 0)@^@@@C^@)^@)^@)^@)^[ D1^^@,^@)@^@@@C^@)^@)OY
)@@G@@^@)^@)^[[F[M^)) 0)@^@@@C^@)^@)^@)^@)^[^CTGELB^@,@ @@@CD(NC9N^@)^@)^[#ET OZ
)@@G@@CTO^@3^@,^@)@^@@@CD(NC81AC%^@)^[GCD]C(G^@,@A@@@C^@)^@)^@)^@)^@:E[[ELOAK?PA
)@@G@@E[[ELOAC) 0)@^@@@CE[[ELOAC)^@)D-[CL D)) 0)@ @@@C^@)^@)^@)^@)^[HETB^@)^@0PB
)@@G@@ )3^@,@B@@@C^@$ET\IL2JC-^[IH94^[(H(0H->H(>H14G(=^8) 0)@ @@@C^@)^@)^@)^@)PC
)@@G@@^[HETB^@)^@1 )3^@,@A@@@C^@$DD,I1-H-(G))H90I-(H9,^[@C0)^8) 0)@ @D@C^@)^@)PD
)@@G@@^@)^@)^[HETB^@)^@6 )2^@,@ @D@C^@)^@)^@)^@)^[HETB^@)^@7 )2^@,@ @G@D^@)^@)PE
)@@G@@^@)^@)^[!IT$^@)^@8A8?AK)@ @G@D^@)^@)^@)^@)^[!IT$^@)^@8B@?AK)@ @@@D^@)^@)PF
)@@G@@^@)^@)^[!IT$^@)^@8BC?AK)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@9A@?AK)@ @@@D^@)^@)PG
)@@G@@^@)^@)^[!IT$^@)^@9AC?AK)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@9AK?AK)@ @@@D^@)^@)PH
)@@G@@^@)^@)^[!IT$^@)^@9AS?AK)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@9A)?AK)@ @@@D^@)^@)PI
)@@G@@^@)^@)^[!IT$^@)^@9A0?AK)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@9A8?AK)@ @@@D^@)^@)PJ
)@@G@@^@)^@)^[!IT$^@)^@9B@?AK)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@9BC?AK)@ @@@D^@)^@)PK
)@@G@@^@)^@)^[!IT$^@)^@1A@0 )2@ @@@D^@)^@)^@)^@)^[!IT$^@)^@1A@1 )2@ @@@D^@)^@)PL
)@@G@@^@)^@)^[!IT$^@)^@1A@2 )2@ @@@D^@)^@)^@)^@)^[!IT$^@)^@1A@3 )2@ @@@D^@)^@)PM
)@@G@@^@)^@)^[!IT$^@)^@1A@4 )2@ @@@D^@)^@)^@)^@)^[HETB^@)^@1AC5 )2@A@D@C^@)^@)PN
)@@G@@^@)^@)^[HETB^@)^@7A)?AK) 0)^@)@ @@@C^@$D1\I))GD3IT(G9,G(=^@$^@,^@)@ @@@CPO
)@@G@@^@)^@)^@)^@)^[HETB^@)^@2 )3^@,@A@@@C^@$E-\H8)H(-H19^[!G(3IT-G9>IS)^8) 0)PP
)@@G@@@ @@@C^@)^@)^@)^@)^[HETB^@)^@3 )2^@,@^@@@C^@$DC\D8)G(2IL\IK)^8) 0)@ @@@CPQ
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4 )3^@,@A@@@C^@$E-\H8)H(5GT*^[\I(4I[5I))^8) 0)^@)PR
)@@G@@@ @@@C^@)^@)^@)^@)^[HETB^@)^@5 )3^@,@B@@@C^@$ET9H(+H9?^[4GD+H->^[\I1>IL&PS
)@@G@@H-\I8)^8) 0)@ @@@D^@)^@)^@)^@)^[!IT$^@)^@6 )4^@)@E@@@D^@$D1\I))I[2H90G(2PT
)@@G@@^[0GD2G(,I-*G(3HD'G(=^[<H9,G-(I-(H9,^@$^@)@ @@@D^@)^@)^@)^@)^[HETB^@)^@7PU
)@@G@@ )2^@)@^@@@D^@$C(IC))HD,IT>IL4G(=^@$@ @@@C^@)^@)^@)^@)^[HETB^@)^@8 )5^@,PV
)@@G@@@C@@@C^@$A00^[+HD4IS)I(3G(=^[&H92^[,I(!GL>IK)^8) 0)^@)@ @@@C^@)^@)^@)^@)PW
)@@G@@^[HETB^@)^@9 )5^@,@C@@@C^@$AC7^[=HD$HD4IS)I(3G(=^[&H92^[,I(!GL>IK)^8) 0)PX
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@?A)) 0)^@)@B@@@C^@$D15H(+G(2^[\I(4^[\G0)PY
)@@G@@IL-H1$G*)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1AC?AS) 0)^@)@ @@@C^@$D1-PZ
)@@G@@H(>^[4H9\^[?H9,G8)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1AK?AK) 0)^@)@ @@@CQA
)@@G@@^@$DD?H->G9-H))IT9H(+H9?^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@1AS?A)) 0)^@)QB
)@@G@@@D@@@C^@$CT\H(!G(,I))GD<IL\IT3^[?HD,G*)GL\I(,G--IL9^@$^@,^@)@A@@@C^@)^@)QC
)@@G@@^@)^@)^[HETB^@)^@1A)?A)) 0)^@)@D@@@C^@$D15H(+G(2^[-GT2H93IS)H-(H1>^[+H95QD
)@@G@@H1=GD2JC)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A*?A)) 0)^@)@D@@@C^@$ET4QE
)@@G@@IL(H1$^[-GT2H93IS)H-(H1>^[+H95H1=GD2JC)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETBQF
)@@G@@^@)^@1A0?AK) 0)^@)@A@@@C^@$D[-IT*I--GL?G*)H96G(2G1?H97^@$^@,@A@@@C^@)^@)QG
)@@G@@^@)^@)^[HETB^@)^@1A8?AC) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@2A@?AC) 0)^@)QH
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@2AC?AC) 0)^@)@#@@@C^@$D15H(+G(2^@$^@,@A@@@CQI
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1B@?AC) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1BC?AC)QJ
)@@G@@ 0)^@)@^@@@C^@$C(8I[\H1>H14^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@2AS?AS)QK
)@@G@@ 0)^@)@ @@@C^@$CT\H-5H(,^@1^[5IT>G))^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@2QL
)@@G@@A)?AK) 0)^@)@^@@@C^@$DD?H->G9-H)) K\^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@2QM
)@@G@@A*?AK) 0)^@)@B@@@C^@$DD,GT\H(0H->I->^[>J[0IL>IT3HD\H0)^8) 0)@A@@@C^@)^@)QN
)@@G@@^@)^@)^[HETB^@)^@2A0?A)) 0)^@)@C@@@C^@$D((IT3HD,G8)GD2G95H(>H14 0)AC)I(3QO
)@@G@@G(=^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@2A8?AK) 0)^@)@ @@@C^@$D((IT3HD,QP
)@@G@@G8)GT\H(!GC)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@2B@?AK) 0)^@)@^@@@C^@$C(!QQ
)@@G@@I[4JC)H-(IT4^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@2BC?AS) 0)^@)@B@@@C^@$C(8QR
)@@G@@I-2GC)H->G14^[0GD2G(,I-*G(3HD3^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@3A@?AS)QS
)@@G@@ 0)^@)@C@@@C^@$D((IT3HD,G8)IL(G9*I))I[-IL>H14H[>IT(IS)^8) 0)@A@@@C^@)^@)QT
)@@G@@^@)^@)^[HETB^@)^@3AC?AK) 0)^@)@ @@@C^@$DD!I[2H90G(2^[,H94^@$^@,^@)@A@@@CQU
)@@G@@^@)^@)^@)^@)^[HETB^@)^@3AK?AS) 0)^@)@A@@@C^@$D1>IT4HD,G8)I-\H8)G->G(0^@$QV
)@@G@@^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@3AS?AS) 0)^@)@C@@@C^@$D((IT3HD,G8)H->QW
)@@G@@G14^[0GD2G(,I-*G(3HD3^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@3A)?AK) 0)^@)QX
)@@G@@@ @@@C^@$C(8I-2GC)GT\H(!GC)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@3A*?AS)QY
)@@G@@ 0)^@)@A@@@C^@$CC)G1\IL!GD4^[-IT3I(!G(=^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETBQZ
)@@G@@^@)^@3A0?AK) 0)^@)@ @@@C^@$E[2G(&HD8^[\IL=G(2^@$^@,^@)@A@@@C^@)^@)^@)^@)RA
)@@G@@^[HETB^@)^@3A8?AS) 0)^@)@ @@@C^@$D95I))H9&^[3I[-GT>^@$^@,^@)@A@@@C^@)^@)RB
)@@G@@^@)^@)^[HETB^@)^@3B@?AC) 0)^@)@#@@@C^@$CT*G(<HS)^8) 0)@A@@@C^@)^@)^@)^@)RC
)@@G@@^[HETB^@)^@3BC?AK) 0)^@)@A@@@C^@$D((IT3HD,G8)HT>JD7H92G))^8) 0)^@)@A@@@CRD
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4A@?AK) 0)^@)@ @@@C^@$D((IT3HD,G8)H--GL>H))^8) 0)RE
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@4AC?AK) 0)^@)@A@@@C^@$ET4GD4G(!G(,I))G->H->RF
)@@G@@I->G))^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@4AK?A)) 0)^@)@F@@@C^@$E(,IL>GT\RG
)@@G@@G9,HD'GD+H->^[>H->H(>H14^[(H0)IT4GD4G(!G(,I))^8) 0)^@)@A@@@C^@)^@)^@)^@)RH
)@@G@@^[HETB^@)^@4AS?AC) 0)^@)@ @@@C^@$E(,IL>GD<H[-GL?G*)^8) 0)^@)@A@@@C^@)^@)RI
)@@G@@^@)^@)^[HETB^@)^@4A)?AK) 0)^@)@A@@@C^@$C(8I-2GC)IT>H((GT\H-\H0)^8) 0)^@)RJ
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@4A*?AK) 0)^@)@A@@@C^@$D((IT3HD,G8)G(8I[2G(3RK
)@@G@@IT(H9,^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@4A0?AK) 0)^@)@ @D@C^@$D((IT3HD,RL
)@@G@@G8)I-*G(,^@$^@,^@)@ @@@D^@$D((IT3HD,G8)E-CC(I^@$^@,^@)@A@@@C^@)^@)^@)^@)RM
)@@G@@^[HETB^@)^@4A8?AK) 0)^@)@A@@@C^@$D((IT3HD,G8)IT>H((GT\H-\H0)^8) 0)@A@F@CRN
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4B@?AC) 0)^@)@A@@@F^@)^@)^@)^@)^[HETB^@)^@4B@?AC3RO
)@@G@@^@,^@)@#@F@C^@$D--GL>H))^8) 0)@M@@@F^@$C(IC))H--GL>H))G-\G(3^[,H94^[!GD4RP
)@@G@@GT*^[-H19^[?GD+G(?^[\H0)C-J ))CL C9DD0?^[\IK)E[MD9#^[3I--I->H(>H14^@$^@)RQ
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@4BC?AS) 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@6RR
)@@G@@AS?AS) 0)^@)@A@@@D^@)^@)^@)^@)^[HETB^@)^@6AS?A*) 0)^@)@ @D@C^@$E-*G(,^[\RS
)@@G@@IK)G(?IT>^@$^@,^@)@D@@@D^@$DD!I[2H90G(2^[OD[ D0)H92^[ D-NC*)G->H->I->G))RT
)@@G@@^8)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@5A@?AC) 0)^@)@#@@@C^@$D90I-(H9,^@$^@,RU
)@@G@@@A@@@C^@)^@)^@)^@)^[HETB^@)^@5AC?AC) 0)^@)@]@D@C^@$E-\^@$^@,@]@@@D^@$E-JRV
)@@G@@^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@5AK?AC) 0)^@)@]@D@C^@$CL9^@$^@,@]@@@DRW
)@@G@@^@$CLT^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@5AS?AC) 0)^@)@#@D@C^@$E9*HD?G*)RX
)@@G@@^8) 0)@#@@@D^@$E9CDDGC*)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@5A)?AK) 0)^@)RY
)@@G@@@A@D@C^@$C-\^[3I[>GT(G1(GT-I-(H9,^@$^@,^@)@A@@@D^@$C-J^[3I[>GT(G1(GT-I-(RZ
)@@G@@H9,^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@5A*?AK) 0)^@)@^@@@C^@$D((IT3HD,SA
)@@G@@G8)B*)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@5A0?AK) 0)^@)@A@@@C^@$D((IT3HD,SB
)@@G@@G8)I1-IL(GD+H->^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@5A8?AK) 0)^@)@^@@@CSC
)@@G@@^@$DC\D8)I[*IL-IT>^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@5B@?AC) 0)^@)@#@D@CSD
)@@G@@^@$C1\IL!GD4^@$^@,@#@@@D^@$C1JELHCDO^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@5SE
)@@G@@BC?AK) 0)^@)@ @D@C^@$D((IT3HD,G8)G(,G))^8) 0)^@)@ @@@D^@$D((IT3HD,G8)C(ISF
)@@G@@C))^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@6A@?A*) 0)^@)@A@D@C^@)^@)^@)^@)SG
)@@G@@^[HETB^@)^@9A8?A*) 0)^@)@D@@@C^@$D1\I))JD>I))HD!I[?G(!G(,I->G))HD,^[KD-PSH
)@@G@@D*)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@6AC?A)) 0)^@)@B@@@C^@$C(,I-2JC)SI
)@@G@@H1\I))HD,^[0IL\GT>G-5IL>^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@6AK?AK) 0)^@)SJ
)@@G@@@B@@@C^@$D(5H-4HD0H->^[=G(<H--IL-I-(H9,^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETBSK
)@@G@@^@)^@6A)?AK) 0)^@)@ @@@C^@$D((IT3HD,G8)GT\H-\H0)^8) 0)@A@@@C^@)^@)^@)^@)SL
)@@G@@^[HETB^@)^@6A*?A)) 0)^@)@B@D@C^@$D1\^[<H[>GT:^[&H92^[,H9<H[>GT:^@$^@,^@)SM
)@@G@@@B@@@D^@$D1J^[#D[ CTF^[&H92^[ID9#D[ CTF^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETBSN
)@@G@@^@)^@6A0?AK) 0)^@)@A@D@C^@$DD!I[2H90G(2^[6GD2JD(H1$^@$^@,^@)@A@@@D^@$DD!SO
)@@G@@I[2H90G(2^[QCDMFDDD1B^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@6A8?AS) 0)^@)SP
)@@G@@@C@@@C^@$D((IT3HD,G8)G(8I->IL,GD?^[0IL\GT>G-5IL>^@$^@,@A@@@C^@)^@)^@)^@)SQ
)@@G@@^[HETB^@)^@6B@?AS) 0)^@)@B@D@C^@$D((IT3HD,G8)I[2H9<G(3IS)GT-IL=^@$^@,^@)SR
)@@G@@@B@@@D^@$D((IT3HD,G8)E[MD9#C(NES)GT-IL=^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETBSS
)@@G@@^@)^@6BC?AS) 0)^@)@A@@@C^@$D1\^[!GD(H0)I[2H9<G(=I(2G*)^8) 0)@A@E@C^@)^@)ST
)@@G@@^@)^@)^[HETB^@)^@7A@?AC) 0)^@)@A@@@E^@)^@)^@)^@)^[HETB^@)^@7A@?AS) 0)^@)SU
)@@G@@@^@E@C^@$CT\H1=HD4HD\H0)^8) 0)@C@@@E^@$DD!I[2H90G(2^[<H9,G-(I-(H9,^[0IL>SV
)@@G@@G1(J@)^8)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@7AC?AK) 0)^@)@B@@@C^@$E[-IL-H(>SW
)@@G@@I->IK)GD4I-2HD+I(4G*)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@7AK?AC) 0)^@)SX
)@@G@@@#@D@C^@$C(,I-2JC)^8) 0)@#@@@D^@$C(IE-MFC)^8) 0)@A@@@C^@)^@)^@)^@)^[HETBSY
)@@G@@^@)^@7AS?A)) 0)^@)@B@@@C^@$C(8I->IL,GD?^[,GD!G*)I-\H8)H-\H1$^@$^@,@A@@@DSZ
)@@G@@^@)^@)^@)^@)^[!IT$^@)^@7A)?AS) 0)^@)@D@@@D^@$E[2H9$IL-H*)HD,IT5G1&HD<HD>TA
)@@G@@H14H-9^[<H9!H(>H14G(=^@$@A@@@C^@)^@)^@)^@)^[HETB^@)^@7A*?AK) 0)^@)@ @@@CTB
)@@G@@^@$DD!I[2H90G(2^[3GT-H->^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@7A0?AK) 0)^@)TC
)@@G@@@A@@@C^@$DD!I[2H90G(2^[0IL>GT(IT(H9,^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@7TD
)@@G@@A8?AS) 0)^@)@B@@@C^@$E-\H8)H(-H19^[(G->H14HD&HD>IL3^@$^@,^@)@A@@@C^@)^@)TE
)@@G@@^@)^@)^[HETB^@)^@7B@?AS) 0)^@)@C@@@C^@$DD!I[2H90G(2^[3I-2I(<I-5IL>^[?G(6TF
)@@G@@G(?^@$^@,^@)@A@F@C^@)^@)^@)^@)^[HETB^@)^@7BC?AC) 0)^@)@A@@@F^@)^@)^@)^@)TG
)@@G@@^[HETB^@)^@7BC?B@) 0)^@)@^@F@C^@$CD4I-2HD+I(4G*)^8) 0)@L@@@F^@$CD4I-2HD+TH
)@@G@@I(4G*)HD3^[(H1<H9!I[-I-(GL?G*)I9(I-*^[0IL>I1(H95IS)GD4I-2HD+I(4G(3^[&H92TI
)@@G@@^[6GD2HD-GL?G*)^8)@A@@@C^@)^@)^@)^@)^[HETB^@)^@8A@?AC) 0)^@)@^@@@C^@$C-(TJ
)@@G@@H(>H13HD\H0)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@8AC?AC) 0)^@)@^@@@C^@$CT\TK
)@@G@@H16G(2IT(H9,^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@8AK?AC) 0)^@)@#@@@C^@$C1-TL
)@@G@@GT4H92^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@8AS?A)) 0)^@)@E@@@C^@$DD!I[2H90TM
)@@G@@G(2^[-I-4IL(GL5I->^[(H0)IT4IL5GT4I(2G*)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETBTN
)@@G@@^@)^@8A)?AK) 0)^@)@^@@@C^@$C(8I-2GC) C)^8) 0)^@)@A@@@C^@)^@)^@)^@)^[HETBTO
)@@G@@^@)^@8A*?AK) 0)^@)@A@D@C^@$DD!I[2H90G(2^[(H1(I-(GD?^8) 0)^@)@A@@@D^@$DD!TP
)@@G@@I[2H90G(2^[DD1DE-DCDG^@$^@,^@)@ @@@D^@)^@)^@)^@)^[HETB^@)^@8A0?A8)@G@@@DTQ
)@@G@@^@$DDIDDODD[D))G1\IK)GD2IL-JD3^[5IT>G))I9(I-*^[3GT-H--IK)I1-IL(GD+H->^@$TR
)@@G@@@ @@@G^@)^@)^@)^@)^[HETB^@)^@8A8?A*)@E@@@G^@$D((IT3HD,G8)GD4I-2HD+I(4G(3TS
)@@G@@^[(H0)EL E-PELIES)H-(IT4^@$^@)@ @@@G^@)^@)^@)^@)^[HETB^@)^@8B@?A0)@D@@@GTT
)@@G@@^@$DD?H->G9-H))IT4GD4G(!G(,I))GD3^[-H0)D9I^[5H1(I))^8)@ @@@D^@)^@)^@)^@)TU
)@@G@@^[!IT$^@)^@9A*?AK)@A@@@D^@$ET5GL3GT2HD0I->G))H--GL>H))^8)^@)@A@D@C^@)^@)TV
)@@G@@^@)^@)^[HETB^@)^@8A0?A8) 0)^@)@E@D@C^@$F-P^[(IS)GD!GL(G95H95IS,^[JH1>^[-TW
)@@G@@I))F1O^[5IT>G))^8) 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@8A8?A)) 0)^@)@A@D@CTX
)@@G@@^@$^(PG-\G(3^[,H94^[2G(3H9?I1>^@$^@,@A@D@C^@)^@)^@)^@)^[HETB^@)^@8B@?AC)TY
)@@G@@ 0)^@)@#@D@C^@$E-9I[>^@$^@,^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@8BC?AC) 0)^@)TZ
)@@G@@@^@D@C^@$D90G(2GD,G))^8) 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@9A@?AS) 0)^@)UA
)@@G@@@C@D@C^@$ET4IL5GT4I(2G(3^[,H94^[(H(0H->H(>H14G(=^@$^@,@A@D@C^@)^@)^@)^@)UB
)@@G@@^[HETB^@)^@9AC?AK) 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@9AS?AK) 0)^@)@ @D@CUC
)@@G@@^@$CT\H(0HD?G(2 0)ET D([^@$^@,@A@D@C^@)^@)^@)^@)^[HETB^@)^@9AK?A)) 0)^@)UD
)@@G@@@D@D@C^@$D15H(+G(2^[\G0)GD2G95H(>H14IS)HD,GT\IL2G(<I))^8) 0)@A@D@C^@)^@)UE
)@@G@@^@)^@)^[HETB^@)^@9A)?AS) 0)^@)@B@D@C^@$ET>H(-^[4GD+H->^[\I1>IL&H-\I8)^8)UF
)@@G@@ 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@9A*?AK) 0)^@)@A@D@C^@$ET5GL3GT2HD0I->UG
)@@G@@G))H--GL>H))^8) 0)@A@D@C^@)^@)^@)^@)^[HETB^@)^@9A0?A*) 0)^@)@D@D@C^@$F-QUH
)@@G@@I(3G(=^[&H92^[(H16GD?HD=^[>J[0IL>IT3HD\H0)^8) 0)@A@D@C^@)^@)^@)^@)^[HETBUI
)@@G@@^@)^@9B@?A)) 0)^@)@A@D@C^@$F-PI(3G(=^[-IS)GD2IL-JC)^8) 0)^@)@A@D@C^@)^@)UJ
)@@G@@^@)^@)^[HETB^@)^@9BC?BC) 0)^@)@J@D@C^@$D1\I))I[2H90G(2^[,I(!GL>IK)H9&^[-UK
)@@G@@IL$I(!G(,I-3^[\IK)IT5GL3GT2HD0I-3^[&H92^[WE*)^8) 0)^@)@A@D@C^@)^@)^@)^@)UL
)@@G@@^[HETB^@)^@1A@0 )3^@,^@)@C@D@C^@$DD?H->G9-H))GT\H(0H->J@)GT\H(0GD2G*)^8)UM
)@@G@@ 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@1A@1 )3^@,^@)@C@D@C^@$CD$G92G($GD4G*)UN
)@@G@@G(8I[2G(3IT(H9,^[>IL2H92^@$^@,@A@D@C^@)^@)^@)^@)^[HETB^@)^@1A@2 )7^@,^@)UO
)@@G@@@J@D@C^@$CD2IL-JC)G-(H(>H13HD\H13^[,H94^[<H9!I[-I-(GL?G*)HD,^[-IL2GD9^[>UP
)@@G@@J[0IL>IT3HD\H0)^8) 0)^@)@A@D@C^@)^@)^@)^@)^[HETB^@)^@1A@3 )6^@,^@)@F@D@CUQ
)@@G@@^@$CD3IT(G9,HD,G8)GD2IL-JC)I-\^[-^[3GT-H--IK)I1-IL(GD+H->^@$^@,^@)@A@D@CUR
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1A@4 )4^@,^@)@C@D@C^@$DD,I1-H-(G))I[-IL-H(>I->IK)US
)@@G@@G1\IK)F-P^@$^@,^@)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@5 )2^@,^@)@ @@@C^@$D((UT
)@@G@@IT3HD,G8)G(2IL\IK)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@6 )2^@,^@)@A@@@CUU
)@@G@@^@$DD,I1-H-(G))IT5GL3GT2HD0I))^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@7 )7UV
)@@G@@^@,^@)@G@@@C^@$CL5HD?I-(H0)G15H1<I-(H9,^[WE(5IT>G))GD3^[0IT>I(=H8)I1-IL(UW
)@@G@@GD+H->^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@8 )5^@,^@)@B@D@C^@$F-PHD3^[,UX
)@@G@@H94^[4JD0G*)I[\HD,I->IK)^8) 0)@B@@@D^@$F-PHD3^[,H94^[4JD0G*)E[JDDIE- EK)UY
)@@G@@^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1A@9 )7^@,^@)@E@D@C^@$CT-H1,H94^[?G(-UZ
)@@G@@I1>^[-^[+G($HD,^[\IK)I[2H9<^[+H-\GT:^@$^@,@E@@@D^@$CT-H1,H94^[?G(-I1>^[-VA
)@@G@@^[]C(BDDI^[\IK)E[MD9#^[+H-\GT:^@$^@,@A@@@C^@)^@)^@)^@)^[HETB^@)^@1AC0 )5VB
)@@G@@^@,^@)@C@D@C^@$D--GL>H))H1\I))H9,^[(I->IL-I-(I1>^[=H8)^8) 0)@C@@@D^@$D--VC
)@@G@@GL>H))H1\I))H9,^[(I->IL-I-(I1>^[^D8)^8) 0)@A@@@C^@)^@)^@)^@)^[HETB^@)^@1VD
)@@G@@AC1 )3^@,^@)@A@D@C^@$CT-IT>^[0IL>G1(J@)G(2IL\IK)^8) 0)@A@@@D^@$CT[ET ^[0VE
)@@G@@IL>G1(J@)G(2IL\IK)^8) 0)@ @@@D^@)^@)^@)^@)^[HETB^@)^@1AC2 )4@D@@@D^@$DD,VF
)@@G@@I1-H-(G))GT\H1=HD4HD\H0,^[ ELMD9M^[5IT>G))^8)^@)@ @@@D^@)^@)^@)^@)^[HETBVG
)@@G@@^@)^@1AC3 )7@J@@@D^@$C-(IT-GL?G(=^[<H9,G-(I-(H9,^[,H94^[-H-?H97G(= 0)C(,VH
)@@G@@GD+H-(H1$^[<H9,G-(I-(H9,^[5IT>G))^8)@ @@@D^@)^@)^@)^@)^[HETB^@)^@1AC4 )5VI
)@@G@@@F@@@D^@$DD,I1-H-(G))H92^[=I(0H-(GT-I->^[<H9,G-(I-(H9,^[0IL>G1(J@)^8)^@)VJ
)@@G@@@A@@@F^@)^@)^@)^@)^[!IT$^@)^@1AK2 )1A@)^@)@K@@@F^@$DD4G(!IS)HD,^[DD1DE-DVK
)@@G@@CDG^[?HD3I))G-\^[,H94^[!GD4GT*^[-I-4IL(GL5I->IS)H9&^[6GD2HD-GL?G*)^8)^@)VL
)@@G@@@ @@@F^@)^@)^@)^@)^[!IT$^@)^@1AK3 )4@D@@@F^@$ETOCDODD#^[-I-4IL(GL5I->^[,VM
)@@G@@H94^[0G(2H((I-4G(=^@$^@)@ @@@F^@)^@)^@)^@)^[!IT$^@)^@1AK4 )6@D@@@F^@$CT[VN
)@@G@@ET ^[0IL>G1(J[>IS)H(-JC)H1\I))GL>^[?GD+G(?G(=^@$@^@@@CE[[ELOAK)^@)^[GCD]VO
)@@G@@C(G^@,@ @D@C^@)^@)^@)^@)^[KE)2^@)^@5A0) 0)@ @F@D^@)^@)^@)^@)^[KE)2^@)^@5VP
)@@G@@B@) 0)@ @@@F^@)^@)^@)^@)^[KE)2^@)^@6AS) 0)@^@@@C^@)^@)^@)^@)^[ D1^^@,^@)VQ
)@@G@@___^@)@A@@@E^@)^@)^@)^@)*[S@@@*SDFF*@A@@@@CASETOOCTAL:PROC OPTIONS(MAIN)VR
)@@G@@;     @A@@@[DCL INFILEEOF BIT(1) INIT('1'B);    @C@@@[ON ENDFILE(INFILE)VS
)@@G@@ BEGIN; INFILEEOF='0'B; END;  @G@@@@/*                                  VT
)@@G@@                                 */ @G@@@@/*  THIS PROGRAM TRANSLATES FRVU
)@@G@@OM UPPER/LOWER CASE CHARECTER STRINGS  */ @G@@@@/*       INTO THE OCTAL VV
)@@G@@CONSTANTS THAT THE ASSEMBLER CAN UNDERSTAND  */ @G@@@@/*                VW
)@@G@@                                                   */ @G@@@@/*          VX
)@@G@@                                                         */ @G@@@@/*  TOVY
)@@G@@ USE:                                                          */ @G@@@@VZ
)@@G@@/*       GIVE THE NAME OF THE INPUT FILE,AND THE NAME OF THE OUTPUT  */ WA
)@@G@@@G@@@@/*       ELEMENT (INCLUDE VERSION NAMES) WHEN PROMPTED BY THE PROGWB
)@@G@@RAM*/ @G@@@@/*                                                          WC
)@@G@@         */ @^@@@@MAKECARD:PROC(CHARS);   @G@@@@    /*                  WD
)@@G@@                                             */ @G@@@@    /* THIS PROC PWE
)@@G@@RINTS OUT THE OCTAL FOR THE 4 CHAR STRING PASSED   */ @G@@@@    /*   PASWF
)@@G@@SED IN TO IT                                             */ @G@@@@    /*WG
)@@G@@                                                               */ @^@@@@WH
)@@G@@    DCL CHARS CHAR(*),  @ @@@@         J FIXED BIN(35,0);   @F@@@@    PUWI
)@@G@@T FILE(OUTFILE) EDIT('+0',(OCTAL(INDEX(COLLATE,SUBSTR(CHARS,@D@@@@      WJ
)@@G@@   J,1))-1) DO J=1 TO 4),' .','''',CHARS,'''')  @B@@@@              (COLWK
)@@G@@(10),6(A),COL(36),3(A));@^@@@@    END /* MAKECARD */; @@@@@@@@@@@@@@@@@@WL
)@@G@@@B@@@@OCTAL:PROC(NUMBER) RETURNS (CHAR(3));     @G@@@@    /*            WM
)@@G@@                                                   */ @G@@@@    /* THIS WN
)@@G@@PROC RETURNS THE THREE CHARACTERS OCTAL STRING THAT      */ @G@@@@    /*WO
)@@G@@   REPERSENTS THE NUMBER PASSED IN TO IT                       */ @G@@@@WP
)@@G@@    /*                                                               */ WQ
)@@G@@@B@@@@    DCL (NUMBER,K) FIXED BINARY(35,0),    @A@@@@         ANSWER CHWR
)@@G@@AR(3) INIT('000');@B@@@@    DO K=3 TO 1 BY -1 WHILE(NUMBER>0);    @F@@@@WS
)@@G@@         SUBSTR(ANSWER,K,1)=SUBSTR('01234567',MOD(NUMBER,8)+1,1); @ @@@@WT
)@@G@@         NUMBER=NUMBER/8;     @A@@@@         END /* CONVERSION LOOP */; WU
)@@G@@@^@@@@    RETURN(ANSWER);     @^@@@@    END /* OCTAL */;    @@@@@@@@@@@@WV
)@@G@@@@@@@@@ @@@@DCL CARD CHAR(80) VARYING,    @^@@@@    I FIXED BIN(35,0),  WW
)@@G@@@^@@@@    INFILE FILE INPUT,  @^@@@@    OUTFILE FILE OUTPUT,@#@@@@    PAWX
)@@G@@SS CHAR(4); @G@@@@PUT SKIP EDIT('WHERE ASKED FOR AN ELEMENT NAME, BE SURWY
)@@G@@E TO INCLUDE' !!  @B@@@@' THE FILENAME AND KEYS AS NEEDED')(A);   @H@@@@WZ
)@@G@@PUT SKIP(2) EDIT('WHAT IS THE ELEMENT THAT THE INPUT IS TO COME FROM?')(XA
)@@G@@A);   @]@@@@PUT SKIP;   @ @@@@GET EDIT(CARD)(COL(1),A(80)); @#@@@@CARD=TXB
)@@G@@RIM(CARD);  @A@@@@OPEN FILE(INFILE) TITLE(CARD) INPUT;@H@@@@PUT SKIP EDIXC
)@@G@@T('WHAT ELEMENT DO YOU WANT THE ASSEMBLED RELOCATABLE IN?')(A);   @]@@@@XD
)@@G@@PUT SKIP;   @ @@@@GET EDIT(CARD)(COL(1),A(80)); @H@@@@CARD=TRIM(REVERSE(XE
)@@G@@TRIM(REVERSE(CARD)))); /* REMOVE BLANKS FROM ENDS OF CARD */@A@@@@OPEN FXF
)@@G@@ILE(OUTFILE) TITLE('O$U$T$.');@H@@@@PUT FILE(OUTFILE) EDIT('@SUSPEND','@XG
)@@G@@HDG,P ***** '!! AFTER(CARD,'.')!!' *****',@A@@@@'@ASM,IL X,' !! CARD)(COXH
)@@G@@L(1),A);    @G@@@@GET FILE(INFILE) EDIT(CARD)(COL(1),A(80));  /* INITIALXI
)@@G@@IZE FOR ENDFILE*/ @ @[@@DO WHILE(^ENDFILE(INFILE));   @^@@@[DO WHILE(INFXJ
)@@G@@ILEEOF);    @G@@@@    /* IF THE CARD DOESN'T HAVE A QUOTE ON IT THEN JUSXK
)@@G@@T PASS         */ @G@@@@    /*   IT ALONG                               XL
)@@G@@                     */ @ @@@@    IF INDEX(CARD,'''')=0 THEN@C@@@@      XM
)@@G@@   PUT FILE(OUTFILE) EDIT(CARD)(COL(1),A);@#@@@@         ELSE     @G@@@@XN
)@@G@@         /* IF IT DOES HAVE A QUOTE ON IT THEN PRINT IT AS A COMMENT */ XO
)@@G@@@G@@@@         /* AND BREAK IT UP INTO 4 CHARACTER GROUPS, CONVERT THE  XP
)@@G@@   */ @G@@@@         /* GROUPS INTO THEIR OCTAL REPRESENTATIONS,AND     XQ
)@@G@@         */ @G@@@@         /* PRINT THEM INTO THE OUTPUT FILE           XR
)@@G@@               */ @G@@@@              /*                                XS
)@@G@@                     */ @G@@@@              /* I HOPE THAT NONE OF THE SXT
)@@G@@TRINGS START WITH "' "     */ @G@@@@              /*                    XU
)@@G@@                                 */ @#@@@@              DO; @F@@@@      XV
)@@G@@             PUT FILE(OUTFILE) EDIT('.',CARD)(COL(1),A,A);  @G@@@@      XW
)@@G@@             DO I=INDEX(CARD,'''')+1 TO INDEX(CARD,''' ')-1 BY 4; @F@@@@XX
)@@G@@                        PASS=TRANSLATE(SUBSTR(CARD,I,4),' ','''');@C@@@@XY
)@@G@@                        CALL MAKECARD(PASS);    @D@@@@                  XZ
)@@G@@ END /* LOOP THRU STRING ON CARD */;@C@@@@              END /* DO TO EXTYA
)@@G@@END THE ELSE */;  @G@@@@    GET FILE(INFILE) EDIT(CARD)(COL(1),A(80)); /YB
)@@G@@*MOVE ON TO NEXT CARD*/ @^@@@@END /* ENDFILE LOOP */; @C@@@@PUT FILE(OUTYC
)@@G@@FILE) EDIT('@RESUME,H')(COL(1),A);  @^@@@@CLOSE FILE(OUTFILE);    @#@@@@YD
)@@G@@PUT SKIP EDIT(    @G@@@@'THE FILE ''O$U$T$.'' MAY BE ''@ADDED'' TO ASSEMYE
)@@G@@BLE YOUR ELEMENT,',     @F@@@@'AND CONTAINS ''@SUSPEND'' AND ''@RESUME,HYF
)@@G@@'' CARDS!')(A,SKIP);    @^@@@@END /* CASETOOCTAL */;  ___ /* CASETOOCTALYG
)@@G@@*[S@@@*SDFF*@C@@@N.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@NYH
)@@G@@.     @D@@@N.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@NYI
)@@G@@.     @ @@@N.        MARVIN V. ZELKOWITZ  @B@@@N.        DEPARTMENT OF CYJ
)@@G@@OMPUTER SCIENCE   @A@@@N.        UNIVERSITY OF MARYLAND     @B@@@N.     YK
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@N.     @G@@@N.        PERMISSIOYL
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@N.   REPRESENYM
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@N.     @G@@@N.     YN
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@NYO
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDYP
)@@G@@@E@@@N.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@NYQ
)@@G@@.     @F@@@N.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDYR
)@@G@@ED:   @[@@@N.     @G@@@N.        (A) ANY RESULTING PROGRAM, OR REPORT, PYS
)@@G@@APER OR DOCUMENTATION   @G@@@N.        DESCRIBING SUCH PROGRAM WILL CLEAYT
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@N.        IS A DIALECT OF PLUM OR IS YU
)@@G@@DERIVED FROM PLUM, AND  @[@@@N.     @G@@@N.        (B) ALL SUCH MODIFICAYV
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@N.        OF ERRORS IN THYW
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@N.        A BRIEF DESCRIPYX
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@N.        TO THE UNYY
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@N.     @F@@@N.        (C) NO PROGRAMSYZ
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@N.        WITHOUT WRITTENZA
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@N.     @F@@@N.     ZB
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@N.     ZC
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@NZD
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     ZE
)@@G@@@E@@@N.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@NZF
)@@G@@.     @G@@@N.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERZG
)@@G@@ ITSELF,    @F@@@N.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN ZH
)@@G@@USING PLUM. @E@@@N.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USZI
)@@G@@ER TO @F@@@N.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRZJ
)@@G@@ODUCT @G@@@N.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT ZK
)@@G@@DEVELOPED   @#@@@N.   FROM PLUM.    @[@@@N.     @[@@@N.     @[@@@N.     ZL
)@@G@@@[@@@N.     @[@@@N.     @[@@@N/.    @#@@@M         AXR$ .   @#@@@M      ZM
)@@G@@   DCLRG .  @C@@@M         UNLIST .            TURN OFF LISTING   @#@@@MZN
)@@G@@@ADD,P PLTVDS     @#@@@M. @ADD,P PLCGST   @#@@@M. @ADD,P PLDSAW   @#@@@MZO
)@@G@@         LIST .   @#@@@M         PLWORD . @#@@@M.          PLAC . @#@@@MZP
)@@G@@.          PLCGD .@#@@@M.          PLSD . @#@@@M.          PLIG . @D@@@MZQ
)@@G@@.          PLAR . ESTABLISH ACTIVATION RECORD DSECTS  @#@@@M         CENZR
)@@G@@D .   @^@@@M/XGCG     CSECT 3 .     @F@N@MDXGXBS   EQU   ADDIT+7+FH2    ZS
)@@G@@   . $ DDGDOSAV + 6 * 4 = DXGXBASE  @]@@@M. **TABLES  @ @@@M .          ZT
)@@G@@ OPERATOR TABLE   @F@@@M. USED BY XGEN TO BRANCH TO APPROPRIATE TABLE INZU
)@@G@@ CGOA OR CGOS     @A@@@M. WHEN OPERATOR IS TO BE PROCESSED  @#@@@MXGTBL1ZV
)@@G@@*  LABEL .  @C@@@MFILL(1) SAC    EXORB,XGORTB   . BIT STR. OR     @C@@@MZW
)@@G@@FILL(1) SAC   EXANDB,XGANTB   . BIT STR. AND    @[@@@M.     @F@@@M.     ZX
)@@G@@     THE FOLLOWING ARE FOR COMPARES THAT PRODUCE BIT STRINGS@E@@@M.     ZY
)@@G@@           THE FIRST HALF WORD IS THE OP CODE FOR THE @B@@@M.           ZZ
)@@G@@     PROPER TEST INSTRUCTION  @[@@@M.     @D@@@MFILL(1) SAC   0600000,XGAA
)@@G@@CMBA  . GE  >=  CODE FOR TP   @D@@@MFILL(1) SAC   0610000,XGCMAB  . GT  AB
)@@G@@>   CODE FOR TN   @D@@@MFILL(1) SAC   0600000,XGCMAB  . NG  \>  CODE FORAC
)@@G@@ TP   @D@@@MFILL(1) SAC   0510000,XGCMAB  . NE  \=  CODE FOR TNZ  @D@@@MAD
)@@G@@FILL(1) SAC   0610000,XGCMBA  . LT  <   CODE FOR TN   @D@@@MFILL(1) SAC AE
)@@G@@  0600000,XGCMBA  . NL  \<  CODE FOR TP   @D@@@MFILL(1) SAC   0600000,XGAF
)@@G@@CMAB  . LE  <=  CODE FOR TP   @D@@@MFILL(1) SAC   0500000,XGCMAB  . EQ  AG
)@@G@@ =  CODE FOR TZ   @D@@@MFILL(1) SAC   EXCONC,XGCATT   . !!  CONCATENATIOAH
)@@G@@N     @C@@@MFILL(1) SAC   000000,XGBPLT   . +  BINARY PLUS  @C@@@MFILL(1AI
)@@G@@) SAC   000000,XGBMNT   . -  BINARY MINUS @D@@@MFILL(1) SAC   RCFLTM,XGMAJ
)@@G@@LTB   . *  MULTIPLICATION     @C@@@MFILL(1) SAC   RCFLTD,XGDVTB   . /  DAK
)@@G@@IVISION     @C@N@MFILL(1) SAC    EXNOT,XGNOTT   .    (UNARY) NOT  @D@N@MAL
)@@G@@FILL(1) SAC   000000,XGEXPN   . **  EXPONENTIAIION    @C@N@MFILL(1) SAC AM
)@@G@@  000000,XGUPLT   .  +  UNARY PLUS  @C@N@MFILL(1) SAC   000000,XGUMNT   AN
)@@G@@.  -  UNARY MINUS @D@@@NFILL(1) SAC   000000,XGEXPN   . **  EXPONENTIAIIAO
)@@G@@ON    @[@@@M.     @E@@@M.        THE FOLLOWING ARE ONLY SEEN ON AN IF-THAP
)@@G@@EN-ELSE     @G@@@M.                TYPE OF COMPARE IF THE EXPR IS SIMPLYAQ
)@@G@@ A RELATION TEST  @[@@@M.     @G@@@M.                THE FIRST QUARTER WAR
)@@G@@ORD IS THE J-FIELD OF THE JUMP INST @G@@@M.                THAT THE DO WAS
)@@G@@ITH SPECS USES...IT IS THE JUMP ON TRUE   @D@@@M.                TO THE AT
)@@G@@START OF THE USER'S DO GROUP  @[@@@M.     @F@@@M.                THE SECAU
)@@G@@OND QUATER WORD IS THE J-FIELD OF THE JUMP@F@@@M.                INST THAV
)@@G@@AT THE IF TEST GENERATES...IT IS THE JUMP @D@@@M.                ON FALSAW
)@@G@@E THAT IS GENERATED HERE...   @[@@@M.     @F@@@M.                IN BOTHAX
)@@G@@ CASES THE PROBLEMS WITH ZEROS ARE TAKEN  @F@@@M.                OUT BY AY
)@@G@@CHANGEING THE ORDER OF THE SUBTRACTION    @[@@@M.     @D@@@MFILL(1) SAC AZ
)@@G@@  002003,XGRCBA  . GE  >=  CODE FOR JN    @D@@@MFILL(1) SAC   003002,XGRBA
)@@G@@CAB  . GT  >   CODE FOR JP    @D@@@MFILL(1) SAC   002003,XGRCAB  . NG  \BB
)@@G@@>  CODE FOR JN    @D@@@MFILL(1) SAC   001000,XGRCAB  . NE  \=  CODE FOR BC
)@@G@@JZ    @D@@@MFILL(1) SAC   003002,XGRCBA  . LT  <   CODE FOR JP    @D@@@MBD
)@@G@@FILL(1) SAC   002003,XGRCBA  . NL  \<  CODE FOR JN    @D@@@MFILL(1) SAC BE
)@@G@@  002003,XGRCAB  . LE  <=  CODE FOR JN    @D@@@MFILL(1) SAC   000001,XGRBF
)@@G@@CAB  . EQ   =  CODE FOR JNZ   @E@O@NFILL(1) SAC   000000,000000 .      PBG
)@@G@@OINTER NOT FILLED IN NOW@B@@@OFILL(1) SAC   000000,XGRPTR .      POINTERBH
)@@G@@@C@@@NFILL(1) SAC    EXNOT,XGNOTT   .    (UNARY) NOT  @C@@@NFILL(1) SAC BI
)@@G@@  000000,XGUPLT   .  +  UNARY PLUS  @C@@@NFILL(1) SAC   000000,XGUMNT   BJ
)@@G@@.  -  UNARY MINUS @[@@@M.     @A@@@M/ .      BUILTIN FUNCTION TABLE     BK
)@@G@@@[@@@M.     @A@@@M.        H1=  EXECUTION ROUTINE     @B@@@M.        H2=BL
)@@G@@  CODE GENERATION ACTION TABLE@[@@@M.     @[@@@M.     @#@@@MXGTBL2* LABEBM
)@@G@@L  .  @E@@@MFILL(1) SAC   000000,FGABST   . BIF  ABS(X)  ABSOLUTE VALUE BN
)@@G@@@D@@@MFILL(1) SAC   000000,FGMAXT   . BIF  MAX(X,Y)  MAXIMUM@D@@@MFILL(1BO
)@@G@@) SAC   000000,FGMINT   . BIF  MIN(X,Y)  MINIMUM@D@N@MFILL(1) SAC   BFMOBP
)@@G@@DT,FGMODT   . BIF  MOD(X,Y) X MOD Y @D@@@NFILL(1) SAC   000000,FGMODT   BQ
)@@G@@. BIF  MOD(X,Y) X MOD Y @D@@@MFILL(1) SAC   000000,FGSIGN   . BIF  SIGN(BR
)@@G@@X) SIGN OF X@D@@@MFILL(1) SAC   000000,FGFLRT   . BIF FLOOR(X)   FLOOR  BS
)@@G@@@D@@@MFILL(1) SAC   000000,FGCEIL   . BIF CEIL(X)    CEILING@D@@@MFILL(1BT
)@@G@@) SAC   000000,FGROUN   . BIF ROUND(X)   ROUND  @E@@@MFILL(1) SAC   0000BU
)@@G@@00,FGTRUN   . BIF TRUNC(X)   TRUNCATE     @E@@@MFILL(1) SAC   000000,FGCBV
)@@G@@PLE   . BIF COMPLEX(X,Y)   COMPLEX  @E@@@MFILL(1) SAC   000000,FGCONJ   BW
)@@G@@. BIF CONJG(X)   CONJUGATE    @E@@@MFILL(1) SAC   000000,FGIMAG   . BIF BX
)@@G@@IMAG(X)    IMAGINARY    @D@@@MFILL(1) SAC   000000,FGREAL   . BIF REAL(XBY
)@@G@@)    REAL   @D@@@MFILL(1) SAC   BFEXPT,FGEXPT   . BIF EXP(X)     E ** X BZ
)@@G@@@E@@@MFILL(1) SAC   BFLOGT,FGLOGT   . BIF LOG(X)     LOG BASE E   @E@@@MCA
)@@G@@FILL(1) SAC   BFLOG1,FGLOG1   . BIF LOG10(X)   LOG BASE 10  @E@@@MFILL(1CB
)@@G@@) SAC   BFLOG2,FGLOG2   . BIF LOG2(X)    LOG BASE 2   @F@@@MFILL(1) SAC CC
)@@G@@  BFATND,FGATND   . BIF ATAND(X)   ARC TAN (DEGREES)  @D@@@MFILL(1) SAC CD
)@@G@@  BFATAN,FGATAN   . BIF ATAN(X)    ARC TAN@F@@@MFILL(1) SAC   BFTAND,FGTCE
)@@G@@AND   . BIF TAND(X)    TANGENT (DEGREES)  @D@@@MFILL(1) SAC   BFTANT,FGTCF
)@@G@@ANT   . BIF TAN(X)     TANGENT@D@@@MFILL(1) SAC   000000,XGBADD   . BIF CG
)@@G@@ADD(X,Y,P,Q) ADD  @D@@@MFILL(1) SAC   BFAFTR,FGAFTR   . BIF AFTER(X,Y)  CH
)@@G@@AFTER @E@@@MFILL(1) SAC   BFSIND,FGSIND   .  BIF SIND(X)   SIN (DEGREES)CI
)@@G@@@D@@@MFILL(1) SAC   BFSINT,FGSINT    . BIF SIN(X)    SIN    @E@@@MFILL(1CJ
)@@G@@) SAC   BFBFOR,FGBFOR   . BIF BEFORE(X,Y)  BEFORE     @F@@@MFILL(1) SAC CK
)@@G@@  BFCOSD,FGCOSD   . BIF COSD(X)    COSINE (DEGREES)   @D@@@MFILL(1) SAC CL
)@@G@@  BFCOST,FGCOST   . BIF COS(X)     COSINE @D@@@MFILL(1) SAC   BFBOOL,FGBCM
)@@G@@OOL   . BIF BOOL(X,Y,Z)  BOOL @F@@@MFILL(1) SAC   BFCLAT,FGCLAT   . BIF CN
)@@G@@COLLATE     COLLATING SEQUENCE@F@@@MFILL(1) SAC   BFCOPY,FGCOPY   . BIF CO
)@@G@@COPY(X,P)   COPY (REPEAT)     @E@@@MFILL(1) SAC   BFSQRT,FGSQRT   . BIF CP
)@@G@@SQRT(X)     SQUARE ROOT @C@@@MFILL(1) SAC   BFSBPV,FGSBPV   . PSEUDOVAR CQ
)@@G@@SUBSTR@D@@@MFILL(1) SAC   BFINDX,FGINDX   . BIF INDEX(X,Y)   INDEX@D@@@MCR
)@@G@@FILL(1) SAC   BFLNTH,FGLNTH   . BIF LENGTH(X)   LENGTH@D@@@MFILL(1) SAC CS
)@@G@@  BFHIGH,FGHIGH   . HIGH(N)          HIGH @D@@@MFILL(1) SAC   BFLOWT,FGLCT
)@@G@@OWT   . LOW (N)          LOW  @D@@@MFILL(1) SAC   BFDCAT,FGDCAT   . DECACU
)@@G@@T(X,Y,Z)    DECAT @E@@@MFILL(1) SAC   BFLBND,FGLBND   . LBOUND(A,N)     CV
)@@G@@LOWER BOUND @F@@@MFILL(1) SAC   BFHBND,FGHBND   . BIF HBOUND(A,N)   UPPECW
)@@G@@R BOUND     @E@@@MFILL(1) SAC   BFDIMT,FGDIMT   . BIF DIM         DIMENSCX
)@@G@@ION   @D@@@MFILL(1) SAC   BFDATE,FGDATE   . BIF DATE         DATE @D@@@MCY
)@@G@@FILL(1) SAC   BFTIME,FGTIME   . BIF TIME       TIME   @B@@@MFILL(1) SAC CZ
)@@G@@  BFBINT,FGBINT   . BIF BINARY@B@@@MFILL(1) SAC   BFBITT,FGBITT   . BIF DA
)@@G@@BIT   @B@@@MFILL(1) SAC   BFCHAR,FGCHAR   . BIF CHAR  @C@@@MFILL(1) SAC DB
)@@G@@  BFDECT,FGDECT   . BIF DECIMAL     @B@@@MFILL(1) SAC   BFFIXD,FGFIXD   DC
)@@G@@. BIF FIXED @B@@@MFILL(1) SAC   BFFLTT,FGFLTT   . BIF FLOAT @C@@@MFILL(1DD
)@@G@@) SAC   BFPREC,FGPREC   . BIF PRECISION   @F@@@MFILL(1) SAC   BFSBST,FGSDE
)@@G@@BST   . BIF SUBSTR(X,Y[,Z]) SUBSTRING     @C@@@MFILL(1) SAC   000000,FGRDF
)@@G@@LPV   . PSEUDOVAR REAL  @C@@@MFILL(1) SAC   000000,FGIMPV   . PSEUDOVAR DG
)@@G@@IMAG  @D@N@MFILL(1) SAC   BFPNPV,FGPNPV   . PSEUDOVAR PAGENO.     @D@@@NDH
)@@G@@FILL(1) SAC   000000,FGPNPV   . PSEUDOVAR PAGENO.     @C@@@MFILL(1) SAC DI
)@@G@@  BFTRNS,FGTRNS   . BIF TRANSLATE   @B@@@MFILL(1) SAC   BFVERY,FGVERY   DJ
)@@G@@. BIF VERIFY@B@@@MFILL(1) SAC   BFSTRT,FGSTRT   . BIF STRING@C@@@MFILL(1DK
)@@G@@) SAC   BFSTPV,FGSTPV   . PSEUDOVAR STRING@B@@@MFILL(1) SAC   000000,XGBDL
)@@G@@DIV   . BIF DIVIDE@B@@@MFILL(1) SAC   BFDOTT,FGDOTT   . BIF DOT   @C@@@MDM
)@@G@@FILL(1) SAC   INEVRY,EVRYIN-XGTBL2 . BIF EVERY  @B@@@MFILL(1) SAC   BFLIDN
)@@G@@NO,FGLINO   . BIF LINENO@B@@@MFILL(1) SAC   000000,XGBMUL   . BIF MULT  DO
)@@G@@@B@@@MFILL(1) SAC   BFPANO,FGPANO   . BIF PAGENO@C@@@MFILL(1) SAC   INPRDP
)@@G@@OD,PRODIN-XGTBL2 . BIF PROD   @C@@@MFILL(1) SAC   BFRVSE,FGRVSE   . BIF DQ
)@@G@@REVERSE     @C@@@MFILL(1) SAC   INSOME,SOMEIN-XGTBL2 . BIF SOME   @C@@@MDR
)@@G@@FILL(1) SAC   000000,XGBSUB   . BIF SUBTRACT    @C@@@MFILL(1) SAC   INSUDS
)@@G@@MT,SUMTIN-XGTBL2 . BIF SUM    @B@@@MFILL(1) SAC   BFRAND,FGRAND   . BIF DT
)@@G@@RAND  @B@N@MFILL(1) SAC   BFENDT,FGENDT   . ENDFILE   @B@@@NFILL(1) SAC DU
)@@G@@  000000,FGONCD   . ONCODE BIF@B@@@MFILL(1) SAC   BFUNSP,FGUNSP   . BIF DV
)@@G@@UNSPEC@D@@@MFILL(1) SAC   BFUNPV,FGUNPV   . BIF UNSPEC PSEUDOVAR  @B@@@MDW
)@@G@@FILL(1) SAC   BFCLCK,FGCLCK   . BIF CLOCK @C@N@MFILL(1) SAC   BFCLPV,FGCDX
)@@G@@LPV   . PSEUDOVAR CLOCK @C@@@NFILL(1) SAC   000000,FGCLPV   . PSEUDOVAR DY
)@@G@@CLOCK @B@@@MFILL(1) SAC   BFCSF$,FGCSF$   . CSF$ BIF  @C@Q@NFILL(1)  SACDZ
)@@G@@     000000,000000 .   ADDR BIF     @C@@@QFILL(1)  SAC     BFADDR,FGADDREA
)@@G@@ .   ADDR BIF     @D@Q@NFILL(1)  SAC     000000,000000 .   ALLOCATION BIEB
)@@G@@F     @D@@@QFILL(1)  SAC     BFALLC,FGALLC .   ALLOCATION BIF     @C@Q@NEC
)@@G@@FILL(1)  SAC     000000,000000 .   NULL BIF     @C@@@QFILL(1)  SAC     0ED
)@@G@@00000,FGNULL .   NULL BIF     @C@@@NFILL(1)  SAC     000000,000000 .   EEE
)@@G@@MTPY BIF    @E@@@NFILL(1)  SAC     BFTRIM,FGTRIM .   TRIM BUILT IN FUNCTEF
)@@G@@ION   @A@@@NFILL(1)  SAC   0,0 .           NULL0@B@@@NFILL(1)  SAC   0,FEG
)@@G@@GONST .      ONSTMT     @B@@@NFILL(1)  SAC   0,FGONCB .      ONCHAR BIF EH
)@@G@@@B@P@NFILL(1)  SAC   0,FGONCP .      ONCHAR PV  @B@@@PFILL(1)  SAC   0,0EI
)@@G@@      .      ONCHAR PV  @C@@@NFILL(1)  SAC   0,FGONSB .      ONSOURCE BIEJ
)@@G@@F     @B@P@NFILL(1)  SAC   0,FGONSP .      ONSOURCE PV@B@@@PFILL(1)  SACEK
)@@G@@   0,0      .      ONSOURCE PV@B@@@OFILL(1)  SAC     0,FGONFD .        OEL
)@@G@@NFIELD@B@@@OFILL(1)  SAC     0,FGONFL .        ONFILE @B@@@OFILL(1)  SACEM
)@@G@@     0,FGONLC .        ONLOC  @B@@@MEVRYIN       +BFEVRY,FGEVRY   . BIF EN
)@@G@@EVERY @F@@@MPRODIN       +RCFLTM,XGMLTB   . BIF PROD (USE MULTIPLY OPERAEO
)@@G@@TOR)  @B@@@MSOMEIN       +BFSOME,FGSOME   .BIF SOME   @B@@@MSUMTIN      EP
)@@G@@ +000000,XGBPLT   . BIF SUM   @D@@@M/ .       UTILITY SUBROUTINES TO MANEQ
)@@G@@AGE METACODE PTR  @[@@@M.     @[@@@M.     @[@@@M.     @[@@@M.     @D@@@MER
)@@G@@BCKPGC*  LLOC   .  ROUTINE BACKS UP GETC ONE TOKEN    @E@@@M          . ES
)@@G@@                           WITHOUT DOING A GETC @C@@@M         TE   A1,KET
)@@G@@LCH2W .   SEE IF H1 OR H2     @E@@@M         LOOP  A1,LJMP .     ->NE, REU
)@@G@@ETURN POINTING TO H1    @C@@@M         ADD   A1,1,I .      RESET  HALF PEV
)@@G@@OINTER@E@@@M         LOOP  X1,LJMP .     ->EQ, RETURN POINTING TO H2    EW
)@@G@@@#@@@MSCGSBC*  LLOC .   @D@@@M .       USE POINTER IN A8 TO SET GETC ANDEX
)@@G@@ DO GETC    @D@@@M         SSC   A8,1 .        RIGHT JUSTIFY OFFSET     EY
)@@G@@@E@@@M         ADD   A8,ADPBCM-FH2+FXH2 .    COMPUTE CODE ADDRESS @E@@@MEZ
)@@G@@         LOADXM X1,A8 .      NEW WORD ADDRESS LESS SIGN BIT @C@@@M      FA
)@@G@@   LOAD  A1,KLCH2W .   PREPARE TO READ H1 @F@@@M         TP    A8 .     FB
)@@G@@     SKIP IF HIGH ORDER BIT NOT SET (H1)  @D@@@M         ADD     A1,1,I FC
)@@G@@.    CODE IS IN H2 SO SKIP H1 @E@@@M         GETC .              FETCH TFD
)@@G@@HE CURRENT CODE INTO A8 @C@@@M         LJMP .              -> RETURN TO FE
)@@G@@CALLER@E@@@MSXGBC*   LLOC .              MAKE BETA CODE POINTER IN A3   FF
)@@G@@@F@@@M         LOAD  A3,W1XU,X1 .  GET ADDRESS OF NEXT WORD TO GETC     FG
)@@G@@@G@@@M         SUB   A3,ADPBCM-FH2+FXH2 . REMOVE OFFSET FOR MOVING B-CODFH
)@@G@@E     @^@@@M         SLB   A3,1 .   @B@@@M         TE    A1,KLCH2W .   SFI
)@@G@@KIP IF H1   @B@@@M         ADD   A3,1,I .      ADD 1 IF H2  @#@@@M      FJ
)@@G@@   LJMP .   @#@@@MBPTRDC*  LLOC  .  @F@@@M . ROUTINE TAKES POINTER IN LOFK
)@@G@@WER BYTE OF A8 TO RESET GETC ROUTINE@G@@@M . LOWEST BIT DETERMINES H1 ORFL
)@@G@@ H2 WHILE BITS 8 - 1 DETERMINE OFFSET     @#@@@M . FROM DXGXBS    @D@@@MFM
)@@G@@ . DESTROYS A9         RESETS X1, A1 TO NEW VALUES    @A@@@M . OUTPUT   FN
)@@G@@TOKEN FROM GETC IS IN A8@G@@@M         AND,U A8,0777 .     GET DESIRED BFO
)@@G@@ITS                ********   @I@@@M         SSC   A9,1 .        SHIFT AFP
)@@G@@WAY H1 AND H2 BIT FROM THE OFFSET          *    @F@@@M         ADD   A9,FQ
)@@G@@W1U,X1 .   INCLUDE ADDRESS OF EXPRESSION START  @D@@@M         LOADXM X1FR
)@@G@@,A9 .      RESET GETC WORD POINTER  @D@@@M         TP    A9 .          SFS
)@@G@@KIP ONE GETC IF EVEN    @#@@@M         GETC .   @#@@@M         GETC .   FT
)@@G@@@C@@@M         LJMP .              -> RETURN TO CALLER@G@@@M         ENDFU
)@@G@@   .             CODE GENERATION SERVICE ROUTINES AND TABLES___FTIME,FGTFV
)@@G@@IME   . BIF TIME       TIME   @B@@@MFILL(1) SAC   BFBINT,FGBINT   . BIF FW
)@@G@@BINARY@B@@@MFILL(1) SAC *[S@@[*SDFF*@F@@@# 0)^@)CTJE[TELDC9CE))AC9A85^[]FX
)@@G@@FC)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@[@@@# 0)^@)@H@@@# 0)^@)EDPC(NE-DD9IFY
)@@G@@ES)CTJD1#C(MD1DD1B^[OD[DES)ETCD9PD-^^[]C*)C-DEL CTOC(^^[OD8'@[@@@# 0)^@)FZ
)@@G@@@B@@@# 0)^@)^@)^@)^[HCDME1DD0)E0,^[UC(GDTJE9DE-U@E@@@# 0)^@)^@)^@)^[^C(KGA
)@@G@@CDME-HC(IE))D9A^[#D9HE[PE- EK)ET#DD D1#C*)@C@@@# 0)^@)^@)^@)^[PD1DE1 ELNGB
)@@G@@DDOFC)D9A^[HCDMFDGCDIC))@E@@@# 0)^@)^@)^@)^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGGC
)@@G@@CDIC))AK0A84AK)^@)@[@@@# 0)^@)@M@@@# 0)^@)^@)^@)^[KC(MD(DETNDDJD0)E-J^[PGD
)@@G@@ET ^[OD[ ET ^[GDDNE-DD1BES)CDIC))E-CC*)CTJD(KE(OC(M^[KELJC9MCDHES)E-CC(TGE
)@@G@@@I@@@# 0)^@)EL E[MC(NC(IE))DDN^[BEL[D1OC(^^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1BGF
)@@G@@^[#D9IC-DE-DD9IES'@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@1 0)E(ID-DD(DE- C))E(NGG
)@@G@@C*)D([FC)CL ^[HCD^C*)D9A^[OD[ ^[KELJC9MCDHES)EL E[MC(NC(IE- C))CLT@M@@@#GH
)@@G@@ 0)^@)E-CC(NC*)D-DETODDIC9N^[KELJE1DC- C))E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JGI
)@@G@@EK)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^@J@@@# 0)^@)E[G 81^[#D9HE[DD- EK)EL GJ
)@@G@@D([DDIES)CDNETJCTDCDOC(^^[RDDOD@)E-CC(NC*)E[MD9BEL[D(N 0)^@)@[@@@# 0)^@)GK
)@@G@@@K@@@# 0)^@)^@)^@)^@2 0)D(JC-DC1DCT[E-DD9IES)D([FC)CL ^[HCD^C*)E-J^[OD[ GL
)@@G@@^[GDDNE-DD1BES)E[MD9QDD^C(^BK)@[@@@# 0)^@)@M@@@# 0)^@)^@)^@)^@*CC(^[[D1TGM
)@@G@@^[MC(NE(GE-DD1B^[KELJC9MCDH ))D9M^[MC(KD9ME)?^[KCDKC(M^[JEK)C-JCTPD( D1OGN
)@@G@@CDODDJD0)^@)@M@@@# 0)^@)^@)^@)^[^C(NCTMDD]DDIC8)ETPCTC^[KELJC9MCDH^[RDDGGO
)@@G@@D))CTGC([ELGFC)DDIC-DCT[E- ^[OD[[E))E-CC*)E[MD9BEL[D*)@J@@@# 0)^@)^@)^@)GP
)@@G@@^[DES)CC)C-DCDGC(#E))D9A^[KD-PD*)D9M^[DES)C- ELDE1 C))C1MD9H^[KD-PD*?^[[GQ
)@@G@@D1^^@)@[@@@# 0)^@)@L@@@# 0)^@)^@)^@)^@*CK(^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DGR
)@@G@@D9IES?^[JE-CC(M^[OD[[D0)E-MDDQDD[D))CTJELMC(#E-DD9IES)@K@@@# 0)^@)^@)^@)GS
)@@G@@^[JC0)C(MELJELN^[DD0)E-CC*)ETJE(MCT ^[KELJC9MCDHES?^[ND[[D-G^[]C*)EL E[JGT
)@@G@@ELOC(^^[[D1^@L@@@# 0)^@)^@)^@)^[[^[]ELDC(A^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)GU
)@@G@@C1 CDOE(MC*)CD^C- C))ETCCDGD))CL ^[NE(]D(DE-OC(^@F@@@# 0)^@)^@)^@)^[OD8)GV
)@@G@@E-CC*)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^ ))CDIC))@[@@@# 0)^@)@L@@@# 0)^@)GW
)@@G@@^@)^@)^@*CS(^[ID8)E[MD9BEL[D(N^[^C(MDDQC(^^[AELJD*)E-CC(NC*)D-DETODDIC9NGX
)@@G@@^[ND[[D-G^[]C*)ETJD-^^@)@M@@@# 0)^@)^@)^@)^[RDDOD[JE(O^[RELDE-OC(I^[[E[KGY
)@@G@@ELJE1[D))C1MD9H^[OD[ ^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC)?^[[D1^^@)@[@@@#GZ
)@@G@@ 0)^@)@L@@@# 0)^@)^@)^@)^@*C)(^[#D9KDD ES)D9A^[OD[ ET ^[KELJC9MCDHES)D([HA
)@@G@@FC)CL ^[OEL[D1ND(DE-OC(^^[OD8)D9OD[ EK)^@)@L@@@# 0)^@)^@)^@)^[GD9#CDODDJHB
)@@G@@D1N^[KELJE1DC- C))E-CCDO^[NE(#D@)E-MCDIETHDDOE-[D-N^[#D- CDMD-T^[DD1^DD#HC
)@@G@@CDOC*)@L@@@# 0)^@)^@)^@)^[RD[ E-CC(M^[OD[ ^[KELJC9MCDHES)CDMC*)C(SCD#E))HD
)@@G@@CTJE[DC(N^[JC0)E-CC*)E(IDDQC(METDE-T^[JC0)@J@@@# 0)^@)^@)^@)^[HCDMFDGCDIHE
)@@G@@C))E[GE(H^[#D9HE[DD- EK)D9M^[[EL ^[HD9^DDADD#CDODDJD1N^[OD8)DDO 0)@[@@@#HF
)@@G@@ 0)^@)@L@@@# 0)^@)^@)^@)^@3 0)E-CC(NC*)CTJD1^DDODDJD1N^[JD1GFC)CDKE[GFC)HG
)@@G@@E-J^[OD[ ^[KD-PD*)CTJD(KDDGC(M^[DE-NC(GC0?@L@@@# 0)^@)CDIC))CDMC*)D1JE))HH
)@@G@@D( CDIE))E-J^[[E[KD-T^[OD8)CDIFC)E[MD9BEL[D*)E9MDDOE- D0)E(NDDIC8)E[GE(HHI
)@@G@@ 0)^@)@J@@@# 0)^@)E-CC*)E[PELKD9NC*)D9A^[OD[ ET ^[#D9IC-DE-DD9IES)DDN^[OHJ
)@@G@@D8)CDGD-JE8)CDIFC)E(NC(M^[OD8)@L@@@# 0)^@)C(SE[ ELDD( D1O^[RDDOD@)E-CC*)HK
)@@G@@CTJD(KDDGC(M^[[ES)D-JD1B^[[ES)E-CC*)EL ETPD-ODDIC8)E[MD9^E(#E))^@)@M@@@#HL
)@@G@@ 0)^@)DDN^[ID9O^[ND9GC))CDIC))CDN^[GD9IC8)CDN^[DE))DDN^[FD1JE9I^[OD[[E))HM
)@@G@@E-CC*)E[MD9^E(#E))C- E1 D-JE[ C))^@)@^@@@# 0)^@)C1MD9H^[KD-PD*,^@)@[@@@#HN
)@@G@@ 0)^@)@[@@@# 0)^@)@[@@@# 0)^@)@[@@@# 0)^@)@[@@@# 0)^@)@[@@@# 8,^@)@ @@@]HO
)@@G@@D(NC8%^@)^@)^[KELJCS)^@%AC) 0)@C@@@]FLH K*D(NC8*AC?AC( C)C(LE*)A)% @= (KHP
)@@G@@CDME)1 C) 0)@B@@@]FLS K*D(NC8*AC?AC( C)C(LE*)D(NC8*AC?AK(^@,@^@@@]^@)^@)HQ
)@@G@@^@)^@)^[ D1^^@,^@)@^@@@]E[OAK%^@)^@)^[KELJCS) 0)@B@@@]C1H^@)^@)^@)^[AD9MHR
)@@G@@D*)^@6 )1AK?A0?AC2^@,^@)@M@@@]DS)^@)^@)^@)^[^D8)^@)^[KE)2 @1 )1 C) ))C1HHS
)@@G@@^@:FLS @2 LF *2 C?FLH @2 LF *2 C?FLS @2 LF *1 C?FLH @2 LF *1 C) 0)@^@@@]HT
)@@G@@^@)^@)^@)^@)^[ D1^^@,^@)@^@@@]^@)^@)^@)^@)^[[F[M^)) 0)@^@@@]^@)^@)^@)^@)HU
)@@G@@^[^CTGELB^@,@ @@@]D(NC9N^@)^@)^[#ET CTO^@3^@,^@)@^@@@]D(NC83AC%^@)^[GCD]HV
)@@G@@C(G^@,@A@@@]^@)^@)^@)^@)^@:E[[ELOAK?E[[ELOAC) 0)@^@@@]E[[ELOAC)^@)^[GCD]HW
)@@G@@C(G^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@0 )4^@,@A@@@]^@)^@)^@)^@)^[HETB^@)^@3HX
)@@G@@AS?A)) 0)^@)@C@@@]^@$ET\IL2JC-^[IH94^[9G(4^[(H(0H->H(>H14G(=^@$^@,@ @@@]HY
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1 )2^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@5 )2^@,@ @@@]HZ
)@@G@@^@)^@)^@)^@)^[HETB^@)^@6 )2^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@7 )2^@,@ @@@]IA
)@@G@@^@)^@)^@)^@)^[HETB^@)^@8 )2^@,@ @@@]^@)^@)^@)^@)^[HETB^@)^@9 )2^@,@A@@@]IB
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1A@?AK) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1AC?AK)IC
)@@G@@ 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1AK?AK) 0)^@)@A@@@]^@)^@)^@)^@)^[HETBID
)@@G@@^@)^@1AS?AK) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1A)?AK) 0)^@)@A@@@]^@)^@)IE
)@@G@@^@)^@)^[HETB^@)^@1A*?AK) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@1A0?AK) 0)^@)IF
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@1A8?AK) 0)^@)@A@#@]^@)^@)^@)^@)^[HETB^@)^@1IG
)@@G@@B@?AK) 0)^@)@A@#@]^@)^@)^@)^@)^[HETB^@)^@1BC?AK) 0)^@)@A@^@]^@)^@)^@)^@)IH
)@@G@@^[HETB^@)^@3BC?AK) 0)^@)@ @@@]^@$D1\I))GD3IT(G9,G(=^@$^@,^@)@ @@@]^@)^@)II
)@@G@@^@)^@)^[HETB^@)^@2 )3^@,@A@@@]^@$E-\H8)H(-H19^[!G(3IT-G9>IS)^8) 0)@ @@@]IJ
)@@G@@^@)^@)^@)^@)^[HETB^@)^@3 )2^@,@^@@@]^@$DC\D8)G(2IL\IK)^8) 0)@ @@@]^@)^@)IK
)@@G@@^@)^@)^[HETB^@)^@4 )2^@,@ @@@]^@$D(-J[(H(5H*)H95I-0I(4^@$^@,@ @@@#^@)^@)IL
)@@G@@^@)^@)^[HETB^@1B@?AC1^@)@J@@@#^@$CD2G95H(>H14^[(IS)C1DF[ C))GL5I))H1\^[3IM
)@@G@@GT-H->^[(IS)G9(I1>H0?^[2G(3I(?I))HD3^[AD-JCDO^@$@ @@@#^@)^@)^@)^@)^[HETBIN
)@@G@@^@1BC?AC0^@)@J@@@#^@$CD2G95H(>H14^[(IS)C1GD9[E))GL5I))IT<GD?G*)HD3^[$HD6IO
)@@G@@G(, ))IL>IT5H-4^[(IS)C1DF[ C))^8)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2A@?AS)IP
)@@G@@ 0)^@)@B@@@]^@$CT\H(0HD?G(2^[>IL2H92 0)CTBCDR^@$^@,^@)@A@@@]^@)^@)^@)^@)IQ
)@@G@@^[HETB^@)^@2AC?AS) 0)^@)@B@@@]^@$CT\H(0HD?G(2^[>IL2H92 0)CTBCL^^@$^@,^@)IR
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@2AK?AS) 0)^@)@B@#@]^@$E--GL?G*)H96G(2G1?H97IS
)@@G@@ 0)CT\G->^@$^@,^@)@B@@@#^@$E--GL?G*)H96G(2G1?H97 0)CTJC- ^@$^@,^@)@A@@@]IT
)@@G@@^@)^@)^@)^@)^[HETB^@)^@2AS?AS) 0)^@)@B@#@]^@$E--GL?G*)H96G(2G1?H97 0)CT$IU
)@@G@@IT4HS)^8) 0)@B@@@#^@$E--GL?G*)H96G(2G1?H97 0)CTBETODS)^8) 0)@A@@@]^@)^@)IV
)@@G@@^@)^@)^[HETB^@)^@2A)?A*) 0)^@)@G@#@]^@$ET9IT(H0\IT9IT0IL(H14^[-IT3I(!G(=IW
)@@G@@^[(H0)HC\H8)IT4GD4G(!G(,I-3^@$^@,^@)@G@@@#^@$ETTETDD0\ETTETKELDD1O^[-IT3IX
)@@G@@I(!G(=^[(H0)DC\D8)IT4GD4G(!G(,I-3^@$^@,^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2IY
)@@G@@A*?A0) 0)^@)@D@#@]^@$D1\^[=GD4GC)G1\IL!GD4^[(H0)G1\IL!GD4^[&HD>H-=^@$^@,IZ
)@@G@@@D@@@#^@$D1\^[=GD4GC)G1\IL!GD4^[(H0)C1JELHCDO^[&HD>H-=^@$^@,@A@@@]^@)^@)JA
)@@G@@^@)^@)^[HETB^@)^@2A0?A*) 0)^@)@D@#@]^@$C1\IL!GD4^[7HD?H))GL>^[>J[>GT5I->JB
)@@G@@G))H9,GT> 0)^8) 0)@D@@@#^@$C1JELHCDO^[7HD?H))GL>^[>J[>GT5I->G))H9,GT> 0)JC
)@@G@@^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2A8?A)) 0)^@)@B@@@]^@$E[-IL-H(>I->IK)JD
)@@G@@HD,^[D 9J^[?HD3I))^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@2B@?A0) 0)^@)@D@@@]JE
)@@G@@^@$D->H1$I-*^[\G0)F-AH1>G9-I-(I1> 0)B@0^[5IT>G))^8) 0)@A@@@]^@)^@)^@)^@)JF
)@@G@@^[HETB^@)^@2BC?AC1^@,^@)@J@@@]^@$CL\I(,G-3^[&H92^[3I(+IT<IL(I[4^[YC-\G0)JG
)@@G@@F-AI-\H8)H--IL$G*,^@*A@'AC0 C)HD3^[5IT>G))^8) 0)@A@@@]^@)^@)^@)^@)^[HETBJH
)@@G@@^@)^@3A@?AC0^@,^@)@H@@@]^@$DD,^[3I(+IT<IL(I[4^[YC-\G0)F-AH-\I9>IK)GL\I(,JI
)@@G@@G))B0)I(0I[>IK)GL\I(,G))^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3AC?AC0^@,^@)JJ
)@@G@@@F@@@]^@$F-AHD3^[4H9\^[?GD2G9> 0)D-\I9>IK)GL\I(,G))HD,^[YC))HD3^@0^@$^@,JK
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@3AK?AC1^@,^@)@H@@@]^@$F-AHD3^[4H9\^[?GD2G9>JL
)@@G@@ 0)E(0I[>IK)GL\I(,G))HD,^[YC).^[?H97G(2^[+H95H1=^@$^@,@A@@@]^@)^@)^@)^@)JM
)@@G@@^[HETB^@)^@3A)?A8) 0)^@)@D@@@]^@$F-AH[-IS)GD4I-2HD+I(4G*)H9&^@% 0)AC0^[5JN
)@@G@@IT>G))^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3A*?A*) 0)^@)@B@@@]^@$F-AH[-IS)JO
)@@G@@GC)H1\H0! K)GL\I(,G))^8) 0)^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@3A0?A*) 0)^@)JP
)@@G@@@C@@@]^@$D->H1$I-*^[4H9\^[+HD$ 0)AC0^[5IT>G))^8) 0)^@)@A@@@]^@)^@)^@)^@)JQ
)@@G@@^[HETB^@)^@3A8?AS) 0)^@)@B@@@]^@$CT\H(0HD?G(2^[>IL2H92 0)CTBCLF^@$^@,^@)JR
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@3B@?AK) 0)^@)@A@@@]^@$DD!I[2H90G(2^[0IL>GT(JS
)@@G@@IT(H9,^@$^@,@A@^@]^@)^@)^@)^@)^[HETB^@)^@4A@?AS) 0)^@)@A@@@^^@)^@)^@)^@)JT
)@@G@@^[HETB^@)^@3BC?BC) 0)^@)@K@@@^^@$CL C9DD0)GL?H9<HS)H[-IS)H1\^[=G(<H--IL>JU
)@@G@@G))I1-IL(GD+H->IS?^[^D8;^[(IS)I[2G(&G(2IL>G))^8) 0)^@)@A@@@^^@)^@)^@)^@)JV
)@@G@@^[HETB^@)^@4A@?AS) 0)^@)@B@#@]^@$C-5I[?HD<GD4G*)GT-IT>^[0IL>G1(J@)^8) 0)JW
)@@G@@@B@@@#^@$C-5I[?HD<GD4G*)CT[ET ^[0IL>G1(J@)^8) 0)@A@@@]^@)^@)^@)^@)^[HETBJX
)@@G@@^@)^@4AC?A*) 0)^@)@E@@@]^@$D1\H0!GT\H13I--H14^[-IL$I(!G(,I),^@1A@)HD3^[5JY
)@@G@@IT>G))^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4AK?A*) 0)^@)@F@@@]^@$D1\H0!IL>JZ
)@@G@@GD?^[-IL$I(!G(,I),^[DH(-G9(H1-IL9^[0GD2I))I(3G(=^@$^@,@A@@@]^@)^@)^@)^@)KA
)@@G@@^[HETB^@)^@4AS?A*) 0)^@)@D@@@]^@$CD+IS*GD2G95H(>H14 C)B0)A05A*3A*,^@1A@)KB
)@@G@@I(3G(=^@$^@,@A@@@]^@)^@)^@)^@)^[HETB^@)^@4A)?A)) 0)^@)@A@@@]^@$ET<GD?G*)KC
)@@G@@G1-GT4H92^@"^@3A*)^8) 0)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4A*?A*) 0)^@)@G@@@]KD
)@@G@@^@$DD,GT\H(0GD4HD+H->^[-I-4IL(GL5I->IS)H9,^[2G(4I(2H1>G))I1-H-5G*)^8) 0)KE
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@4A0?AS) 0)^@)@B@@@]^@$CT\H(0HD?G(2^[>IL2H92KF
)@@G@@ 0)CTBC-M^@$^@,^@)@A@@@]^@)^@)^@)^@)^[HETB^@)^@4A8?BC) 0)^@)@G@#@]^@$F-AKG
)@@G@@HD3^[(H-?G($GD?^[(H0)IT4GD4HD<^[6GD2HD-GL?G*,^[WC((IS)I(3G(=^@$^@,@G@@@#KH
)@@G@@^@$F-AHD3^[(H-?G($GD?^[(H0)ETOCDODD#^[6GD2HD-GL?G*,^[WC((IS)I(3G(=^@$^@,KI
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@4B@?B@) 0)^@)@H@#@]^@$F-AHD3^[,H94^[<H9,IT4KJ
)@@G@@GD,I))H90G(2GD,G))HD,^[3I--I-(GS)I1-IL(GD+H->^@$^@,^@)@H@@@#^@$F-AHD3^[,KK
)@@G@@H94^[<H9,IT4GD,I))H90G(2GD,G))HD,^[NE-[E-DCS)I1-IL(GD+H->^@$^@,^@)@A@#@]KL
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4BC?B@) 0)^@)@A@@@#^@)^@)^@)^@)^[HETB^@)^@4BC?AC3KM
)@@G@@^@,^@)@H@#@]^@$CT\H16G(2IT(H9,^[2G(1I((IL>G))I-\^[!GD4GT*^[0GD2GD!G(4G(2KN
)@@G@@^[WC1\G0)F-#^@$^@,@O@@@#^@$CT\H16G(2IT(H9,^[2G(1I((IL>G))I-\^[!GD4GT*^[0KO
)@@G@@GD2GD!G(4G(2^[WC1\G0)F-#^@,^[[IL$I(!G(,I))I[-IT3G(=^[+JC)I1-H-5G*)^8) 0)KP
)@@G@@@A@@@]^@)^@)^@)^@)^[HETB^@)^@5A@?A0) 0)^@)@I@@@]^@$ET<GD?GD2^[-IL$I(!G(,KQ
)@@G@@I))IT5I[0H-(G(=^[4H8)GD$G92G($GD4G*)I[-IL-H(>I->IK)^8) 0)^@)@A@@@]^@)^@)KR
)@@G@@^@)^@)^[HETB^@)^@5AC?AC1^@,^@)@N@@@]^@$C15H1<I-(H9,^[2G(1I((IL>IS)IL>GD?KS
)@@G@@^[-IL$I(!G(,I),^[MG(-H))I[-IL4^[\G0)GT\H(0H->J@)GD2G95H(>H14^[(IS)I(3G(=KT
)@@G@@^@$^@,@A@@@]^@)^@)^@)^@)^[HETB^@)^@5AK?A)) 0)^@)@B@@@]^@$C[PHD3^[,H9, (3KU
)@@G@@I--H1=GD2G))E[G 81^@$^@,@A@@@]^@)^@)^@)^@)^[HETB^@)^@5AS?BC) 0)^@)@G@#@]KV
)@@G@@^@$CD2G95H(>H14^[4H8)IL\I(,G))H95I))H9&^[2GD,G9> 0)A@)HD3^[5IT>G))^8) 0)KW
)@@G@@@G@@@#^@$CD2G95H(>H14^[4H8)ELJE(IC))H95I))H9&^[2GD,G9> 0)A@)HD3^[5IT>G))KX
)@@G@@^8) 0)@ @@@ ^@)^@)^@)^@)^[!IT$^@)^@5A)?AC3@O@@@ ^@$CD2G95H(>H14^[WC-4H8)KY
)@@G@@G15H1<I-(H9,^[WCT(IS)CL[ET C))H92^[#D9IE-MD9GD- C),^[[IL$I(!G(,I))I[-IT3KZ
)@@G@@G(=^[+JC)I1-H-5G*)^8)^@)@A@@@A^@)^@)^@)^@)^[HETB^@)^@)^@5A*?BC) 0)@L@@@ALA
)@@G@@^@)^@)^@)^@)^@$D-\I8)H92G->IK)G-(G9(I-3^[-IL>^[?H93I))G-5G*)I-\^[=HD6HD3LB
)@@G@@HD\H0)H90G(2GD4HD\H0)^8) 0)^@)@^@@@]E[[ELOAK)^@)^[GCD]C(G^@,@ @ @]^@)^@)LC
)@@G@@^@)^@)^[KE)2^@)^@2A8) 0)@ @@@ ^@)^@)^@)^@)^[KE)2^@)^@2B@) 0)@^@@@#^@)^@)LD
)@@G@@^@)^@)^[ D1^^@,^@)___AK) 0)^@)@A@^@]^@)^@)^@)^@)^[HETB^@)^@3BC?AK) 0)^@)LE
)@@G@@*[S@@@*SDFF*@C@C@B.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @C@@@CLF
)@@G@@.   COPYRIGHT 1976 BY UNIVERSITY OF MARYLAND    @[@@@B.     @D@@@B.   QULG
)@@G@@ESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@B.     @ @@@B.     LH
)@@G@@   MARVIN V. ZELKOWITZ  @B@@@B.        DEPARTMENT OF COMPUTER SCIENCE   LI
)@@G@@@A@@@B.        UNIVERSITY OF MARYLAND     @B@@@B.        COLLEGE PARK, MLJ
)@@G@@ARYLAND 20742     @[@@@B.     @G@@@B.        PERMISSION TO USE THESE LISLK
)@@G@@TINGS AND THE COMPUTER PROGRAMS THEY@E@@@B.   REPRESENT IS GRANTED UNDERLL
)@@G@@ THE FOLLOWING CONDITIONS:    @[@@@B.     @G@@@B.        1. UNLIMITED USLM
)@@G@@E MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@B.   THESE LISTINGSLN
)@@G@@ PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLAND@E@@@B.   PL/1 COMLO
)@@G@@PILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@B.     @F@@@B.     LP
)@@G@@   2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDED:   @[@@@B.     LQ
)@@G@@@G@@@B.        (A) ANY RESULTING PROGRAM, OR REPORT, PAPER OR DOCUMENTATLR
)@@G@@ION   @G@@@B.        DESCRIBING SUCH PROGRAM WILL CLEARLY INDICATE THAT LS
)@@G@@THE PROGRAM @E@@@B.        IS A DIALECT OF PLUM OR IS DERIVED FROM PLUM,LT
)@@G@@ AND  @[@@@B.     @G@@@B.        (B) ALL SUCH MODIFICATIONS, OTHER THAN LU
)@@G@@TRIVIAL CORRECTIONS     @F@@@B.        OF ERRORS IN THE SOURCE PROGRAMS,LV
)@@G@@ SHALL BE REPORTED AND  @G@@@B.        A BRIEF DESCRIPTION OF THE FEATURLW
)@@G@@E ADDED SHALL BE SUBMITTED    @C@@@B.        TO THE UNIVERSITY OF MARYLALX
)@@G@@ND, AND     @[@@@B.     @F@@@B.        (C) NO PROGRAMS DERIVED FROM THESLY
)@@G@@E LISTINGS SHALL BE SOLD@G@@@B.        WITHOUT WRITTEN APPROVAL FROM THELZ
)@@G@@ UNIVERSITY OF MARYLAND, AND  @[@@@B.     @F@@@B.        (D) COPIES OF TMA
)@@G@@HESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@B.        LOCATIONS PROVIMB
)@@G@@DED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@B.        WHETHER TMC
)@@G@@HE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     @E@@@B.        MARMD
)@@G@@YLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@B.     @G@@@B.     ME
)@@G@@   3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILER ITSELF,    @F@@@BMF
)@@G@@.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN USING PLUM. @E@@@BMG
)@@G@@.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USER TO @F@@@B.   EXMH
)@@G@@PERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRODUCT @G@@@B.   ISMI
)@@G@@ NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DEVELOPED   @#@@@BMJ
)@@G@@.   FROM PLUM.    @[@@@B.     @[@@@B.     @[@@@B.     @[@@@B.     @[@@@BMK
)@@G@@.     @[@@@B/.    @#@@@B         AXR$ .   @#@@@B         DCLRG .  @#@@@BML
)@@G@@         UNLIST . @#@@@B@ADD,P PLTVDS .   @#@@@B@ADD,P PLCGST .   @#@@@BMM
)@@G@@@ADD,P PLDSAW .   @#@@@B          LIST .  @#@@@B          PLWORD .@#@@@BMN
)@@G@@          PLCGD . @#@@@B          PLSD .  @#@@@B         PLAC .   @#@@@BMO
)@@G@@          PLIG .  @#@@@BCGBF     CSECT 3. @[@C@B.     @]@C@BFGLOG1*     MP
)@@G@@@]@C@BFGLOG2*     @]@C@BFGSIND*     @]@C@BFGCOSD*     @]@C@BFGTAND*     MQ
)@@G@@@[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   GGTNOP,CBB1RL .@^@C@BFILL(1MR
)@@G@@)  SAC   CBBNOP,0 @[@C@B.     @C@C@B.        RAND FUNCTION - NON- PL/1 SMS
)@@G@@TANDARD     @[@C@B.     @[@C@B.     @ @C@BFGRAND*  SAC GGTNOP,CBRAND    MT
)@@G@@@^@C@BFILL(1)  SAC CBBNOP,0 . @[@C@B.     @[@C@B.     @[@C@B.     @]@C@BMU
)@@G@@FGEXPT*     @]@C@BFGLOGT*     @]@C@BFGTANT*     @]@C@BFGSINT*     @]@C@BMV
)@@G@@FGCOST*     @]@C@BFGSQRT*     @[@C@B.     @[@C@B.     @[@C@B.     @ @C@BMW
)@@G@@FILL(1)  SAC GGTNOP,CBB1RC    @^@C@BFILL(1)  SAC CBBNOP,0   @[@C@B.     MX
)@@G@@@[@C@B.     @B@C@BFGATAN* .                          ARC TAN@[@C@B.     MY
)@@G@@@[@C@B.     @ @C@BFILL(1)  SAC   GGTNOP,CBBATN  @^@C@BFILL(1)  SAC   CBBMZ
)@@G@@NOP,0 @[@C@B.     @[@C@B.     @D@C@BFGATND* .                          ANA
)@@G@@RC TAN DEGREES    @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   GGTNOP,CBNB
)@@G@@BATD  @^@C@BFILL(1)  SAC   CBBNOP,0 @[@C@B.     @B@C@B.                 NC
)@@G@@                 FLOOR  @[@C@B.     @]@C@BFGFLRT*     @ @C@BFILL(1)  SACND
)@@G@@   CBSIGN,CBSFLR  @D@C@BFILL(1)  SAC   CBXFLF,CBXFNP     . FLOAT , FIXEDNE
)@@G@@ Q = 0@D@C@BFILL(1)  SAC   CBXFLQ,CBXFDQ     . FB Q<0, FD Q<0     @D@C@BNF
)@@G@@FILL(1)  SAC   CBXFLR,CBXFFF     . FB Q>0, FD Q>0     @[@C@B.     @[@C@BNG
)@@G@@.     @B@C@B.                                  CEIL   @[@C@B.     @]@C@BNH
)@@G@@FGCEIL*     @ @C@BFILL(1)  SAC   CBSIGN,CBSCEL  @ @C@BFILL(1)  SAC   CBXNI
)@@G@@FLC,CBXFNP  @ @C@BFILL(1)  SAC   CBXFLQ,CBXFDQ  @ @C@BFILL(1)  SAC   CBXNJ
)@@G@@CEL,CBXFFC  @[@C@B.     @[@C@B.     @B@C@B.                             NK
)@@G@@     TRUNC  @]@C@BFGTRUN*     @ @C@BFILL(1)  SAC   CBSIGN,CBSTRN  @ @C@BNL
)@@G@@FILL(1)  SAC   CBXFTQ,CBXFNP  @ @C@BFILL(1)  SAC   CBXFLQ,CBXFDQ  @ @C@BNM
)@@G@@FILL(1)  SAC   CBXTRN,CBXFDP  @[@C@B.     @[@C@B.     @[@C@B.     @B@C@BNN
)@@G@@FGROUN* .                           ROUND @G@C@BFILL(1)  SAC     GGTNOP,NO
)@@G@@CBSRON .   ALL OF THE WORK IS DONE AT STAGEING  @ @C@BFILL(1)  SAC     CNP
)@@G@@BBNOP,0 .   @[@C@B.     @[@C@B.     @[@C@B.     @B@C@BFGMAXT*  .        NQ
)@@G@@                 MAX    @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   GGTNR
)@@G@@ARI,BFSMAX .@ @C@BFILL(1)  SAC   BFFMIN,CBBNOP  @ @C@BFILL(1)  SAC   BFBNS
)@@G@@MIN,CBBNOP  @[@C@B.     @[@C@B.     @B@C@BFGMINT*  .                    NT
)@@G@@     MIN    @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   GGTARI,BFSMIN  NU
)@@G@@@ @C@BFILL(1)  SAC   BFFMIN,CBBNOP  @ @C@BFILL(1)  SAC   BFBMIN,CBBNOP  NV
)@@G@@@[@C@B.     @[@C@B.     @B@C@BFGMODT*  .                         MOD BIFNW
)@@G@@@[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   BFTMOD,BFSMOD  @ @C@BFILL(1NX
)@@G@@)  SAC   BFMODF,CBBNOP  @ @C@BFILL(1)  SAC   BFMODB,CBBNOP  @[@C@B.     NY
)@@G@@@[@C@B.     @C@C@BFGABST* .                          ABSOLUTE VAL @[@C@BNZ
)@@G@@.     @[@C@B.     @ @C@BFILL(1)  SAC   CBTABS,CBSABS  @ @C@BFILL(1)  SACOA
)@@G@@   CBABFR,CBBNOP .@H@C@BFILL(1)  SAC   CBABBR,CBBNOP .     REAL ARE CODEOB
)@@G@@, COMPLEX DONE AT STAGING     @[@C@B.     @[@C@B.     @C@C@BFGSIGN* .   OC
)@@G@@                       SIGN BIF     @[@C@B.     @[@C@B.     @A@C@BFILL(1OD
)@@G@@)  SAC     CBSIGN,CSSIGN .    @A@C@BFILL(1)  SAC     CBSGFR,CBBNOP .    OE
)@@G@@@A@C@BFILL(1)  SAC     CBSGBR,CBBNOP .    @[@C@B.     @[@C@B.     @E@C@BOF
)@@G@@.                                  INLINE DATA TYPE BIF'S   @B@C@BFGBINTOG
)@@G@@*  .                         BINARY @B@C@BFGDECT*  .                    OH
)@@G@@     DECIMAL@B@C@BFGFIXD*  .                         FIXED  @B@C@BFGFLTTOI
)@@G@@*  .                         FLOAT  @C@C@BFGPREC*  .                    OJ
)@@G@@     PRECISION    @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   CBCONV,GGOK
)@@G@@SNOP .@ @C@BFILL(1)  SAC   CBBNOP,0 .     @[@C@B.     @[@C@B.     @E@C@BOL
)@@G@@.                                  REAL IMAG BIFS AND P.V.  @[@C@B.     OM
)@@G@@@]@C@BFGCPLE*     @[@C@B.     @[@C@B.     @C@C@BFILL(1)  SAC   BFTMOD,GGON
)@@G@@SADS .     COMPLEX BIF  @ @C@BFILL(1)  SAC   CBCPLF,CBCPLF .@ @C@BFILL(1OO
)@@G@@)  SAC   CBCPLB,CBCPLB .@[@C@B.     @[@C@B.     @C@C@BFGCONJ* .         OP
)@@G@@                 CONJUGATE    @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SACOQ
)@@G@@   CBTABS,GGSNOP .@ @C@BFILL(1)  SAC   CBCJGR,CBCJGF  @ @C@BFILL(1)  SACOR
)@@G@@   CBCJGR,CBCJGB  @[@C@B.     @[@C@B.     @C@C@BFGIMAG* .               OS
)@@G@@           IMAG BIF     @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   CBTOT
)@@G@@REL,GGSNOP .@^@C@BFILL(1)  SAC   CBIMG,0 .@[@C@B.     @[@C@B.     @B@C@BOU
)@@G@@FGRLPV* .                          REAL PV@C@C@BFGREAL* .               OV
)@@G@@           REAL BIF     @[@C@B.     @[@C@B.     @ @C@BFILL(1)  SAC   CBTOW
)@@G@@REL,GGSNOP .@^@C@BFILL(1)  SAC   CBREL,0 .@[@C@B.     @[@C@B.     @B@C@BOX
)@@G@@FGIMPV*  .                         IMAG PV@[@C@B.     @[@C@B.     @ @C@BOY
)@@G@@FILL(1)  SAC   CBTREL,GGSNOP .@ @C@BFILL(1)  SAC   CBIMAG,0 .     @[@C@BOZ
)@@G@@.     @[@C@B.     @A@C@B.         HBOUND, LBOUND AND DIM    @]@C@BFGDIMTPA
)@@G@@*     @]@C@BFGHBND*     @]@C@BFGLBND*     @[@C@B.     @[@C@B.     @ @C@BPB
)@@G@@FILL(1)   SAC   CBTDIM,GGSNOP @^@C@BFILL(1)   SAC   CBDIM,0 @[@C@B.     PC
)@@G@@@[@C@B.     @A@C@B/ .      MATHEMATICAL FUNCTIONS     @[@C@B.     @B@C@BPD
)@@G@@.        FUNCTIONS WITH 1 REAL ARGUMENT   @[@C@B.     @[@C@B.     @^@C@BPE
)@@G@@.        GENERATED CODE @[@C@B.     @A@C@B.        DL    A3,REAL ARGUMENPF
)@@G@@T     @ @C@B.        LMJ   X11,FUNCTION   @B@C@B.        DS    A3,TEMPORPG
)@@G@@ARY FOR RESULT    @[@C@B.     @[@C@B.     @D@C@B.        STAGING (TARGETPH
)@@G@@ING AND CODE GEN ARE NO-OPS)  @[@C@B.     @[@C@B.     @#@C@BCBRAND   LABPI
)@@G@@EL .  @D@C@B         GNTR   2.                 RAND ENTRY POINT   @E@C@BPJ
)@@G@@         NONPL1 XGFRND,DCBRND,CBBRL1 .   RAND NOT STANDARD  @F@C@B      PK
)@@G@@   GOTO  CBBRL1 .            MERGE WITH REAL ARG ROUTINES   @#@C@BCBB1RLPL
)@@G@@   LABEL .  @#@C@B         GNTR  2 .@#@C@BCBBRL1   LABEL .  @F@C@B      PM
)@@G@@   IF    SDRLCX,OFF,SGDCLS THEN,CBBRL2 . -> REAL ARGUMENT   @D@C@B      PN
)@@G@@   SET   SDRLCX,OFF,SGDCLS . USE REAL PART ONLY @C@C@B         EXERR EXEPO
)@@G@@RB1 LEVEL,2 . 'REAL PART USED'@]@C@B         GEN@^@C@B         GFREE AGIPP
)@@G@@M1    @#@C@BCBBRL2   LABEL .  @#@C@BCBBRL3   LABEL .  @D@C@B         LOAPQ
)@@G@@DA X2,SGDAID+DCGSLT .  POINT TO RESULT    @D@C@B         MOVE  SGDAID+DCPR
)@@G@@GSLT,SGDAID . SET RESULT AIDC @G@C@B         SET     SGDSGN,OFF,SGDAID+DPS
)@@G@@CGSLT . TURN OFF UNARY MINUS IN OPND@D@C@B         LINK  CBSFLT .       PT
)@@G@@     SET RESULT TO FLOAT@#@C@BCBBRL5   LABEL .  @E@C@B         IF    SDRPU
)@@G@@LCX,OFF,SGDCLS THEN,CBBRL6 . ->REAL ARG.  @#@C@B         GEN .    @C@C@BPV
)@@G@@         GDBLE OPDL,AGRA1,AGIM1 . LOAD IMAG PART@#@C@BCBBRL6   LABEL .  PW
)@@G@@@#@C@B         GENM .   @A@C@B         GDBLE OPDL,AGRA3,AGRL1 .   @#@C@BPX
)@@G@@CBBRL7   GLBL .   @^@C@B         GSUB  'BILTN'  @E@C@BCBBNOP   GLBL .   PY
)@@G@@                 USED FOR NO-OP ICODE     @#@C@B         GFIN .   @E@C@BPZ
)@@G@@         IF    SDRLCX,OFF,SGDCLS THEN,CBBRL8 . RESULT REAL  @#@C@B      QA
)@@G@@   GENM     @E@C@B         GGETGR  AGIM2,2 .         GET REGISTERS FOR RQB
)@@G@@ESULT @B@C@B         GDBLE OPDS,AGRA1,AGIM2 'NO' .    @#@C@B         GFIQC
)@@G@@N .   @#@C@BCBBRL8   LABEL .  @#@C@B         GENM     @E@C@B         GGEQD
)@@G@@TGR  AGRL2,2 .         GET A TWO WORD REGISTER  @B@C@B         GDBLE OPDQE
)@@G@@S,AGRA3,AGRL2 'NO' .    @#@C@B         GFIN .   @D@C@B         XGPOP .  QF
)@@G@@                 POP OFF STACK ELT  @#@C@BCBBRL4*  LABEL .  @A@C@B      QG
)@@G@@   MOVE  SGDID,SD0ART+SGDEXP,I@C@C@B         LOAD  X4,0,I .            SQH
)@@G@@ET ICODE    @^@C@B         GOTO  GGTRET . @[@C@B/.    @E@C@B.        MATQI
)@@G@@HEMATICAL FUNCTIONS WITH 1 ARG (REAL OR COMPLEX)@[@C@B.     @[@C@B.     QJ
)@@G@@@^@C@B.        CODE GENERATED @[@C@B.     @ @C@B.        DL    A1,COMPLEQK
)@@G@@X RG  @ @C@B.        DL    A3,REAL ARG    @B@C@B.        LMJ   X11,FUNCTQL
)@@G@@ION (REAL ARG)    @C@C@B.        LMJ   X11,FUNCTION+1 (COMPLEX ARG)     QM
)@@G@@@ @C@B.        DS    A3,REAL RESULT @A@C@B.        DS    A1,COMPLEX RESUQN
)@@G@@LT    @[@C@B.     @H@C@BCBB1RC   LABEL .                   STAGEING FOR QO
)@@G@@ONE ARG (REAL OR COMPLEX)     @#@C@B         GNTR  2 .@#@C@BCBBRC1   LABQP
)@@G@@EL .  @E@C@B         IF    SDRLCX,OFF,SGDCLS THEN,CBBRL2 . -> REAL ARG  QQ
)@@G@@@C@C@B         LOAD  A7,DXGARG .         COMPLEX ARG  @^@C@B         ADDQR
)@@G@@   A7,1,I . @ @C@B         STORE A7,DXGARG .    @E@C@B         GOTO  CBBQS
)@@G@@RL3 .            PROCESS AS IN REAL PART  @[@C@B.     @B@C@B.        FUNQT
)@@G@@CTION TO CONVRT ARG TO FLOAT  @[@C@B.     @#@C@BCBSFLT   LLOC .   @ @C@BQU
)@@G@@         USING SGDSCT,X2 .    @D@C@B         MOVE  SGDSCL,0,I .        NQV
)@@G@@O SCALE FOR FLOAT @C@C@B         LOAD    A3,SGDCLS,X7 .    GET CLASS    QW
)@@G@@@D@C@B         OR,U    A3,SDFXFL .       TURN ON FLOAT BIT  @ @C@B      QX
)@@G@@   STORE A4,SGDCLS,X2 . @E@C@BCBSFL2   LOCAL .                   ALTERNAQY
)@@G@@TE ENTZY POINT    @D@C@B         CGCONV  R,X2  R,X7 .      CONVERT TO FLQZ
)@@G@@OAT   @D@C@B         SET   SGDSGN,OFF,SGDCLS .  RESULT NOT NEG.   @ @C@BRA
)@@G@@         USING SGDSCT,X7 .    @#@C@B         JMP .    @[@C@B.     @^@C@BRB
)@@G@@.        ARC TANGENT    @[@C@B.     @D@C@B.        ATAN 1 REAL OR COMPLERC
)@@G@@X ARG OR 2 REAL ARGS    @[@C@B.     @ @C@B.        ENTRY POINT 1 = 1 ARGRD
)@@G@@@ @C@B.        ENTRY POINT 2 = 2 ARG@[@C@B.     @C@C@BCBBATD   LABEL .  RE
)@@G@@                 ATAND ENTRY  @#@C@B         GNTR  2 .@C@C@B         LOARF
)@@G@@D  A7,DXGNAR .         SEE IF 2 ARGS@E@C@B         IF    A7,EQ,DCGSLT,I RG
)@@G@@THEN,CBBRL1 . -> I REAL ARG   @D@C@B         LOAD  A7,DXGARG .         SRH
)@@G@@ET ENTRY POINT 2  @^@C@B         ADD   A7,1,I . @#@C@BCBATD1   LABEL .  RI
)@@G@@@ @C@B         STORE A7,DXGARG .    @E@C@B         IF    SDRLCX,OFF,SGDCRJ
)@@G@@LS THEN,CBATD2 . -> ARG 2 REAL@A@C@B         SET   SDRLCX,OFF,SGDCLS .  RK
)@@G@@@C@C@B         EXERR EXERB1 LEVEL,2 . 'REALPART USED' @]@C@B         GENRL
)@@G@@@^@C@B         GFREE AGIM1    @#@C@BCBATD2   LABEL .  @F@C@B         IF RM
)@@G@@   SDRLCX,OFF,SGDCLS+DCGSLT THEN,CBATD3 . ->ARG 1 REAL@B@C@B         SETRN
)@@G@@   SDRLCX,OFF,SGDCLS+DCGSLT . @C@C@B         EXERR EXERB1 LEVEL,2 . 'REARO
)@@G@@L PART USED'@#@C@B         GEN .    @^@C@B         GFREE AGIM2 .  @#@C@BRP
)@@G@@CBATD3   LABEL .  @F@C@B         MOVE  SGDPRE+2*DCGSLT,SGDPRE . ARG 2 ISRQ
)@@G@@ RESULTING PREC   @I@C@B         LOADA X2,SGDAID+2*DCGSLT .             RR
)@@G@@       CONVERT ARG TO RESULTING     @^@C@B         LINK  CBSFLT . @D@C@BRS
)@@G@@         XGPOP .                   POP ARG 2 FOR NOW  @C@C@B         LOART
)@@G@@DA X2,SGDAID+DCGSLT .  CONVERT ARG 1@^@C@B         LINK  CBSFL2 . @D@C@BRU
)@@G@@         SUB   X7,DCGSLT,I .       GET ARG 2 BACK     @#@C@B         GENRV
)@@G@@M .   @A@C@B         GDBLE  OPDL,AGRA3,AGRL2 .  @A@C@B         GDBLE  OPRW
)@@G@@DL,AGRA1,AGRL1 .  @^@C@B         GSUB  'BILTN'  @D@C@B         GGETGR  ARX
)@@G@@GRL2+DCGSLT,2 .  GET REAL REGISTER  @F@C@B         GDBLE  OPDS,AGRA3,AGRRY
)@@G@@L2+DCGSLT 'NO' .         SET RESULT @#@C@B         GFIN .   @D@C@B      RZ
)@@G@@   XGPOP   'SIZE',2*DCGSLT . POP OFF TWO ARGS.  @C@C@B         GOTO  CBBSA
)@@G@@RL4 .            ->RETURN     @[@C@B.     @#@C@B.        ARCTAN   @^@C@BSB
)@@G@@.        EP1=1 REAL     @^@C@B.        EP2=1 COMPLEX  @^@C@B.        EP3SC
)@@G@@=2 REAL     @[@C@B.     @#@C@BCBBATN   LABEL .  @#@C@B         GNTR  2 .SD
)@@G@@@D@C@B         LOAD  A7,DXGNAR .         SEE HOW MANY ARGS  @D@C@B      SE
)@@G@@   IF    A7,EQ,DCGSLT,I THEN,CBBRC1 . -> 1 ARG  @ @C@B         LOAD  A7,SF
)@@G@@DXGARG .    @C@C@B         ADD   A7,2,I .            ENTRY POINT 3@D@C@BSG
)@@G@@         GOTO  CBATD1 .            ->MERGE WITH ATAND @ @C@B/ .         SH
)@@G@@      INLINE BIF'S@[@C@B.     @^@C@B.        ABSOLUTE VALUE @[@C@B.     SI
)@@G@@@C@C@BCBTABS   LABEL .                   TARGETING    @#@C@B         GNTSJ
)@@G@@R 2 . @A@C@B         CGCONV R,X7 R,X7 . SET X4  @I@C@B         MOVE  SGDSK
)@@G@@AID+DCGSLT,SGDAID .                 RESULTING TYPE IS TYPE OF     @^@C@BSL
)@@G@@         GOTO  GGTRET . @[@C@B.     @[@C@B.     @[@C@B.     @C@C@BCBSABSSM
)@@G@@   LLOC .                    STAGEING     @D@C@B         IF    SDRLCX,OFSN
)@@G@@F,SGDCLS THEN,LJMP . -> REAL  @^@C@B         GNTR    2 .    @E@C@B      SO
)@@G@@   LOADA   X2,SGDAID+DCGSLT . POINT TO ELT. FOR BIF   @E@C@B         MOVSP
)@@G@@E    SGDAID+DCGSLT,SGDAID . COPY ATTRIBUTES     @D@C@B         LINK    CSQ
)@@G@@BSFLT .          CONVERT TO FLOAT   @E@C@B         GENM .               SR
)@@G@@     COMPUTE (X**2+Y**2)**1/2 @D@C@B         GIFR    CBSAB1,AGRL1 .    ISS
)@@G@@S REAL IN REG?    @D@C@B         GIFR    CBSAB2,AGIM1 .    IS IMAG IN REST
)@@G@@G?    @C@C@B         GLOAD   AGIM1,2 .         GET INTO REG @D@C@BCBSAB2SU
)@@G@@   GLBL .                    IMAG IN REG HERE   @D@C@B         GFLOAT  OSV
)@@G@@PDFM,AGIM1,AGIM1 'NO' . GET Y**2    @E@C@B         GDBLE   OPDL,AGRA3,AGSW
)@@G@@RL1 . GET REAL INTO A3-A4     @D@C@B         GFLOAT OPDFM,AGRA3,AGRA3 'NSX
)@@G@@O' . GET X**2     @C@C@B         GFLOAT  OPDFA,AGRA3,AGIM1 . GET SUM    SY
)@@G@@@C@C@B         GGOTO   CBSAB3 .          GO CALL SQRT @D@C@BCBSAB1   GLBSZ
)@@G@@L .                    REAL PART IS IN REG@D@C@B         GFLOAT  OPDFM,ATA
)@@G@@GRL1,AGRL1 'NO' . GET X**2    @E@C@B         GDBLE   OPDL,AGRA3,AGIM1 . TB
)@@G@@GET IMAG INTO A3-A4     @D@C@B         GFLOAT  OPDFM,AGRA3,AGRA3 'NO' . TC
)@@G@@GET Y**2    @C@C@B         GFLOAT  OPDFA,AGRA3,AGRL1 . GET SUM    @D@C@BTD
)@@G@@CBSAB3   GLBL .                    HERE TO CALL SQRT  @C@C@B         GSUTE
)@@G@@B    BFSQRT .          COMPUTE SQRT @D@C@B         GGETGR  AGRL2,2 .    TF
)@@G@@     GET REG FOR RESULT @C@C@B         GDBLE   OPDS,AGRA3,AGRL2 . SAVE RTG
)@@G@@ESULT @#@C@B         GFIN .   @D@C@B         XGPOP .                   PTH
)@@G@@OP OFF ARGUEMENT  @F@C@B         SET     SDRLCX+SGDSGN,OFF,SGDCLS . SAY TI
)@@G@@RESULT IS REAL    @D@C@B         GOTO    GGTRET .          RETURN TO XGETJ
)@@G@@N     @[@C@B.     @^@C@B.        SIGN(N) BIF    @[@C@B.     @B@C@BCBSIGNTK
)@@G@@   LABEL .  TARGETING FOR SIGN BIF  @#@C@B         GNTR  2 .@F@C@B      TL
)@@G@@   LINK  CBRLCX .            CONVERT ARG TO REAL, IF IMAG   @#@C@BCBSGN2TM
)@@G@@   LABEL .  @B@C@B         CGCONV R,X7 R,X7 .        SET X4 @#@C@BCBSGN3TN
)@@G@@   LABEL .  @B@C@B         GOTO  GGTRET .            DONE   @[@C@B.     TO
)@@G@@@F@C@B.         COMPLEX INPUT TO SIGN, GIVE ERROR AND USE ONLY REAL PARTTP
)@@G@@@[@C@B.     @#@C@BCBRLCX   LLOC .   @E@C@B         IF    SDRLCX,OFF,SGDCTQ
)@@G@@LS THEN,LJMP . ->REAL ALREADY @#@C@B         LOCAL .  @E@C@B         SETTR
)@@G@@     SDRLCX,OFF,SGDCLS .  USE ONLY REAL PART    @#@C@B         GEN .    TS
)@@G@@@^@C@B         GFREE   AGIM1 .@D@C@B         EXERR   EXERB1 LEVEL,2 .   TT
)@@G@@'REAL PART USED'  @C@C@B         JMP     .                 ->RETURN     TU
)@@G@@@[@C@B.     @[@C@B.     @[@C@B.     @B@C@BCSSIGN   LABEL .  STAGGING FORTV
)@@G@@ SIGN BIF   @^@C@B         GNTR    2 .    @G@C@B         MOVE    SGDAID+TW
)@@G@@DCGSLT,DCBCLN .  SET RESULT TO FIXED BIN 35,0   @B@C@B         GOTO    GTX
)@@G@@GTRET .           EXIT  @ @C@B/ .      HBOUND LBOUND AND DIM@[@C@B.     TY
)@@G@@@[@C@B.     @#@C@BCBTDIM   LLOC .   @#@C@B         GNTR  2. @F@C@B      TZ
)@@G@@   CGCONV DCBCSM R,X7 .         CONVERTT TO FIXED BIN(17,0) @E@C@B      UA
)@@G@@   LOADA X3,SGDRBS .            SAVE ADDR OF ARG. 2   @E@C@B         STOUB
)@@G@@RE   X3,DCGSV2+8 .     SAVE FOR RETURN TO XGEN  @#@C@B         XGPOP .  UC
)@@G@@@D@C@B         LOAD  X2,SGDIBS+1 .          DIMENSIONALITY  @E@C@B      UD
)@@G@@   STORE   X2,DCGSV2+3 .     SAVE FOR RETURN TO XGEN  @E@C@B         MOVUE
)@@G@@E  SGDAID+DCGSLT,DCBCSM . SET RESULT DATA TYPE  @^@C@B         LOAD  X4,UF
)@@G@@0,I . @C@C@B         GOTO  GGTRET .               RETURN    @A@C@B/ .   UG
)@@G@@         MAX MIN AND MOD BIF'S@[@C@B.     @D@C@BBFSMAX   LLOC .         UH
)@@G@@           STAGING FOR MAX    @F@C@B         SET   IGPLUS,ON,DGFLGZ . SEUI
)@@G@@T FLAG FOR 'JP' INSTRUCTION   @D@C@B         GOTO  BFSMNG .           COUJ
)@@G@@NTINUE STAGING    @F@C@BBFSMIN   LLOC .                   ENTRY POINT FOUK
)@@G@@R STAGING FOR MIN @F@C@B         SET   IGPLUS,OFF,DGFLGZ . SET FLAG FOR UL
)@@G@@'JN' INSTRUCTION  @#@C@BBFSMNG   LABEL .  @#@C@B         GNTR  2 .@C@C@BUM
)@@G@@         LOAD  X4,0,I .            CLEAR X4     @D@C@B         MOVE  AGLUN
)@@G@@BL,0,I .         CLEAR AW FOR JUMPS @C@C@B         LOADA X3,AGLBL .     UO
)@@G@@     SET AW TO USE@D@C@B         STORE X3,DCGSV2+8 .       SET ICODE REGUP
)@@G@@ X3   @C@C@B         LINK  CBRLCX .            MAKE ARG REAL@F@C@B      UQ
)@@G@@   ADD   X7,DCGSLT,I .       MOVE DOWN ONE STACK ELEMENT    @D@C@B      UR
)@@G@@   LINK  CBRLCX .            MAKE ARG 2 REAL    @C@C@B         SUB   X7,US
)@@G@@DCGSLT,I .       RECOVER STACK@D@C@B         IF    SDFXFL,ON,SGDCLS THENUT
)@@G@@,GGSAD5 . ->FLOAT @^@C@B         LOAD  X2,SGDPRE@F@C@B         SUB   X2,UU
)@@G@@1,I .            STAGING PREC 1 LESS THAN + PREC@ @C@B         STORE X2,UV
)@@G@@SGDPRE .    @A@C@B         LOAD  X2,SGDPRE+DCGSLT .   @^@C@B         SUBUW
)@@G@@   X2,1,I . @A@C@B         STORE X2,SGDPRE+DCGSLT .   @ @C@B         STOUX
)@@G@@RE X2,DGGPRE .    @^@C@B         GOTO  GGSAD5 . @^@C@B/.       MOD TARGEUY
)@@G@@TTING @[@C@B.     @[@C@B.     @[@C@B.     @#@C@BBFTMOD   LLOC .   @#@C@BUZ
)@@G@@         GNTR  2 .@C@C@B         LINK  CBRLCX .            MAKE ARG REALVA
)@@G@@@F@C@B         ADD   X7,DCGSLT,I .       MOVE DOWN ONE STACK ELEMENT    VB
)@@G@@@D@C@B         LINK  CBRLCX .            MAKE ARG 2 REAL    @C@C@B      VC
)@@G@@   SUB   X7,DCGSLT,I .       RECOVER STACK@B@C@B         GOTO  GGTAR2 . VD
)@@G@@           ->MERGE@[@C@B.     @[@C@B.     @[@C@B.     @^@C@B.        MODVE
)@@G@@ STAGING    @#@C@BBFSMOD   LLOC .   @#@C@B         GNTR  2 .@C@C@B      VF
)@@G@@   LOAD    A8,0,I .          ASSUME FLOAT @C@C@B         IF    SDFXFL,ONVG
)@@G@@ THEN,BFSMO1 . ->FLOAT  @D@C@B         LINK    GGSSCL .          SCALE TVH
)@@G@@O SAME SCALE@D@C@B         LOAD    A8,DGGSCP .       GET SCALE AND PRE  VI
)@@G@@@D@C@B         SSA     A8,9 .            GET SIGNED SCALE   @D@C@BBFSMO1VJ
)@@G@@   LABEL .                   MERGE WITH FLOAT   @D@C@B         ADD     AVK
)@@G@@8,SGDPRE .       GET P2+MAX(Q1,Q2)  @D@C@B         LOAD    A9,18,I .    VL
)@@G@@     ASSUME DECIMAL     @D@C@B         IF SDDCBN,OFF THEN,BFSMO2 . IS ITVM
)@@G@@ DECIMAL    @D@C@B         LOAD    A9,60,I .         ASSUME FLOAT BIN   VN
)@@G@@@D@C@B         IF SDFXFL,ON THEN,BFSMO2 . IS IT FLOAT BIN   @D@C@B      VO
)@@G@@   LOAD    A9,35,I .         IT IS FIXED BIN    @F@C@BBFSMO2   LABEL .  VP
)@@G@@                 MERGE HERE WITH MAX PRE IN A9  @E@C@B         IF A9,GE,VQ
)@@G@@A8 THEN,BFSMO3 . IS COMPUTED PRE TOO BIG? @D@C@B         LOAD    A8,A9 .VR
)@@G@@           YES,USE MAX PRE    @#@C@BBFSMO3   LABEL .  @E@C@B         MOVVS
)@@G@@E    SGDAID+2*DCGSLT,SGDAID+DCGSLT . SET RESULT @D@C@B         STORE   AVT
)@@G@@8,SGDPRE+2*DCGSLT . SET NEW PRE     @D@C@B         MOVE    SGDSCL+2*DCGSVU
)@@G@@LT,DGGSCL . SET SCALE   @E@C@B         MOVE    AGLBL,0,I .       CLEAR WVV
)@@G@@ORD FOR JUMPS     @D@C@B         GRTN    2 .               RETURN TO XGEVW
)@@G@@N     @E@C@B/ .            CONVERSION BIF'S (BIN, DEC, FIX, FLT, PREC)  VX
)@@G@@@#@C@BCBCONV   LABEL .  @#@C@B         GNTR  2 .@D@C@B         LOAD  A2,VY
)@@G@@0,I .            SET PRECISION TO 0 @B@C@B         STORE A2,DGGSCP .    VZ
)@@G@@     Q=0    @D@C@B         LOAD  A3,DXGNAR .         GET NUMBER OF ARGS WA
)@@G@@@E@C@B         DIV   A2,DCGSLT,I .       DIVIDE BY STACK SIZE     @D@C@BWB
)@@G@@         LOAD  X5,A2 .             SAVE NUMBER OF ARGS@D@C@B         GOTWC
)@@G@@O  *$,A2 .             A2 IS AT LEAST 1   @C@C@B         +CBCNV1 .      WD
)@@G@@           1 ARG (X)    @C@C@B         +CBCNV2 .                 2 ARGS WE
)@@G@@(X,P) @D@C@B         +CBCNV3 .                 3 ARGS (X,P,Q)     @[@C@BWF
)@@G@@.     @[@C@B.     @#@C@BCBCNV3   LABEL .  @D@C@B         LINK  CBCNST . WG
)@@G@@           GET CONSTANT Q     @ @C@B         STORE A8,DGGSCL .    @#@C@BWH
)@@G@@CBCNV2   LABEL .  @D@C@B         LINK  CBCNST .            GET CONSTANTTWI
)@@G@@ P    @B@C@B         STORE A8,DGGPRE .         SET P  @#@C@BCBCNV1   LABWJ
)@@G@@EL .  @D@C@B         MOVE  DGGCLS,SGDCLS .     GET ATTR. OF X     @D@C@BWK
)@@G@@         LOAD  X4,X5 .             SAVE NUMBER OF ARGS@F@C@B         ADDWL
)@@G@@   X5,DXGARG .         GET ADDRESS OF BRANCH  TABLE   @ @C@B         LOAWM
)@@G@@D  X11,0,X5 .     @^@C@B         LINK  0,X11 .  @I@C@B.                 WN
)@@G@@                 RETURN FROM SETTING PROPER DATA TYPE FOR RESU    @D@C@BWO
)@@G@@         CGCONV DGGSTK R,X7 .      CONVERT ARGUMENT   @#@C@B         GENWP
)@@G@@ .    @^@C@B         GMOVE  2,1 .   @#@C@B         XGPOP .  @D@C@B      WQ
)@@G@@   LOAD  X4,0,I .            SET NO ICODE TOGEN @E@C@B         GOTO  GGTWR
)@@G@@RET .            SET RESULT STACK ENTRY   @[@C@B.     @[@C@B.     @[@C@BWS
)@@G@@.     @[@C@B.     @[@C@B.     @D@C@BBFDECT*  EQU   $-1 .               DWT
)@@G@@ECIMAL ROUTINES   @C@C@B         +FGDEC1  .                DECIMAL (X)  WU
)@@G@@@C@C@B         +FGDEC1  .                DECIMAL(X,P) @D@C@B         +FGWV
)@@G@@DEC1  .                DECIMAL(X,P,Q)     @[@C@B.     @^@C@BBFBINT*  EQUWW
)@@G@@   $-1 .    @C@C@B         +FGBIN1 .                 BINARY (X)   @C@C@BWX
)@@G@@         +FGBIN1 .                 BINARY (X,P) @C@C@B         +FGBIN1 .WY
)@@G@@                 BINARY(X,P,Q)@[@C@B.     @^@C@BBFFLTT*  EQU   $-1 .    WZ
)@@G@@@C@C@B         +FGFLT1 .                 FLOAT (X)    @C@C@B         +FGXA
)@@G@@FLT2 .                 FLOAT (X,P)  @E@C@B.        +FGFLT3 .            XB
)@@G@@     FLOAT(X,P,Q) ILLEGAL     @[@C@B.     @^@C@BBFFIXD*  EQU   $-1 .    XC
)@@G@@@C@C@B         +FGFIX1 .                 FIXED (X)    @C@C@B         +FGXD
)@@G@@FIX2 .                 FIXED (X,P)  @C@C@B         +FGFIX2 .            XE
)@@G@@     FIXED (X,P,Q)@[@C@B.     @^@C@BBFPREC*  EQU   $-1 .    @C@C@B      XF
)@@G@@   +FGPRC1 .                 PRECISION(X) @D@C@B         +FGPRC2 .      XG
)@@G@@           PRECISION(X,P)     @D@C@B         +FGPRC3 .                 PXH
)@@G@@RECISION(X,P,Q)   @[@C@B.     @#@C@BFGDEC1   LABEL .  @E@C@B         SETXI
)@@G@@   SDDCBN,OFF,DGGCLS . SET RESULT TO DECIMAL    @D@C@B         GOTO  *BFXJ
)@@G@@PREC,X4 .        DO PRECISION PART  @[@C@B.     @#@C@BFGBIN1   LABEL .  XK
)@@G@@@E@C@B         SET   SDDCBN,ON,DGGCLS .  SET RESULT TO BINARY     @C@C@BXL
)@@G@@         GOTO  *BFPREC,X4 .        DO PRECISION @[@C@B.     @#@C@BFGFLT1XM
)@@G@@   LABEL .  @B@C@B         LOAD  A7,6,I .            SET P=6@E@C@B      XN
)@@G@@   IF    SDDCBN,OFF,DGGCLS THEN,FGFLT1X . ->NOT BINARY@F@C@B         LOAXO
)@@G@@D  A7,27,I .           SET FLOAT BINARY PRECCSION     @#@C@BFGFLT1X  LABXP
)@@G@@EL .  @B@C@B         STORE A7,DGGPRE .         SET P  @#@C@BFGFLT2   LABXQ
)@@G@@EL .  @A@C@B         SET   SDFXFL,ON,DGGCLS .   @C@C@B         LJMP .   XR
)@@G@@                 ->RETURN     @[@C@B.     @[@C@B.     @#@C@BFGFIX1   LABXS
)@@G@@EL .  @D@C@B         LOAD  A7,5,I .            SET FIXED DEC P    @C@C@BXT
)@@G@@         IF    SDDCBN,OFF,DGGCLS THEN,FGTFX2 .  @D@C@B         LOAD  A7,XU
)@@G@@35,I .           SET FIXED BIN PP   @#@C@BFGTFX2   LABEL .  @ @C@B      XV
)@@G@@   STORE A7,DGGPRE .    @#@C@BFGFIX2   LABEL .  @A@C@B         SET   SDFXW
)@@G@@XFL,OFF,DGGCLS .  @C@C@B         LJMP .                    ->RETURN     XX
)@@G@@@[@C@B.     @#@C@BFGPRC3   LABEL .  @E@C@B         IF    SDFXFL,OFF,DGGCXY
)@@G@@LS THEN,LJMP . ->FIXED RESULT @[@C@B.     @F@C@B. Q SHOULD NOT BE EXPRESXZ
)@@G@@SED FOR FLOAT (EXCEPT IF ZERO)!  ERROR?   @[@C@B.     @D@C@B         MOVYA
)@@G@@E  DGGSCL,0,I .      IGNORE Q FOR FLOAT   @#@C@BFGPRC2   LABEL .  @#@C@BYB
)@@G@@FGPRC1   LABEL .  @#@C@B         LJMP .   @[@C@B.     @[@C@B.     @[@C@BYC
)@@G@@.     @E@C@B.              ROUTINE TO GET CONSTANT VALUE FROM STACK     YD
)@@G@@@[@C@B.     @#@C@BCBCNST   LOCAL .  @G@C@B         IF    SDVRCN,ON,SGDCLYE
)@@G@@S THEN,CBCNS8 . -> CONSTANT, SO FAR OK    @E@C@B         EXERR ERRG08 LEYF
)@@G@@VEL,2 . ARG SHOULD BE CONSTANTT     @B@C@B.                             YG
)@@G@@     10 USED@#@C@BCBCNS6   LABEL .  @D@C@B         LOAD  A8,10,I .      YH
)@@G@@     SET DEFAULT OF 10  @^@C@B         GOTO  CBCNS7 . @F@C@BCBCNS8   LABYI
)@@G@@EL .                   SET IS SMALL INTEGER CONSTANT  @F@C@B         IF YJ
)@@G@@   SDRLCX,OFF,SGDCLS THEN,CBCNS1 . ->REAL CONSTTNT    @C@C@B         EXEYK
)@@G@@RR ERRG10 LEVEL,1 . USE REAL PART   @]@C@B         GEN@ @C@B         GSEYL
)@@G@@T  AGRL1,AGIM1 .  @#@C@BCBCNS1   LABEL .  @ @C@B         USING SDSECT,X4YM
)@@G@@ .    @ @C@B         LSDP  X4,SGDRSD .    @ @C@B         LOAD  A2,SDLCOFYN
)@@G@@,X4 . @^@C@B         USING WORD,A2 .@E@C@B         IF    SDFXFL,ON,SDCLSYO
)@@G@@1 THEN,CBCNS9 . -> FLOAT CONST@^@C@B         SUB   A2,2,I . @F@C@B      YP
)@@G@@   IF    W1,NZERO THEN,CBCNS9 . -> NOT FIXED BINARYCONST    @E@C@B      YQ
)@@G@@   ADD   A2,1,I .            POINT TO FIXED BINARY    @G@C@B         IF YR
)@@G@@   SGDSCL,NZERO THEN,CBCNS3 . ->NOT INTEGER FIXED BINARY    @F@C@B      YS
)@@G@@   LOAD  A8,W1 .             FINALLY GET FIXEDDBINARY VALUE @^@C@B      YT
)@@G@@   GOTO  CBCNS4 . @#@C@BCBCNS9   LABEL .  @D@C@B         EXERR ERRG09 LEYU
)@@G@@VEL,2 . NON INTEGER VALUE     @D@C@B         GOTO  CBCNS6 ,            SYV
)@@G@@ET DEFAULT OF 10  @#@C@BCBCNS3   LABEL .  @C@C@B         LOAD  A8,W1 .  YW
)@@G@@           GET VALUE    @C@C@B         LOAD  A3,SGDSCL .         SET SCAYX
)@@G@@LE    @D@C@B         SSA   A8,0,A3 .           SCALE TO INTEGER   @D@C@BYY
)@@G@@CBCNS4   LABEL .                   CHECK VALID VALUE  @E@C@B         IF YZ
)@@G@@   A8,GT,0177777,I THEN,CBCNS9 . ->NO GOOD VALUE@E@C@B         IF    SGDZA
)@@G@@SGN,OFF,SGDCLS THEN,CBCNS7 . ->NOT COMPL. @C@C@B         LOADN   A8,A8 .ZB
)@@G@@           SWITCH SIGN  @D@C@BCBCNS7   LABEL .                   SET RETZC
)@@G@@URN VALUE   @#@C@B         GENM     @^@C@B         GFREE AGRL1 .  @^@C@BZD
)@@G@@         GFIN  'POP'    @G@C@B         JMP .                     ->RETURZE
)@@G@@N, VALUE IN A8, STACK POPPED  @B@C@B/ .      REAL AND IMAGINARY BIF'S ANZF
)@@G@@D PV'S@[@C@B.     @[@C@B.     @#@C@BCBTREL   LABEL .  @#@C@B         GNTZG
)@@G@@R 2.  @E@C@B         MOVE  DGFLGZ,SGDCLS .     SET FLAGS FOR ICODER     ZH
)@@G@@@A@C@B         SET   SDRLCX,OFF,SGDCLS    @D@C@B         LOAD  X4,0,I . ZI
)@@G@@           SET ICODE TYPE     @^@C@B         GOTO  GGTRET . @#@C@B/.    ZJ
)@@G@@   ROUND    @[@C@B.     @[@C@B.     @#@C@BCBSRON   LABEL .  @^@C@B      ZK
)@@G@@   GNTR    2 .    @E@C@B         LINK    CBRLCX .          SET CONSTANT ZL
)@@G@@TO REAL     @D@C@B         LINK    CBCNST .          GET THE CONSTANT   ZM
)@@G@@@E@C@B         CGCONV  R,X7 R,X7 .       SET CONSTANTS STRAIGHT   @C@C@BZN
)@@G@@         LOAD    A7,SGDSCP .       GET SCALE,PRE@E@C@B         SSA     AZO
)@@G@@7,9 .            GET SIGN EXTENDED SCALE  @G@C@B         ANU     A8,A7 .ZP
)@@G@@           GET N-Q INTO A9         ************ @C@C@B         LOADM   AZQ
)@@G@@8,A8 .           GET ABS(N)   @D@C@B         LOAD    A6,SGDPRE .       GZR
)@@G@@ET PRE FOR TESTING@D@C@B         ADD     A6,1,I .          ROUND UPS THEZS
)@@G@@ PRE  @G@C@B         SET IGPLUS++IGRLCX++IGMPDV,OFF,DGFLGZ . ASSUME REALZT
)@@G@@ AND SCALING@E@C@B         IF SDRLCX,OFF,SGDCLS THEN,CBSRO1 . IS IT REALZU
)@@G@@?     @C@C@B         SET     IGRLCX,ON,DGFLGZ . SAY COMPLEX @#@C@BCBSRO1ZV
)@@G@@   LABEL .  @E@C@B         IF SDDCBN,OFF,SGDCLS THEN,RONDF1 . IS IT DECIZW
)@@G@@MAL?  @E@C@B         IF SDFXFL,ON,SGDCLS THEN,RONBF1 . IS IT FLOAT BIN? ZX
)@@G@@@[@C@B.     @^@C@B.        BIN FIXED HERE @G@C@B.                COMPUTEZY
)@@G@@:          TRUNC(A*2^(N-Q-1)+1/2)/2^(N-Q-1)     @F@C@B.                 ZZ
)@@G@@                 =TRUNC(A*2^(N-Q)+1)/2^(N-Q)    @[@C@B.     @D@C@B      AA
)@@G@@   LOAD    A3,34,I .         SET UP FOR CHECKING@D@C@B         LINK    RAB
)@@G@@ONCHK .          CHECK IF ARG OK    @C@C@B         LOADN   A9,A9 .      AC
)@@G@@     GET -(N-Q)   @E@C@B         IF A9,LT,0,I THEN,RONEND . ROUND AT EXIAD
)@@G@@STING DIGIT?@F@C@B         IF A9,NE,0,I THEN,RONBX3 . INITIAL SHIFTING TAE
)@@G@@O BE DONE   @E@C@B         SET     IGPLUS,ON,DGFLGZ . SAY NO INITIAL SHIAF
)@@G@@FT    @D@C@BRONBX3   LABEL .                   SET UP SHIFT COUNTS@E@C@BAG
)@@G@@         STORE   A9,AGX0OF .       SET INITIAL SHIFT COUNT  @E@C@B      AH
)@@G@@   MOVE    AGXTMP,AGXR0 .    SET TEMP ADDRESS WORD    @E@C@B         ADDAI
)@@G@@     A9,1,I .          SHIFT BACK ONE EXTRA     @E@C@B         STORE   AAJ
)@@G@@9,AGX0OF .       SET SHIFT BACK COUNT     @#@C@B         GENM .   @D@C@BAK
)@@G@@         GBOFF   RONBX6,IGRLCX .   IS IT COMPLEX?     @D@C@B         GIFAL
)@@G@@R    RONBX4,AGIM1 .    IS IMAG IN REG?    @D@C@B         GLOAD   AGIM1,IAM
)@@G@@ .         GET IMAG INTO REG  @#@C@BRONBX4   GLBL .   @E@C@B         GBOAN
)@@G@@N    RONBX5,IGPLUS .   INITIAL SHIFT TO BE DONE?@E@C@B         GSHIN   OAO
)@@G@@PSSA,AGIM1,AGXTMP 'NO' . SHIFT TO SCALE   @E@C@BRONBX5   GLBL .         AP
)@@G@@           HERE IF NO INITIAL SHIFT @D@C@B         GINST   OPLA,AGRA3,AGAQ
)@@G@@RR12 'NO' . GET A ONE   @D@C@B         GINST   OPTP,AGRX0,AGIM1 'NO' .SEAR
)@@G@@E IF POS    @E@C@B         GINST   OPLNA,AGRA3,AGRA3 'NO' . GET -1 IF NEAS
)@@G@@G     @D@C@B         GINST   OPAA,AGIM1,AGRA3 'NO' . ADD IN +- 1/2@C@C@BAT
)@@G@@         GSHIN   OPSSA,AGIM1,1,I 'NO' . TRUNCATE@D@C@B         GSHIN   OAU
)@@G@@PLSSC,AGIM1,AGXR0 'NO' . RESCALE    @A@C@BRONBX6   GLBL .  HERE FOR REALAV
)@@G@@ PART @D@C@B         GIFR    RONBX7,AGRL1 .    IS REAL PART IN REG@D@C@BAW
)@@G@@         GLOAD   AGRL1,1 .         GET IT INTO REG    @B@C@BRONBX7   GLBAX
)@@G@@L .  REAL PART NOW IN REG     @G@C@B         GBON    RONBX8,IGPLUS .   IAY
)@@G@@NITIAL SHIFT NEEDED FOR REAL PART?  @C@C@B         GSHIN   OPSSA,AGRL1,AAZ
)@@G@@GXTMP 'NO' . SCALE@#@C@BRONBX8   GLBL .   @D@C@B         GINST   OPLA,AGBA
)@@G@@RA3,AGRR12 'NO' . GET A ONE   @E@C@B         GINST   OPTP,AGRX0,AGRL1 'NBB
)@@G@@O' . IS REAL PART POS   @C@C@B         GINST   OPLNA,AGRA3,AGRA3 'NO' . BC
)@@G@@GET -1@C@C@B         GINST   OPAA,AGRL1,AGRA3 'NO' . ADD +-1@C@C@B      BD
)@@G@@   GSHIN   OPSSA,AGRL1,1,I 'NO' . TRUNCATE@D@C@B         GSHIN   OPLSSC,BE
)@@G@@AGRL1,AGXR0 'NO' . RESCALE    @#@C@B         GFIN .   @A@C@BRONEND   LABBF
)@@G@@EL . HERE TO FINISH UP  @#@C@B         GEN .    @E@C@B         GMOVE   +BG
)@@G@@2,1 .            MOVE ARG ONTO BIF SGD    @A@C@B         XGPOP . POP OFFBH
)@@G@@ STACK TOP  @D@C@B         LOAD    X4,0,I .          SET TO ONLY ICODE  BI
)@@G@@@B@C@B         GOTO    GGTRET .          RETURN @D@C@BRONBF1   LABEL .  BJ
)@@G@@                 FLOAT BIN HERE     @[@C@B.     @G@C@B.        COMPUTE: BK
)@@G@@                 TRUNC(A*2^(N-Q-1)+1/2)/2^(N-Q-1)     @[@C@B.     @C@C@BBL
)@@G@@         LOAD    A3,59,I .         SET FOR CHECK@C@C@B         LINK    RBM
)@@G@@ONCHK .          GO CHECK ARG @E@C@B         IF A9,EQ,0,I THEN,RONDF4 . BN
)@@G@@IS ANY SHIFTING NEEDED  @F@C@B         ADD     A9,02000,I .      GET EXPBO
)@@G@@ONENT FOR FLOAT NUMBER  @D@C@B         SLB     A9,1 .            MAKE ROBP
)@@G@@OM FOR 1    @D@C@B         ADD     A9,1,I .          GET SET FOR 020004 BQ
)@@G@@@F@C@B         STORE   A9,AGX0OF .       PUT IT WHERE IT CAN BE GOTTEN  BR
)@@G@@@#@C@B         GENM .   @F@C@B         GINST   OPLA,AGRA2,AGXR0,U 'NO' .BS
)@@G@@ GET EXPONENT INTO REG  @F@C@B         GSHIN   OPLDSL,AGRA1,59,I 'NO' . BT
)@@G@@SHIFT TO PROPER POSITION@E@C@B         GFIN .                    SCALINGBU
)@@G@@ CONSTANT SET UP  @C@C@B         LOADA   A3,A1 .           POINT TO A1  BV
)@@G@@@E@C@B         STORE   A3,AGX0OF .       SET TO POINT TO CONSTANT @E@C@BBW
)@@G@@         GOTO    RONDF5 .          GO MERGE WITH DECIMAL    @E@C@BRONDF1BX
)@@G@@   LABEL .                   HERE FOR DECIMAL ROUNDING@[@C@B.     @G@C@BBY
)@@G@@.        COMPUTE:         TRUNC(A*10^(N-Q-1)+SIGN(A)*.5)/10^(N-Q-1)     BZ
)@@G@@@[@C@B.     @D@C@B         LOAD    A3,17,I .         SET FOR CHECK .    CA
)@@G@@@C@C@B         LINK    RONCHK .          CHECK PRE,ARG@D@C@B         LOACB
)@@G@@DM   A3,A9 .           GET MAG OF N-Q-1   @G@C@B         ADD     A3,A3 .CC
)@@G@@           GET 2*N-Q-1 FOR INDEX INTO TABLE     @E@C@B         LOADA   ACD
)@@G@@8,KKPW10-2,A3 .  POINT TO POWER OF 10     @C@C@B         STORE   A8,AGX0CE
)@@G@@OF .       SET FOR ICODE@D@C@B         IF A9,NE,0,I THEN,RONDF5 . NEED SCF
)@@G@@CALING?     @D@C@BRONDF4   LABEL .                   HERE IF NO SCALING CG
)@@G@@@D@C@B         SET     IGPLUS,ON,DGFLGZ . SAY NO SCALING    @B@C@B      CH
)@@G@@   GOTO    RONDF6 .          MERGE  @E@C@BRONDF5   LABEL .              CI
)@@G@@     CHOOSE DIVIDE OR MULT    @D@C@B         IF A9,GE,1,I THEN,RONDF6 . CJ
)@@G@@MUST MULTIPLY     @D@C@B         SET     IGMPDV,ON,DGFLGZ . SAY TO DIVIDCK
)@@G@@E     @ @C@BRONDF6   LABEL . START CODEGEN@#@C@B         GENM .   @C@C@BCL
)@@G@@         GBOFF   RONDX1,IGRLCX .   IS IT REAL?  @D@C@B         GIFR    RCM
)@@G@@ONDF7,AGIM1 .    IS IMAG IN REG?    @C@C@B         GLOAD   AGIM1,2 .    CN
)@@G@@     GET INTO REG @E@C@BRONDF7   GLBL .                    IMAG PART NOWCO
)@@G@@ IN REG     @D@C@B         GBON    RONDF9,IGPLUS .   SCALING NEEDED?    CP
)@@G@@@D@C@B         GBON    RONDF8,IGMPDV .   MULTIPLY OR DIVIDE?@F@C@B      CQ
)@@G@@   GFLOAT  OPDFM,AGIM1,AGXR0 'NO' . MULTIPLY BY SCALE FACTOR@E@C@B      CR
)@@G@@   GGOTO   RONDF9 .          FINISHED FIRST SCALING   @D@C@BRONDF8   GLBCS
)@@G@@L .                    HERE TO DIVIDE     @D@C@B         GFLOAT  OPDFD,ACT
)@@G@@GIM1,AGXR0 'NO' . SCALE DOWN  @D@C@BRONDF9   GLBL .                    HCU
)@@G@@ERE TO ADD .5     @^@C@B         GLIT    1 .    @B@C@B         DL      ACV
)@@G@@3,KK5000 .       GET .5 @D@C@B         GINST   OPTP,AGRX0,AGIM1 'NO' . SCW
)@@G@@EE IF POS   @D@C@B         GDBLE   OPDLN,AGRA3,AGRA3 'NO' . GET -.5     CX
)@@G@@@C@C@B         GFLOAT  OPDFA,AGIM1,AGRA3 'NO' . ADD .5@D@C@B         GFLCY
)@@G@@OAT  OPDFA,AGIM1,AGXUNZ 'NO' . TRUNCATE   @D@C@B         GBON    RONDX1,CZ
)@@G@@IGPLUS .   ANY SCALING NEEDED?@D@C@B         GBON    RONDF0,IGMPDV .   MDA
)@@G@@ULT OR DIVIDE?    @D@C@B         GFLOAT  OPDFD,AGIM1,AGXR0 'NO' . UNSCALDB
)@@G@@E     @C@C@B         GGOTO   RONDX1 .          NOW DO REAL  @B@C@BRONDF0DC
)@@G@@   GLBL .  HERE TO UNDO DIVISION    @D@C@B         GFLOAT  OPDFM,AGIM1,ADD
)@@G@@GXR0 'NO' . UNSCALE     @D@C@BRONDX1   GLBL .                    HERE FODE
)@@G@@R REAL PART @D@C@B         GBAL    CDXLDR .          LOAD REAL INTO REG DF
)@@G@@@F@C@B         GBON    RONDX3,IGPLUS .   ANY INITIAL SCALING NEEDED?    DG
)@@G@@@D@C@B         GBON    RONDX2,IGMPDV .   MULT OR DIVIDE     @C@C@B      DH
)@@G@@   GFLOAT  OPDFM,AGRL1,AGXR0 'NO' . SCALE @ @C@B         GGOTO   RONDX3 DI
)@@G@@.     @F@C@BRONDX2   GLBL .                    HERE TO DIVIDE FOR SCALINDJ
)@@G@@G     @C@C@B         GFLOAT  OPDFD,AGRL1,AGXR0 'NO' . SCALE @D@C@BRONDX3DK
)@@G@@   GLBL .                    HERE TO DO TRUNC   @^@C@B         GLIT    1DL
)@@G@@ .    @B@C@B         DL      A3,KK5000 .       GET .5 @D@C@B         GINDM
)@@G@@ST   OPTP,AGRX0,AGRL1 'NO' . SEE IF POS   @D@C@B         GDBLE   OPDLN,ADN
)@@G@@GRA3,AGRA3 'NO' . GET -.5     @D@C@B         GFLOAT  OPDFA,AGRL1,AGRA3 'DO
)@@G@@NO' . ADD +- .5   @D@C@B         GFLOAT  OPDFA,AGRL1,AGXUNZ 'NO' . TRUNCDP
)@@G@@ATE   @C@C@B         GBON    RONDX5,IGPLUS .   ALL DONE?    @D@C@B      DQ
)@@G@@   GBON    RONDX4,IGMPDV .   MULTIPLY OR DIVIDE?@D@C@B         GFLOAT  ODR
)@@G@@PDFD,AGRL1,AGXR0 'NO' . UNSCALE     @C@C@B         GGOTO   RONDX5 .     DS
)@@G@@     ALL DONE     @E@C@BRONDX4   GLBL .                    HERE TO UNSCADT
)@@G@@LE DIVIDE   @D@C@B         GFLOAT  OPDFM,AGRL1,AGXR0 'NO' . UNSCALE     DU
)@@G@@@E@C@BRONDX5   GLBL .                    MERGE HERE WHEN DONE     @#@C@BDV
)@@G@@         GFIN .   @E@C@B         GOTO    RONEND .          MERGE WITH BIDW
)@@G@@N FIXED     @F@C@BRONCHK   LLOC .        HERE TO CHECK COMPUTED PRE AND DX
)@@G@@ARG SIZE    @ @C@B         USING   WORD,A3 .    @D@C@B         IF A6,GE,DY
)@@G@@W1U+2 THEN,RONCH1 . NEW PRE TOO BIG?@D@C@B         STORE   A6,SGDPRE .  DZ
)@@G@@     ROUND UPS THE PRE  @#@C@BRONCH1   LABEL .  @D@C@B         IF A8,LE,EA
)@@G@@W1U THEN,LJMP .  ARG SMALL ENOUGH?  @D@C@B         LOCAL .              EB
)@@G@@     CALL FOR ERROR MSG @F@C@B         EXERR EXROUN LEVEL,2 .    ARG TO EC
)@@G@@ROUND TOO BIG. ONE USED @D@C@B         LOAD    A9,1,I .          GET REPED
)@@G@@LACEMENT ONE@C@C@B         SUB     A9,A7 .           GET N-Q AGAIN@B@C@BEE
)@@G@@         JMP .                     RETURN @A@C@B/ .            FLOOR, CEEF
)@@G@@IL AND TRUNC@[@C@B.     @[@C@B.     @#@C@B.        STAGING  @[@C@B.     EG
)@@G@@@D@C@B.         ON OUTPUT, X4 HAS THE FOLLOWING VALUES:     @[@C@B.     EH
)@@G@@@^@C@B.        X4  X        Q @ @C@B.        0   FLOAT    ANY     @^@C@BEI
)@@G@@.        1   FIXED    0 @ @C@B.        2   FIXED BIN <0     @ @C@B.     EJ
)@@G@@   3   FIXED DEC <0     @ @C@B.        4   FIXED BIN >0     @ @C@B.     EK
)@@G@@   5   FIXED DEC >0     @[@C@B.     @#@C@BCBSFLR   LABEL .  @#@C@BCBSCELEL
)@@G@@   LABEL    @#@C@BCBSTRN   LABEL .  @#@C@B         GNTR  2 .@E@C@B      EM
)@@G@@   MOVE    SGDAID+DCGSLT,SGDAID . SET ATTR OF RESULT  @D@C@B         LOAEN
)@@G@@D  X4,0,I .            ASSUME FLOAT RETURN@D@C@B         IF    SDFXFL,ONEO
)@@G@@,SGDCLS THEN,CBSTRX . -> FLOAT@D@C@B         STORE X4,SGDSCL+DCGSLT .  SEP
)@@G@@ET RESULT Q=0     @B@C@B         ADD   X4,1,I .            X4=1   @D@C@BEQ
)@@G@@         IF    SGDSCL,ZERO THEN,GGTRET . ->FIXED Q=0  @[@C@B.     @B@C@BER
)@@G@@.        COMPUTE Q=MIN(N, MAX(P-Q+1,1) )  @[@C@B.     @B@C@B         LOAES
)@@G@@DN A7,SGDSCP .         -Q     @^@C@B         SSA   A7,9     @B@C@B      ET
)@@G@@   LOAD  A9,A7 .             SAVE -Q@B@C@B         ADD   A7,SGDPRE .    EU
)@@G@@     P-Q    @B@C@B         IF    A7,LT,0,I THEN,CBSCL1 .    @^@C@B      EV
)@@G@@   LOAD  A7,0,I . @C@C@BCBSCL1   LABEL .                   MAX(P-Q,0)   EW
)@@G@@@^@C@B         ADD   A7,1,I . @C@C@B         LOAD  A8,18,I .           SEX
)@@G@@ET MAX P    @C@C@B         IF    SDDCBN,OFF,SGDCLS THEN,CBSCL2 .  @^@C@BEY
)@@G@@         LOAD  A8,35,I .@#@C@BCBSCL2   LABEL .  @B@C@B         IF    A7,EZ
)@@G@@LT,A8 THEN,CBSFL5 .     @^@C@B         LOAD  A7,A8 .  @C@C@BCBSFL5   LABFA
)@@G@@EL .                   A7=PRECISION @A@C@B         STORE A7,SGDPRE+DCGSLFB
)@@G@@T .   @B@C@B         ADD   X4,1,I .            X4=2   @C@C@B         STOFC
)@@G@@RE A9,AGX0OF .         ASSUME Q<0   @F@C@B         IF    SDDCBN,OFF,SGDCFD
)@@G@@LS THEN,CBSFL3 . ->DECIMAL DATA     @B@C@B         IF    A9,GE,0,I THEN,FE
)@@G@@GGTRET .    @E@C@B         STOREN  A9,DCGSV2+3 .     SET TO RETURN Q TO FF
)@@G@@ICODE @B@C@B         ADD   X4,2,I .            X4=4   @C@C@B         ADDFG
)@@G@@   A9,36,I .           GET 36-Q     @D@C@B         STORE A9,AGX0OF .    FH
)@@G@@     SET SHIFT FACTOR   @^@C@B         GOTO  GGTRET . @#@C@BCBSFL3   LABFI
)@@G@@EL .  @B@C@B         ADD   X4,1,I .            X4=3   @B@C@B         IF FJ
)@@G@@   A9,GE,0,I THEN,CBSFL4 . Q<0@^@C@B         LOADN A9,A9 .  @B@C@B      FK
)@@G@@   ADD   X4,2,I .            X4=5   @#@C@BCBSFL4   LABEL .  @E@C@B      FL
)@@G@@   LOADA A8,KKPW10-2 .       POINT TO 10**(ABS(Q))    @^@C@B         ADDFM
)@@G@@   A8,A9 .  @C@C@B         ADD   A8,A9 .             2*Q IS OFFSET@ @C@BFN
)@@G@@         STORE A8,AGX0OF .    @C@C@B         GOTO  GGTRET .            -FO
)@@G@@>RETURN     @D@C@BCBSTRX   LABEL .                   FLOAT OPERATION    FP
)@@G@@@ @C@B         LOADA A7,KK9999 .    @ @C@B         STORE A7,AGX0OF .    FQ
)@@G@@@^@C@B         GOTO  GGTRET . @[@C@B.     @[@C@B.     @[@C@B/.    @^@C@BFR
)@@G@@.         ICODE FOR SIGN@[@C@B.     @#@C@BCBSGFR   GLBL .   @B@C@B      FS
)@@G@@   GSHIN    OPDLSC,AGRA1,AGRL1 .    @^@C@B         GLIT    1 .    @^@C@BFT
)@@G@@         SSA     A1,34 .@ @C@B         GGETGR  AGRL2,1 .    @A@C@B      FU
)@@G@@   GINST   OPLA,AGRL2,AGRA1 . @^@C@B         GFIN    'POP' .@#@C@BCBSGBRFV
)@@G@@   GLBL .   @D@C@B         GIFR    CBSGB1,AGRL1 .    IF RL1 IN REG?     FW
)@@G@@@ @C@B         GGETGR  AGRL2,1 .    @B@C@B         GSHIN    OPLSC,AGRL2,FX
)@@G@@AGRL1 .     @B@C@B         GGOTO   CBSGB2 .          MERGE  @C@C@BCBSGB1FY
)@@G@@   GLBL .                    RL1 IS IN REG@B@C@B         GSHIN   OPLSC,AFZ
)@@G@@GRL1,AGRL1 'NO' . @ @C@B         GSET    AGRL2,AGRL1 .@#@C@BCBSGB2   GLBGA
)@@G@@L .   @A@C@B         GSHIN    OPSSA,AGRL2,34,I .@^@C@B         GFIN    'GB
)@@G@@POP' .@[@C@B.     @^@C@B.        ICODES  FOR ABS@[@C@B.     @C@C@B      GC
)@@G@@   GMODE 'M' .     PACK ICODES TOGETHER   @#@C@BCBABFR   GLBL .   @ @C@BGD
)@@G@@         GIFR  CBABF2,AGRL1 . @ @C@B         GGETGR AGRL2,2 .     @A@C@BGE
)@@G@@         GDBLE OPDLM,AGRL2,AGRL1 .  @^@C@B         GFIN 'POP'     @#@C@BGF
)@@G@@CBABF2   GLBL .   @C@C@B         GDBLE OPDLM,AGRL1,AGRL1 'NO' . ABS     GG
)@@G@@@ @C@B         GSET  AGRL2,AGRL1 .  @^@C@B         GFIN  'POP'    @[@C@BGH
)@@G@@.     @#@C@BCBABBR   GLBL     @ @C@B         GIFR  CBABB2,AGRL1 . @^@C@BGI
)@@G@@         GGETGR AGRL2,1 @A@C@B         GINST OPLMA,AGRL2,AGRL1    @^@C@BGJ
)@@G@@         GFIN  'POP'    @#@C@BCBABB2   GLBL .   @B@C@B         GINST OPLGK
)@@G@@MA,AGRL1,AGRL1 'NO'     @ @C@B         GSET    AGRL2,AGRL1 .@E@C@B      GL
)@@G@@   GFIN    'POP' .           POP STACK AND RETURN     @[@C@B.     @F@C@BGM
)@@G@@.                                  ICODE FOR HBOUND,LBOUND &  DIM @[@C@BGN
)@@G@@.     @#@C@BCBDIM   GLBL .    @E@C@B         GINST OPLA,AGRA3,AGRL1,U   GO
)@@G@@  . DV OF ARGUMENT ARRAY@C@C@B          GINST OPLA,AGRA2,AGPTX3 .   ARG2GP
)@@G@@ ->A2 @^@C@B         GSUB  'BILTN'  @^@C@B         GLITRG A9 .    @^@C@BGQ
)@@G@@         GGETGR AGRL2   @A@C@B         GINST OPLA,AGRL2,AGRA3 .   @^@C@BGR
)@@G@@         GFIN  'POP'    @[@C@B.     @D@C@B.                             GS
)@@G@@     ICODE FOR MAX/MIN  @[@C@B.     @#@C@B         GMODE 'M'@#@C@BBFFMINGT
)@@G@@   GLBL     @C@C@B         GIFR BFFMX1,AGRL2 .       SET IN REG   @^@C@BGU
)@@G@@         GLOAD AGRL2,2  @#@C@BBFFMX1   GLBL     @C@C@B         GDBLE OPDGV
)@@G@@L,AGRA3,AGRL2 'NO' .  DL  A3,Y@C@C@B         GFLOAT OPDFAN,AGRA3,AGRL1 'GW
)@@G@@NO' . A3=Y-X@F@C@B         GBON  BFFMX5,IGPLUS .      SHOULD IT BE A 'JPGX
)@@G@@' OR A 'JN'?@H@C@B         GCJMP OPJN,AGRA3,AGPTX3 .  GENERATE A 'JN' FOGY
)@@G@@R THE 'MIN' FUNCTION    @E@C@B         GGOTO BFFMX6 .             CONTINGZ
)@@G@@UE CODE GENERATION@#@C@BBFFMX5   GLBL .   @H@C@B         GCJMP OPJP,AGRAHA
)@@G@@3,AGPTX3 . GENERATE A 'JP' FOR THE 'MAX' FUNCTION     @#@C@BBFFMX6   GLBHB
)@@G@@L .   @D@C@B         GDBLE OPDL,AGRL2,AGRL1 .  SWITCH X AND Y     @E@C@BHC
)@@G@@         GGOTO BFFMX2 .            CONTINUE CODE GENERATION @D@C@BBFBMINHD
)@@G@@   GLBL .                    BINARY MAX AND MIN @ @C@B         GIFR  BFFHE
)@@G@@MX3,AGRL2   @^@C@B         GLOAD AGRL2,1  @#@C@BBFFMX3   GLBL     @B@C@BHF
)@@G@@         GINST OPLA,AGRA3,AGRL2 'NO' .    @B@C@B         GINST OPANA,AGRHG
)@@G@@A3,AGRL1 'NO' .   @F@C@B         GBON  BFFMX7,IGPLUS .      SHOULD IT BEHH
)@@G@@ A 'JP' OR A 'JN'?@H@C@B         GCJMP OPJN,AGRA3,AGPTX3 .  GENERATE A 'HI
)@@G@@JN' FOR THE 'MIN' FUNCTION    @E@C@B         GGOTO BFFMX8 .             HJ
)@@G@@CONTINUE CODE GENERATION@#@C@BBFFMX7   GLBL .   @H@C@B         GCJMP OPJHK
)@@G@@P,AGRA3,AGPTX3 .  GENERATE A 'JP' FOR THE 'MAX' FUNCTION    @#@C@BBFFMX8HL
)@@G@@   GLBL .   @A@C@B         GINST OPLA,AGRL2,AGRL1 .   @D@C@BBFFMX2   GLBHM
)@@G@@L .                    CLEAN UP EVERYTHING@ @C@B         GLABEL  AGPTX3 HN
)@@G@@.     @F@C@B         GAPPN BFMINMORE . SEE IF ANY MORE MAX AND MIN INNARHO
)@@G@@G     @C@C@B         GSET  AGRL2,AGRL1 . MOVE ANS TO SLOT   @#@C@BBFFMX4HP
)@@G@@   GLBL .   @^@C@B         GFIN  'POP' .  @H@C@BBFMINMORE GLBL .        HQ
)@@G@@                               SET IF ANY MORE IN LST @ @C@B         LOAHR
)@@G@@D  A3,DXGNAR .    @ @C@B         SUB   A3,DCGSLT,I .  @D@C@B         IF HS
)@@G@@   A3,LE,DCGSLT,I  THEN,BFMIN9 .  --> DONE@ @C@B         STORE A3,DXGNARHT
)@@G@@ .    @A@C@B         SET   DCGRPT,ON,DCGFLG .   @D@C@B         SETL A4,5HU
)@@G@@,I .             IGNORE NEXT ICODE  @#@C@BBFMIN8   LABEL .  @#@C@B      HV
)@@G@@   GETC .   @^@C@B         LOOP A4,BFMIN8 @#@C@B         LJMP     @#@C@BHW
)@@G@@BFMIN9   LABEL.   @C@C@B         XGPOP .                   RESET STACK  HX
)@@G@@@B@C@B         MOVE  SGDAID+DCGSLT,SGDAID .     @#@C@B         LJMP .   HY
)@@G@@@[@C@B.     @E@C@B.                                  REAL AND IMAG BIFS HZ
)@@G@@& PV'S@[@C@B.     @#@C@B         GMODE 'M'@#@C@BCBIMAG   GLBL     @C@C@BIA
)@@G@@         GBON  CBIMG1,SDRLCX .->COMPLEX ARG     @#@C@BCBREL    GLBL     IB
)@@G@@@B@C@B         GBOFF CBREL1,SDRLCX . ->REAL     @D@C@B         GFREE AGIIC
)@@G@@M1 .             FREE IMAG PART     @#@C@BCBREL1   GLBL .   @^@C@B      ID
)@@G@@   GMOVE +2,1 .   @^@C@B         GFIN 'POP' .   @#@C@BCBIMG    GLBL     IE
)@@G@@@ @C@B         GBON  CBIMG1,SDRLCX  @C@C@B         GSET  AGIM1,AGDZRO . IF
)@@G@@     SET IMAG TO 0@#@C@BCBIMG1   GLBL .   @^@C@B         GFREE AGRL1 .  IG
)@@G@@@ @C@B         GSET  AGRL1,AGIM1 .  @^@C@B         GGOTO CBREL1 . @[@C@BIH
)@@G@@.     @[@C@B.     @[@C@B.     @[@C@B.     @#@C@BCBCPLF   GLBL .   @D@C@BII
)@@G@@         GIFR    CBCP10,AGRL1 .    IMAG PART IN REG?  @ @C@B         GGEIJ
)@@G@@TGR  AGXTMP,2 .   @A@C@B         GDBLE   OPDL,AGXTMP,AGRL1 .@#@C@BCBCP10IK
)@@G@@   GLBL .   @E@C@B         GSET    AGIM2,AGXTMP .    MOVE RESULT TO STACIL
)@@G@@K     @ @C@B         GAPPN   CBPLXA .     @^@C@B         GMOVE   +2,1 . IM
)@@G@@@^@C@B         GFIN    'POP' .@[@C@B.     @[@C@B.     @#@C@BCBCPLB   GLBIN
)@@G@@L .   @A@C@B         GIFR    CBCP10,AGRL1 .     @ @C@B         GGETGR  AIO
)@@G@@GXTMP,1 .   @A@C@B         GINST   OPLA,AGXTMP,AGRL1 .@ @C@B         GGOIP
)@@G@@TO   CBCP10 .     @#@C@BCBPLXA   GLBL .   @ @C@B         USING SGDSCT,X7IQ
)@@G@@ .    @H@C@B         SET   SDRLCX,ON,SGDCLS+DCGSLT .               SET CIR
)@@G@@OMPLEX RESULT     @C@C@B         XGPOP .                   POP STACK    IS
)@@G@@@#@C@B         LJMP .   @[@C@B.     @[@C@B.     @[@C@B.     @C@C@BCBCJGFIT
)@@G@@   GLBL .                    CONJG BIF    @ @C@B         GIFR  CBCJ1,AGIIU
)@@G@@M1    @C@C@B         GGETGR AGXTMP,2 .         ALLOCATE REG @A@C@B      IV
)@@G@@   GDBLE OPDLN,AGXTMP,AGIM1 . @ @C@B         GSET  AGIM1,AGXTMP   @^@C@BIW
)@@G@@         GGOTO CBCJGR . @#@C@BCBCJ1    GLBL     @B@C@B         GDBLE OPDIX
)@@G@@LN,AGIM1,AGIM1 'NO'     @^@C@B         GGOTO CBCJGR . @#@C@BCBCJGB   GLBIY
)@@G@@L     @C@C@B         GIFR  CBCJ2,AGIM1 .       BINARY CONJG @^@C@B      IZ
)@@G@@   GGETGR AGXTMP,1@A@C@B         GINST OPLNA,AGXTMP,AGIM1   @ @C@B      JA
)@@G@@   GSET AGIM1,AGXTMP    @^@C@B         GGOTO CBCJGR   @#@C@BCBCJ2    GLBJB
)@@G@@L     @B@C@B         GINST OPLNA,AGIM1,AGIM1 'NO'     @#@C@BCBCJGR   GLBJC
)@@G@@L     @^@C@B         GMOVE +2,1 .   @^@C@B         GFIN 'POP'     @[@C@BJD
)@@G@@.     @[@C@B.     @[@C@B.     @[@C@B.     @B@C@B.        ICODES FOR TRUNJE
)@@G@@C, FLOOR AND CEIL @[@C@B.     @[@C@B.     @[@C@B.     @ @C@B.        FIXJF
)@@G@@ED BINARY ICODES  @[@C@B.     @D@C@BCBXFLR   GLBL .                    FJG
)@@G@@IXED BIN+Q FLOOR  @D@C@B         GIFR  CBXFL1,AGRL1 .      PUT OP 1 IN RJH
)@@G@@EG    @^@C@B         GLOAD AGRL1,1 .@#@C@BCBXFL1   GLBL .   @H@C@B      JI
)@@G@@   GINST OPLA,AGRA3,AGRL1 'NO' .                  GET SIGN OF ARGUMENT  JJ
)@@G@@@D@C@B         GSHIN   OPSSA,AGRA3,36,I . PROPAGATE SIGN    @C@C@B      JK
)@@G@@   GSHIN OPSSL,AGRA3,AGXR0 . SHIFT BY 36-Q@C@C@B         GINST OPANA,AGRJL
)@@G@@L1,AGRA3 . ADD Q 1'S    @^@C@B         GGOTO CBXTRN   @[@C@B.     @D@C@BJM
)@@G@@CBXCEL   GLBL .                    FIXED BIN +Q CEIL  @ @C@B         GIFJN
)@@G@@R  CBXCL1,AGRL1   @^@C@B         GLOAD AGRL1,1  @#@C@BCBXCL1   GLBL     JO
)@@G@@@B@C@B         GINST OPLNA,AGRA3,AGRL1 'NO'     @D@C@B         GSHIN   OJP
)@@G@@PSSA,AGRA3,36,I . PROPAGATE SIGN    @A@C@B         GSHIN OPSSL,AGRA3,AGXJQ
)@@G@@R0    @A@C@B         GINST OPAA,AGRL1,AGRA3 .   @[@C@B.     @[@C@B.     JR
)@@G@@@D@C@BCBXTRN   GLBL .                    FIXED BIN +Q TRUNC @ @C@B      JS
)@@G@@   GIFR  CBXTR1,AGRL1   @^@C@B         GLOAD AGRL1,1  @#@C@BCBXTR1   GLBJT
)@@G@@L     @^@C@B         GAPPN CBXTR    @A@C@B         GSHIN OPSSA,AGRL1,AGXJU
)@@G@@R0 .  @F@C@BCBXFNP   GLBL .                    FIXED Q=0 FLOOR,CEIL & TRJV
)@@G@@UNC   @D@C@B         GSET  AGRL2,AGRL1 .       SET RESULT REG     @^@C@BJW
)@@G@@         GFIN  'POP'    @[@C@B.     @#@C@BCBXTR    GLBL     @E@C@B      JX
)@@G@@   LOAD  A3,DCGSV4+3 .       GET Q FROM CALLING REG   @ @C@B         STOJY
)@@G@@RE A3,AGX0OF .    @#@C@B         LJMP     @[@C@B.     @[@C@B.     @F@C@BJZ
)@@G@@CBXFLQ   GLBL .                    FIXED BIN -Q FLOOR,CEIL & TRUNC@ @C@BKA
)@@G@@         GIFR  CBXFQ1,AGRL1   @^@C@B         GLOAD AGRL1,1  @#@C@BCBXFQ1KB
)@@G@@   GLBL     @E@C@B         GSHIN OPLSSC,AGRL1,AGXR0 . WATCH FOR SIGN BITKC
)@@G@@S     @^@C@B         GGOTO CBXFNP . @[@C@B.     @[@C@B.     @D@C@B.     KD
)@@G@@   FLOATING ARGUMENTS TO FLOOR, CEIL AND TRUNC  @[@C@B.     @F@C@BCBXFDQKE
)@@G@@   GLBL .                    FIXED DEC -Q FLOOR,CEIL & TRUNC@E@C@B      KF
)@@G@@   GBAL    CDXLDR .          MAKE SURE IT IS IN REG   @H@C@B         GFLKG
)@@G@@OAT OPDFM,AGRL1,AGXR0 .                    MPY BY 10**Q (Q<0)     @A@C@BKH
)@@G@@         GGOTO CBXFNP . ->FINISH UP @[@C@B.     @[@C@B.     @D@C@BCBXFDPKI
)@@G@@   GLBL .                    FIXED DEC +Q TRUNC @D@C@B         GBAL  CDXKJ
)@@G@@LDR .            LOAD ARG INTO REG  @D@C@B         GFLOAT OPDFD,AGRL1,AGKK
)@@G@@XR0 . SCALE BY 10**Q    @C@C@BCBXFTQ   GLBL .                    FLOAT TKL
)@@G@@RUNC  @C@C@B         GBAL CDXLDR .             LOAD ARG     @#@C@BCBXFT1KM
)@@G@@   GLBL .   @H@C@B         GFLOAT OPDFA,AGRL1,AGXUNZ .                  KN
)@@G@@ TRUNCATE - ADD FUNNY 0 @C@C@B         GGOTO CBXFNP .            ->FINISKO
)@@G@@H UP  @[@C@B.     @E@C@BCDXLDR   GLBL .                    FLOAT LOAD INKP
)@@G@@TO REGS     @C@C@B         GIFR  CBXLD1,AGRL1 . -> ALREADY IN REG @^@C@BKQ
)@@G@@         GLOAD AGRL1,2  @#@C@BCBXLD1   GLBL     @#@C@B         GRTRN .  KR
)@@G@@@[@C@B.     @[@C@B.     @[@C@B.     @C@C@BCBXFLC   GLBL .               KS
)@@G@@     FLOAT CEIL   @^@C@B         GBAL CDXLDR .  @E@C@B         GINST OPTKT
)@@G@@N,AGRX0,AGRL1 'NO' . TEST SIGN OF NUMBER  @C@C@B         GFLOAT OPDFA,AGKU
)@@G@@RL1,AGXR0 . ADD .99999  @^@C@B         GGOTO CBXFT1 . @[@C@B.     @C@C@BKV
)@@G@@CBXFLF   GLBL .                    FLOAT FLOOR  @^@C@B         GBAL  CDXKW
)@@G@@LDR . @A@C@B         GINST OPTP,AGRX0,AGRL1 'NO'@C@C@B         GFLOAT OPKX
)@@G@@DFAN,AGRL1,AGXR0 .  ADD .99999@A@C@B         GGOTO CBXFT1 . ->TRUNCATE  KY
)@@G@@@[@C@B.     @[@C@B.     @D@C@BCBXFFC   GLBL  .                   FIX DECKZ
)@@G@@ +Q CEIL    @C@C@B         GBAL CDXLDR .             LOAD ARG     @B@C@BLA
)@@G@@         GDBLE OPDL,AGRA3,AGXR0 . 10**Q   @#@C@B         GLIT 1   @E@C@BLB
)@@G@@         DFAN  A3,KKPW10-2-(IN 63,0,1,0) . 10**Q-1=9999999  @B@C@B      LC
)@@G@@   GINST OPTN,AGRX0,AGRL1 'NO' .    @D@C@B         GFLOAT OPDFA,AGRL1,AGLD
)@@G@@RA3 .  ADD IF POS NUM   @B@C@B         GGOTO CBXFDP .   -> TRUNCATE     LE
)@@G@@@[@C@B.     @[@C@B.     @D@C@BCBXFFF   GLBL  .                   FIXED DLF
)@@G@@EC +Q FLOOR @C@C@B         GBAL  CDXLDR .            LOAD ARG     @A@C@BLG
)@@G@@         GDBLE OPDL,AGRA3,AGXR0 .   @#@C@B         GLIT  1 .@B@C@B      LH
)@@G@@   DFAN  A3,KKPW10-2-(IN 63,0,1,0)  @A@C@B         GINST OPTP,AGRX0,AGRLLI
)@@G@@1 'NO'@E@C@B         GFLOAT OPDFAN,AGRL1,AGRA3 .   SUB IF NUMBER NEG    LJ
)@@G@@@C@C@B         GGOTO CBXFDP .            ->FINISH UP  @[@C@B.     @C@C@BLK
)@@G@@.                                  FIXED BIN MOD@[@C@B.     @#@C@BBFMODBLL
)@@G@@   GLBL .   @D@C@B         GIFR    BFMOB1,AGRL2 .    IS ARG1 IN REG?    LM
)@@G@@@D@C@B         GLOAD   AGRL2,1 .         GET IT INTO ONE    @D@C@BBFMOB1LN
)@@G@@   GLBL .                    ARG1 NOW IN REG    @D@C@B         GIFR    BLO
)@@G@@FMOB5,AGRL1 .    IS ARG2 IN REG?    @D@C@B         GINST   OPTNZ,AGRX0,ALP
)@@G@@GRL1 'NO' . SEE IF ZERO @C@C@B         GJUMP   AGLBL .           JUMP ARLQ
)@@G@@OUND  @B@C@B         GGOTO   BFMOB6 .          MERGE  @E@C@BBFMOB5   GLBLR
)@@G@@L .                    HERE AGRL1 IS IN REG     @F@C@B         GCJMP   OLS
)@@G@@PJZ,AGRL1,AGLBL 'NO' . LEAVE RESULT IF ZERO     @E@C@BBFMOB6   GLBL .   LT
)@@G@@                 MERGE HERE TO CONTINUE   @D@C@B         GSHIN   OPDSA,ALU
)@@G@@GRL2,36,I 'NO' . SIGN EXTEND  @C@C@B         GINST   OPDI,AGRL2,AGRL1 'NLV
)@@G@@O' . DIVIDE @F@C@B         GSHIN   OPLDSL,AGRL2,36,I 'NO' . PUT BACK INTLW
)@@G@@O ODD REG   @F@C@B         GCJMP   OPJZ,AGRL2,AGLBL . TEST POS. DOESN'T LX
)@@G@@HDLE NEG. 0 @B@C@B         GINST   OPTP,AGRX0,AGRL2 'NO' .  @E@C@B      LY
)@@G@@   GINST   OPAMA,AGRL2,AGRL1 . GET POSITIVE RESULT    @D@C@B         GLALZ
)@@G@@BEL  AGLBL .           SET JUMP TO HERE   @C@C@B         GSET    AGRL2+DMA
)@@G@@CGSLT,AGRL2 . SET RESULT@D@C@B         GAPPN   BFMOB4 .          GO POP MB
)@@G@@OFF ARGS    @D@C@B         GFIN .                    ALL DONE ICODE     MC
)@@G@@@E@C@BBFMOB4   GLBL .                    HERE TO POP OFF TWO ARGS @A@C@BMD
)@@G@@         XGPOP   'SIZE',2*DCGSLT .  @#@C@B         LJMP .   @[@C@B.     ME
)@@G@@@F@C@B.                                  FLOAT OR FIXED DEC MOD BIF     MF
)@@G@@@[@C@B.     @#@C@BBFMODF   GLBL .   @D@C@B         GIFR    BFMOF1,AGRL2 MG
)@@G@@.    ARG ONE IN REG?    @D@C@B         GLOAD   AGRL2,2 .         GET IT MH
)@@G@@INTO ONE    @D@C@BBFMOF1   GLBL .                    ARG ONE NOW IN REG MI
)@@G@@@F@C@B         GINST   OPTNZ,AGRX0,AGRL1 'NO' .   SEE IF DIVISOR ZERO   MJ
)@@G@@@^@C@B         GJUMP   AGLBL .@F@C@B         GDBLE   OPDL,AGRA1,AGRL2 'NMK
)@@G@@O' . LOAD INTO SCRATCH REG    @C@C@B         GFLOAT  OPDFD,AGRA1,AGRL1 'ML
)@@G@@NO' . DIVIDE@D@C@B         GINST   OPTP,AGRX0,AGRA1 'NO' . SEE IF POS   MM
)@@G@@@E@C@B         GLIT    1 .               NEG HERE,HELP FLOOR FUNC @ @C@BMN
)@@G@@         DFAN    A1,KK9999 .  @D@C@B         GFLOAT  OPDFA,AGRA1,AGXUNZ MO
)@@G@@'NO' . TRUNCATE   @G@C@B         GFLOAT  OPDFM,AGRA1,AGRL1 'NO' . GET FLMP
)@@G@@OOR(ARG1/ARG2)*ARG2     @D@C@B         GFLOAT  OPDFAN,AGRL2,AGRA1 'NO' .MQ
)@@G@@ GET MOD    @C@C@B         GSET    AGRL2+DCGSLT,AGRL2 . SET RESULT@D@C@BMR
)@@G@@         GCJMP   OPJP,AGRL2,AGLBL . IS RESULT NEG.    @F@C@B         GINMS
)@@G@@ST   OPTP,AGRX0,AGRL1 'NO' .    DO DBLE ADD MAGN.     @E@C@B         GFLMT
)@@G@@OAT  OPDFAN,AGRL2,AGRL1 'NO' . GET POS. RESULT  @B@C@B         GINST   OMU
)@@G@@PTN,AGRX0,AGRL1 'NO' .  @E@C@B         GFLOAT  OPDFA,AGRL2,AGRL1 .    GEMV
)@@G@@T POS. RESULT     @^@C@B         GLABEL  AGLBL .@C@C@B         GAPPN   BMW
)@@G@@FMOB4 .          POP STACK    @#@C@B         GFIN .   @ @C@B/.       CONMX
)@@G@@STANTS NEEDED     @[@C@B.     @[@C@B.     @^@C@BDCBCSM   SFW     0 .    MY
)@@G@@@B@C@B         +SGDEXP++SD0ART,SDDCBN,0,17 .    @A@C@BDCBCLN   SFW 0 . SMZ
)@@G@@TACK ELT FOR 35,0 @D@C@B         +SGDEXP++SD0ART,SDDCBN,0,35 . WHY SGDEXNA
)@@G@@P?    @[@C@B.     @ @C@B.        WORDS FOR NONPL1 MSGS@[@C@B.     @C@C@BNB
)@@G@@DCBRND   INSERT  4,'RAN','D   ' .  RAND USED    @C@C@BERXGRN    EQU  52 NC
)@@G@@.        NON STANDARD PL1 USED@B@C@BEXERB1    EQU  51 .         REAL PARND
)@@G@@T USED@G@C@BEXROUN   EQU     0200 .            ARG TO ROUND OUT OF BOUNDNE
)@@G@@S. ONE USED @D@C@BERRG08   EQU   41 .            NON-CONSTANT. 10 USED  NF
)@@G@@@C@C@BERRG10   EQU   42      .       REAL PART USED   @F@C@BERRG09   EQUNG
)@@G@@   43    .         SMALL INTEGER NEEDED, NOT FOUND    @D@C@BIGPLUS   EQUNH
)@@G@@   02000 .         FLAG FOR MIN & MAX     @F@C@BIGMPDV   EQU     01000 .NI
)@@G@@           MULTIPLY OR DIVIDE IN ROUND    @E@C@BIGZERO   EQU     01000 .NJ
)@@G@@           FLAG FOR ZERO SHIFT COUNT@#@C@B         CEND .   @#@C@B      NK
)@@G@@    END .   @A@@@C/. BASED STORAGE BUILT-IN FUNCTIONS @[@@@C.     @[@@@CNL
)@@G@@.     @[@@@C.     @]@@@CFGNULL*     @ @@@CFILL(1)  SAC     GGTNOP,BBBNULNM
)@@G@@@ @@@CFILL(1)  SAC     BBBNOP,0     @[@@@C.     @[@@@C.     @]@@@CFGALLCNN
)@@G@@*     @A@@@CFILL(1)  SAC     GGTNOP,BBBALL .    @ @@@CFILL(1)  SAC     BNO
)@@G@@BBNOP,0 .   @[@@@C.     @[@@@C.     @]@@@CFGADDR* .   @A@@@CFILL(1)  SACNP
)@@G@@     GGTNOP,BBBADR .    @ @@@CFILL(1)  SAC     BBBNOP,0 .   @]@@@C/. NULNQ
)@@G@@L BIF @[@@@C.     @[@@@C.     @ @@@C         USING   SGDSCT,X7 .  @#@@@CNR
)@@G@@BBBNUL   LABEL .  @^@@@C         GNTR    2 .    @E@@@C         LOADA    NS
)@@G@@A3,BFNULL  .     GET ADDR OF A NULL PTR   @ @E@C         STORE   A3,SGDRNT
)@@G@@BS .  @ @@@E         STORE   A3,SGDRDS .  @D@@@C         LOADA    A3,AGRNU
)@@G@@X0  .      MAKE ADDR OFF X0   @ @E@C         STORE   A3,SGDRDS .  @ @@@ENV
)@@G@@         STORE   A3,SGDRBS .  @D@@@C         MOVE    SGDAID,BBBPTR .   SNW
)@@G@@AY IT IS A PTR    @^@@@C         GRTN    2 .    @[@@@C.     @[@@@C.     NX
)@@G@@@[@@@C.     @[@@@C.     @ @@@CBBBALL   LABEL . ALLOCATON BIF@[@@@C.     NY
)@@G@@@^@@@C         GNTR    2 .    @#@@@C         GENM .   @F@@@C         GINNZ
)@@G@@ST   OPLA,AGRA3,AGRL1,U  . LOAD ADDR OF IMPLIED PTR   @ @@@C         GSUOA
)@@G@@B    BFALLC .     @^@@@C         GFIN    'POP' .@E@@@C         MOVE    SOB
)@@G@@GDAID,BBBFBC .   SAY RESULT IS FIXED BIN  @E@@@C         LOAD    A3,AGRAOC
)@@G@@2 .        SET TO SAY RESULT IN A2  @ @@@C         STORE   A3,AGRL1 .   OD
)@@G@@@^@@@C         GRTN    2 .    @[@@@C.     @[@@@C.     @[@@@C.     @[@@@COE
)@@G@@.     @ @@@CBBBADR   LABEL .    ADDR BIF  @[@@@C.     @[@@@C.     @^@@@COF
)@@G@@         GNTR     2 .   @D@@@C         LOAD    A3,SGDRSD .       GET SD OG
)@@G@@OF THING    @D@@@C         STORE   A3,AGX0OF .       SET TO PASS IT     OH
)@@G@@@#@@@C         GENM .   @D@@@C         GINST   OPLA,AGRA1,AGXR0,U . LA,UOI
)@@G@@ A1,SDADDR  @E@@@C         GINST   OPLA,AGRA3,AGRL1,U . LA,U A3,ADDR OF OJ
)@@G@@THING @^@@@C         GFIN    'POP' .@D@@@C         GTMP    3 .          OK
)@@G@@     GET A TEMP PTR     @D@@@C         STORE   A8,AGR10D .       MAKE ANOL
)@@G@@ AW FOR IT  @ @@@C         LOAD    A3,AGXR10 .  @E@@@C         STORE   AOM
)@@G@@3,AGRL1 .        SET TOP OF STK TO TEMP   @D@@@C         MOVE    SGDAID,ON
)@@G@@BBBPTR .   MAKE STACKTOP A PTR@#@@@C         GENM .   @F@@@C         GINOO
)@@G@@ST   OPLA,AGRA2,AGRL1,U . LA,U A2,ADDR OF TEMP PTR    @ @@@C         GSUOP
)@@G@@B    BFADDR .     @#@@@C         GFIN .   @^@@@C         GRTN     2     OQ
)@@G@@@[@@@C.     @[@@@C.     @B@@@CBBBNOP   GLBL .  TELL XGEN TO DO NO MORE  OR
)@@G@@@#@@@C         GFIN .   @#@@@C/. CONSTANTS USED @[@@@C.     @D@@@CBBBFBCOS
)@@G@@   SFW      0 .              FIXED BIN RESULT   @ @@@C         +SD0ART,SOT
)@@G@@DDCBN,0,35  @C@@@CBBBPTR   SFW     0 .               PTR RESULT   @ @F@COU
)@@G@@         +SD0PTR,SDVRCN,0,0 . @ @@@F         +SD0PTR,SDDCBN,0,0 . @#@@@COV
)@@G@@         END .    ___ESULT    @D@C@B         GLABEL  AGLBL .           SOW
)@@G@@ET JUMP TO HERE   @C@C@B*[S@@@*SDFF*@C@@@@.   COPYRIGHT 1975 BY UNIVERSIOX
)@@G@@TY OF MARYLAND    @[@@@@.     @D@@@@.   QUESTIONS CONCERNING THIS SHOULDOY
)@@G@@ BE DIRECTED TO:  @[@@@@.     @ @@@@.        MARVIN V. ZELKOWITZ  @B@@@@OZ
)@@G@@.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@@.        UNIVERSITY OF MPA
)@@G@@ARYLAND     @B@@@@.        COLLEGE PARK, MARYLAND 20742     @[@@@@.     PB
)@@G@@@G@@@@.        PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMPC
)@@G@@S THEY@E@@@@.   REPRESENT IS GRANTED UNDER THE FOLLOWING CONDITIONS:    PD
)@@G@@@[@@@@.     @G@@@@.        1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS PE
)@@G@@REPRESENTED BY    @G@@@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OPF
)@@G@@R UNIVERSITY OF MARYLAND@E@@@@.   PL/1 COMPILER REMAINS ASSOCIATED WITH PG
)@@G@@THESE PROGRAMS.   @[@@@@.     @F@@@@.        2. MODIFICATIONS MAY BE MADPH
)@@G@@E TO THE LISTINGS PROVIDED:   @[@@@@.     @G@@@@.        (A) ANY RESULTIPI
)@@G@@NG PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   @G@@@@.        DESCRIBINPJ
)@@G@@G SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM @E@@@@.        IS PK
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  @[@@@@.     @G@@@@.     PL
)@@G@@   (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@@PM
)@@G@@.        OF ERRORS IN THE SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@@PN
)@@G@@.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTED    PO
)@@G@@@C@@@@.        TO THE UNIVERSITY OF MARYLAND, AND     @[@@@@.     @F@@@@PP
)@@G@@.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@@PQ
)@@G@@.        WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  PR
)@@G@@@[@@@@.     @F@@@@.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTPS
)@@G@@ED TO OTHER @G@@@@.        LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEPT
)@@G@@ARLY INDICATE     @G@@@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OPU
)@@G@@F THE UNIVERSITY OF     @E@@@@.        MARYLAND PLUM COMPILER OR ARE MODPV
)@@G@@IFICATIONS TO IT. @[@@@@.     @G@@@@.        3. THESE CONDITIONS ONLY APPW
)@@G@@PLY TO THE PLUM COMPILER ITSELF,    @F@@@@.   AND ARE NOT MEANT TO APPLYPX
)@@G@@ TO ANY PROGRAM WRITTEN USING PLUM. @E@@@@.   THE PURPOSE OF THESE CONDIPY
)@@G@@TIONS IS TO ALLOW ANY USER TO @F@@@@.   EXPERIMENT WITH THE COMPILER AS PZ
)@@G@@LONG AS THE RESULTING PRODUCT @G@@@@.   IS NOT SOLD AND AS LONG AS IT ISQA
)@@G@@ KNOWN THAT THE PRODUCT DEVELOPED   @#@@@@.   FROM PLUM.    @[@@@@.     QB
)@@G@@@[@@@@.     @[@@@@.     @[@@@@.     @[@@@@.     @[@@@@/.    @#@@@@/     QC
)@@G@@   AXR$ .   @#@@@@         DCLRG .  @#@@@@@ADD,P PLTVDS     @#@@@@@ADD,PQD
)@@G@@ PLCGST     @#@@@@@ADD,P PLDSAW     @#@@@@         LIST .   @#@@@@      QE
)@@G@@   PLWORD . @#@@@@         PLAC .   @#@@@@         PLCGD .  @#@@@@      QF
)@@G@@   PLSD .   @#@@@@         PLIG .   @D@@@@         PLAR . ESTABLISH ACTIQG
)@@G@@VATION RECORD DSECTS    @#@@@@         CEND .   @^@@@@/XGCG     CSECT 3 QH
)@@G@@.     @D@@@@GSSL     EQU   0400000000000 . GET SUBSCRIPT LIST     @D@@@@QI
)@@G@@GTMP     EQU   0200000000000 . GET CROSS SECTION DV   @E@@@@LIST     EQUQJ
)@@G@@   0100000000000 . START SCAN OF SUBSCRIPT LIST @E@@@@GTCV     EQU   004QK
)@@G@@0000000000 . LOCATE TALLY CELL VECTOR     @F@@@@SSUB     EQU   002000000QL
)@@G@@0000 . FORM TALLY CELL INTO SUBSCRIPT     @E@@@@SCPY     EQU   001000000QM
)@@G@@0000 . COPY BNDS&MULTP INTP CRSC DV @D@@@@SEND     EQU   0004000000000 .QN
)@@G@@ BEGIN COMMA PROCESSING @D@@@@BSSL     EQU   0002000000000 . BUMP SS LISQO
)@@G@@T OFFSET    @E@@@@TCV0     EQU   0001000000000 . START CONSECUTIVE STAR QP
)@@G@@COUNT @D@@@@TCV1     EQU   0000400000000 . COUNT CONSECUTIVE STARS@C@@@@QQ
)@@G@@TCV2     EQU   0000200000000 . COUNT #SUB'S     @E@@@@STFS     EQU   000QR
)@@G@@0100000000 . MOVE CONSECURIVE TC'S TO SSL @E@@@@SSBW     EQU   000004000QS
)@@G@@0000 . COMPUTE NON-* SUBSCRIPT MASK @D@@@@STUF     EQU   0000020000000 .QT
)@@G@@ MOVE SUBSCRIPT TO SSL  @D@@@@COMP     EQU   0000010000000 . ADDR <-ADDRQU
)@@G@@+SS(I)*M(I) @D@@@@NEXT     EQU   0000004000000 . SCAN NEXT SUBSCRIPT    QV
)@@G@@@C@@@@STF0     EQU   0000002000000 . (SAME AS STFS)   @D@@@@LARG     EQUQW
)@@G@@   0000001000000 . GEN LA OF SSL AND DV   @D@@@@TLYC     EQU   000000040QX
)@@G@@0000 . GEN CALL TO EXTLYC     @D@@@@SUBR     EQU   0000000200000 . GEN CQY
)@@G@@ALL TO EXSUBR     @D@@@@CRSC     EQU   0000000100000 . GEN CALL TO EXCRSQZ
)@@G@@C     @D@@@@RESA     EQU   0000000040000 . SET RESULT DESCRIPTION @F@@@@RA
)@@G@@RESB     EQU   0000000020000 . SET RESULT DESCRIPTION(NOSUBRG)    @E@@@@RB
)@@G@@STV0     EQU   0000000010000 . FINISH CRSC DV CONSTRUCTION  @D@@@@POPS  RC
)@@G@@   EQU   0000000004000 . CLEAR STACK ENTRIES    @C@@@@ . DEFINITION OF ARD
)@@G@@RRAY PROCESSING STATE MASKS   @F@@@@XGSCLR SF +GSSL+LIST+TCV2+STUF+COMP+RE
)@@G@@NEXT+LARG+SUBR+RESB+RESA+POPS @^@@@@ . ARRAY EXPRSSION MASK @F@@@@XGACCXRF
)@@G@@ SF +GSSL+LIST+GTCV+SSUB+SEND+TCV0+STUF+COMP+NEXT+SSBW;     @ @@@@+LARG+RG
)@@G@@TLYC+RESB+RESA+POPS .   @^@@@@ . CROSS SECTION MASK   @F@@@@XGCRSE SF +GRH
)@@G@@SSL+GTMP+LIST+SCPY+BSSL+TCV2+SSBW+STUF+COMP+NEXT;     @A@@@@+LARG+CRSC+RRI
)@@G@@ESA+RESB+STV0+POPS .    @F@@@@ . ONE OF THE FOLLOWING MASKS IS ANDED AGARJ
)@@G@@INST ONE OF THE ABOVE   @E@@@@ . MASKS TO ACCOUNT FOR THE STATUS OF THE RK
)@@G@@SUBSCRIPT RANGE   @#@@@@ . CONDITION.     @^@@@@ . SUBSCRIPT RANGE MASK RL
)@@G@@@F@@@@XGSBRG SF +GSSL+LIST+GTCV+BSSL+TCV0+TCV2+SSBW+STUF+NEXT+LARG+SUBR;RM
)@@G@@@^@@@@+TLYC+CRSC+RESA+POPS .  @ @@@@ . NO SUBSCRIPT RANGE MASK    @G@@@@RN
)@@G@@XGNBRG SF +GTMP+LIST+GTCV+SSUB+SCPY+SEND+TCV2+SSBW+COMP+NEXT+RESA+RESB; RO
)@@G@@@]@@@@+STV0+POPS .@ @@@@ . MASK FOR SUBSEQUENT STARS  @A@@@@XGSTAR SF +TRP
)@@G@@CV0+TCV1+STFS+STF0 .    @^@@@@XGCCS2   SFW   0  .     @^@@@@FILL(1)  SQ RQ
)@@G@@   SD0STR   @A@@@@FILL(1)  SQ    SDCHBT+SDARST+SDVRCN @#@@@@FILL(1)  SQ RR
)@@G@@   0  @#@@@@FILL(1)  SQ    1  @D@@@@XGCCS1   SAC   AGRX0-AGRX0+AGAW,KKF1RS
)@@G@@-(IN 63,0,1,0) .  @D@@@@FILL(1)  SAC   AGRX0-AGRX0+AGAW,KKD0-(IN 63,0,1,RT
)@@G@@0) .  @#@@@@XGCONO   SFW   0 .@B@@@@FILL(1)  SQ    SD0ART+SGDEXP        RU
)@@G@@   .  @ @@@@FILL(1)  SQ    SDDCBN        .@ @@@@FILL(1)  SQ    0        RV
)@@G@@     .@ @@@@FILL(1)  SQ    KBXMXP        .@D@@@@FILL(1)  SAC   AGXR0-AGRRW
)@@G@@X0+AGAW,KKF0-(IN 63,0,1,0) .  @#@@@@XGCON1   SFW   0 .@ @@@@FILL(1)  SQ RX
)@@G@@   SD0ART+SGDEXP .@^@@@@FILL(1)  SQ    SDDCBN . @#@@@@FILL(1)  SQ    0 .RY
)@@G@@@^@@@@FILL(1)  SQ    KSLPRE . @#@@@@XGCON2   SFW   0 .@^@@@@FILL(1)  SQ RZ
)@@G@@   SD0ART . @^@@@@FILL(1)  SQ    SDDCBN . @#@@@@FILL(1)  SQ    0 .@^@@@@SA
)@@G@@FILL(1)  SQ    KBXMXP . @#@@@@XGCON3   SFW   0 .@^@@@@FILL(1)  SQ    SD0SB
)@@G@@ART . @^@@@@FILL(1)  SQ    SDDCBN . @#@@@@FILL(1)  SQ    0 .@^@@@@FILL(1SC
)@@G@@)  SQ    KSLPRE . @#@@@@XGCON4   SFW   0 .@^@@@@FILL(1)  SQ    SD0ART . SD
)@@G@@@B@@@@FILL(1)  SQ    SDRLCX++SDFXFL++SDDCBN .   @#@@@@FILL(1)  SQ    0 .SE
)@@G@@@^@@@@FILL(1)  SQ    60 .     @B@@@@LRR1U0   SF    +(LR R1,0,0,U)       SF
)@@G@@   .  @H@@@@DRAW34   SAC   AGRX0-AGRX0+AGAW,34  . AW USED AFTER LSC IN FSG
)@@G@@INDING POWERS OF 2@C@@@@R14ETY   SAC   AGRX0-AGRX0+AGAW,EXTLYC     .    SH
)@@G@@@D@@@@XGMSK1   SF    0777000  . MASK USED TO CHECK Q3 OF H2 @H@@@@XGMSK2SI
)@@G@@   SF    0400000000000 . MASK USED TO MARK A10 WITH BY-NAME EXPRESSION  SJ
)@@G@@@ @@@@XGMSK3   SAC   1,0           .@G@@@@XGMSK4   SAC   0777777,000000 SK
)@@G@@         . FOR MASKING OUT LOWER HALF WORD@H@@@@XGMSK5   SAC   0200000,0SL
)@@G@@00000 . COMPARISON AFTER SHIFTING TO SEE IF POWER OF 2@]@@@@. **TABLES  SM
)@@G@@@A@@@@XGTBLE   EQU   +(IN 0,H2,1,$) .     @A@@@@XGPCTB   EQU   +(IN 0,H1SN
)@@G@@,1,$) .     @G@@@@                                   . H1 IS PUNCTUATIONSO
)@@G@@ BRANCHING TABLE  @F@@@@                                   . H2 IS OPERASP
)@@G@@ND BRANCHING TABLE@H@@@@FILL(1)  SAC   XGNXT0,XGARST          . SKIP QNSSQ
)@@G@@ SYMBOL, ARITHMATIC OPERAND   @B@@@@FILL(1)  SAC   000000,XGMLA         SR
)@@G@@  .   @B@@@@FILL(1)  SAC   XGCCST,XGSART          .   @B@@@@FILL(1)  SACSS
)@@G@@   XGSTRR,XGSART          .   @F@@@@FILL(1)  SAC   XGNXT0,XGETRY        ST
)@@G@@  . SKIP ACNIL, ENTRY OPERAND @B@@@@FILL(1)  SAC   000000,XGMLE         SU
)@@G@@  .   @B@@@@FILL(1)  SAC   XGCCST,XGSTNR          .   @B@@@@FILL(1)  SACSV
)@@G@@   XGCMMA,XGSTNR          .   @I@@@@FILL(1)  SAC   XGCCST,XGSTRU        SW
)@@G@@  . CHECK FOR CONDITION CODE, STRUCTURE OPER    @D@@@@FILL(1)  SAC   XGCSX
)@@G@@MMA,XGSTRU          .  ACCOMA FOUND @F@@@@FILL(1)  SAC   XGCCST,XGSTRU  SY
)@@G@@        . CHECK FOR CONDITION CODE  @G@@@@FILL(1)  SAC   XGASOP,XGSTRU  SZ
)@@G@@        . ASSIGNMENT OPERATOR OR COMMA    @G@@@@FILL(1)  SAC   XGNXT0,XGTA
)@@G@@ARST          . SKIP RIGHT PAREN, STRING OPERAND@B@@@@FILL(1)  SAC   000TB
)@@G@@000,XGMLS           .   @I@@@@FILL(1)  SAC   XGNXT0,XGSTST          . SKTC
)@@G@@IP LEFT PAREN, STRING IN STATIC CHECK     @B@@@@FILL(1)  SAC   000000,XGTD
)@@G@@STST          .   @I@@@@FILL(1)  SAC   XGCCST,XGLABL          . CHECK FOTE
)@@G@@R CONDITION CODE, LABEL OPERAND     @B@@@@FILL(1)  SAC   XGRBRK,XGMLA   TF
)@@G@@        .   @B@@@@FILL(1)  SAC   XGNXT0,XGSTLA          .   @B@@@@FILL(1TG
)@@G@@)  SAC   000000,XGSTLA          .   @H@@@@FILL(1)  SAC   XGCCST,XGFILE  TH
)@@G@@        . CHECK FOR CONDITION CODE, FILE OPERAND@B@@@@FILL(1)  SAC   XGATI
)@@G@@CMA,XGMLA           .   @B@@@@FILL(1)  SAC   XGSBNX,XGSTFI          .   TJ
)@@G@@@B@@@@FILL(1)  SAC   000000,XGSTFI          .   @G@@@@FILL(1)  SAC   XGNTK
)@@G@@XT0,XGVRBL           . SKIP ACPTQ, POINTER OPERAND    @B@@@@FILL(1)  SACTL
)@@G@@   000000,XGMLA           .   @B@@@@FILL(1)  SAC   XGSEXP,000000        TM
)@@G@@  .   @B@@@@FILL(1)  SAC   000000,000000          .   @B@@@@FILL(1)  SACTN
)@@G@@   XGSEX1,000000          .   @B@@@@FILL(1)  SAC   000000,000000        TO
)@@G@@  .   @B@@@@FILL(1)  SAC   XGNEXP,000000          .   @B@@@@FILL(1)  SACTP
)@@G@@   000000,000000          .   @D@@@@ . ** BUILT-IN FUNCTION ARGUMENT BRATQ
)@@G@@NCHING TABLE **   @A@@@@XGBFTB    EQU   +(IN 0,H1,1,$)   .  @ @@@@XBU   TR
)@@G@@   LABEL               .@H@@@@FILL(1)  SAC   XBSSS,0             . 0    TS
)@@G@@  THE LEFT HALF TELLS YOU WHICH     @H@@@@XBX      LABEL               .TT
)@@G@@              PATTERN OF EVENTS TO CHOSE FROM,  @G@@@@FILL(1)  SAC   XBMTU
)@@G@@,XGBNON          . 1 .    WHILE THE RIGHT HALF GIVES  @G@@@@XBNS     LABTV
)@@G@@EL               .              THE PATTERNS FOR THE VARIOUS@H@@@@FILL(1TW
)@@G@@)  SAC   XBSSS,XGBARY        . 2 .    ARRANGEMENTS OF ARGS FOR BIF'S.   TX
)@@G@@@ @@@@XBSSS    LABEL               .@B@@@@FILL(1)  SAC   XBL,XGBVAL     TY
)@@G@@     . 3 .  @ @@@@XBSS     LABEL               .@B@@@@FILL(1)  SAC   XBSTZ
)@@G@@,XGBVAL          . 4 .  @ @@@@XBS      LABEL               .@B@@@@FILL(1UA
)@@G@@)  SAC   XBR,XGBVAL          . 5 .  @ @@@@XBM      LABEL               .UB
)@@G@@@B@@@@FILL(1)  SAC   XBS,XGBMAT          . 6 .  @ @@@@XBL      LABEL    UC
)@@G@@           .@B@@@@FILL(1)  SAC   XBU,XGBMAX          . 7 .  @ @@@@XBLLI UD
)@@G@@   LABEL               .@B@@@@FILL(1)  SAC   XBSSS,XGBMAX        . 8 .  UE
)@@G@@@ @@@@XBLII    LABEL               .@B@@@@FILL(1)  SAC   XBLII,XGBMAX   UF
)@@G@@     . 9 .  @B@@@@FILL(1)  SAC   XBSS,XGBGNR         . 10 . @ @@@@XBLR  UG
)@@G@@   LABEL               .@B@@@@FILL(1)  SAC   XBLLI,XGBMAX        . 11 . UH
)@@G@@@ @@@@XBR      LABEL               .@B@@@@FILL(1)  SAC   XBSS,0         UI
)@@G@@     . 12 . @ @@@@XBLQ     LABEL               .@B@@@@FILL(1)  SAC   XBLUJ
)@@G@@R,XGBMAX         . 13 . @B@@@@FILL(1)  SAC   XBA,0               . 14 . UK
)@@G@@@ @@@@XBA      LABEL               .@B@@@@FILL(1)  SAC   XBM,XGITER     UL
)@@G@@     . 15 . @B@@@@FILL(1)  SAC   XBX,XGSAX           . 16 . @B@@@@FILL(1UM
)@@G@@)  SAC   XBX,XGEAX            . 17 .@ @@@@XBB      LABEL               .UN
)@@G@@@B@@@@FILL(1)  SAC   XBA,XGITER          . 18 . @B@@@@FILL(1)  SAC   XBLUO
)@@G@@,XGSASL          . 19 . @B@@@@FILL(1)  SAC   XBA,XGEAXL          . 20 . UP
)@@G@@@ @@@@XBP      LABEL               .@#@@@]XBADDR   LABEL .  @B@]@@FILL(1UQ
)@@G@@)  SAC   XBB,000000          . 21 . @B@@@]FILL(1)  SAC   XBB,XGBADR     UR
)@@G@@     . 21 . @B@@@@FILL(1)  SAC   XBP,000000          . 22 . @ @@@@XBVW  US
)@@G@@   LABEL               .@B@@@@FILL(1)  SAC   XBX,000000          . 23 . UT
)@@G@@@B@@@@FILL(1)  SAC   XBVW,000000         . 24 . @B@@@@FILL(1)  SAC   XBMUU
)@@G@@,000000          . 25 . @B@@@@FILL(1)  SAC   XBNS,000000         . 26 . UV
)@@G@@@B@@@@FILL(1)  SAC   XBM,000000          . 27 . @B@#@@FILL(1)  SAC   XBXUW
)@@G@@,000000          . 28 . @C@@@#FILL(1)  SAC   XBADDR,000000          . 28UX
)@@G@@ .    @B@@@@FILL(1)  SAC   XBM,000000          . 29 . @^@@@@. ** ARRAY TUY
)@@G@@ABLES **    @H@@@@XGATBL   EQU   +(IN 0,H1,1,$)   . H1 IS ARRAY SUBSCRIPUZ
)@@G@@T LIST PROCESSING TABLE @F@@@@XGOPST   EQU   +(IN 0,H2,1,$)   . H2 IS ENVA
)@@G@@D OF SUBEXPRESSION TABLE@E@@@@FILL(1)  SAC   XGGSSL,XGRRAY           . GVB
)@@G@@ET SUBSCRIPT LIST @F@@@@FILL(1)  SAC   XGGTMP,XGUSCL           . GET CROVC
)@@G@@SS SECTION DV     @E@@@@FILL(1)  SAC   XGLIST,XGRVAG           . SCAN SUVD
)@@G@@BSCRIPT LIST@F@@@@FILL(1)  SAC   XGGTCV,XGRTMP           . GET TALLY CELVE
)@@G@@L VECTOR    @D@@@@FILL(1)  SAC   XGSSUB,XGRVR4           . MAKE TCV SUB VF
)@@G@@@F@@@@FILL(1)  SAC   XGSCPY,XGRBVL           . BOUND + MULTPR TO CRSC   VG
)@@G@@@E@@@@FILL(1)  SAC   XGSEND,0                . SUBSCRIPT COMMA    @E@@@@VH
)@@G@@FILL(1)  SAC   XGBSSL,XGRFLL           . SUBSCRIPT OFFSET   @D@@@@FILL(1VI
)@@G@@)  SAC   XGTCV0,XGRCRS           . COUNT STARS  @D@@@@FILL(1)  SAC   XGTVJ
)@@G@@CV1,XGRSNG           . COUNT STARS  @F@@@@FILL(1)  SAC   XGTCV2,XGRSBF  VK
)@@G@@         . NUMBER OF SUBSCRIPTS     @G@@@@FILL(1)  SAC   XGSTFS,000000  VL
)@@G@@         . TALLY CELL TO SUBSCRIPT LIST   @D@@@@FILL(1)  SAC   XGSSBW,00VM
)@@G@@0000           . NON STAR MASK@G@@@@FILL(1)  SAC   XGSTUF,000000        VN
)@@G@@   . SUBSCRIPT TO SUBSCRIPT LIST    @C@@@@FILL(1)  SAC   XGCOMP,000000  VO
)@@G@@         . COMPUTE@D@@@@FILL(1)  SAC   XGANXT,000000          . NEXT SUBVP
)@@G@@SCRIPT@G@@@@FILL(1)  SAC   XGSTF0,000000           . TALLY CELL TO SUBSCVQ
)@@G@@RIPT LIST   @F@@@@FILL(1)  SAC   XGLARG,000000           . LOAD SUBSCRIPVR
)@@G@@T AND DV    @D@@@@FILL(1)  SAC   XGTLYC,000000           . CALL EXTLYC  VS
)@@G@@@D@@@@FILL(1)  SAC   XGSUBR,000000           . CALL EXSUBR  @D@@@@FILL(1VT
)@@G@@)  SAC   XGCRSC,000000           . CALL EXCRSC  @D@@@@FILL(1)  SAC   XGRVU
)@@G@@ESA,000000           . SET RESULT   @D@@@@FILL(1)  SAC   XGRESB,000000  VV
)@@G@@        . SET RESULT    @D@@@@FILL(1)  SAC   XGSTV0,000000           . FVW
)@@G@@INISH CRSC  @E@@@@FILL(1)  SAC   XGPOPS,000000          . CLEAR STACK ENVX
)@@G@@TRY   @B@@@@FILL(1)  SAC   000000,000000           .  @#@@@@         CENVY
)@@G@@D     @#@@@@XGSARY   EQU   0  @#@@@@XGSUSC   EQU   1  @#@@@@XGSVAG   EQUVZ
)@@G@@   2  @#@@@@XGSTP1   EQU   3  @#@@@@XGSVR4   EQU   4  @#@@@@XGSBVL   EQUWA
)@@G@@   5  @C@@@@FILL(1)  EQU   6                   . UNUSED *** @#@@@@XGSFLLWB
)@@G@@   EQU   7  @#@@@@XGSCSC   EQU   8  @#@@@@XGSSNG   EQU   9  @#@@@@XGSSBFWC
)@@G@@   EQU   10 @#@@@@XGSETS   EQU   0  @^@@@@XGSTRS   EQU   3   .    @^@@@@WD
)@@G@@XGCOMS   EQU   11  .    @^@@@@XGBRKT   EQU   16  .    @^@@@@ . ** TEMPORWE
)@@G@@ARY EQU'S **@H@@@@SDBFLM   EQU   12                      . $$$ PARTITIONWF
)@@G@@S SDBFCL INTO 2 SECTIONS@D@@@@DXGAXSLT EQU   SGDXSD-SGDXNX+1 . AGGR STACWG
)@@G@@K ENTRY SIZE@C@@@@DXGFSLT  EQU   9  . FUNCTION STACK ENTRY SIZE   @F@@@@WH
)@@G@@AQDVMSLN EQU   1  . OFFSET OF MAX LENGTH FIELD IN STRING DV AR    @E@@@@WI
)@@G@@ERCGSTER EQU   47  . ILLEGAL OP IN STATIC MODE - OTHER USED @C@@@@ERCGSWWJ
)@@G@@   EQU   48  . ILLEGAL OP IN STATIC MODE  @D@@@@KBXMXP   EQU   35  . MAXWK
)@@G@@IMUM FIXED BINARY PRECISION   @F@@@@KSLPRE   EQU   17                   WL
)@@G@@   . SUPPLIED LENGTH PRECISION@H@@@@ERGPRG   EQU   50            . SCALEWM
)@@G@@R ARGUMENT SUPPLIED TO AGGREGATE PARAMETER@ @@@@ERCGNDCL EQU   49       WN
)@@G@@     .@D@@@@ERCGBSBV  EQU  54 . BASED PARAMETER PASSED BY VALUE   @D@@@@WO
)@@G@@DCGTSLOT EQU   1             . TEMPORARY STACK WIDTH  @G@@@@SUBSCR   EQUWP
)@@G@@   DCONSU            . SUBSCRIPT CHECKING FLAG IN DCGONF    @D@@@@LFDGE WQ
)@@G@@   EQU   +(IN 0,0,1,0) . FUDGE FOR LOCAL DATA   @ @@@@AGSSL    EQU   SGDWR
)@@G@@SLB-FH1  .  @C@@@@AGMPLR   EQU   SGDMLR        . MULTIPLIER AW    @ @@@@WS
)@@G@@AGTCV    EQU   SGDCVB-FH1  .  @B@@@@AGADDR   EQU   SGDSLB-FH1    . ADDREWT
)@@G@@SS AW @ @@@@AGBRO    EQU   AGARTN        .@^@@@@AGDV     EQU   AGIM1  . WU
)@@G@@@ @@@@AGALST   EQU   SGDFAL        .@A@@@@DXGFCK   EQU   DCGSLT+DXGFSLT WV
)@@G@@ .    @I@@@@DXGFCHK2 EQU   DXGFSLT+DXGAXSLT        . NUMBER OF WORDS TO WW
)@@G@@MOVE FOR CHECK ENTRY    @F@@@@FLITRG   EQU   A10+1         . GEN LITERALWX
)@@G@@ STORED IN F REGISTER   @]@@@@/. **XGEN** @^@@@@         USING SGDSCT,X7WY
)@@G@@@#@@@@XGENFL*  LLOC     @D@@@@         LOAD  A6,XGSVAL*01000+XGSFLL,I   WZ
)@@G@@. LOADS 7   @A@@@@         GOTO  XGBEGN              .@#@@@@XGENS*   LLOXA
)@@G@@C .   @D@@@@         LOAD  A6,XGSVAL*01000+XGSSNG,I   . LOADS 9   @#@@@@XB
)@@G@@XGBEGN   LABEL    @E@@@@         GNTR  1 .     STORE REGS X1-X5 AND A7-AXC
)@@G@@10 AND F.   @#@@@@XGBGN1   LABEL .  @F@@@@         STORE A6,DXGSTT . PREXD
)@@G@@PARES DXGOPS IN Q3 & DXGOPN IN Q4   @ @@@@         MOVE  DXGMSK,XGSCLR .XE
)@@G@@@ @@@@         MOVE  DXGSBG,XGSBRG  @I@@@@         IF    SUBSCR,ON,DCGONXF
)@@G@@F THEN,XGNEXT . -> ENABLED SUBSCRIPT CHECKING SO S    @E@@@@         MOVXG
)@@G@@E  DXGSBG,XGNBRG       . MASK FOR SUBREGISTERS  @D@@@@         GOTO  XGNXH
)@@G@@EXT              . START GENERATION @#@@@@XGNXT1   LABEL .  @D@@@@      XI
)@@G@@   GETC                      . READ TOKEN(PTR)  @#@@@@XGNXT0   LABEL .  XJ
)@@G@@@E@@@@         GETC                      . READ NEXT CHARACTER    @#@@@@XK
)@@G@@XGNEXT   LABEL .  @F@@@@         IF    A8,GE,ACQNS,I THEN,XGSPSM . SPECIXL
)@@G@@AL PUNCTUATION    @E@@@@         IF    A8,LT,ACOPER,I THEN,XGOPND . FOUNXM
)@@G@@D OPERAND   @#@@@@. **OPERATOR**    @#@@@@XGOP     LABEL .  @F@@@@      XN
)@@G@@   LOADA X5,XGTBL2 .  BUILT-IN FUNCTIONS BRANCH USING XGTBL2@H@@@@      XO
)@@G@@   IF    A8,GE,ACABS,I   THEN,XGOP0 . SKIP TO USE XGTBL2 FOR BIFUNC     XP
)@@G@@@E@@@@         LINK    XGBSDO .          RESOLVE BASED ON OP TYPE @F@@@@XQ
)@@G@@         LOADA X5,XGTBL1 .  REGULAR OPERATORS BRANCH USING XGTBL1 @#@@@@XR
)@@G@@XGOP0    LABEL .  @ @@@@         LOADA X11,XGOP3 .    @#@@@@XGOP1    LOCXS
)@@G@@AL .  @F@@@@         LAND  A8,0377,I           . 8 LOW ORDER BITS IDENTIXT
)@@G@@FY OP @^@@@@         ADD   X5,A8    @^@@@@         USING WORD,X5 .@ @@@@XU
)@@G@@         LOAD  F,W1H1   .     @D@@@@         STORE F,DXGARG           . XV
)@@G@@STORE ADDRESS     @E@@@@         LOAD F,W1H2        . LOAD POINTER TO ACXW
)@@G@@TION TABLE  @F@@@@         STORE   F,DCGODE .        SAVE POINTER TO ACTXX
)@@G@@ION TABLE   @E@@@@XGOP2    LABEL .  IF REPEAT PERFORMED X5 IS FIRST RELOXY
)@@G@@ADED  @D@@@@         LOAD  X5,DCGODE          . MODIFY BY OFFSET  @F@@@@XZ
)@@G@@         LOAD  X6,W1H1,X5          . GET OFFSET TO TARGET ROUTING @D@@@@YA
)@@G@@         LINK  0,X6                . LINK TO TARGETING@E@@@@         LOAYB
)@@G@@D  X6,W1H2,X5          . GET OFFSET TO STAGING  @G@@@@         LINK  0,XYC
)@@G@@6          . OFFSET TO PROPER GENERATION ROUTINE IN X4@ @@@@         LOAYD
)@@G@@D  A7,X4         .@^@@@@         SRBD  A7,1     @H@@@@         ADD   X5,YE
)@@G@@A7         . DECODE RETURNED OFFSET INTO TABLE POSITION     @ @@@@      YF
)@@G@@   LOAD  X2,W1H2+1    . @B@@@@         IF    A8,LT,0,I THEN,XGOP6 .     YG
)@@G@@@ @@@@         LOAD  X2,W1H1+1    . @#@@@@XGOP6    LABEL .  @^@@@@      YH
)@@G@@   GENMR R,X2 .   @D@@@@         JMP   . RETURN ADDRESS SET INTO STACK AYI
)@@G@@BOVE  @#@@@@XGOP4    LABEL .  @A@@@@         SET   DCGRPT,OFF,DCGFLG    YJ
)@@G@@@[@@@@.     @G@@@@. KLUDGE   KLUDGE   KLUDGE   KLUDGE   KLUDGE   KLUDGE YK
)@@G@@  KLUDGE   KLUDGE @G@@@@. KLUDGE   KLUDGE   KLUDGE   KLUDGE   KLUDGE   KYL
)@@G@@LUDGE   KLUDGE   KLUDGE @G@@@@. KLUDGE   KLUDGE   KLUDGE   KLUDGE   KLUDYM
)@@G@@GE   KLUDGE   KLUDGE   KLUDGE @[@@@@.     @G@@@@         ADD     A0,1,I YN
)@@G@@.          RESET RETURN ADDRESS ONTO STACK***** @^@@@@         GOTO  XGOYO
)@@G@@P2    @#@@@@XGOP3    LABEL .  @[@@@@.     @C@@@@.        THIS IS A POSSIYP
)@@G@@BLE PLACE FOR A STUDY   @G@@@@.                MAYBE THE CONSTANT FLAG SYQ
)@@G@@HOULDN'T BE TURNED OFF HERE   @[@@@@.     @A@@@@         SET   SDVRCN,OFYR
)@@G@@F,SGDCLS  . @F@@@@XGCNRT*  LABEL .                   RETURN HERE FROM UNYS
)@@G@@ARY OPS     @G@@@@         IF    DCGRPT,ON,DCGFLG THEN,XGOP4 . BACK FOR YT
)@@G@@MORE ARGUMENTS    @#@@@@XGEXPR   LABEL .  @E@@@@         SET   SGDEXP,ONYU
)@@G@@,SGDID     . SET EXPRESSION BIT     @#@@@@XGLOOP   LABEL .  @G@@@@      YV
)@@G@@   LOAD  A8,DXGOPN          . GET THE OPERAND STATE FM DXGSTT     @G@@@@YW
)@@G@@         IF    A8,NE,XGSSNG,I THEN,XGNXT0 . IF SINGLE OPERAND RETURN    YX
)@@G@@@#@@@@XGEND    LABEL .  @#@@@@         GRTNS 1  @ @@@@. **PROCESS SPECIAYY
)@@G@@L SYMBOL**  @^@@@@         USING WORD,X2 .@#@@@@XGSPSM   LABEL .  @ @@@@YZ
)@@G@@         ANU,U A8,ACPRNT .    @F@@@@         AND,U A9,017000      . MASKZA
)@@G@@ BITS FOR BRANCHING INTO A10  @G@@@@         SRB   A10,8 .              ZB
)@@G@@  SELECT BITS WHICH IDENTIFY CODE   @G@@@@         LOAD  X5,A10  . X5 ISZC
)@@G@@ DOUBLE WORD INDEX INTO PUNCT BRANCH TABLE@ @@@@         LOAD  X2,XGPCTBZD
)@@G@@,X5  .@^@@@@         GOTO  0,X2     @#@@@@XGCCST   LABEL .  @G@@@@      ZE
)@@G@@   LOAD  X11,XGPCTB+1,X5 . MUST ALLOW FOR H1          JAP1/14     @G@@@@ZF
)@@G@@         GOTO  0,X11 . PART OF XGPCTB                       JAP1/14     ZG
)@@G@@@A@@@@. **PROCESS META CODE IDENTIFIER**  @B@@@@ .  X5 (AND A8) POINT TOZH
)@@G@@ SD OF OPERAND    @C@@@@ .  A10 HOLDS THE ADDRESS WORD TAKEN FROM THE SDZI
)@@G@@@ @@@@ .  A7 IS USED FOR SCRATCH    @E@@@@ .  X2 POINTS TO APPROPRIATE PZJ
)@@G@@ROCESSING MODULE IN XGTBLE    @#@@@@XGOPND   LABEL .  @F@@@@         LINZK
)@@G@@K  XGPUSH         . PUSH SGDSCT ONTO STACK FOR OPAND  @ @@@@         USIZL
)@@G@@NG SGDSCT,X7 .    @#@@@@XGOPN0   LABEL .  @F@@@@         STORE A8,SGDRSDZM
)@@G@@           . SAVE SD POINTER IN STACK     @E@@@@         LSDP  X5,A8    ZN
)@@G@@           . LOAD PNT TO SD INTO X5 @^@@@@         USING SDSECT,X5@#@@@@ZO
)@@G@@XGOPN1   LABEL .  @D@@@@         LOAD  A10,SDA1BS-FH1    . LOAD AW 1 FM ZP
)@@G@@SD    @#@@@@XGOPNA   LABEL .  @F@@@@         MOVE  SGDCLS,SDCLS1       .ZQ
)@@G@@ FILL STACK W/SD ATTRIBTURS   @F@@@@         MOVE  SGDEPT,SD2SP        .ZR
)@@G@@ MOVE SCALE AND PRECISION     @G@@@@         LOAD  A6,SDCLS0           .ZS
)@@G@@ USE SD TYPE AS INDEX INTO TABLE    @F@@@@         AND,U A6,15 .        ZT
)@@G@@       REMOVE STORAGE TYPE BITS     @F@@@@         STORE A7,SGDID       ZU
)@@G@@     . SET SGD STACK ENTRY TYPE     @D@@@@         IF      SD0BSD++SD0CNZV
)@@G@@T,OFF,SDCLS0 THEN,XGOPNB@F@@@@         SET     SGDRES,ON,SGDID .  SAY BSZW
)@@G@@D VAR NEEDS RESOLVING   @#@@@@XGOPNB   LABEL .  @F@@@@         IF    SDCZX
)@@G@@HCK,OFF,SDCLS3 THEN,XGIND . VARIABLE CHECKED?   @F@@@@         SET   SGDZY
)@@G@@CHR,ON,SGDID     . SET VARIABLE CHECKED FLAG    @#@@@@XGIND    LABEL .  ZZ
)@@G@@@E@@@@         SLB   A7,2          . INDEX ON FOUR WORD GROUPS    @E@@@@AA
)@@G@@         ADD   A7,DXGOPS           . ADD IN STATE FACTOR    @E@@@@      AB
)@@G@@   ADD   A7,DXGTPS           . TYPE TESTING STATE     @^@@@@         LOAAC
)@@G@@D  X2,A7 .  @^@@@@         USING WORD,X2  @F@@@@         LOAD  X3,XGTBLEAD
)@@G@@-SD0ART*4-XGSVAL,X2 . OFFSET TO MODULE    @F@@@@         GOTO  0,X3     AE
)@@G@@           . SPLIT TO APPROPRIATE MODULE  @I@@@@ . ---------------------AF
)@@G@@--------------------------------------------------------    @B@@@@. **OPAG
)@@G@@ERANDS IN MAXIMUM LENGTH MODE**     @I@@@@ . ---------------------------AH
)@@G@@--------------------------------------------------    @F@@@@ . MAXIMUM LAI
)@@G@@ENGTH MODE OCCURS ONLY DURING THE PROCESSING OF STRING@F@@@@ . FUNCTION AJ
)@@G@@ARGUMENTS FOR WHICH A DUMMY ARGUMENT MUST BE CREATED. @E@@@@ . IN MAX LEAK
)@@G@@NGTH MODE, THE MAX LENGTH FIELDS OF STRING DV'S @F@@@@ . (INCLUDING THE AL
)@@G@@TOP+1 WORD OF ARRAY DV'S AND THE DUMMY DV OF    @F@@@@ . STRING RETURNINAM
)@@G@@G FUNCTIONS) ARE EXAMINED TO CALCULATE THE MAX  @F@@@@ . LENGTH FIELD OFAN
)@@G@@ THE DV OF THE DUMMY ARGUMENT TO BE CREATED.    @F@@@@ . AFTER THIS INFOAO
)@@G@@RMATION IS CALCULATED THE ARGUMENT IS RESCANNED @F@@@@ . SO THAT CODE TOAP
)@@G@@ GENERATE THE TEMPORARY IS CREATED.  IF EVER    @F@@@@ . AUTOMATIC ARITHAQ
)@@G@@MATIC TO STRING CONVERSIONS ARE IMPLEMENTED     @B@@@@ . SEVERE CHANGED AR
)@@G@@WILL BE NEEDED HERE.    @I@@@@ . ---------------------------------------AS
)@@G@@--------------------------------------    @#@@@@XGMLA    LABEL .  @D@@@@AT
)@@G@@         LINK  XGIGNR              . SKIP ARG/SS LIST @G@@@@         IF AU
)@@G@@   A8,LT,ACGE,I THEN,XGIGNR . IGNORE G-CODE WHICH IS NOT    @G@@@@      AV
)@@G@@   IF    A8,GE,ACCAT,I THEN,XGIGNR . A COMPARISON OP (=<> ETC)    @#@@@@AW
)@@G@@XGMLA1   LABEL .  @G@@@@         MOVE  SGDAID,XGCONO,2  . RESULT OF COMPAX
)@@G@@ARE IS STRING LENGTH    @G@@@@         GMARK   SGDCDE .          . REMEMAY
)@@G@@BER LOC OF CODE FOR OPERAND   @^@@@@         GOTO  XGNXT0   @D@@@@XGMLE AZ
)@@G@@   LABEL . ENTRY NAME IN MAX LENGTH COMPUTATION @ @@@@         USING SDSBA
)@@G@@ECT,X5 .    @C@@@@         IF    SDARST,OFF,SDCLS1 THEN,XGMLA  .  @E@@@@BB
)@@G@@         IF    SDBLUS,ON,SDCLS1 THEN,XGMLS1 ELSE,XGBNTR .   @F@@@@XGMLS BC
)@@G@@   LABEL . STRING VAR OR CONST IN MAX LENGTH COMPUTATION    @F@@@@      BD
)@@G@@   IF    SDVRCN+SDCCNC,ON,SDCLS1 THEN,XGMLSC . CONSTANT     @#@@@@XGMLS1BE
)@@G@@   LABEL .  @F@@@@         ADD   A10,AQDVMSLN,I       . SET AW TO REF MABF
)@@G@@X LENGTH FLD@C@@@@         STORE A10,AGRL1            . SET AW    @E@@@@BG
)@@G@@XGMLS2   LABEL .  ENTRY POINT FROM STRING CONSTANTS BELOW   @H@@@@      BH
)@@G@@   MOVE  SGDAID,XGCON1     . SET STACK ID, CLS, SCALE AND PRECISION     BI
)@@G@@@^@@@@         LINK  XGIGNR   @F@@@@         GMARK   SGDCDE .          .BJ
)@@G@@ SAVE LOC OF THIS OPNS CODE   @^@@@@         GOTO  XGNEXT   @#@@@@XGMLSCBK
)@@G@@   LABEL .  @E@@@@         LOADXM X6,SDLCOF          . OFFSET TO CONSTANBL
)@@G@@T     @ @@@@         LOADXI X6,AGXR0+FH1 .@E@@@@         SUB   X6,1,I   BM
)@@G@@     . AW POINTS TO MAX LENGTH FIELD@B@@@@         STORE X6,AGRL1       BN
)@@G@@   . FORM AW@B@@@@         GOTO  XGMLS2              . MERGE@I@@@@ . ---BO
)@@G@@------------------------------------------------------------------------BP
)@@G@@--    @B@@@@. ** OPERANDS IN STATIC TYPE CHECK MODE** @I@@@@ . ---------BQ
)@@G@@--------------------------------------------------------------------    BR
)@@G@@@G@@@@ . STATIC STATE IS ENTERED BY THE DRIVER (CGBK) DURING THE CREATIOBS
)@@G@@N     @F@@@@ . OF DOPE VECTORS FOR STATIC VARIABLES.  NATURALLY IN THIS BT
)@@G@@STATE @E@@@@ . ONLY STATIC VARIABLES AND CONSTANTS ARE ACCEPTABLE SINCE BU
)@@G@@@B@@@@ . NO OTHER VARIABLES HAVE BEEN ALLOCATED.@B@@@@ .  X4 POINTS TO SBV
)@@G@@D OF POSSIBLE CORRECTION@F@@@@XGSTST   LABEL .                   . STRINBW
)@@G@@G IN STATIC CHECK MODE  @E@@@@         LOAD  X4,DLXVC            . SUPPLBX
)@@G@@Y  1 IF IN ERROR  @^@@@@         GOTO  XGSTCN   @G@@@@XGSART   LABEL .  BY
)@@G@@                 . ARITHMETIC IN STATIC CHECK MODE    @^@@@@         LOABZ
)@@G@@D  X4,DLXB1 @#@@@@XGSTCN   LABEL .  @^@@@@         USING SDSECT,X5@E@@@@CA
)@@G@@         IF    SDVRCN,OFF,SDCLS1 THEN,XGSTVR . NOT CONSTANT @F@@@@XGSTLWCB
)@@G@@   LABEL .                   . CONTINUE PROCESSING OPERAND  @^@@@@      CC
)@@G@@   USING WORD,X2 .@F@@@@         LOADXM X3,XGTBLE-2-SD0ART*4-XGSVAL,X2 .CD
)@@G@@ TO NORMAL MODULE @#@@@@         GOTO 0,X3@G@@@@XGSTVR   LABEL .        CE
)@@G@@           . CHECK FOR POSSIBLE ST VARIABLE     @H@@@@         IF    SD0CF
)@@G@@STA,ON,SDCLS0 THEN,XGSTWN . -> CAN BE USED AFTER WARNING    @#@@@@XGSTERCG
)@@G@@   LABEL .  @A@@@@         EXERR  ERCGSTER LEVEL,2    @E@@@@ . SD (X5), CH
)@@G@@'IS ILLEGAL IN DIMENSION, LENGTH, OR INITIAL;   @D@@@@ . ATTRIBUTE OF STCI
)@@G@@ATIC VARIABLE', SD (X2), ' IS USED' @^@@@@         LINK  XGIGNR   @D@@@@CJ
)@@G@@         LINK  BCKPGC    . BACK UP GETC ONE TOKEN     @^@@@@         LOACK
)@@G@@D  A8,X4 .  @C@@@@         GOTO  XGOPN0              . MERGE T    @#@@@@CL
)@@G@@XGSTWN   LABEL .  @B@@@@         IF    A8,EQ,X4  THEN,XGSTLW .    @G@@@@CM
)@@G@@XGSTWA   LABEL . ENTRY POINT WHEN X4 HAS NOT BEEN SET TO CORRECTION SD  CN
)@@G@@@A@@@@         EXERR ERCGSW LEVEL,1 .     @F@@@@ . 'NON-CONSTANT OPERANDCO
)@@G@@ (' SD (X5), 'IN DIMENSION, LENGTH, OR;   @B@@@@ . INITIAL ATTRIBUTE OF CP
)@@G@@STATIC VARIABLE.' @^@@@@         GOTO  XGSTLW . @E@@@@XGSTFI   LABEL .  CQ
)@@G@@                 . FILE IN STATIC MODE    @A@@@@         LOAD  X4,KFOSD CR
)@@G@@        .   @E@@@@         IF    SDPARM,ON,SDCLS2 THEN,XGSTER ELSE,XGSTLCS
)@@G@@W .   @#@@@@XGSTNR   LABEL .  @E@@@@         IF    SDBLUS,ON,SDCLS1 THENCT
)@@G@@,XGSTT0 . USER DEFINED  @ @@@@         LOAD  A9,SDBFCL .    @D@@@@      CU
)@@G@@   IF    A9,LT,SDBFLM THEN,XGSTWA ELSE,XGSTT1 . @#@@@@XGSTT0   LABEL .  CV
)@@G@@@C@@@@         IF    SDEXTN,OFF,SDCLS2 THEN,XGSTT1    @D@@@@         LOACW
)@@G@@D  X6,SDPLST          . ARG LIST POINTER  @F@@@@         GOTO  XGSTT2  .CX
)@@G@@ JUMP INTO LOOP TO TEST EACH PARAMETER    @#@@@@XGSTT3   LABEL .  @ @@@@CY
)@@G@@         LOAD  X6,ELWNXT,X6  .@#@@@@XGSTT2   LABEL .  @B@@@@         IF CZ
)@@G@@  X6,ZERO   THEN,XGSTWA .     @ @@@@         LOAD  X3,ELWSD,X6   .@ @@@@DA
)@@G@@         USING SDSECT,X3     .@D@@@@         IF   SD4ENT+SDSTRU,ON,SDCLSDB
)@@G@@4 THEN,XGSTT1     @C@@@@         IF    SDARRY,OFF,SDCLS2 THEN,XGSTT3 .  DC
)@@G@@@#@@@@XGSTT1   LABEL .  @^@@@@         USING SDSECT,X5@E@@@@         IF DD
)@@G@@   SDARST,OFF,SDCLS1 THEN,XGSART ELSE,XGSTST .  @D@@@@XGSTLA   LABEL    DE
)@@G@@                 . LABEL IS STATIC  @ @@@@         LOAD  X4,DUVLB .     DF
)@@G@@@C@@@@         IF    A8,EQ,X4 THEN,XGSTLW ELSE,XGSTER @I@@@@ . ---------DG
)@@G@@--------------------------------------------------------------------    DH
)@@G@@@ @@@@. **OPERANDS IN VALUE MODE**  @I@@@@ . ---------------------------DI
)@@G@@--------------------------------------------------    @F@@@@ . VALUE MODDJ
)@@G@@E IS THE NORMAL STATE OF AFFAIRS FOR MOST OPERANDS.   @E@@@@ . SUB BRANCDK
)@@G@@HING IS MADE HERE ACCORDING TO THE TYPE OPERAND @D@@@@ . AS DETERMINED FDL
)@@G@@ROM THE SD'S (SYMBOL TABLE ENTRIES).@E@@@@XGARST   LABEL .  CHECK IF OPEDM
)@@G@@RAND IS VARIABLE OR CONSTANT  @F@@@@         IF    SDVRCN,ON,SDCLS1 THENDN
)@@G@@,XGCNT . OPERAND IS A CONSTANT@D@@@@XGVRBL   LABEL .             ENTRY FDO
)@@G@@ROM LABEL VARIABLE@D@@@@         IF    SDARRY,ON,SDCLS2 THEN,XGARY1 . ARDP
)@@G@@RAY   @G@@@@         IF    SDMEMS,ON,SDCLS2 THEN,XGMEMS . SCAL MEM OF STDQ
)@@G@@RUCTURE     @#@@@@XGOPN2   LABEL .  @F@@@@         STORE A10,AGRL1      DR
)@@G@@     . SET AW IN SG FOR REAL PART   @#@@@@XGOPN3   LABEL .  @G@@@@      DS
)@@G@@   IF    SDRLCX,OFF,SDCLS1 THEN,XGLOOP . REAL VARIABLE THEN DONE  @F@@@@DT
)@@G@@         LOAD  A9,SDRTC            . GET SPACE ALLOTED TO VAR     @E@@@@DU
)@@G@@         SRB   A9,1                . USE 1/2 FOR IMAG PART  @D@@@@      DV
)@@G@@   ADD   A10,A9               . GET IMAG ADDRESS@F@@@@         STORE A10DW
)@@G@@,AGIM1            . SET AW IN SG FOR IMAG PART  @C@@@@         GOTO  XGLDX
)@@G@@OOP              . FINISHED   @#@@@@XGMEMS   LABEL .  @G@@@@         IF DY
)@@G@@   SDARST,ON,SDCLS1 THEN,XGOPN2 . STRING HAS DOPE VECTOR    @F@@@@      DZ
)@@G@@   STORE A10,AGARL1            . SET AUX WORD FOR REAL BASE @ @@@@      EA
)@@G@@   LOADA A10,AGARL1     @F@@@@         SLB   A10,18              . MOVE EB
)@@G@@TO AW BASE FIELD POS    @C@@@@         GOTO  XGOPN2               . MERGEC
)@@G@@E     @#@@@@. **CONSTANTS**   @#@@@@XGCNT    LABEL .  @G@@@@         MOVED
)@@G@@E  SGDRDS,SDLCOF       . MOVE SD DISPLACEMENT TO AW IN SGD  @#@@@@XGCNT1EE
)@@G@@   LABEL .  @E@@@@         MOVE  SGDRBS,AGXR0+FH1    . SET ABSOLUTE ADDREF
)@@G@@ESS   @F@@@@         SET   SGDSGN,OFF,SGDCLS  . MAKE SURE CONST IS POSITEG
)@@G@@IVE   @E@@@@         IF    SDRLCX,OFF,SDCLS1 THEN,XGLOOP . FINISHED     EH
)@@G@@@F@@@@         MOVE  AGIM1,AGRL1         . IMAG CONST SO SET IMAG PART  EI
)@@G@@@H@@@@         MOVE  AGRL1,AGDZRO-AGRX0+(IN 63,0,1,AGAW)     . SET REAL EJ
)@@G@@PART TO ZERO@I@@@@         GOTO  XGEXPR              . MAKE INTO AN EXPREK
)@@G@@ESSION-SO CONVERSIONS WORK    @#@@@@XGFILE   LABEL .  @F@@@@         IF EL
)@@G@@   SDPARM,ON,SDCLS2 THEN,XGOPN2 . PARAMETER FILE VAR  @E@@@@         MOVEM
)@@G@@E  SGDRDS,SGDRSD       . AW TO REFERENCE SD     @D@@@@         MOVE  SGDEN
)@@G@@RBS,AGXR0+FH1   . FILL BASE FIELD   @^@@@@         GOTO  XGLOOP   @#@@@@EO
)@@G@@XGETRY   LABEL .  @F@@@@ . THE GAMMA CODE FOR FUNCTIONS IS AN SD POINTEREP
)@@G@@ FOR THE FUNCTION @D@@@@ . FOLLOWED BY AN ARGUMENT LIST (WHICH MAY BE NUEQ
)@@G@@LL OR)@D@@@@ . ACRBRK , POSTFIX EXPRESSION, ACCOMA, ... , ACLBRK. @G@@@@ER
)@@G@@ . EACH ACRBRK OR ACCOMA HAS A POINTER IN ITS 2ND QUARTER (Q2 OR Q4)    ES
)@@G@@@F@@@@ . TO A REPRESENTATIVE SD FOR THE ARGUMENT SO THAT APPROPRIATE    ET
)@@G@@@C@@@@ . DUMMY DV'S OR TEMPS MAY BE SET UP AS NEEDED. @G@@@@ . AFTER PROEU
)@@G@@CESSING THESE ARGUMENTS (FIRST SCANNING THE REPRESENTIVE DV @F@@@@ . ANDEV
)@@G@@ THEN SCANNING THE WHOLE ARGUMENT) A CALL TO THE FUNCTION   @#@@@@ . IS EW
)@@G@@GENERATED.  @F@@@@         IF    SDBLUS,OFF,SDCLS1 THEN,XGBNTR  . BUILT EX
)@@G@@IN ENTRY    @A@@@@. *USER DEFINED FUNCTION REFERENCE  @I@@@@         IF EY
)@@G@@   SDARST,ON,SDCLS1 THEN,XGSTRY    . USER DEFINED FUNCT RTNS STRING     EZ
)@@G@@@D@@@@. **USER DEFINED FUNCTION RETURNING ARITHMETIC VALUE  @B@@@@      FA
)@@G@@   LOAD  A3,SGDID                .  @A@@@@         AND,U A3,SD0ART++0760FB
)@@G@@ .    @B@@@@         STORE A4,SGDID                .  @E@@@@         LOAFC
)@@G@@D  A7,2,I     . ASSUME TYPE REQUIRES 2 WORDS    @D@@@@         IF    SDFFD
)@@G@@XFL,ON,SDCLS1 THEN,XGNTTM . FLOAT   @E@@@@         IF    SDDCBN,OFF,SDCLFE
)@@G@@S1 THEN,XGNTTM . DEC-FIXED    @C@@@@         LOAD  A7,1,I              .FF
)@@G@@ FIXED BIN  @#@@@@XGNTTM   LABEL .  @F@@@@         LOAD  A8,A7     . A7 FG
)@@G@@CONTAINS THE NUMBER OF WORDS NEEDED @^@@@@         GTMP  R,A8     @^@@@@FH
)@@G@@         STORE A8,SGDRDS@A@@@@         MOVE  SGDRBS,AGXR10+FH1 .  @]@@@@FI
)@@G@@         GEN@A@@@@         GINST OPLA,AGRA1,AGRL1,U   @I@@@@         IF FJ
)@@G@@   SDRLCX,OFF,SDCLS1 THEN,XGNTY1 . SKIP GETTING MORE TEMPS FOR IMAG     FK
)@@G@@@G@@@@         LOAD  A8,A7     . RELOAD A8 WITH # OF WRDS NEEDED FOR TEMFL
)@@G@@P AW  @^@@@@         GTMP  R,A8     @D@@@@         GOTO  XGNTY1         FM
)@@G@@     . READY FOR MERGE  @C@@@@. ** USER DEFINED FUNCTION RETURNING STRINFN
)@@G@@G     @#@@@@XGSTRY   LABEL .  @E@@@@         MOVE  AGRL1,AGSTK . SET RESFO
)@@G@@ULT TO STRING STACK     @F@@@@         LOAD  A3,SGDID                .  FP
)@@G@@                 JAP1/14@F@@@@         AND,U A3,SD0STR++0760 .          FQ
)@@G@@                 JAP1/14@F@@@@         STORE A4,SGDID                .  FR
)@@G@@                 JAP1/14@G@@@@         STORE A10,AGARL1   .      A10 = AFS
)@@G@@DDRESS WORD FROM XGOPN1 .     @#@@@@         GENM     @G@@@@         GINFT
)@@G@@ST OPLA,AGRA1,AGARL1,U     . LOAD ADDRESS FOR DV TEMPLATE   @G@@@@      FU
)@@G@@   GSUB  EXSTMP        . ALLOCATE STRING TEMP ACCORDING TO DV     @#@@@@FV
)@@G@@         GFIN     @F@@@@. **ALLOCATE SPACE FOR ARG LIST AND GIVE CONTROLFW
)@@G@@ ARG LIST STARTS  @#@@@@XGNTY1   LABEL .  @E@@@@         LOAD  A8,SDNARGFX
)@@G@@    . NUMBER OF ARGUMENTS TO EXPECT @^@@@@         ADD   A8,1,I . @^@@@@FY
)@@G@@         GTMP  R,A8 .   @E@@@@         STORE A8,SGDTLV . SAVE OFFSET FORFZ
)@@G@@ LATER FREEING    @E@@@@         STORE A8,SGDFAT .   SAVE START OF ARG LGA
)@@G@@IST OFFSET  @E@@@@         STORE A8,SGDRAD  .  INITIALIZE ARGUMENT LIST GB
)@@G@@AW    @A@@@@         MOVE  SGDRAB,AGXR10+FH1  . @F@@@@         GENM .   GC
)@@G@@             ADDRESS OF RETURNED VALUE LOCATION @G@@@@         GINST OPSGD
)@@G@@A,AGRA1,AGARL1       . STORE AS FIRST ENTRY IN ARGLIST@F@@@@         GSUGE
)@@G@@B  EXGDVA        . TELL EX CONTROL ARG LIST STARTS NOW@#@@@@         GFIGF
)@@G@@N     @E@@@@         STORE X7,AGIM1    . SAVE COMPILE STACK POINTER     GG
)@@G@@@B@@@@         IF    SDNARG,ZERO THEN,XGNFC1 .  @E@@@@         GETC     GH
)@@G@@         . SKIP SD POINTER IN META-CODE   @G@@@@         XGPUSH 'SIZE',DGI
)@@G@@XGFSLT-DCGSLT  . NEED MORE SPACE FOR FUNCTION   @C@@@@         MOVE  SGDGJ
)@@G@@FSA,DXGSTT .  SAVE XGEN STATE @ @@@@         MOVE  SGDFSM,DXGMSK .@ @@@@GK
)@@G@@         LOAD  X4,SDPLST    . @^@@@@         STORE X5,SGDFSD@ @@@@      GL
)@@G@@   GOTO   XGBMP1     .  @H@@@@ . ---------------------------------------GM
)@@G@@------------------------------------@ @@@@/. **BUILT IN FUNCTIONS**     GN
)@@G@@@I@@@@ . ---------------------------------------------------------------GO
)@@G@@--------------    @F@@@@ . THE BUILT-IN FUNCTION CLASS IS USED TO DETERMGP
)@@G@@INE WHAT ACTION   @F@@@@ . IS NECESSARY FOR EACH ARGUMENT.  STACK ITEMS GQ
)@@G@@MAY BE GENERATED  @E@@@@ . FOR EACH ITEM ALONG WITH APPROPRIATE CONVERSIGR
)@@G@@ON MACHINE  @E@@@@ . CODE SO THAT THE ARGUMENT WILL BE OF THE PROPER TYPGS
)@@G@@E.    @F@@@@ . AFTER THE ARGUMENTS ARE SCANNED THE OP CODE IS PLACED IN GT
)@@G@@A8    @E@@@@ . AND THE OPERATOR DRIVER IS USED (AS WITH OTHER OPERATORS)GU
)@@G@@@F@@@@ . TO GENERATE (USING CGOA,CGBF, OR CGOS) WHATEVER CODE IS NEEDED GV
)@@G@@@E@@@@ . FOR TARGETING, STAGING, OR CHANGING THE STACK ITEMS.     @I@@@@GW
)@@G@@ . ---------------------------------------------------------------------GX
)@@G@@--------    @B@@@@ . ** REGISTER USAGE DURING COMPILATION **@F@@@@ .  X2GY
)@@G@@ IS USED TO COMPUTE CURRENT ACTION AND TO COUNT ARGUMENTS   @D@@@@ .  X3GZ
)@@G@@ POINTS TO CURRENT ACTION POINTER IN XGBFTB     @A@@@@ .  X4 TEMPORARY SHA
)@@G@@DSECT POINTER     @^@@@@ .  X5 POINTS TO SDSECT @ @@@@ .  X6 IS USED FORHB
)@@G@@ SCRATCH    @C@@@@ .  X7 POINTS TO SGDSCT (CODE GENERATOR STACK)  @F@@@@HC
)@@G@@ .  A10 IS USED TO SAVE THE METACODE POINTER (H2 OF X1 AND A1)    @D@@@@HD
)@@G@@ .  X10 POINTS TO 1ST FREE WORD FOR GENERATED CODE    @B@@@@ .          HE
)@@G@@ (H2 OFTEN STORED IN SGDCD1)  @B@@@@ .  X1 USED BY GETC (H2 STORED IN SGHF
)@@G@@DCD2) @B@@@@ .  A1 USED BY GETC (H2 STORED IN SGDCD3) @A@@@@ .  A7 HOLDSHG
)@@G@@ SELECTOR BITS WORD     @D@@@@ .  A9 USED FOR SCRATCH (NUM OF VARYING DIHH
)@@G@@MENSIONS)   @ @@@@ .  GENR AND GENMR CLOBBER X2 @B@@@@ .         BUILT-IHI
)@@G@@N ENTRY NAME ENCOUNTERED@#@@@@XGBNTR   LABEL .  @ @@@@         USING  SGHJ
)@@G@@DSCT,X7     @ @@@@         USING SDSECT,X5 .    @E@@@@         MOVE  SGDHK
)@@G@@ACT,SDBLAC       . OPERATOR CODE FOR BIF  @C@@@@         MOVE  SGDBST,DXHL
)@@G@@GSTT . SAVE XGEN STATE  @D@@@@         MOVE  SGDBMS,DXGMSK .  SAVE XGEN HM
)@@G@@MASK STATE  @D@@@@         MOVE  SGDBAR,DXGNRG       . SAVE ARG COUNTER HN
)@@G@@@F@@@@         LOAD  X2,SDBFCL           . BIF CLASS FOR ARG LIST CAN   HO
)@@G@@@F@@@@         ADD   X2,DXGOPS           . MODIFIED BY VAL/LEN STATE    HP
)@@G@@@F@@@@         LOAD  X3,XGBFTB-XGSVAL,X2 . X3=OFFSET TO ARG DESCRIPTION HQ
)@@G@@@B@@@@         GETC                . SKIP '('   @ @@@@         MOVE  DXGHR
)@@G@@NRG,0,I     @H@@@@         LOAD  X2,W1U,X7     . X2+OFFSET POINTS TO ARGHS
)@@G@@UMENT DESCRIPTION IN SGD@^@@@@         GOTO  XGBSRT   @D@@@@XGBVL0   LABHT
)@@G@@EL            . RESET META CODE POINTER   @E@@@@         LMCP  R,A10 . RHU
)@@G@@ELOAD META CODE POINTER WITH A GETC @C@@@@         LINK  BCKPGC . BACK UHV
)@@G@@P BEFORE THE GETC @E@@@@XGBVAL   LABEL .                   . COMPUTE VALHW
)@@G@@ OF BIF ARGU@D@@@@         SUB   X3,1,I        . BACK UP ACTION POINTER HX
)@@G@@@ @@@@         LOAD   X2,DXGNRG     @ @@@@         ADD   X2,W1U,X7     .HY
)@@G@@@E@@@@         STORE X3,SGDBPT,X2  . RESET ACTION TABLE POINTER   @F@@@@HZ
)@@G@@         MOVE  DXGOPS,XGSVAL,I         . SET VALUE/LENGTH MODE    @#@@@@IA
)@@G@@XGBVML   LABEL .  @F@@@@         MOVE  DXGOPN,XGSBVL,I     . RETURN TO VIB
)@@G@@ALUE AFTER EXP    @D@@@@XGBARG   LABEL .                   . SCAN BIF ARIC
)@@G@@GUMENT@F@@@@         GOTO  XGNXT0        . -> EVALUATE ARGUMENT EXPRESSIID
)@@G@@ON    @H@@@@XGRBVL   LABEL               . COME HERE AFTER EVALUATION OFIE
)@@G@@ BIF ARGUMENT     @E@@@@         LOAD   X2,DXGNRG          . COUNT NUMBEIF
)@@G@@R OF ARG    @ @@@@         ADD   X2,DCGSLT,I .  @^@@@@         STORE X2,IG
)@@G@@DXGNRG@ @@@@         ADD   X2,W1U,X7 .    @H@@@@         IF    A8,EQ,ACRIH
)@@G@@BRK,I THEN,XGBEND   . -> ALL ARGUMENTS ARE SCANNED    @E@@@@         LOAII
)@@G@@D  X3,SGDBPT,X2   . DESCRIPTION OF LAST ARGUMENT@E@@@@         ADD   X3,IJ
)@@G@@1,I         . POINT TO NEXT DECRIPTION    @D@@@@XGBSRT   LABEL          IK
)@@G@@  . ENTER HERE FOR FIRST ARG  @ @@@@         STORE X3,SGDBPT,X2  .@^@@@@IL
)@@G@@         USING WORD,X3  @ @@@@         LOAD  X6,W1H2  .     @^@@@@      IM
)@@G@@   GOTO  0,X6     @E@@@@XGBMAX   LABEL .                   . COMPUTE MAXIN
)@@G@@ LENGTH     @C@@@@         MOVE  DXGOPS,XGSMXL,I     . SET STATE  @E@@@@IO
)@@G@@         GOTO  XGBVML              . MERGE WITH VALE PROC   @F@@@@XGBNONIP
)@@G@@   LABEL .                   . BIF'S WITH NO ARGS COME HERE @F@@@@      IQ
)@@G@@   LINK  BCKPGC              . ADJUST BETA CODE POINTER     @D@@@@XGBENDIR
)@@G@@   LABEL .                   . END OF ARG LIST  @D@@@@         MOVE  DXGIS
)@@G@@NAR,DXGNRG       . SET COUNT OF ARG @D@@@@         USING SGDSCT,X2      IT
)@@G@@     . RESTORE STATE    @B@@@@         MOVE  DXGSTT,SGDBST         .    IU
)@@G@@@A@@@@         MOVE  DXGMSK,SGDBMS      . @E@@@@         MOVE  DXGNRG,SGIV
)@@G@@DBAR       . RESTORE OUNER ARG COUNT@F@@@@         LOADA X5,XGTBL2     .IW
)@@G@@ PREPARE TO PROCESS BIF OPERATOR    @E@@@@         LOAD  A8,SGDACT      IX
)@@G@@    . OPERATOR CODE FOR BIF   @F@@@@         GOTO  XGOP0         . -> MEIY
)@@G@@RGE WITH OPERATOR PROCESSING  @A@@@@         USING SGDSCT,X7        .   IZ
)@@G@@@F@@@@XGITER   LABEL .                   . ITERATE THRU ARRAY/STRU ARG  JA
)@@G@@@ @@@@         USING WORD,X3  .     @F@@@@         MOVE  SGDCD1,W1H2+1  JB
)@@G@@. SAVE OFFSETS TO EXPRESSION DRIVERS@A@@@@         MOVE  SGDCD2,W1H2+2  JC
)@@G@@.     @^@@@@         LOAD  X2,SGDACT@F@@@@         LOADA X6,XGTBL2,X2 . JD
)@@G@@LOAD ADDRESS OF BIF OPERATOR TABLE  @^@@@@         USING WORD,X6 .@ @@@@JE
)@@G@@         LOAD X5,W1H1,X6 .    @C@@@@         LINK  XGPUSH        . GET SJF
)@@G@@TACK SPACE  @C@@@@         LINK  0,X5    . GO TO INITALIZATION    @D@@@@JG
)@@G@@         LINK  XGPUSH        . GET MORE STACK SPACE   @E@@@@         LINJH
)@@G@@K  XGETSD              . FIND REPRSENTATIVE SD  @#@@@@         GOTO  $+2JI
)@@G@@@F@@@@         LINK  XGETB9              . SET UP STACK ENTRY FOR SCALARJJ
)@@G@@@F@@@@         LOAD  X2,SGDCD1+DXGAXSLT+2*DCGSLT . OFFSET TO SAX ROUTINEJK
)@@G@@@^@@@@         LINK  0,X2     @F@@@@         LOAD  X3,DXGXPR           .JL
)@@G@@ EXTABLISH REFERENCE POINT    @E@@@@         LOADA X3,DXGAXSLT,X3       JM
)@@G@@ . ENTRY FOR ARG VLAUE  @A@@@@         STORE X7,SGDBWK+2*DCGSLT,X3@ @@@@JN
)@@G@@         MOVE  DXGTMP,0,I     @E@@@@         MOVE  DXGTMP+FS1,IGMOVE,I .JO
)@@G@@ CONSTRUCT MACRO CALL   @ @@@@         SUB   X3,W1U,X7 .    @ @@@@      JP
)@@G@@   STORE X3,DXGTMP+FS2 .@ @@@@         GENR  DXGTMP        .@^@@@@      JQ
)@@G@@   ADD   X7,X3 .  @ @@@@         LOADA X5,XGTBL2     .@A@@@@         LOAJR
)@@G@@D  A8,SGDACT+2*DCGSLT . @^@@@@         LINK  XGOP1    @B@@@@         LOAJS
)@@G@@DXM X2,SGDCD2+DCGSLT,X7 .     @E@@@@         LOAD  X7,SGDBWK+DCGSLT     JT
)@@G@@ . RESET STACK LEVEL    @#@@@@         XGPOP    @F@@@@         LINK  0,XJU
)@@G@@2                . ENTER END OF LEAF EXPR RTN   @E@@@@         MOVE  DXGJV
)@@G@@STT,SGDBST+2*DCGSLT . RESTORE XGEN STATE  @D@@@@         MOVE  DXGMSK,SGJW
)@@G@@DBMS+2*DCGSLT . RESTORE MASK  @E@@@@         MOVE  DXGNRG,SGDBAR+2*DCGSLJX
)@@G@@T . RESTORE ARG COUNT   @]@@@@         GEN@#@@@@         GMOVE 3,2@E@@@@JY
)@@G@@         XGPOP 'SIZE',2*DCGSLT     . CLEAR STACK ENTRIES    @^@@@@      JZ
)@@G@@   GOTO  XGLOOP   @F@@@@XGSASL   LABEL .                   . SAX ROUTINEKA
)@@G@@ FOR STRING BIF   @E@@@@         LOAD  X3,DXGXPR           . PTR FOR AGGKB
)@@G@@ STACK ENTRY@E@@@@         STORE X11,SGDAXR,X3        . SAVE LEAF EXIT AKC
)@@G@@DDRESS@C@@@@         MOVE  DXGOPN,XGSSBF,I . SET RETURN     @E@@@@      KD
)@@G@@   LINK  XGSDL1              . START SCAN OF RP SD    @#@@@@XGSAX1   LABKE
)@@G@@EL .  @E@@@@         LMCP  SGDFMC+FH2,X3 . POINT TO START OF METACODE   KF
)@@G@@@F@@@@         GOTO  XGNEXT              . EVALUATE EXPR FN THIS LEAF   KG
)@@G@@@F@@@@XGRSBF   LABEL .                   . PROCESS STR BIF ARGUMENT     KH
)@@G@@@C@@@@         LOAD  X4,SGDATP+DCGSLT    . LEAF SD PTR@^@@@@         USIKI
)@@G@@NG SDSECT,X4@E@@@@         IF    SDARRY,OFF,SDCLS2 THEN,XGRVR4 . NOT ARRKJ
)@@G@@AY    @E@@@@         LOAD  A9,SDNDIM           . NUMBER OF DIMENSIONS   KK
)@@G@@@A@@@@         STORE A9,SGDANS+DCGSLT .   @E@@@@         IF    A9,EQ,0,IKL
)@@G@@ THEN,XGRVR4 . -> SCALER REFERENCE  @#@@@@         GENM     @A@@@@      KM
)@@G@@   GIFR  XGRSB7,AGRL1   .     @A@@@@         GLOAD AGRL1 'A'      .     KN
)@@G@@@#@@@@XGRSB7   GLBL  .  @D@@@@         GINST OPAA,AGRL1,AGRR12 'NO' . LOKO
)@@G@@AD A ONE    @#@@@@         GFIN     @E@@@@         LOAD  A7,SGDXSW+DCGSLKP
)@@G@@T     . SELECTOR BITS WORD    @ @@@@         USING SDSECT,X4 .    @C@@@@KQ
)@@G@@         MOVE  AGIM1,SDA1BS-FH1 . SET AW FOR DV @ @@@@         LOAD  X3,KR
)@@G@@SGDIDS .    @D@@@@         SUB     A9,1,I .          SET FOR LOOP INST  KS
)@@G@@@#@@@@XGRSB4   LABEL .  @D@@@@         ADD   X3,2,I      . OFFSET TO NEXKT
)@@G@@T MLPR PAIR @ @@@@         SLBD  A6,1          .@ @@@@         JB    A6,KU
)@@G@@XGRSB4     .@E@@@@         STORE X3,SGDIDS         . FORM AW FOR MPLR/BNKV
)@@G@@D     @#@@@@         GENM     @B@@@@         GINST OPLA,AGRA1,AGRR12 'NOKW
)@@G@@' .   @^@@@@         GFSR   AGRX5 . @D@@@@         GINST OPAA,AGRA1,AGIMKX
)@@G@@1,H2  'NO' . A1 = 1 + U @E@@@@         GINST OPANA,AGRA1,AGIM1,H1  'NO' KY
)@@G@@. A1 = 1 + U - L  @D@@@@         GIFR    XGRS4B,AGRL1 .    IS REAL IN REKZ
)@@G@@G?    @ @@@@         GLOAD AGRL1         .@C@@@@XGRS4B   GLBL .         LA
)@@G@@           NOW IN REG   @E@@@@         GINST OPMSI,AGRL1,AGRA1  'NO' . LLB
)@@G@@ <- L * EXTENT    @#@@@@         GFIN     @D@@@@         LOOP  A9,XGRSB4LC
)@@G@@  . REPEAT FOR EACH DIMENSION @#@@@@         GEN  .   @D@@@@         GINLD
)@@G@@ST OPANA,AGRL1,AGRR12 . ADD NEGATIVE ONE  @^@@@@         GOTO  XGRVR4   LE
)@@G@@@F@@@@XGEAXL   LOCAL .                   . EAX ROUTINE FOR STRING BIF   LF
)@@G@@@E@@@@         LINK  XGSDL2              . CONTINUE SCAN OF SD    @D@@@@LG
)@@G@@         GOTO  XGSAX1              . EVAL NEXT LEAF   @^@@@@         GOTLH
)@@G@@O  XGEAX8   @G@@@@XGSDL1   LLOC  .             ROUTINE TO LOOP THRU LEAVLI
)@@G@@ES OF STRUCTURE   @F@@@@         LOAD  X4,SGDXLS,X3        . ADDR (MAJORLJ
)@@G@@ STRUCTURE SD)    @G@@@@XGSDL4   LABEL .                   . LOOP THRU SLK
)@@G@@ONS TO NON-STRUCTURE    @ @@@@         USING SGDSCT,X3     .@ @@@@      LL
)@@G@@   USING SDSECT,X4   .  @E@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,XGSDLM
)@@G@@L3 . -> LEAF FOUND@F@@@@         LSDP  X4,SDSON,X4             . FOLLOW LN
)@@G@@POINTER TO SON    @E@@@@         GOTO  XGSDL4              . LOOP TIL LELO
)@@G@@AF IS FOUND @F@@@@XGSDL3   LABEL                         . SAVE LEAF SD,LP
)@@G@@COUNT IT    @C@@@@         STORE X4,SGDATP,X3  . SAVE LEAF SD     @ @@@@LQ
)@@G@@         LOAD  X6,SGDXDP,X3  .@E@@@@         ADD   X6,1,I        . COUNTLR
)@@G@@ 1 FOR EACH LEAF SCANNED@ @@@@         STORE X6,SGDXDP,X3  .@B@@@@      LS
)@@G@@   LJMP    . -> RETURN TO CALLER    @C@@@@XGSDL2   LLOC  . PICK UP SCANNLT
)@@G@@ING OF STRUCTURE  @F@@@@         LOAD  X3,DXGXPR     . BASE ADDRESS OF ALU
)@@G@@GGX STACK ENTRY   @D@@@@         LOAD  X4,SGDATP,X3  . SD OF LAST LEAF SLV
)@@G@@CANNED@E@@@@XGSDL5   LABEL                . SCAN BROTHERS OF LEAF SD    LW
)@@G@@@^@@@@         LOAD  A3,X4    @G@@@@         IF    A3,EQ,SGDXLS THEN,LJMLX
)@@G@@P1 . ALL LEAFS HAVE BEEN SCANNED    @E@@@@         LOAD  X6,SDDAD,X4   .LY
)@@G@@ SAVE POINTER TO FATHER SD    @E@@@@         LSDP  X4,SDBROT,X4     . FOLZ
)@@G@@LLOW POINTER TO FATHER  @F@@@@         IF    X4,NZERO THEN,XGSDL4 . -> TMA
)@@G@@EST BROTHER FOR SON, ETC@E@@@@         LOAD  X4,X6         . FOLLOW POINMB
)@@G@@TER TO FATHER     @E@@@@         GOTO  XGSDL5 .      -> TEST BROTHER OF MC
)@@G@@FATHER, ETC.@#@@@@XGBGNR   LABEL .  @^@@@@         LINK  XGIGNR   @B@@@@MD
)@@G@@         IF    A9,NE,ACRBRK,I THEN,XGIGNR @ @@@@         LOAD  X2,DXGNRGME
)@@G@@   .  @E@@@@         ADD   X2,W1U,X7 .            POINT TO STACK ENTRY  MF
)@@G@@@^@@@@         GOTO  XGBEND   @#@@@@XGBMAT   LABEL .  @#@@@@         XGPMG
)@@G@@OP    @C@@@@         LINK   BCKPGC . RESET BETA-CODE POINTER@^@@@@      MH
)@@G@@   GOTO  XGMLA    @#@@@@XGBARY   LABEL .  @C@@@@         LINK  XGPUSH   MI
)@@G@@     . GET STACK SPACE  @^@@@@         LINK  XGETSD   @ @@@@         LINMJ
)@@G@@K  XGEA8C        .@ @@@@         USING SDSECT,X4     .@^@@@@         USIMK
)@@G@@NG SGDSCT,X7@F@@@@         MOVE  AGRL1,SDA1BS-FH1 . SET DV OF REPRESENTAML
)@@G@@TIVE SD     @C@@@@         STORE A7,AGIM1      . SBW FOR REFERENCE@ @@@@MM
)@@G@@         LOAD  A7,SDNDIM,X4   @^@@@@         SUB   A7,X3    @ @@@@      MN
)@@G@@   STORE A7,SGDIBS+1    @D@@@@         LMCP  R,A10 .       RESET META-COMO
)@@G@@DE POINTER  @D@@@@         LINK  BCKPGC .      BACK UP GETC ROUTINE     MP
)@@G@@@^@@@@         LINK  XGIGNR   @E@@@@         IF    A9,NE,ACCOMA,I THEN,XMQ
)@@G@@GIGNR ELSE,XGRBVL .     @[@@@^/.    @A@@@^XGBADR   LABEL . EVAL ADDR ARGMR
)@@G@@UMENT @ @@@^         USING   SGDSCT,X7 .  @ @@@^         USING   SDSECT,MS
)@@G@@X5 .  @D@@@^         LINK    XGPUSH .          GET STACK SPACE    @^@@@^MT
)@@G@@         GETC .  READ SD@E@@@^         STORE   A8,SGDRSD .       PUT IT MU
)@@G@@IN STACK ENTRY    @^@@@^         LSDP    X5,A8 .@F@@@^         IF SD0BSDMV
)@@G@@++SD0CNT,ON,SDCLS0 THEN,XGBADR3 . -> IF BASED   @D@@@^         LOAD    AMW
)@@G@@10,SDA1BS-FH1 .  GET AW FOR SSTACK  @C@@@^         IF SDARRY,ON,SDCLS2  MX
)@@G@@THEN,XGBADR1 .    @C@@@^         IF SDARST,ON,SDCLS1 THEN,XGBADR1 .     MY
)@@G@@@C@@@^         IF SDMEMS,OFF,SDCLS2 THEN,XGBADR1 .    @C@@@^         . SMZ
)@@G@@CALER MEM OF STRUCT => SET UP 2 AWS @ @@@^         STORE   A10,AGARL1 . NA
)@@G@@@ @@@^         LOADA   A10,AGARL1 . @ @@@^         SLB     A10,18 .     NB
)@@G@@@F@@@^XGBADR1  LABEL .                   AUTOMATIC NOT SCALER IN SRUCT  NC
)@@G@@@ @@@^         STORE   A10,AGRL1 .  @ @@@^         GOTO    XGBADR4 .    ND
)@@G@@@D@@@^XGBADR3  LABEL .           BASED VAR -- RESOLVE IT    @A@@@^      NE
)@@G@@   SET     SGDRES,ON,SGDID .  @E@@@^         LINK    XGBSDU .          RNF
)@@G@@ESOLVE TOP OF STACK     @#@@@^XGBADR4  LABEL .  @#@@@^         GETC .   NG
)@@G@@@ @@@^         GOTO    XGRBVL .     @[@@@^.     @[@@@^.     @[@@@^.     NH
)@@G@@@[@@@^.     @[@@@^.     @[@@@^.     @ @@@@. ** OPERANDS IN VALUE MODE   NI
)@@G@@@#@@@@XGLABL   LABEL .  @ @@@@         USING SDSECT,X5     .@F@@@@      NJ
)@@G@@   IF    SDVRCN,OFF,SDCLS1 THEN,XGVRBL   . LABEL VARIABLE   @D@@@@      NK
)@@G@@   LSDP  X4,SDBKLK       .  COMP TO REF IN WORD @D@@@@         LOAD  X4,NL
)@@G@@SDBKAW,X4       . AW DISP TO AW OF  @^@@@@         STORE X4,SGDRBS@[@@@@NM
)@@G@@.     @B@@@@.        DISPLACEMENT OF ARINCT IS ZERO   @[@@@@.     @F@@@@NN
)@@G@@ .       MOVE  SGDRDS,ARINCT,I .  SET UP AW FOR INVOCATION COUNT  @[@@@@NO
)@@G@@.     @G@@@@         STORE X5,SGDIDS .         SET LABEL'S SD INTO SGD FNP
)@@G@@OR REFERENCE@A@@@@         MOVE  SGDIBS,AGXR0+FH1 .   @^@@@@         GOTNQ
)@@G@@O  XGLOOP   @C@@@@/ . ** STRUCTURE IN STRUCTURE EXPRESSION **     @A@@@@NR
)@@G@@ . ENTRY FROM OPERAND PROCESSING    @A@@@@ .  X4 CONTAINS AW OF STRUCTURNS
)@@G@@E     @^@@@@ .  X5 POINTS TO SD     @A@@@@ .  X3 IS AN AUXILLARY SD POINNT
)@@G@@TER   @B@@@@ .  X6 IS USED AS A TEMPORARY SD POINTER  @D@@@@ .  X2 COUNTNU
)@@G@@S THE NUMBER OF ELEMENT BEING PROCESSED   @#@@@@XGSTRU   LABEL .  @B@@@@NV
)@@G@@         LOAD  A7,DXGOPN               .  @G@@@@         IF    A7,NE,XGSNW
)@@G@@CSC,I THEN,XGSTR0  . NOT CROSS SECTION EXPANSION@^@@@@         LOAD  A7,NX
)@@G@@DXGMSK@^@@@@         LAND  A7,XGSBRG@ @@@@         STORE A7,DXGMSK     .NY
)@@G@@@F@@@@         GOTO  XGARY0        . -> MERGE WITH ARRAY PROCESSING     NZ
)@@G@@@#@@@@XGSTR0   LABEL .  @E@@@@         LOAD  X4,DXGXPR           . X3 CUOA
)@@G@@RRENT STACK ENTRY @G@@@@         LOAD  X2,SGDXDP,X4        . NUMBER OF EOB
)@@G@@LEM IN STRU PROCESSED   @D@@@@         SUB   X2,1,I .      LESS ON FOR COC
)@@G@@URRENT COUNT@#@@@@XGSTR1   LABEL .  @A@@@@         LOAD  X5,SDSON,X5    OD
)@@G@@    . @ @@@@         STORE X5,SGDRSD .    @#@@@@XGSTR3   LABEL .  @G@@@@OE
)@@G@@         IF    SDSTRU,ON,SDCLS4 THEN,XGSTR1      . CHECK FOR NEXT SON   OF
)@@G@@@F@@@@         LOOP  X2,XGSTR2     . -> THIS ELEMENT HAS BEEN PROCESSED OG
)@@G@@@E@@@@         LAND  A10,XGMSK4    . MASK OUT LOWER HALF WORD     @E@@@@OH
)@@G@@         ADD   A10,SDA1DP,X5       . ADD NEW DISPLACEMENT   @C@@@@      OI
)@@G@@   GOTO  XGOPNA     . PROCESS THIS ELEMENT@#@@@@XGSTR2   LABEL .  @E@@@@OJ
)@@G@@         LOAD  X6,SDDAD            . SAVE FATHER POINTER    @D@@@@      OK
)@@G@@   LOAD  X5,SDBROT     . FOLLOW BROTHER POINTER @^@@@@         STORE X5,OL
)@@G@@SGDRSD@F@@@@         IF    X5,NZERO THEN,XGSTR3 . -> TEST BROTHER FOR SOOM
)@@G@@N, ETC@ @@@@         LOAD  X5,X6         .@^@@@@         GOTO  XGSTR2   ON
)@@G@@@ @@@@. **PROCESS ARRAY IDENTIFIER**@ @@@@ .  A7 CONTAINS ARRAY BIT MASKOO
)@@G@@@D@@@@ .  A10 CONTAINS ARRAY AW FROM OPERAND PROCESSING     @C@@@@ .  X2OP
)@@G@@ COMPUTES ACTION IN ARRAY TABLE XGATBL    @F@@@@ .  X4 POINTS TO ADDRESSOQ
)@@G@@ OF CURRENT ACTION IN ARRAY TABLE XGATBL  @^@@@@ .  A9 USED FOR SCRATCH OR
)@@G@@@^@@@@ .  X3 USED FOR SCRATCH @^@@@@ .  X5 POINTS TO SD     @A@@@@ . X2 OS
)@@G@@IS DESTROYED BY GENR AND GENMR@A@@@@ . X2 AND X3 ARE DESTROYED BY GASSN OT
)@@G@@@#@@@@XGARY1   LABEL .  @^@@@@         LOAD  A7,DXGMSK@^@@@@         LANOU
)@@G@@D  A7,DXGSBG@^@@@@         STORE A7,DXGMSK@E@@@@XGARY0   LABEL .        OV
)@@G@@           . ENTRY FROM STRU IF CRSC@C@@@@         LINK  XGPUSH        .OW
)@@G@@ GET STACK SPACE  @C@@@@         MOVE  SGDSTT,DXGSTT   . SAVE XGEN STATEOX
)@@G@@@ @@@@         MOVE  SGDMSK,DXGMSK .@C@@@@         MOVE  DXGSTT,XGSVAL*0OY
)@@G@@1000+XGSARY,I .   @ @@@@         MOVE  DXGMSK,XGSCLR  @E@@@@         STOOZ
)@@G@@RE A10,AGRL1            . FOR NO SUBREGISTER    @D@@@@         STORE A10PA
)@@G@@,AGIM1            . AW FOR ARRAY DV @E@@@@         STORE A10,AGRL2      PB
)@@G@@      . FOR CROSSECTION USE   @F@@@@         MOVE  SGDNDM,SDNDIM        PC
)@@G@@   . DIMENSIONALITY OF ARRAY  @E@@@@         MOVE  SGDDVT,SDDVA         PD
)@@G@@. ADDRESS OF DV TEMPLATE@C@@@@         IF      SUBSCR,ON,DCGONF THEN,XGAPE
)@@G@@RYA   @G@@@@         LINK    XGBSA2 .           REOLVE ARRAY DV ADDRESS PF
)@@G@@PRIOR TO    @I@@@@                                   . SUBSCRIPTS IF SS PG
)@@G@@CHECKING IS DISABLED SINCE    @H@@@@                                   .PH
)@@G@@ THE DV ADDR IS NEEDED TO GEN INLINE CODE @#@@@@XGARYA   LABEL .  @ @@@@PI
)@@G@@         LOAD  X2,0,I        .@E@@@@XGDECD   LABEL .                   .PJ
)@@G@@ ARRAY EXPANSION DRIVER @D@@@@         LOAD  A7,SGDMSK           . SELECPK
)@@G@@T INPUT     @#@@@@XGDCDA   LABEL  . @ @@@@         SLB   A7,0,X2    .   PL
)@@G@@@G@@@@         LOADA X4,XGATBL-1,X2      . POINT TO FIRST -1 SLOT FOR INPM
)@@G@@PUT   @ @@@@XGDCDB   LABEL               .@D@@@@         LOADA X11,XGDCDPN
)@@G@@B    . SET RETURN ADDRESS     @ @@@@         ADD   X4,1,I        .@E@@@@PO
)@@G@@         IF  A7,EQ,0,I THEN,XGLOOP     . END OF MASK -> EXIT@ @@@@      PP
)@@G@@   SLBD  A6,1          .@H@@@@         IF    A6,EVEN THEN,LJMP1 . -> NO PQ
)@@G@@BIT AND NOT ZERO -> LOOP FOR BIT    @ @@@@         LOAD  X2,W1H1,X4    .PR
)@@G@@@ @@@@         GOTO  0,X2          .@E@@@@XGCOMA   LABEL .          COMMPS
)@@G@@A SCANNED IN ARRAY EXPRESSION @F@@@@XGRRAY   LABEL               ENTRY FPT
)@@G@@ROM COMMA OR RIGHT BRACKET    @E@@@@         LOAD  X2,SGDNSB+DCGSLT   . PU
)@@G@@COUNT # OF SUBSCRIPT    @D@@@@         ADD   X2,1,I                . BY PV
)@@G@@1 FOR EACH  @A@@@@         STORE X2,SGDNSB+DCGSLT     @G@@@@         LOAPW
)@@G@@D  A7,SGDMSK+DCGSLT    . BIT MASK FOR ARRAY BRANCH TABLE    @F@@@@      PX
)@@G@@   LOADA X2,XGCOMS           . SHIFT CONSTANT FOR COMMA     @E@@@@      PY
)@@G@@   GOTO  XGDCDA              . LET DRIVER DO REST     @F@@@@XGSTRR   LABPZ
)@@G@@EL               . * (STAR) IN SUBSCRIPT LIST SCANNED @F@@@@         LOAQA
)@@G@@D  X2,SGDNSS     . COUNT NUMBER OF STAR SUBSCRIPTS    @C@@@@         ADDQB
)@@G@@   X2,1,I        . BY ONE FOR EACH  @ @@@@         STORE X2,SGDNSS     .QC
)@@G@@@ @@@@         LOADA X2,XGSTRS     .@D@@@@         GOTO  XGDECD        .QD
)@@G@@ LET DRIVER DO THE REST @F@@@@XGABRK   LABEL .                   . ARRAYQE
)@@G@@ RIGHT BRACKET SCANNED  @ @@@@         LOAD  A3,SGDNDM .    @G@@@@      QF
)@@G@@   IF    A3,NE,SGDNSB THEN,XGSTRR . ARE ALL DIM ACCOUNTED FOR ?   @C@@@@QG
)@@G@@         LINK    XGBSA1 .          RESOLVE ARRAY@#@@@@XGBRK0   LABEL .  QH
)@@G@@@A@@@@         MOVE  DXGSTT,SGDSTT    .   @B@@@@         MOVE  DXGMSK,SGQI
)@@G@@DMSK           .  @G@@@@         LOADA X2,XGBRKT           . SHIFT CONSTQJ
)@@G@@ANT FOR RIGHT BRAKET    @E@@@@         GOTO  XGDECD              . LET DQK
)@@G@@IRVER DO REST     @F@@@@XGGSSL   LOCAL               . GET TEMP FOR SUBSQL
)@@G@@CRIPT (SS) LIST   @B@@@@         LOAD  A8,SGDNDM           . # DIM@D@@@@QM
)@@G@@         GTMP  R,A8               . GET SPACE FOR LIST@A@@@@         STOQN
)@@G@@RE A8,SGDSLD           .@D@@@@         MOVE  SGDSLB,AGXR10+FH1   . ESTABQO
)@@G@@LISH BASE   @E@@@@         MOVE  SGDAID,XGCON2        . ATTRIBUTES FOR SQP
)@@G@@S     @F@@@@         STORE A8,SGDSLR     . REMEMBER OFFSET FOR LATTER FRQQ
)@@G@@EEING @C@@@@         JMP                 . RETURN TO DRIVER @F@@@@XGGTMPQR
)@@G@@   LOCAL                       . GET TEMP SPACE FOR CRSC    @D@@@@      QS
)@@G@@   LOAD  A8,SGDNDM   . NUMBER OF DIMENSIONS     @F@@@@         SLB   A8,QT
)@@G@@1          . *2 = # WORDS FOR CRSC DOPE VECTOR  @D@@@@         GTMP  R,AQU
)@@G@@8        . GET TEMP FOR DOPE VECTOR @ @@@@         STORE A8,AGR10D     .QV
)@@G@@@E@@@@         MOVE  SGDCVD-FH2,AGXR10 . AW FOR CROSS SECTION DV  @#@@@@QW
)@@G@@         GENM  .  @G@@@@         GDBLE OPDL,AGRA3,SGDDVB-FH1   . COPY VIQX
)@@G@@RTUAL ORIGIN AND LENGTH @B@@@@         GDBLE OPDS,AGRA3,AGXR10       .  QY
)@@G@@@#@@@@         GFIN  .  @C@@@@         JMP                 . RETURN TO DQZ
)@@G@@RIVER @E@@@@XGLIST   LABEL                . TEST FOR PRESENCE OF LIST   RA
)@@G@@@F@@@@         GETC                . ->LOOK AHEAD TO NEXT META-CODE     RB
)@@G@@@E@@@@         AND,U A8,0777000 . MASK OUT FLAG AND POINTER BITS  @H@@@@RC
)@@G@@         IF    A9,EQ,ACLBRK,I THEN,XGNXT0   . -> '(' PRESENT SCAN FIRST RD
)@@G@@SS    @F@@@@         LINK  BCKPGC        . RETURN GETC TO CURRENT POSITIRE
)@@G@@ON    @G@@@@         GOTO  XGABRK        . -> SIMULATE ')', STARS WILL BRF
)@@G@@E ADDED     @ @@@@ . ** STAR IN SUBSCRIPTS**    @E@@@@XGGTCV   LLOC     RG
)@@G@@              . FIRST STAR IN SS SCANNED  @G@@@@         LOAD  X3,DXGXPRRH
)@@G@@     . ADDRESS OF AGGR EXPRESSION STACK ENTRY   @F@@@@         LOAD  X2,RI
)@@G@@SGDXTI,X3  . OFFSET TO TALLY CELL VECTOR (TCV)  @H@@@@         SUB   X2,RJ
)@@G@@1,I        . NUM OF SUBSCRIPTS COUNTED BEFORE ACTION TAKEN  @C@@@@      RK
)@@G@@   STORE X2,SGDCVD     . FORM AW FOR TCV  @E@@@@         MOVE  SGDCVB,AGRL
)@@G@@PX10+FH1 . PROTECTED TEMPORARY BASE @C@@@@         LJMP                .RM
)@@G@@ RETURN TO DRIVER @E@@@@XGSSUB   LOCAL           . FORM STACK ENTRY FOR RN
)@@G@@TCV ENTRY   @D@@@@         LINK  XGPUSH        . -> GET STACK SPACE     RO
)@@G@@@B@@@@         MOVE  SGDAID,XGCON3           .  @G@@@@         LOAD  A2,RP
)@@G@@SGDNSS+DCGSLT,X7 .   OFFSET FOR NUMBER OF SUBSCRIPT   @G@@@@         AU RQ
)@@G@@   A2,DCGSLT+SGDCVB-SGDAID-FH1,X7 . AW FOR TCV INDEX ****** @ @@@@      RR
)@@G@@   STORE A3,AGRL1      .@D@@@@         ADD   A2,W1U+1,A2 . OFFSET IN DV RS
)@@G@@OF BOUNDS   @A@@@@         ADD   A2,SGDADV+DCGSLT .   @ @@@@         STORT
)@@G@@RE A2,AGTMP1 .    @D@@@@         GENM .              GET TALLY CELL OFFSRU
)@@G@@ET    @ @@@@         GLOAD AGRL1,1 'NO' . @I@@@@         GINST OPAA,AGRLRV
)@@G@@1,AGTMP1,XH2 'NO' . ADD LOWER BOUND TO TALLY CELL OFFSET    @F@@@@      RW
)@@G@@   GFIN .              COMPUTED SUBSCRIPT IS NOW IN REGISTER@C@@@@      RX
)@@G@@   JMP                 . RETURN TO DRIVER @G@@@@XGSCPY   LOCAL          RY
)@@G@@     . COPY MULTIPLIER AND BOUNDS TO CRSCDV     @F@@@@         LOAD  X2,RZ
)@@G@@SGDCVD     . CROSS-SECTION DV AW DISP FIELD     @C@@@@         ADD   X2,SA
)@@G@@2,I        . COUNT BY 2'S     @E@@@@         STORE X2,SGDCVD     . AW FOSB
)@@G@@R MPLR/BNDS IN CRSC DV  @E@@@@         LOAD  X2,SGDNSB     . NUMBER OF SSC
)@@G@@UBSCRIPTS SEEN    @G@@@@         ADD   X2,W1U,X2     .  X2 = OFFSET IN ASD
)@@G@@RRAY DOPE VECTOR OF MB  @C@@@@         ADD   X2,SGDDVB-FH1 . AW FOR DV OSE
)@@G@@RIGIN @E@@@@         STORE X2,SGDMLR     . PUT IT WHERE GEN CAN USE IT  SF
)@@G@@@#@@@@         GENM  .  @D@@@@         GDBLE OPDL,AGRA3,SGDMLR . MOVE TOSG
)@@G@@ CRSC DV    @B@@@@         GDBLE OPDS,AGRA3,SGDCVB-FH1 .    @#@@@@      SH
)@@G@@   GFIN  .  @C@@@@         JMP                 . RETURN TO DRIVER @#@@@@SI
)@@G@@XGSEND   LABEL .  @E@@@@         LINK BCKPGC         . GO BACK AND REGETSJ
)@@G@@ META-CODE  @E@@@@         GETC                . REALLY LOOKING AT A '*'SK
)@@G@@?     @E@@@@         AND,U A8,0777000 . MASK OUT FLAG AND POINTER BITS  SL
)@@G@@@I@@@@         IF    A9,NE,ACSTAR,I THEN,XGCOMA  . -> NO, DON'T MOVE METSM
)@@G@@A-CODE POINTER    @C@@@@         GETC                . SKIP TO COMMA    SN
)@@G@@@D@@@@         GOTO  XGCOMA        . -> ENTER COMMA DRIVER  @E@@@@XGBSSLSO
)@@G@@   LABEL               . BUMP SUBSCRIPT LIST OFFSET   @D@@@@         LOASP
)@@G@@D  X2,SGDSLD     . POINT TO NEXT SUBSCRIPT@ @@@@         ADD   X2,1,I   SQ
)@@G@@     .@ @@@@         STORE X2,SGDSLD     .@F@@@@         GOTO  XGTCV2   SR
)@@G@@     . -> COUNT NUM OF SUB'S AND CONTINUE @D@@@@XGTCV0   LABEL          SS
)@@G@@     . FIRST * IN A SERIES    @F@@@@         LOAD  A3,SGDMSK     . ACTIVST
)@@G@@ATE TCV,STFS, DEACTIVATE TCV0 @B@@@@         XOR   A3,XGSTAR-(IN 0,0,1,0SU
)@@G@@) .   @ @@@@         STORE A4,SGDMSK     .@F@@@@         MOVE  SGDNST,0,SV
)@@G@@I    . CLEAR CONSECUTIVE STAR COUNTER     @E@@@@XGTCV1   LABEL          SW
)@@G@@     . STAR SUBSCRIPT NOT THE FIRST @F@@@@         LOAD  X2,SGDNST     .SX
)@@G@@ COUNT NUMBER OF CONSECUTIVE STARS  @D@@@@         ADD   X2,1,I        .SY
)@@G@@ COUNT BY 1 FOR EACH    @ @@@@         STORE X2,SGDNST     .@E@@@@XGTCV2SZ
)@@G@@   LABEL               . COUNT # SUB'S AND CONTINUE   @D@@@@         LOATA
)@@G@@D  X2,SGDNSB     . COUNT # SUBSCRIPTS     @G@@@@         ADD   X2,1,I   TB
)@@G@@     . COMMA WILL NOT BE ENTERED AFTER THIS STAR@ @@@@         STORE X2,TC
)@@G@@SGDNSB     .@E@@@@         LINK  BCKPGC        . RE-GETC THE CURRENT METTD
)@@G@@A-CODE@E@@@@         GETC                . REALLY LOOKING AT A STAR?    TE
)@@G@@@F@@@@         AND,U A8,0777000 .  MASK OUT ANY FLAG AND POINTER BITS   TF
)@@G@@@H@@@@         IF    A9,NE,ACSTAR,I THEN,XGABRK . -> MERGE WITH COMMA AFTG
)@@G@@TER STAR    @B@@@@         GETC                . SKIP COMMA @F@@@@      TH
)@@G@@   GOTO  XGANXA        . -> MERGE WITH COMMA AFTER STAR     @ @@@@ . ** TI
)@@G@@PROCESS SUBSCRIPT**     @F@@@@XGSSBW   LLOC                      . SET BTJ
)@@G@@IT INDICATING NON * SS  @C@@@@         LOAD  F,0,I              . SET FLTK
)@@G@@AG BIT@ @@@@         LOAD  A4,1,I        .@D@@@@         LOAD  X3,SGDNSBTL
)@@G@@+DCGSLT        . NUMBER SUB   @G@@@@         SRBD  A4,0,X3            . TM
)@@G@@MOVE FLAG TO PROPER POSITION IN WORD@D@@@@         OR    F,SGDSBW-SGDAIDTN
)@@G@@+DCGSLT,X7        .     @G@@@@         STORE A6,SGDSBW+DCGSLT . ACCUMULATO
)@@G@@TE BIT FLAGS INTO WORD ****** @E@@@@         LJMP  1                    TP
)@@G@@ . RETURN TO DRIVER     @#@@@@XGSTF0   LOCAL .  @E@@@@         SUB   X7,TQ
)@@G@@DCGSLT,I         . FAKE A STACK ENTRY     @E@@@@         LINK  XGSTF2   TR
)@@G@@           . MERGE W/ NON STARSS STF@ @@@@         XGPOP               .TS
)@@G@@@D@@@@         LOAD  F,DXGMSK          . RESET MASK BITS    @E@@@@      TT
)@@G@@   XOR   F,XGSTAR-(IN 0,0,1,0)   .              ******@ @@@@         STOTU
)@@G@@RE A6,DXGMSK     .@C@@@@         JMP                  . RETURN TO CALLERTV
)@@G@@@F@@@@XGSTFS   LABEL .                   . COPY TCV CHUNK TO SS LIST    TW
)@@G@@@#@@@@XGSTF2   LOCAL  . @H@@@@         LOADN A8,SGDNST+DCGSLT,X7 .      TX
)@@G@@    NUMBER OF CONSECUTIVE STARS     @B@@@@         AU,U  A8,1 .        -TY
)@@G@@ (NST - 1)  @C@@@@         AU    A9,SGDCVD-SGDAID-FH2+DCGSLT,X7 . @F@@@@TZ
)@@G@@         ADD   A10,SGDNSS+DCGSLT,X7 .         ADD NUMBER OF STARS @E@@@@UA
)@@G@@         STORE A10,SGDCVD+DCGSLT .  (A(TCV)-1)+NSS-(NST-1)  @F@@@@      UB
)@@G@@   LOAD  X2,SGDNSB+DCGSLT .   NUMBER OF SUBSCRIPTS SEEN     @C@@@@      UC
)@@G@@   ADD   X2,A9 .       NSB - (NST - 1)    @H@@@@         ADD   X2,W1U+1,UD
)@@G@@X2 . 2 * (NSB - (NST - 1)) + 1 = LOWER BOUND OFFSET   @D@@@@         ADDUE
)@@G@@   X2,SGDDV+DCGSLT,X7 . A(LOWER BOUND)    @E@@@@         STORE X2,AGTMP1UF
)@@G@@ .   SAVE IT FOR CODE GENERATOR     @I@@@@         SUB   A8,SGDSLD-FH2+DUG
)@@G@@CGSLT,X7 .      PREPARE ADDRESS OF NEXT SUBSCRIPT     @F@@@@         JNZUH
)@@G@@   A9,XGSTF1 .   ->NUMBER OF CONSECUTIVE STARS > 1    @F@@@@         GENUI
)@@G@@M  .             PREPARE ONE SUBSCRIPT LIST ENTRY     @F@@@@         GINUJ
)@@G@@ST OPLA,AGRA1,SGDCVD+DCGSLT-FH2 . TALLY CELL INDEX    @D@@@@         GINUK
)@@G@@ST OPAA,AGRA1,AGTMP1,XH2 . ADD LOWER BOUND@G@@@@         GINST OPSA,AGRAUL
)@@G@@1,SGDSLD+DCGSLT-FH2 . PUT IN SUBSCRIPT LIST     @#@@@@         GFIN .   UM
)@@G@@@E@@@@         GOTO  XGSTF3 .      -> BUMP SUBSCRIPT LIST POINTER @#@@@@UN
)@@G@@XGSTF1   LABEL .  @E@@@@         STOREN A9,AGX0OF .  STORE NST-1 FOR LOOUO
)@@G@@P COUNT     @H@@@@         GENM .                        PREPARE MULTIPLUP
)@@G@@E SUBSCRIPT LIST ENTRIES@G@@@@         GINST OPLA,AGRA1,SGDCVD+DCGSLT,U UQ
)@@G@@.   A1 = A(TALLY CELL INDEX)  @F@@@@         GINST OPLA,AGRA2,AGTMP1,U .UR
)@@G@@   A2 = A(NEXT LOWER BOUND)   @C@@@@         GINST OPLA,AGRA3,SGDSLD+DCGUS
)@@G@@SLT-FH2,U . @F@@@@         GINST OPLR,AGRA1,AGXR0,U .      R1 = LOOP COUUT
)@@G@@NT = NST - 1@A@@@@ .       FAKE RAW FOR R1 USING AGRA1@F@@@@         GSUUU
)@@G@@B  EXPMSL .      SUBROUTINE CALCULATES SUBSCRIPTS     @#@@@@         GFIUV
)@@G@@N .   @#@@@@XGSTF3   LABEL .  @H@@@@         STOREN A8,SGDSLD-FH2+DCGSLTUW
)@@G@@,X7 .     UPDATE SUBSCRIPT LIST POINTER   @B@@@@         LOAD  F,SGDMSK+UX
)@@G@@DCGSLT       .    @F@@@@         XOR   F,XGSTAR-LFDGE   . DEACTIVATE TCVUY
)@@G@@,STFS   ******    @B@@@@         STORE A6,SGDMSK+DCGSLT        .  @ @@@@UZ
)@@G@@         JMP                 .@E@@@@XGSTUF   LOCAL                   . MVA
)@@G@@OVE SUBSCRIPT TO SS LIST@F@@@@         GASGN SGDAID+DCGSLT R,X7  . ASSIGVB
)@@G@@N SUB TO SS LIST SLOT   @ @@@@         USING SGDSCT,X7     .@#@@@@      VC
)@@G@@   XGPOP    @E@@@@         LOAD   X2,SGDSLD          . BUMP  SSLD TO NEXVD
)@@G@@T SLOT@^@@@@         ADD   X2,1,I   @^@@@@         STORE X2,SGDSLD@#@@@@VE
)@@G@@         JMP   .  @D@@@@XGCOMP   LOCAL .             COMPUTE A <- A + I VF
)@@G@@* M   @ @@@@ .  A9 CONTAINS MULTIPLIER    @A@@@@ .  A10 COUNTS PLACES TOVG
)@@G@@ SHIFT LEFT @ @@@@ .  X2 IS USED FOR SCRATCH    @ @@@@ .  X3 IS USED FORVH
)@@G@@ SCRATCH    @F@@@@         LOAD   X2,SGDNSB+DCGSLT    . NUMBER OF SUBSCRVI
)@@G@@IPTS SEEN   @E@@@@         ADD   X2,SGDNSB+DCGSLT        . MULTIPLY IT BVJ
)@@G@@Y 2   @E@@@@         LOAD  A9,SGDADV+DCGSLT   . AW WORD FOR DV ORIGIN   VK
)@@G@@@E@@@@         ADD   A9,X2               . A9=AW FOR MPLR FOR SS  @E@@@@VL
)@@G@@         STORE A9,SGDMLR+DCGSLT   . WHERE IDEN CAN GET IT   @F@@@@      VM
)@@G@@   ADD   X2,SGDDVT+DCGSLT .   ADD ADDRESS OF DV TEMPLATE    @ @@@@      VN
)@@G@@   USING WORD,X2       .@C@@@@         LOAD  A9,W1+1,X2 .   GET THE MULTVO
)@@G@@IPLIER@ @@@@         LOADA X11,XGCPAD    .@E@@@@         STACK X11      VP
)@@G@@     . SET RETURN ADDRESS ON STACK  @B@@@@ . REGISTERS  A7,  AND  X11,  VQ
)@@G@@X1 AND A1,  @B@@@@ .  X7,  X9,  X10,  TVDSECT,  ADXGEN,     @C@@@@ .  ADVR
)@@G@@CGSTRT, AND  X4  MUST BE RETURNED AS IS.  @ @@@@ .  A9 CONTAINS THE MULTVS
)@@G@@IPLIER@G@@@@ .  X2 CONTAINS A POINTER TO AW ON RETURN OR [A2] VALUE OF SVT
)@@G@@UBSCRIPT    @B@@@@ .  X5,  X6,  X8 AND A10, AND  ARE FREE   @ @@@@      VU
)@@G@@   GOTO  VGCVB0        .@ @@@@XGCPAD   LABEL               .@E@@@@      VV
)@@G@@   LOAD  X5,SGDASD,X7 .          ARRAY SD POINTER     @G@@@@         IF VW
)@@G@@   A3,EQ,VGCON,I THEN,XGCMP5  . -> SUBSCRIPT IS A CONSTANT  @E@@@@      VX
)@@G@@   LOAD  X3,X2 .       POINTER TO VARIABLE SUBSCRIPT  @H@@@@         LOAVY
)@@G@@DA X2,XGCMP3     . ICODE ADDRESS FOR MULTIPLIER NOT A POWER OF 2  @F@@@@VZ
)@@G@@         IF  A9,EQ,0,I THEN,XGCMP1  . -> MULTIPLIER NOT KNOWN     @ @@@@WA
)@@G@@         USING SDSECT,X5 .    @H@@@@         IF    SDPARM,ON,SDCLS2 THENWB
)@@G@@,XGCMP1 . -> PARM CODE IS NOT OPTIMIZED   @F@@@@         LSC   A9,A9 .  WC
)@@G@@     TEST IF MULTIPLIER IS POWER OF 2     @F@@@@         IF    A9,NE,XGMWD
)@@G@@SK5 THEN,XGCMP1 . -> NOT A POWER OF 2     @F@@@@         LOADA X2,XGCMPOWE
)@@G@@ .   ICODE ADDRESS FOR MULTIPLIER OF ONE  @F@@@@         IF    A10,EQ,34WF
)@@G@@,I THEN,XGCMP1 . -> MULTIPLIER IS ONE     @C@@@@         SUB   A10,DRAW3WG
)@@G@@4 .  CREATE SHIFT AW    @ @@@@         STOREN A10,SGDMLR .  @F@@@@      WH
)@@G@@   LOADA X2,XGCMP4 .   ADDRESS OF IGEN CODE TO MAKE SHIFT   @F@@@@XGCMP1WI
)@@G@@   LABEL .             GEN CODE FOR MULTIPLIER * SUBSCRIPT  @E@@@@      WJ
)@@G@@   GENMR R,X2                . CALL INTERPRETIVE ODED @E@@@@         JMPWK
)@@G@@                         . RETURN TO DRIVER     @E@@@@         GMODE 'M'WL
)@@G@@           . SET FOR MACRO TYPE PACKING   @D@@@@XGCMP4   GLBL           WM
)@@G@@          . MLPR POWER OF TWO @E@@@@         GIFR  XGCMPR,AGPTX3       .WN
)@@G@@ SUBSCRIPT IN REGISTER  @F@@@@         GLOAD AGPTX3             . LOAD SWO
)@@G@@UBSCRIPT INTO REGISTER  @#@@@@XGCMPR   GLBL     @F@@@@         GSHIN OPLWP
)@@G@@SSC,AGPTX3,SGDMLR     . SUBSCRIPT * MULTIPLIER  @B@@@@         GGOTO XGCWQ
)@@G@@MPN        . -> MERGE   @E@@@@XGCMP3   GLBL               . MULTIPLIER NWR
)@@G@@OT POWER OF 2     @A@@@@         GIFR  XGCMP0,AGPTX3   .    @^@@@@      WS
)@@G@@   GLOAD AGPTX3,1 @#@@@@XGCMP0   GLBL     @F@@@@         GINST OPMSI,AGPWT
)@@G@@TX3,SGDMLR     . SUBSCRIPT * MULTIPLIER   @#@@@@XGCMPN   GLBL     @F@@@@WU
)@@G@@         GINST OPAA,AGPTX3,AGADDR . ADD NEW CONPONENT TO ADDRESS  @E@@@@WV
)@@G@@         GSET  AGADDR,AGPTX3       . KEEP TRACK OF ADDRESS  @#@@@@      WW
)@@G@@   GFIN     @D@@@@XGCMP5   LABEL .              CONSTANT SUBSCRIPT IN X3WX
)@@G@@@F@@@@         IF    A9,EQ,0,I THEN,XGCMP6 . -> MULTIPLIER NOT KNOWN    WY
)@@G@@@ @@@@         USING SDSECT,X5 .    @I@@@@         IF    SDPARM,ON,SDCLSWZ
)@@G@@2 THEN,XGCMP6 . -> MULTIPLIERS ARE UNKNOWN FOR PAR    @D@@@@         MPYXA
)@@G@@S  A9,A2         . SUBSCRIPT * MULTIPLIER @G@@@@         ADD   A9,SGDCOFXB
)@@G@@           .  ACCUMULATE CONSTANT COMPONENT     @ @@@@         STORE A9,XC
)@@G@@SGDCOF     .@D@@@@         JMP                       . RETURN TO DRIVER XD
)@@G@@@#@@@@XGCMP6   LABEL .  @C@@@@         IF  A2,EQ,0,I THEN,JMP . NO CODE XE
)@@G@@NEEDED@ @@@@         MOVE  DGFLGZ,1,I     @E@@@@         IF    A2,GE,0,IXF
)@@G@@ THEN,XGCMP7   . SUBSCRIPT POSITIVE @D@@@@         MOVE  DGFLGZ,0,I     XG
)@@G@@     . NEGATIVE OFFSET  @ @@@@         LOADM A2,A2         .@#@@@@XGCMP7XH
)@@G@@   LABEL .  @D@@@@         STORE A2,AGX0OF     . ADDRESS FIELD OF LOADA XI
)@@G@@@B@@@@         LOADA X2,XGCMPA     . IF SS = 1  @C@@@@         SUB   A2,XJ
)@@G@@1,I        . DOES SS = 1 ?    @D@@@@         IF  A2,EQ,0,I THEN,XGCMP8 .XK
)@@G@@ -> YES, GEN CODE @C@@@@         LOADA X2,XGCMPB     . DOES SS = 2 ?    XL
)@@G@@@ @@@@         SUB   A2,1,I        .@F@@@@         IF  A2,EQ,0,I THEN,XGXM
)@@G@@CMP8 . YES, GEN APPROPRIATE CODE    @B@@@@         LOADA X2,XGCMPC     .XN
)@@G@@ FOR SS > 2 @#@@@@XGCMP8   LABEL .  @^@@@@         GENMR R,X2     @A@@@@XO
)@@G@@         JMP   . -> RETURN TO DRIVER@E@@@@         GMODE 'M'           .XP
)@@G@@ SET FOR MACRO TYPE PACKING   @B@@@@XGCMPB   GLBL                . WHEN XQ
)@@G@@SS = 2@C@@@@         GLOAD SGDMLR,1      . LOAD MULTIPLIER  @C@@@@      XR
)@@G@@   GINST OPAA,SGDMLR,SGDMLR 'NO' . *2     @B@@@@XGCMPA   GLBL  .        XS
)@@G@@           . SS=1 @ @@@@         GSET  AGTMP1,SGDMLR .@B@@@@         GGOXT
)@@G@@TO XGCMP9        . -> MERGE   @#@@@@XGCMPC   GLBL  .  @^@@@@         GGEXU
)@@G@@TGR AGTMP1  @D@@@@         GINST OPLA,AGTMP1,AGXR0,U . LOAD CONSTANT    XV
)@@G@@@C@@@@         GINST OPMSI,AGTMP1,SGDMLR   . SUB*MLR  @#@@@@XGCMP9   GLBXW
)@@G@@L  .  @D@@@@         GBON  XGCMPD,0001         . POSITIVE OFFSET  @ @@@@XX
)@@G@@         GIFR  XGCMPH,AGADDR .@ @@@@         GLOAD AGADDR,1 .     @#@@@@XY
)@@G@@XGCMPH   GLBL .   @E@@@@         GINST OPANA,AGADDR,AGTMP1  . ADD IN NEWXZ
)@@G@@ COMPONENT  @#@@@@         GFIN  .  @H@@@@XGCMPO   GLBL .              EYA
)@@G@@NTRY FOR NON-CONSTANT SUBSCRIPT, MULTIPLIER = 1 @F@@@@         GSET  AGTYB
)@@G@@MP1,AGPTX3 . TREAT SUBSCRIPT AS THE PRODUCT     @#@@@@XGCMPD   GLBL  .  YC
)@@G@@@D@@@@         GIFR  XGCMPF,AGTMP1 . -> PROD IS IN REGISTER @E@@@@      YD
)@@G@@   GIFR  XGCMPG,AGADDR . -> ADDRESS IS IN REGISTER    @ @@@@         GLOYE
)@@G@@AD AGTMP1,1 .     @D@@@@XGCMPF   GLBL  . MERGE WHEN PRODUCT IS IN REGISTYF
)@@G@@ER    @E@@@@         GINST OPAA,AGTMP1,AGADDR  . ADD IN NEW ADDR COMP   YG
)@@G@@@F@@@@         GSET  AGADDR,AGTMP1       . DEEP TRACK OF RESULT ADDR.   YH
)@@G@@@#@@@@         GFIN     @A@@@@XGCMPG   GLBL  . ADDR IS IN REGISTER@A@@@@YI
)@@G@@         GINST OPAA,AGADDR,AGTMP1 . @#@@@@         GFIN .   @ @@@@XGANXTYJ
)@@G@@   LABEL               .@G@@@@         LINK  BCKPGC        . RE-GETC THEYK
)@@G@@ CURRENT META-CODE INTO A8    @#@@@@         GETC  .  @G@@@@XGANXA   LABYL
)@@G@@EL               . MERGE POINT - CURRENT META-CODE IN A8    @E@@@@      YM
)@@G@@   AND,U A8,0777000 .  MASK OUT POINTER IN LOW BYTE   @E@@@@         IF YN
)@@G@@   A9,EQ,ACCOMA,I THEN,XGNXT0 . IF MORE TO LIST @#@@@@XGNLST   LABEL .  YO
)@@G@@@E@@@@         GOTO  XGABRK        . -> END OF LIST WRAP IT UP    @ @@@@YP
)@@G@@. ** END OF SUBSCRIPT LIST**  @F@@@@XGLARG   LOCAL .                   .YQ
)@@G@@ LOAD ADDR OF SS LIST AND DV  @F@@@@         MOVE  SGDSLD,SGDSLR       .YR
)@@G@@ DISP TO START OF SS LIST     @C@@@@         LOAD  X3,SGDNDM     . # OF YS
)@@G@@DIMENSIONS  @F@@@@         SUB   X3,1,I        . -1 FORM BETTER FOR RUNTYT
)@@G@@IME ROUTINE @E@@@@         STORE X3,SGDNDM     . PUT IT WHERE IGEN CAN GYU
)@@G@@ET IT @#@@@@         GENM     @G@@@@         GINST OPLA,AGRA1,SGDSLB-FH1YV
)@@G@@,U  . LOAD ADDRESS OF SUBSCRIPT     @ @@@@         GFSR  AGRX5         .YW
)@@G@@@E@@@@         GINST OPLA,AGRA2,SGDDV,U   . LOAD ADDRESS OF DV    @#@@@@YX
)@@G@@         GFIN     @E@@@@         LOAD  A8,SGDSLR            . OFFSET TO YY
)@@G@@SS LIST TEMP@C@@@@         FTMP  R,A8          . FREE TEMPORARY   @E@@@@YZ
)@@G@@         JMP                         . RETURN TO DRIVER     @F@@@@XGTLYCZA
)@@G@@   LLOC                      . GEN CALL TO BOUNDS CHCKER    @E@@@@      ZB
)@@G@@   IF    SGDNSS,ZERO THEN,XGSUBR . NO STARS PRESENT   @E@@@@         LOAZC
)@@G@@D  X3,DXGXPR           . ADDRESS OF AGGX STACK  @E@@@@         LOAD  X2,ZD
)@@G@@0200000,I .  SET I-FIELD FOR USE WITH LMJ @C@@@@         ADD   X2,SGDXTCZE
)@@G@@,X3 .  OFFSET TO TCV    @C@@@@         STORE   X2,AGR10D .      SAY OFFSZF
)@@G@@ET,X10@B@@@@         LOAD    X2,AGXR10 .       GET AW @E@@@@         MOVZG
)@@G@@E  DGFLGZ,3,I    . SET FLAG FOR SBW AND FREE  A1@B@@@@         GOTO  XGSZH
)@@G@@UB1        . -> MERGE   @G@@@@XGSUBR   LABEL               . CALL SUBROUZI
)@@G@@TINE TO DO SUBSCRIPT CHECK    @D@@@@         LOADA X2,EXSUB      . SUBROZJ
)@@G@@UTINE'S ADDRESS   @C@@@@         MOVE  DGFLGZ,2,I    . NO SBW, FREE  A1 ZK
)@@G@@@E@@@@XGSUB3   LABEL . ENTRY FROM BELOW TO PUT ADDRESS INTO AGRX0 @E@@@@ZL
)@@G@@         STORE   X2,AGX0OF .       SET AS OFFSET PAST X0    @E@@@@      ZM
)@@G@@   LOAD    X2,AGXR0 .        GET ADRESS WORD FOR CALL @E@@@@XGSUB1   LOCZN
)@@G@@AL               . ENTRY FROM TLYC AND CRSC     @E@@@@         STORE X2,ZO
)@@G@@AGXTMP         . SET ARGUMENT TO GSUB     @^@@@@         LOAD  A9,SGDSBWZP
)@@G@@@C@@@@         MOVE  SGDASD-FH1+FH2,SGDNDM . #DIMS -1 @E@@@@         LOAZQ
)@@G@@D  A10,SGDASD-FH1      . SD OF ARRAY !! #DIMS -1@#@@@@         GENM     ZR
)@@G@@@F@@@@         GINST   074,AGRX11,AGXTMP,013  'NO' . GEN CALL TO SUB    ZS
)@@G@@@D@@@@         GBOFF XGSUB2,1          . -> SBW NOT REQUIRED@D@@@@      ZT
)@@G@@   GLITRG A9                  . MOVE SBW TO CODE@ @@@@XGSUB2   GLBL     ZU
)@@G@@           .@E@@@@         GLITRG A10                . SD OF ARRAY !! #DZV
)@@G@@IMS -1@D@@@@         GBOFF XGSBR3,2      . -> LEAVE RESULT IN  A1 @G@@@@ZW
)@@G@@         GGETGR SGDDBS-FH1+DCGSLT  'X' . GET FIXED PT REG FOR ADDRESS   ZX
)@@G@@@F@@@@         GINST OPLX,SGDDBS-FH1+DCGSLT,AGRA1 . LOAD ADDR IN NEW REGZY
)@@G@@@#@@@@XGSBR3   GLBL  .  @#@@@@         GFIN     @#@@@@         JMP   .  ZZ
)@@G@@@F@@@@XGCRSC   LLOC                . GENERATE CALL TO CROSS SECTIONER   AA
)@@G@@@F@@@@         LOADA X2,EXCRSC     . OFFSET TO CROSS-SECTIONER ADDRESS  AB
)@@G@@@B@@@@         MOVE  SGDDBS-FH1+DCGSLT,AGRA1 .  @D@@@@         MOVE  DGFAC
)@@G@@LGZ,1,I    . FLAG FOR SBW, KEEP  A1 @B@@@@         GOTO  XGSUB3        .AD
)@@G@@ -> MERGE   @D@@@@XGRESA   LLOC                   . FORM ADDRESS WORD   AE
)@@G@@@A@@@@         LOADA F,SGDDBS+DCGSLT-FH1 .@^@@@@         SLB   F,18 .   AF
)@@G@@@^@@@@         STORE F,AGRL2 .@H@@@@         IF    SDRLCX,OFF,SGDCLS+DCGAG
)@@G@@SLT THEN,LJMP1 . -> NOT COMPLEX, DONE     @C@@@@         MOVE  SGDIBS+DCAH
)@@G@@GSLT,SGDRBS+DCGSLT .    @C@@@@         LSDP  X3,SGDASD           . GET SAI
)@@G@@D     @E@@@@         LOAD  F,SDRTC,X3       . # BYTES IN BASIC ELEMENT  AJ
)@@G@@@E@@@@         SRB   F,1                . HALVE IT FOR OFFSET     @E@@@@AK
)@@G@@         STORE F,SGDIDS+DCGSLT    . FINISH OFF STACK ENTRY  @#@@@@      AL
)@@G@@   LJMP  1 .@F@@@@XGRESB   LOCAL   . FORM AW FORM ADDRESS AND CONSTANT CAM
)@@G@@OMP OF ADDR @E@@@@         IF    SGDCOF,ZERO THEN,XGRES3 . -> NO CODE NEAN
)@@G@@EDED  @F@@@@         MOVE  DGFLGZ,0,I    . SET CODE FOR NO HIGH ORDER BIAO
)@@G@@TS    @F@@@@         LOADM A9,SGDCOF .   PREPARE TO TEST SIZE OF CONSTANAP
)@@G@@T     @G@@@@         IF    A9,LT,XGMSK2+FH1 THEN,XGRES4 . -> LOW ORDER BAQ
)@@G@@ITS ONLY    @E@@@@         MOVE  DGFLGZ,1,I    . SET CODE FOR HIGH ORDERAR
)@@G@@ BITS @G@@@@         MOVE  AGX0OF,SGDCOF+FH1       . PREPARE HIGH ORDER AS
)@@G@@BITS AW     @D@@@@XGRES4   LABEL . MERGE TO PREPARE LOW ORDER BITS AW   AT
)@@G@@@B@@@@         MOVE  SGDCOF+FH1,AGXR0+FH1 .     @#@@@@         GENM .   AU
)@@G@@@ @@@@         GGETGR AGTMP1 'X'   .@G@@@@         GINST OPLX,AGTMP1,SGDAV
)@@G@@COF,XU 'NO' . GEN LOAD OF LOW ORDER BITS  @E@@@@         GBOFF XGRES5,1 AW
)@@G@@     . -> HIGH ORDER BITS NOT NEEDED@E@@@@         GINST OPLXI,AGTMP1,AGAX
)@@G@@XR0,U . LOAD HIGH ORDER BITS  @G@@@@XGRES5   GLBL  . MERGE WHEN CONSTANTAY
)@@G@@ COMPONENT LOADED IN X-REGISTER     @G@@@@         GINST OPAX,AGTMP1,AGAAZ
)@@G@@DDR      . ADD IN PART ALREADY COMPUTED   @B@@@@         GSET  SGDDBS+DCBA
)@@G@@GSLT-FH1,AGTMP1 . @#@@@@         GFIN  .  @A@@@@         JMP   . -> RETUBB
)@@G@@RN TO DRIVER@D@@@@XGRES3   LABEL . MAKE SURE AW IS IN RIGHT LOCATION    BC
)@@G@@@ @@@@         GEN                 .@D@@@@         GSET  SGDDBS+DCGSLT-FBD
)@@G@@H1,AGADDR . TRANSFER AW @#@@@@         JMP   .  @B@@@@XGSTV0   LOCAL .  BE
)@@G@@         STORE NEW V.O. @D@@@@         LOAD  X2,SGDNSS . NUMBER OF STAR BF
)@@G@@SS SEEN     @D@@@@         ADD   X2,2+W1U,X2 . OFFSET TO END OF TEMP DV BG
)@@G@@@F@@@@         LOAD  A2,DCGTLV     . POINTS TO TEMP STACK ENTRY FOR DV  BH
)@@G@@@ @@@@         USING TGDSCT,A2 .    @C@@@@         STORE X2,TGSIZE,A2  .BI
)@@G@@ SET NEW DV SIZE  @C@@@@         MOVE  AGR10D,TGFSET . FORM AW FOR TEMP BJ
)@@G@@@#@@@@         GENM  .  @F@@@@         GINST OPLA,AGRA1,AGRL2,U . LOAD ABK
)@@G@@DDRESS OF CONSTANT PART @E@@@@         GINST OPSA,AGRA1,AGXR10 . RESULT BL
)@@G@@IS LOCATION OF DV @ @@@@         GSET  AGRL2,AGXR10 . @#@@@@         GFIBM
)@@G@@N .   @#@@@@         JMP .    @G@@@@XGPOPS   LABEL .                   .BN
)@@G@@ REMOVE WORK STACK ENTRY FROM STACK @#@@@@         XGPOP    @E@@@@      BO
)@@G@@   GOTO  XGLOOP              . PROCESS NEXT ICODE     @^@@@@. **ASSINGMEBP
)@@G@@NT OPERATOR @F@@@@XGASOP   LABEL .                   ASSIGNMENT COMMA ISBQ
)@@G@@ @ LINE 2555@G@@@@         IF A8,EQ,ACASNC,I THEN,XGACMA . IS THIS AN ASBR
)@@G@@SIGNMENT COMMA?   @E@@@@         IF    DXGLHS,NZERO THEN,XGASN0  . -> MUBS
)@@G@@LTIPLE LHS  @F@@@@         LINK    XGBSDB .          SINGLE ASG- RESOLVEBT
)@@G@@ RHS + LHS  @B@@@@         GASGN SGDAID+DCGSLT SGDAID .     @D@@@@      BU
)@@G@@   XGPOP   'SIZE',2*DCGSLT . POP OFF BOTH SIDES @G@@@@         GOTO  XGLBV
)@@G@@OOP              .  PROCESS NEXT META CODE SYMBOL     @#@@@@XGASN0   LABBW
)@@G@@EL .  @E@@@@         LINK    XGBSDU .          MULT ASG-RESOLVE RHS     BX
)@@G@@@C@@@@         LOAD    X3,X7 .           POINT TO LHS @F@@@@         IF BY
)@@G@@SDARST,ON,SGDCLS THEN,XGASN2 . SEE IF STRING TEMP     @F@@@@         LOABZ
)@@G@@D  X2,X7               . SET TO USE ATTRIBUTES OF RHS @D@@@@         GASCA
)@@G@@GN 'TEMP' R,X3 'ATTR',R,X2 'COND','IFEXPR'@#@@@@         GEN .    @D@@@@CB
)@@G@@         GKEEP AGRL1               . PROTECT REAL PART@E@@@@         IF CC
)@@G@@SDRLCX,OFF,SGDCLS THEN,XGASN4 . IS IT COMPLEX?  @#@@@@         GEN .    CD
)@@G@@@E@@@@         GKEEP AGIM1               . PROTECT IMAGINARY PART @E@@@@CE
)@@G@@         GOTO    XGASN4 .          GO MERGE WITH STRINGS    @F@@@@XGASN2CF
)@@G@@   LABEL .                   COME HERE TO HANDLE STRINGS    @F@@@@      CG
)@@G@@   IF SGDEXP,OFF,SGDID THEN,XGASN4 . DON'T FUSS IF NOT TEMP @F@@@@      CH
)@@G@@   GENM .                    FIND REAL ADDRESS OF STRING    @G@@@@      CI
)@@G@@   GSUB    EXTMPS .          GET ADDRESS OF STRING TEMP INTO A1   @F@@@@CJ
)@@G@@         GINST   OPLX,AGRX1,AGRA1 . GET POINTER TO DV INTO X1     @#@@@@CK
)@@G@@         GFIN .   @D@@@@         LOADA   A7,AGRX1 .        SET UP ADDRESCL
)@@G@@S WORD@D@@@@         STORE   A7,SGDRBS .       SET X1 AS BASE     @D@@@@CM
)@@G@@         MOVE    SGDRDS,0,I .      SET TO BE 0,X1     @#@@@@XGASN4   LABCN
)@@G@@EL  . @ @@@@         USING WORD,X3       .@ @@@@         MOVE DXGTMP,W1,CO
)@@G@@3     @D@[@@         LOAD  X5,W1U,X7          . OLD STACK TOP     @E@@@[CP
)@@G@@         LOAD  X5,W1U+DCGSLT,X7          . OLD STACK TOP    @ @@@@      CQ
)@@G@@   LOAD  X2,DXGLHS     .@H@@@@         . CHECK FOR EXPLICIT PTR IN RIGHTCR
)@@G@@MOST LHS TO ADJUST STACK SIZE CTR   @^@@@@         . EG A,PC->D=  @H@@@@CS
)@@G@@         IF SGDPTR,OFF,SGDID+DCGSLT THEN,XGASN5 . LOOK AT SECOND STACK ECT
)@@G@@NTRY  @E@@@@         ADD     X2,DCGSLT,I .     ADD IN ANOTHER STACK SIZECU
)@@G@@@#@@@@XGASN5   LABEL .  @F@@@@         ADD   X2,W1U+DCGSLT,X7    . LEFT CV
)@@G@@MOST LEFT HAND SIDE     @E@@@@         LOADXM X7,DCGSLT+W1U,X2        . CW
)@@G@@NEW TOP OF STACK  @ @@@@XGASN1   LABEL               .@D@@@@         LINCX
)@@G@@K    XGBSDA .          RESOLVE CURRENT LHS@C@@@@         GASGN R,X2 R,X3CY
)@@G@@              . ASSIGN  @E@@@@         MOVE  W1,DXGTMP,3         . REFRECZ
)@@G@@SH STACK ENTRY    @E@@@@         LXI,XU X2,-DCGSLT   .     SET TO GO BACDA
)@@G@@K UP STACK  @E@@@@         TLEM,U  X5,0,*X2 .            . LOOP THRU ALLDB
)@@G@@ LHS  @ @@@@         GOTO  XGASN1        .@D@@@@         MOVE  DCGTLV,DXDC
)@@G@@GTLV       . FREE ALL TEMPS   @ @@@@         USING SGDSCT,X3     .@E@@@@DD
)@@G@@         IF    SDARST,OFF,SGDCLS THEN,XGLOOP . NON STRING   @F@@@@      DE
)@@G@@   IF    SGDEXP,OFF,SGDID THEN,XGLOOP . NON EXPRESSIONS     @E@@@@      DF
)@@G@@   LOADA X2,SGDRBS,X3        . AW FOR DOPE VECTOR     @ @@@@         USIDG
)@@G@@NG SGDSCT,X7     .@B@@@@         MOVE  AGR10D,5,I . AD(ARENDPTR)  @#@@@@DH
)@@G@@         GENM     @E@@@@         GINST OPLA,AGRA3,AGPTX2,H2 . GET POINTEDI
)@@G@@R TO STRING @D@@@@         GINST OPSA,AGRA3,AGXR10,H2 . RESET AREPTR    DJ
)@@G@@@#@@@@         GFIN  .  @^@@@@         GOTO XGLOOP    @A@@@@. ** SUBSCRIDK
)@@G@@PT OR ARGUMENT COMMA**  @#@@@@XGCMMA   LABEL .  @#@@@@XGRBRK   LABEL .  DL
)@@G@@@#@@@@XGNEXP   LABEL .  @H@@@@         LINK    XGBSDU . RESOLVE TOP OF SDM
)@@G@@TK- SUBSCRIPT OR EXPRESSSION END    @D@@@@         LOAD  X11,DXGOPN     DN
)@@G@@     . GET STATE OFFSET @D@@@@         LOAD  X11,XGOPST,X11  . OPERAND SDO
)@@G@@TATE TABLE  @F@@@@         GOTO  0,X11               . BRANCH TO SELECTEDP
)@@G@@D MODULE    @ @@@@. **PROCESS FUNCTION ARGUMENT @F@@@@XGUSCL   LABEL .  DQ
)@@G@@                 . RETURN HERE AFTER CALR AGR   @#@@@@XGUARG   LABEL .  DR
)@@G@@@A@@@@         LOAD  X5,SGDPSD+DCGSLT     @^@@@@         USING SDSECT,X5DS
)@@G@@@ @@@@. ** ALL SCALAR ARGUMENTS     @^@@@@         LOAD  A7,SGDID @G@@@@DT
)@@G@@         IF    A7,EQ,SD0FLE,I THEN,XGLAAG . FILE PASSED AS ARG, NOT TEMPDU
)@@G@@@E@@@@XGATST   LABEL .             TEST FOR ARG/PARAMETER MATCH   @A@@@@DV
)@@G@@         MOVE  DXGWRK,SDCLS0-FQ1 .  @E@@@@         MOVE  DXGWRK+FXH2,SD2DW
)@@G@@SP . COPY SCALE AND PRECISION @ @@@@         LOAD  A3,DXGWRK+FH1 .@C@@@@DX
)@@G@@         AND,U A3,0760 .     REMOVE LOWER BITS  @ @@@@         LOAD  F,SDY
)@@G@@GDCLS .     @^@@@@         AND,U F,017 .  @G@@@@         ADD   A6,A4 .  DZ
)@@G@@           IGNORE CONST.VRBL,ARITH/STRNG,FCTN   @ @@@@         STORE A6,EA
)@@G@@DXGWRK+FQ2 .@F@@@@         LOAD  A3,DXGWRK+FXH2 . A3<- SCALE AND PREC OFEB
)@@G@@ ARG SD     @G@@@@         IF    A6,NE,SGDCLS THEN,XGBOBS . -> ATTRIBUTEEC
)@@G@@S DO NOT MATCH    @F@@@@         IF    A3,EQ,SGDSCP THEN,XGUAS2 . -> ATTED
)@@G@@RIBUTES MATCH     @#@@@@XGBOBS   LABEL .  @G@@@@         IF SGDEXP,ON,SGEE
)@@G@@DID THEN,XGUAS1 . IF EXPRESSION, NO MESSAGE     @C@@@@.        LOAD  A3,EF
)@@G@@SGDID,X7 . GET TYPE FROM STACK@D@@@@         AND,U A3,SD0LAB .   EXAMINEEG
)@@G@@ ONLY LABEL BITS  @H@@@@         IF    A4,EQ,SD0LAB,I THEN,XGUAS1 . -> LEH
)@@G@@ABEL VARIABLE NEVER NEEDS     @D@@@@         SET   SGDEXP,ON,SGDID . FOREI
)@@G@@CE INTO TEMPORARY @F@@@@         IF SDVRCN,ON,SGDCLS THEN,XGUAS1 . NO MEEJ
)@@G@@SSAGE FOR CONSTANT@D@@@@         LOAD  X2,SGDFSD+DCGSLT        . A(ENTRYEK
)@@G@@ SD)  @A@@@@         EXERR ERCGNDCL LEVEL,0 .   @F@@@@         GOTO    XEL
)@@G@@GUAS1            . SKIP BASED PARAMTER TEST     @E@@@@ . 'CONVERSION REQEM
)@@G@@UIRED TO MATCH PARAMETER',SDX5,'OF',SDX2  @G@@@@XGUAS2   LABEL .        EN
)@@G@@           CHECK IF PARAMETER IS BSD OR CNT     @D@@@@         LOAD    XEO
)@@G@@3,SGDRSD         . GET SD OF ACTUAL @ @@@@         USING   SDSECT,X3    EP
)@@G@@@G@@@@         IF      SD0BSD++SD0CNT,OFF,SDCLS0 THEN,XGUAS1 . -> IF NOTEQ
)@@G@@ BASED@E@@@@         SET     SGDEXP,ON,SGDID   . PASS BSD VAR BY VALUE  ER
)@@G@@@A@@@@         LOAD    X2,SGDFSD+DCGSLT . @A@@@@         EXERR   ERCGBSBES
)@@G@@V  LEVEL,0 .@C@@@@ . BASED PARAMETER SDX3 OF SDX2 PASSED BY VALUE @#@@@@ET
)@@G@@XGUAS1   LABEL .  @F@@@@         GASGN  'TEMP' R,X7 'ATTR',DXGWRK 'COND'EU
)@@G@@,'IFEXPR'   .     @H@@@@         IF    SGDEXP,ON,SGDID THEN,XGLAA3 . -> EV
)@@G@@ARG IS EXPRESSION, NO CHECK   @^@@@@         LOAD  X3,SGDRSD@^@@@@      EW
)@@G@@   USING SDSECT,X3@C@@@@         IF    SDCHCK,OFF,SDCLS3 THEN,XGLAA3    EX
)@@G@@@^@@@@         XGPUSH 'SIZE',1@B@@@@         MOVE  SGDAID,SGDAID+1,DXGFCEY
)@@G@@K     @B@@@@         STORE X3,SGDAID+DXGFCK+FH1     . @H@@@@         IF EZ
)@@G@@   SDARRY,OFF,SDCLS2 THEN,XGCHR1     . -> NOT AN ARRAY REFERENCE  @A@@@@FA
)@@G@@         LOAD  A6,SGDFAL+DCGSLT     @A@@@@         STORE A6,SGDAID+DXGFCFB
)@@G@@K+FH2 @^@@@@         GOTO  XGLAA3 . @#@@@@XGCHR1   LABEL .  @B@@@@      FC
)@@G@@   MOVE  SGDAID+DXGFCK+FH2,0,I .    @#@@@@XGLAA3   LABEL .  @E@@@@      FD
)@@G@@   IF    SGDRDS,NZERO THEN,XGLAAG . -> MUST USE LOADA @D@@@@         IF FE
)@@G@@SDARST,OFF,SGDCLS THEN,XGLAA0 . NOT STRING@F@@@@         IF      SGDEXP,FF
)@@G@@OFF,SGDID THEN,XGLAA0 . -> NOT STRING TEMP@F@@@@         GEN .          FG
)@@G@@           LOAD ADDRESS OF STRING TEMP    @E@@@@         GSUB    EXTMPS FH
)@@G@@.          FIND ADDRESS OF TEMP     @C@@@@         GOTO    XGXPOP .     FI
)@@G@@     MERGE THERE  @#@@@@XGLAA0   LABEL .  @[@@@@.     @E@@@@.        SGDFJ
)@@G@@RDS = 0,ADDRESS MUST BE IN REG,POINT TO THAT REG@[@@@@.     @E@@@@      FK
)@@G@@   LOAD  X2,SGDRBS .         POINT TO THE ADDRESS WORD@[@@@@.     @H@@@@FL
)@@G@@.                                  SINCE SGDRDS WAS ZERO,THE VALUE MUST FM
)@@G@@BE    @G@@@@.                                  0,ADDRESS , AND WE NEED TFN
)@@G@@O STORE THE @E@@@@.                                  ADDR. INTO THE PARMFO
)@@G@@ LIST.@[@@@@.     @#@@@@XGLAAE   LABEL .  @#@@@@         GENM     @ @@@@FP
)@@G@@         GIFR  XGLAA1,AGPTX2 .@A@@@@         GINST OPLA,AGRA3,AGPTX2    FQ
)@@G@@@B@@@@         GINST OPSA,AGRA3,AGALST+DCGSLT   @^@@@@         GGOTO XGLFR
)@@G@@AA2   @#@@@@XGLAA1   GLBL     @E@@@@         GIFX    XGLA1A,AGPTX2 .   IFS
)@@G@@S ADDRESS IN X REG?     @E@@@@         GINST OPSA,AGPTX2,AGALST+DCGSLT .FT
)@@G@@ IN AN 'A' REG    @B@@@@         GGOTO   XGLAA2 .          MERGE  @#@@@@FU
)@@G@@XGLA1A   LABEL .  @F@@@@         GINST OPSX,AGPTX2,AGALST+DCGSLT . IT ISFV
)@@G@@ IN A 'X' REG     @#@@@@XGLAA2   GLBL     @^@@@@         GFREE  AGPTX2  FW
)@@G@@@^@@@@         GFIN  'POP'   .@^@@@@         GOTO  XGBMPL   @A@@@@ .  PRFX
)@@G@@OCESS USER FUNCTION ARGUMENT  @ @@@@XGRCRS   LABEL               .@ @@@@FY
)@@G@@XGLAAG   LABEL               .@#@@@@         GEN .    @G@@@@         GINFZ
)@@G@@ST OPLA,AGRA1,AGRL1,U         . LOAD ADDRESS OF ARGUMENT    @#@@@@XGXPOPGA
)@@G@@   LABEL .  @#@@@@         XGPOP    @ @@@@XGSTAG   LABEL               .GB
)@@G@@@#@@@@         GENM     @^@@@@         GFSR  AGRX5    @G@@@@         GINGC
)@@G@@ST OPSA,AGRA1,AGALST . STORE ADDRESS INTO ARGUMENT LIST     @#@@@@      GD
)@@G@@   GFIN     @F@@@@XGBMPL   LABEL               . FOLLOW POINTER TO NEXT GE
)@@G@@SD PARAMETER@^@@@@         LOAD  X4,SGDPLS@F@@@@         LSDP  X4,ELWNXTGF
)@@G@@,X4  . X4 = A(NEXT ENTRY CHAIN ENTRY)     @#@@@@XGBMP1   LABEL .  @G@@@@GG
)@@G@@         STORE X4,SGDPLS   . SAVE ADDRESS OF NEXT PARAMETER LIST WORD   GH
)@@G@@@#@@@@XGBMAL   LABEL .  @E@@@@         LOAD  X2,1,I        . INCREMENT AGI
)@@G@@RG LIST POINTER   @ @@@@         ADD   X2,SGDFLD   .  @ @@@@         STOGJ
)@@G@@RE X2,SGDFLD   .  @ @@@@         LINK  BCKPGC        .@#@@@@         GETGK
)@@G@@C  .  @A@@@@         AND   A8,XGMSK1-LFDGE  .   @E@@@@         IF    A9,GL
)@@G@@EQ,ACRBRK,I THEN,XGNFCN . END OF ARG LIST @H@@@@XGPRAR   LABEL .        GM
)@@G@@     GETC POINTS TO ACCOMA OR '(', X4 -> ENTRY CHAIN  @ @@@@         LSDGN
)@@G@@P  X5,ELWSD,X4   .@E@@@@         STORE X5,SGDPSD           . SAVE PARAM GO
)@@G@@SD ADDR     @E@@@@         LINK  XGETSD              . FIND REP SD FOR AGP
)@@G@@RG    @D@@@@         GOTO  XGPA10        . -> AGGREGATE ARGUMENT  @G@@@@GQ
)@@G@@         LMCP  R,A10 .       RESET GETC ROUTINE FOR SCALER ARGUMENT     GR
)@@G@@@D@@@@         LINK  BCKPGC .      BACK UP GETC ROUTINE     @ @@@@      GS
)@@G@@   LOAD  X5,SGDPSD .    @^@@@@         USING SDSECT,X5@G@@@@         IF GT
)@@G@@   SDSTRU,ON,SDCLS4 THEN,XGPA01 . SCALAR ARG TO AGGRE PARAM @H@@@@      GU
)@@G@@   IF    SDARRY,OFF,SDCLS2 THEN,XGPA20 . -> SCALER ARG AND PARAMETER    GV
)@@G@@@A@@@@ . SCALAR ARG TO AGGREGATE PARAM    @#@@@@XGPA01   LABEL .  @ @@@@GW
)@@G@@         LOAD  X2,SGDFSD     .@B@@@@         EXERR ERGPRG LEVEL,1       GX
)@@G@@   .  @D@@@@ . 'SCALER ARGUMENT SUPPLIED TO AGGREGATE PARAMETER'  @ @@@@GY
)@@G@@ . [SD6] SD5, 'OF',[SD1] SD2 .@E@@@@         LINK  XGETAG        . -> SEGZ
)@@G@@T UP AGG STACK ENTRY    @E@@@@         STORE X5,SGDXLS     . USE PARM SDHA
)@@G@@ AS REPRESENTATIVE@ @@@@         STORE X5,SGDXEL     .@D@@@@         LINHB
)@@G@@K  SXGBC .       CREATE META CODE POINTER @F@@@@         STORE A3,SGDFMCHC
)@@G@@,X7 .          SAVE IT IN COMPILE STACK   @H@@@@         MOVE  SGDXDV,SDHD
)@@G@@A2BS-FH1       . USE PARM'S DV TEMPLATE FOR BOUNDS    @F@@@@         LINHE
)@@G@@K  XGTMP0        . -> ALLOCATE AGGREGATE TEMPORARY    @F@@@@         LOAHF
)@@G@@DA X2,SGDFAL+DXGAXSLT .  X2 -> ARG LIST =A(TEMP DV)   @G@@@@         STOHG
)@@G@@RE X2,SGDXDV+FH1           . FORM AW TO REFERENCE TEMP DV   @B@@@@      HH
)@@G@@   MOVE  SGDXDV+FH2,0,I          .  @F@@@@         GOTO  XGPA13        .HI
)@@G@@ -> MERGE WITH AGGREGATE PARAMETERS @B@@@@ . **SCALAR ARGUMENT TO SCALARHJ
)@@G@@ PARAMETER  @#@@@@XGPA20   LABEL .  @G@@@@         MOVE  DXGSTT,XGSVAL*0HK
)@@G@@1000+XGSUSC,I . STATE FOR SCALER ARGUMENT @B@@@@         MOVE  DXGMSK,XGHL
)@@G@@SCLR           .  @C@@@@         GETC .              READ SD POINTER    HM
)@@G@@@C@@@@         GETC  .             READ WHAT FOLLOWS  @E@@@@         ANDHN
)@@G@@,U A8,0777000 .  MASK OUT ANY FLAGS OR POINTER  @F@@@@         IF    A9,HO
)@@G@@NE,ACNIL,I THEN,XGFRED . -> NO, POSSIBLE LHS    @E@@@@         SET   040HP
)@@G@@0,ON,SGDID           . MUST BE EXPRESSION @E@@@@XGFRED   LABEL          HQ
)@@G@@     . MERGE POINT WHEN FLAG NOT SET@^@@@@         SUB   X1,1,I . @ @@@@HR
)@@G@@         USING SDSECT,X5     .@E@@@@         LOAD  A3,SDCLS0 .        SEHS
)@@G@@E IF ENTRY PARAMETER    @^@@@@         AND,U A3,017 . @E@@@@         IF HT
)@@G@@   A4,NE,SD0ENT,I THEN,XGNXT0 . -> NOT ENTRY    @E@@@@         ADD   X1,HU
)@@G@@1,I        . SKIP SD ALSO      (2 GETC'S) @C@@@@         LINK  XGPUSH   HV
)@@G@@     . GET STACK SPACE  @ @@@@         USING SDSECT,X4     .@G@@@@      HW
)@@G@@   IF    SDBLUS,ON,SDCLS1 THEN,XGNTNM . -> USER DEFINED FUNCTION  @B@@@@HX
)@@G@@ . **PASSING BUILT IN FUNTION AS ARGUMENT @D@@@@         LOAD  X2,SDBLACHY
)@@G@@,X4  . OPERATOR CODE FOR BIF  @D@@@@         LX,H1 X2,XGTBL2,X2  .  X2 AHZ
)@@G@@DDRESS OF BIF     @ @@@@         LOAD  F,SDBLAC,X5    @I@@@@         IF IA
)@@G@@   F,EQ,ACATND-ACABS THEN,XGPA25 . -> BIF IS ATAND, OFFSET IS CORREC    IB
)@@G@@@F@@@@         LSDP  X3,SDPLST,X5  . LOOK AT PARAMETERS OF ENTRY PARM   IC
)@@G@@@D@@@@         LSDP  X6,W1H1,X3    . SD OF FIRST PARAMETER  @^@@@@      ID
)@@G@@   USING SDSECT,X6@I@@@@         IF    SDRLCX,ON,SDCLS1 THEN,XGPA24 . ->IE
)@@G@@ PARM REQUIRES 1 COMPLEX ARGUMEN    @E@@@@         LOAD  F,ELWNXT,X3   .IF
)@@G@@ OFFSET TO NEXT PARM ENTRY    @B@@@@         IF    F,GE,0,I THEN,XGPA25 IG
)@@G@@.     @G@@@@         LOADA X2,W1,X2      . SET OFFSET FOR ENTRY WITH 2 RIH
)@@G@@EAL ARG     @E@@@@XGPA24   LABEL .               SET ENTRY FOR 1 COMPLEXII
)@@G@@ ARG  @ @@@@         LOADA X2,W1,X2      .@F@@@@XGPA25   LABEL .        IJ
)@@G@@       NORMAL OFFSET IS 1 REAL ARGUMENT   @H@@@@         STORE X2,AGX0OFIK
)@@G@@               . PUT OFFSET WHERE IGEN CAN GET IT     @#@@@@         GENIL
)@@G@@M     @D@@@@         GGETT AGRL1,1       . GET TEMPORARY SPACE    @F@@@@IM
)@@G@@         GINST OPLA,AGRA3,AGXR0,U     . COPY ADDCON INTO ARG WORD @G@@@@IN
)@@G@@         GINST OPSA,AGRA3,AGRL1,H1    . STORE ROUTINE ADDRESS IN H1     IO
)@@G@@@F@@@@         GINST OPSNA,AGRA3,AGRL2,XH2 . SET NEGATIVE FLAG FOR BIF  IP
)@@G@@@#@@@@         GFIN     @E@@@@         GOTO  XGROBT .      FREE TEMPORARIQ
)@@G@@IES BELOW THIS ONE@C@@@@ . ** USER DEFINED FUNCTION PASSED AS ARGUMEMT  IR
)@@G@@@#@@@@XGNTNM   LABEL .  @ @@@@         USING SDSECT,X5     .@C@@@@      IS
)@@G@@   LOAD  X2,SDA1BS,X4  . SET AW FOR PARM  @G@@@@         IF    SDPARM,ONIT
)@@G@@,SDCLS2 THEN,XGLAAE . -> PARAMETER ENTRY NAME   @F@@@@         LOAD  X2,IU
)@@G@@SDBKLK     . FIND BLOCK WHERE FCN IS DECLARED   @ @@@@         USING X2,IV
)@@G@@SDSECT     .@F@@@@         MOVE  AGR10D,SDBSLD . SET UP AW FOR ENVIORNMEIW
)@@G@@NT POINTER  @C@@@@         STORE X4,AGX0OF .   FORM AW FOR SD     @#@@@@IX
)@@G@@         GENM     @G@@@@         GGETT AGRL1,1             . TEMP WORD FIY
)@@G@@OR SD AND ENVIORNMENT   @F@@@@         GINST OPLA,AGRA1,AGXR0,XU . LOAD IZ
)@@G@@ADDRESS OF ENTRY'S SD   @ @@@@         GFSR  AGRX5         .@F@@@@      JA
)@@G@@   GINST OPSA,AGRA1,AGRL1,H1 . STORE IN H1 OF TEMP WORD     @E@@@@      JB
)@@G@@   GINST OPLA,AGRA3,AGXR10   .     ENVIORNMENT POINTER@G@@@@         GINJC
)@@G@@ST OPSA,AGRA3,AGRL1,XH2 . STORE ENVIORNMENT AR BASE IN H2   @#@@@@      JD
)@@G@@   GFIN     @F@@@@XGROBT   LABEL .             FREE TEMPORARIES BELOW CUJE
)@@G@@RRENT ONE   @G@@@@         LOAD  A8,SGDFTP+DCGSLT,X7 .   ADDRESS OF UNDEJF
)@@G@@RNEATH TEMPORARY  @B@@@@         FTMP  R,A8 .        FREE THEM    @G@@@@JG
)@@G@@         MOVE  SGDFTP+DCGSLT,AGRL1 . SET LATEST TEMP FOR LATER FREEING  JH
)@@G@@@E@@@@         GOTO XGLAAG               . -> ADD TO AGRUMENT LIST@B@@@@JI
)@@G@@ . **AGGREGATE EXPRESSION AS ARGUMENT     @#@@@@XGPA10   LABEL .  @D@@@@JJ
)@@G@@         LOAD  X5,SGDPSD+DXGAXSLT      . PARAMETER SD @C@@@@         GETJK
)@@G@@C  . TEST CODE FOLLOWING SYMBOL     @E@@@@         AND,U A8,0777000 . MAJL
)@@G@@SK OUT FLAGS AND POINTERS     @D@@@@         LMCP  R,A10 .       RESET GJM
)@@G@@AMMA-CODE POINTER @C@@@@         LINK  BCKPGC . BACK UP GETC ROUTINE    JN
)@@G@@@H@@@@         IF    A9,LT,ACEPON,I THEN,XGPA09 . -> OPERATOR AT LEVEL 0JO
)@@G@@ AGG EXPR   @E@@@@ . BRANCH BELOW IF THE CURRENT META CODE POINTS TO ONEJP
)@@G@@ MORE @D@@@@ . THAN THE CURRENT POSITION OF THE GETC ROUTINE.     @ @@@@JQ
)@@G@@         LINK  BCKPGC        .@C@@@@         GETC  . LET'S LOOK AT THE PJR
)@@G@@OINTER AGAIN@C@@@@         AND,U A8,0777 . GET THE OFFSET ALONE   @F@@@@JS
)@@G@@         IF    A9,EQ,0,I THEN,XGPA04 . -> POSSIBLE CROSS SECTION  @C@@@@JT
)@@G@@XGPA09   LABEL . AGGREGATE EXPRESSION ARGUMENT  @F@@@@         LINK  XGTJU
)@@G@@EMP        . -> ALLOCATE AGGREGATE TEMPORARY    @E@@@@XGPA13   LABEL    JV
)@@G@@           . ENTRY FROM SCALER ARGUMENT   @E@@@@         LINK  XGSAX    JW
)@@G@@     . -> PROCESS ARRAY EXPRESSION  @E@@@@         LOAD  X4,DXGXPR     .JX
)@@G@@ BASE OF AGG EXPR STACK ENTRY @D@@@@         LOAD  X5,SGDPSD+DXGAXSLT,X4JY
)@@G@@   . PARAMETER SD @E@@@@         LOADA A10,SGDFAL+DXGAXSLT,X4  . FORM AWJZ
)@@G@@ FOR TEMP   @C@@@@         LINK  XGPUSH        . GET STACK SPACE  @G@@@@KA
)@@G@@         STORE X5,SGDRSD,X7 .          PUT SD POINTER INTO STACK ITEM   KB
)@@G@@@E@@@@         SLB   A10,18      .  A10 = AW FOR PARAMETER DV     @H@@@@KC
)@@G@@         MOVE  DXGOPN,XGSVAG,I         . COME BACK TO XGRVAG AFTER PROCEKD
)@@G@@SSING @G@@@@         SUB   X1,1,I        . BACK UP META CODE POINTER ONEKE
)@@G@@ POSITION   @#@@@@         GETC  .  @D@@@@         GOTO  XGOPNA        .KF
)@@G@@ -> FAKE SCAN OF TEMP SD@G@@@@XGRVAG   LABEL               . RETURN HEREKG
)@@G@@ AFTER SETTING UP TEMP LS     @E@@@@         SET   SGDCHR,OFF,SGDID     KH
)@@G@@   . TURN OFF CHECK FLAG@E@@@@         MOVE  DXGOPN,XGSVR4           . RKI
)@@G@@ESET TO AGGX STATE@G@@@@         LOAD  F,SGDCLS+DCGSLT         . TAKE 4 KJ
)@@G@@LOW BITS OF CLASS +     @E@@@@         SRBD  F,4           . MOVE BITS TKK
)@@G@@O TOP STACK ENTRY @D@@@@         LOAD  F,SGDCLS      . THIS SIMULATES MVKL
)@@G@@N     @ @@@@         SLBD  F,4           .@ @@@@         STORE F,SGDCLS KM
)@@G@@     .@F@@@@         IF    F,NE,SGDCLS+DCGSLT THEN,XGPCKL . CHECK FOR LAKN
)@@G@@BEL   @G@@@@         LOAD  F,SGDEPT      . LOAD TO CHECK BOTH SCALE AND KO
)@@G@@PRECISION   @H@@@@         IF    F,EQ,SGDEPT+DCGSLT THEN,XGPA16 . -> THEKP
)@@G@@Y'RE THE SAME, NO MSG   @F@@@@XGPCKL   LABEL               . MERGE POINTKQ
)@@G@@ TO CHECK FOR LABEL     @C@@@@         LOAD    F,SGDID .         GET TYPKR
)@@G@@E     @D@@@@         AND,U   F,SD0LAB .        SEE IF TYPE LABEL  @F@@@@KS
)@@G@@         IF A6,EQ,SD0LAB,I THEN,XGPA16 . A LABEL, SO NO CONVERSION@G@@@@KT
)@@G@@         IF SGDEXP,ON THEN,XGPA16 . AN EXPRESSION REQUIRES NO MESSAGE   KU
)@@G@@@E@@@@         LOAD  X4,DXGXPR     . BASE OF AGGREGATE EXPRESSION @E@@@@KV
)@@G@@         LOAD  X2,SGDFSD+DXGAXSLT,X4 . ORIGINAL SD PARAMETER@E@@@@      KW
)@@G@@   LOAD  X5,SGDPSD+DXGAXSLT,X4 . ORIGINAL PARAMETER SD@ @@@@         USIKX
)@@G@@NG SDSECT,X5     .@I@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,XGPA17 . -KY
)@@G@@> NON-STRUCTURE, SD IS THE SAME     @D@@@@         LOAD  X5,SGDRSD     .KZ
)@@G@@ PARAMETER SD OF LEAF   @ @@@@XGPA17   LABEL               .@A@@@@      LA
)@@G@@   EXERR ERCGNDCL LEVEL,1 .   @D@@@@XGPA16   LABEL               . ASSIGLB
)@@G@@N ARG TO TEMP     @A@@@@         GASGN SGDAID SGDAID+DCGSLT @E@@@@      LC
)@@G@@   XGPOP 'SIZE',2*DCGSLT         . CLEAR STACK ENTRIES@F@@@@         LINLD
)@@G@@K  XGEAX         . -> SIGNAL END OF LEAF EXPRESSION   @D@@@@         GOTLE
)@@G@@O  XGBMPL        . -> ARGUMENT COMPLETED  @D@@@@ . ** TEST FOR POSSIBLE LF
)@@G@@OCCURANCE OF CROSS SECTION    @F@@@@ . THESE 2 REGISTERS ARE THUSLY ONLYLG
)@@G@@ DURING THIS TEST ROUTINE     @ @@@@ .  X11 HOLDS A LOOP POINTER  @A@@@@LH
)@@G@@ .  A2 SAVES ORIGINAL SD POINTER    @#@@@@XGPA04   LABEL .  @ @@@@      LI
)@@G@@   LOAD  A2,X5         .@E@@@@         GETC                . LOOK AHEAD LJ
)@@G@@TO NEXT META-CODE @E@@@@         LOAD  X6,A8         .  X6 = SD POINTER LK
)@@G@@TO ARGUMENT @F@@@@         LINK  BCKPGC        . RETURN GETC TO FORMER PLL
)@@G@@OSITION     @E@@@@         LINK  XGPA08        . SKIP NORMAL LOOP INCREMLM
)@@G@@ENT   @E@@@@         LOAD  X6,SDBROT,X6  . FOLLOW POINTER TO BROTHER SD LN
)@@G@@@ @@@@XGPA08   LABEL               .@ @@@@         USING SDSECT,A2     .LO
)@@G@@@I@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,XGPA07 . -> BASE ELEMENT OF LP
)@@G@@STRUCTURE FOUN    @F@@@@         LOAD  X6,SDSON,X6   . FOLLOW SON POINTELQ
)@@G@@R OF ARGUMENT     @E@@@@         LOAD  A2,SDSON,A2   . FIND SON SD IN PALR
)@@G@@RAMETER     @G@@@@         GOTO  XGPA08        . -> LOOP THRU SONS TO FILS
)@@G@@RST BASE ELEM     @D@@@@XGPA07   LABEL               . COMPARE CLS1 TYPELT
)@@G@@S     @F@@@@         LOAD  F,SDCLS1,X6   . USE WORD TO SIMULATE SDCLS1(XLU
)@@G@@6)    @H@@@@         IF    F,NE,SDCLS1 THEN,XGPA09 . -> CONVERSION REQUILV
)@@G@@RED, CREATE DUMMY @ @@@@         USING SDSECT,X6     .@G@@@@         LOALW
)@@G@@D  A3,SDCLS0,X6 .          LOOK ONLY AT LABEL CLASS BITS    @C@@@@      LX
)@@G@@   AND,U A3,SD0LAB .   MASK OUT OTHERS    @H@@@@         IF    A4,EQ,SD0LY
)@@G@@LAB,I THEN,XGPA11 . -> SKIP REST OF TEST FOR LABEL    @F@@@@         LOALZ
)@@G@@D  F,SD2SP,A2    . COMPARE LENGTH-SCALE/PRECISION     @F@@@@         IF MA
)@@G@@   F,NE,SD2SP THEN,XGPA09 . -> CONVERSION REQUIRED    @ @@@@XGPA11   LABMB
)@@G@@EL               .@F@@@@         LOAD  X3,SDDAD,A2   . SAVE FATHER POINTMC
)@@G@@ER IN PARAMETER   @F@@@@         LOAD  A2,SDBROT,A2  . FIND BROTHER IN PMD
)@@G@@ARM SD STRUCTURE  @E@@@@         IF    A2,NE,0,I THEN,LJMP . -> TEST BROME
)@@G@@THER, ETC.  @ @@@@         LOAD  A2,X3         .@G@@@@         IF    A2,MF
)@@G@@EQ,0,I THEN,XGPA14 . -> ENTIRE STRUCTURE CHECKED, OK. @F@@@@         LOAMG
)@@G@@D  X6,SDDAD,X6   . FIND FATHER SD IN ARG STRUCTURE    @ @@@@         GOTMH
)@@G@@O  XGPA11        .@C@@@@ . **ARGUMENT AND PARAMETER IDENTICALLY DECLAREDMI
)@@G@@@#@@@@XGPA14   LABEL    @ @@@@         USING SDSECT,X6     .@F@@@@      MJ
)@@G@@   IF    SDCHCK,OFF,SDCLS3 THEN,XGPA19 . -> NOT CHECKED     @E@@@@      MK
)@@G@@   XGPUSH 'SIZE',1     . MAKE ROOM FOR CHECK INFO     @B@@@@         MOVML
)@@G@@E  SGDAID,SGDAID+1,DXGFCHK2 . @ @@@@         USING WORD,X7       .@E@@@@MM
)@@G@@         STORE A8,W1H1+DXGFCHK2        . SAVE SD POINTER    @I@@@@      MN
)@@G@@   MOVE  W1H2+DXGFCHK2,0,I       . INDICATE THIS IS NOT AN ARRAY REFERENMO
)@@G@@CE    @ @@@@XGPA19   LABEL               .@D@@@@         LOAD  F,SGDANS MP
)@@G@@     . NUMBER OF CONSTANT SUBS@E@@@@         LINK  XGEA8C        . -> POMQ
)@@G@@P AGG EXPR STACK ENTRY  @F@@@@         IF    F,EQ,0,I THEN,XGPA12 . -> FMR
)@@G@@ULL ARRAY OR STRUCTURE  @C@@@@         MOVE  DXGSTT,XGSVAL*01000+XGSCSC,MS
)@@G@@I .   @B@@@@         MOVE  DXGMSK,XGCRSE           .  @D@@@@         GOTMT
)@@G@@O  XGNXT0        . ->EVALUATE ARGUMENT    @ @@@@XGPA12   LABEL          MU
)@@G@@     .@B@@@@         SUB   X7,DCGSLT,I   . PUSH STACK @ @@@@         USIMV
)@@G@@NG SDSECT,X6     .@F@@@@         MOVE  AGRL1,SDA1BS-FH1        . AW FOR MW
)@@G@@ARRAY DOPE VECTOR @#@@@@         GETC  .  @ @@@@         LINK  XGIGNR   MX
)@@G@@     .@G@@@@         GOTO  XGLAA3        . -> MERGE WITH USER ARGUMENT PMY
)@@G@@ROCESSING   @C@@@@ . **END OF USER DEFINED FUNCTION ARGUMENT LIST @#@@@@MZ
)@@G@@XGNFCN   LABEL .  @E@@@@         MOVE  DXGSTT,SGDFSA       . RESTORE XGENA
)@@G@@N STATE     @C@@@@         MOVE  DXGMSK,SGDFSM     . RESTORE MASK @E@@@@NB
)@@G@@         LOAD  X5,SGDFSD           . PICK UP ENTRY SDA DRESS@E@@@@      NC
)@@G@@   XGPOP  'SIZE',DXGFSLT-DCGSLT . GET RID OF EXCESS   @^@@@@         USIND
)@@G@@NG SDSECT,X5@#@@@@XGNFC1   LABEL .  @F@@@@         LOAD  A8,SGDTLV .   FNE
)@@G@@REE TEMPS USED IN FUNCTION CALL     @^@@@@         FTMP  R,A8 .   @H@@@@NF
)@@G@@         MOVE  SGDALD,SGDFAT .         RESET ARGUMENT LIST POINTER TO BONG
)@@G@@TTOM  @B@@@@         LOAD  F,ARPRBG+ARFNRN+ARPRNM,I   @G@@@@         IF NH
)@@G@@   SDPARM,OFF,SDCLS2 THEN,XGNFC2 . REFERENCE TO ENTRY NAME  @E@@@@      NI
)@@G@@   SUB   F,ARPRNM,I    . SET FLAG FOR PARAMETER NAME  @D@@@@         LOANJ
)@@G@@DA  X3,SDA1BS          . AW FOR APRAMETER @]@@@@         GEN@F@@@@      NK
)@@G@@   GINST OPLA,AGRA2,AGPTX3,U     . LOAD ADDRESS OF PARAMETER@#@@@@XGNFC2NL
)@@G@@   LABEL .  @G@@@@         IF    SDCHCK,OFF,SDCLS3 THEN,XGNWLB . -> ENTRNM
)@@G@@Y NAME NOT CHECKED@F@@@@         ADD   F,ARCHCK,I         . ADD FLAG FORNN
)@@G@@ CHECKED FUNCTION @#@@@@XGNWLB   LABEL  . @E@@@@         STORE F,SGDIAD NO
)@@G@@     . SAVE FLAGS NEXT TO SD POINTER@ @@@@         SLB   F,18          .NP
)@@G@@@ @@@@         ADD   F,SGDRSD      .@#@@@@         GENM     @F@@@@      NQ
)@@G@@   GINST OPLA,AGRA1,AGARL1,U . LOAD ADDRESS OF ARGUMENT LIST@G@@@@      NR
)@@G@@   GSUB EXNTRY         . CALL SERVICE ROUTINE TO ENTER FUNCTION   @F@@@@NS
)@@G@@         GMRK  AGARL1 .      SAVE LOCATION OF FLAG BYTE FOR CGDR  @ @@@@NT
)@@G@@         GLITRG FLITRG       .@#@@@@         GFIN .   @D@@@@         LOANU
)@@G@@D  F,W1U,X7      . WAS STACK ENTRY MOVED? @F@@@@         IF    F,EQ,SGDINV
)@@G@@DS THEN,XGNFN4 . NO CHECKED ARGUMENTS     @D@@@@         MOVE  DXGWRK,SGNW
)@@G@@DAID,4     . SAVE STACK ENTRY @F@@@@         LOAD  X4,SGDIDS      .  X4 NX
)@@G@@-> ORIGINAL POSITION OF ENTRY @#@@@@XGCHG5   LABEL .  @A@@@@         LOANY
)@@G@@D  A7,SGDISD,X4     .   @D@@@@         IF  A7,EQ,0,I THEN,XGCHG3 . NOT ANZ
)@@G@@RRAG REF    @F@@@@         STORE A7,AGXR10-AGRX0+(IN 63,H2,1,AGAW) . FOROA
)@@G@@M AW FOR ADD@#@@@@         GENM     @G@@@@         GINST  OPLA,AGRA1,AGXOB
)@@G@@R10   . LOAD ADDRESS OF CHECKED VARIABLE  @E@@@@         GSUB  ONCHKA   OC
)@@G@@     . CALL ROUTINE TO DO PRINTING  @B@@@@         GGOTO XGCHG4        .OD
)@@G@@ -> MERGE   @#@@@@         GFIN  .  @#@@@@XGCHG3   LABEL  . @#@@@@      OE
)@@G@@   GENM     @G@@@@         GSUB  ONCHK         . CALL ROUTINE TO PRINT COF
)@@G@@HECK VARIABLE     @#@@@@XGCHG4   GLBL     @#@@@@         GLITRG X4@#@@@@OG
)@@G@@         GFIN     @^@@@@         SUB  X5,1,I    @^@@@@         LOAD  F,XOH
)@@G@@5     @^@@@@         USING WORD,X7 .@A@@@@         IF    F,NE,W1U THEN,XOI
)@@G@@GCHG5 @E@@@@         LOADXM X7,AGIM1           . RESET STACK POINTER    OJ
)@@G@@@E@@@@         MOVE  SGDAID,DXGWRK,4     . REFRESH STACK ENTRY    @#@@@@OK
)@@G@@XGNFN4   LABEL .  @F@@@@         LOAD  F,SDRTC            . NUMBER OF BYOL
)@@G@@TES USED BY ANSWER@B@@@@         SRB   F,1           . TAKE HALF  @D@@@@OM
)@@G@@         ADD   F,SGDRBS           . ADD TO REAL PART  @C@@@@         STOON
)@@G@@RE F,SGDIBS           . FORM IMAG AW@^@@@@         GOTO  XGEXPR   @F@@@@OO
)@@G@@XGPUSH   LLOC                . GET STACK ENTRY OF STANDARD SIZE   @ @@@@OP
)@@G@@         XGPUSH              .@#@@@@         LJMP   . @C@@@@ . STACK ENTOQ
)@@G@@RY FOR AGGX HAS BEEN ESTABLISHED    @ @@@@ . FUNCTION ENTRY IS BELOW IT OR
)@@G@@@#@@@@XGTEMP   LLOC  .  @F@@@@         LOAD  X5,SGDPSD+DXGAXSLT      .  OS
)@@G@@X5 = PARAMETER'S SD     @F@@@@         STORE X5,SGDXLS     . USE PARM SDOT
)@@G@@ TO DRIVE LENGTH COMP   @ @@@@XGTMP0   LLOC                .@D@@@@      OU
)@@G@@   STORE X11,SGDAXR    . SAVE RETURN ADDRESS    @B@@@@         LOAD  X6,OV
)@@G@@SGDPLS+DXGAXSLT      .  @ @@@@         USING SDSECT,X5     .@E@@@@      OW
)@@G@@   IF    SDSTRU,ON,SDCLS4 THEN,XGTMP6 . -> STRUCTURE  @ @@@@         LOAOX
)@@G@@D  X2,SDNDIM,X5  .@D@@@@         ADD   X2,W1U+2,X2   . ARRAY DOPE VECTOROY
)@@G@@ SIZE @ @@@@         GOTO  XGTMP7        .@D@@@@XGTMP6   LABEL          OZ
)@@G@@     . STRUCTURE MERGE POINT  @E@@@@         LOAD  X2,SDDVLG,X5  . SIZE PA
)@@G@@OF STRUCTURE DOPE VECTOR@C@@@@XGTMP7   LABEL               . ARRAY MERGEPB
)@@G@@ POINT@C@@@@         STORE X2,SGDXTI     . SET DV LENGTH    @F@@@@      PC
)@@G@@   LOAD  X3,DXGXPR     .  X3 = BASE OF AGG EXPRESSION STACK @A@@@@      PD
)@@G@@   USING ELWDST,X6       .    @C@@@@         MOVE  SGDXSD,ELWSD  . PARAMPE
)@@G@@ETER SD     @F@@@@         LOAD  A8,SDNSPS,X5 . NUMBER OF STRING LEAVES PF
)@@G@@OF PARAMETER@F@@@@         IF    A8,EQ,0,I  THEN,XGTMP5 . -> NO STRING LPG
)@@G@@ENGTH LIST  @E@@@@         GTMP  R,A8          . POTENTIAL LIST OF LENGTPH
)@@G@@HS    @E@@@@         MOVE  DXGSTT,XGSMXL*01000+XGSTP1,I . MAXL STATE    PI
)@@G@@@B@@@@         STORE A8,SGDXTC     . SAVE OFFSET@E@@@@         LINK  XGSPJ
)@@G@@DL1        . -> START SCAN OF PARAMETER SD@E@@@@XGTMP2   LABEL          PK
)@@G@@     . HERE WHEN LEAF IS FOUND  X4  @ @@@@         USING SDSECT,X4     .PL
)@@G@@@E@@@@         IF    SDARST,OFF,SDCLS1 THEN,XGTMP4 . -> NOT STRING@D@@@@PM
)@@G@@         LMCP SGDFMC,X7 .    LOAD BETA CODE POINTER   @F@@@@         GOTPN
)@@G@@O  XGNEXT        . -> EVALUATE EXPRESSION IN MAXL MODE@G@@@@XGRTMP   LABPO
)@@G@@EL               . RETURN HERE AFTER EVALUATING ARGUMENT    @I@@@@      PP
)@@G@@   LOAD  A2,SGDXTL+DCGSLT+FQ2,X7 .                                      PQ
)@@G@@ C    @D@@@@         AU,U  A2,1 .        MOVE TO NEXT LENGTH SLOT @B@@@@PR
)@@G@@         STORE A3,SGDXTL+DCGSLT+FQ2,X7 .  @A@@@@         ADD   A2,SGDXTCPS
)@@G@@+DCGSLT,X7 .@F@@@@         STORE A2,AGR10D     . FORM AW FOR SLOT IN LENPT
)@@G@@GTH LIST    @#@@@@         GENM  .  @F@@@@         GIFR  XGTP3R,AGRL1  .PU
)@@G@@ ->LENGTH EXPRESSION IS IN REGISTER @F@@@@         GINST OPLA,AGRA3,AGRLPV
)@@G@@1,H1        . MOVE LENGTH EXPRESSION@ @@@@         GSET  AGRL1,AGRA3 .  PW
)@@G@@@D@@@@XGTP3R   GLBL  . LENGTH EXPRESSION IS IN REGISTER     @G@@@@      PX
)@@G@@   GINST OPSA,AGRL1,AGXR10       . STORE LENGTH INTO LENGTH LIST  @ @@@@PY
)@@G@@         GFIN  'POP'         .@G@@@@         MOVE  SGDXTL+FQ1,0777,I    PZ
)@@G@@   . FLAG THAT LENGTH VECTOR USED   @ @@@@XGTMP4   LABEL               .QA
)@@G@@@D@@@@         LINK  XGSDL2        . -> CONTINUE SCANNING SD@C@@@@      QB
)@@G@@   GOTO  XGTMP2        . -> ANOTHER LEAF  @E@@@@XGTMP5   LABEL          QC
)@@G@@   . PREPARE FOR LITERAL GENERATION @F@@@@         LOAD  A7,SGDXSW   . LQD
)@@G@@OAD SELECTOR BITS WORDENERATION     @H@@@@         LOAD  A8,SGDXTI-FH2 .QE
)@@G@@ LOAD REPRESENTATIVE SD POINTER AND DV LENGTH   @B@@@@         MOVE  AGRQF
)@@G@@10D,SGDXTC           .  @#@@@@         GENM  .  @G@@@@         GINST OPLQG
)@@G@@A,AGRA1,SGDXDV,U 'NO' . LOAD ADDRESS OF CONTROLLING DV@G@@@@         GBRQH
)@@G@@   XGTP5S,07777,OFF,SGDTLV,Q1 . -> NO LENGTH  LIST USED     @H@@@@      QI
)@@G@@   GINST OPLA,AGRA2,AGXR10,U 'NO'  . LOAD ADDRESS OF STRING LENGTHS LISTQJ
)@@G@@@ @@@@XGTP5S   GLBL                .@E@@@@         GSUB  EXTMP1        .QK
)@@G@@ -> CALL TEMPORARY ALLOCATOR  @A@@@@         GLITRG A7           . SBW  QL
)@@G@@@C@@@@         GLITRG A8           . LENGTH, SD PTR   @I@@@@         GINQM
)@@G@@ST OPSA,AGRA1,AGALST+DXGAXSLT                                      .    QN
)@@G@@@G@@@@         GFIN  .                       WHICH HAS JUST BEEN ALLOCATQO
)@@G@@ED    @D@@@@         MOVE  SGDXDP,0,I    . RESET AGG STACK ENTRY  @ @@@@QP
)@@G@@         MOVE  SGDXLS,SGDXEL .@E@@@@         LOAD  A8,SGDXTC     . STRINQQ
)@@G@@G LENGTH VECTOR OFFSET  @B@@@@         IF    A8,EQ,0,I THEN,XGTP81 .    QR
)@@G@@@B@@@@         FTMP  R,A8          . FREE IT    @E@@@@XGTP81   LABEL .  QS
)@@G@@           MERGE WHEN NO LENGTH LIST USED @D@@@@         LOAD  X11,SGDAXQT
)@@G@@R    . GET RETURN ADDRESS     @A@@@@         LJMP  . -> RETURN TO CALLERQU
)@@G@@@ @@@@ . **FIND REPRESENTATIVE SD   @ @@@@ .  F  SBW SELECTOR BITS WORD QV
)@@G@@@^@@@@ .  X4 POINTS TO SD     @A@@@@ .  X6 COUNTS NUM OF DIMENSIONS     QW
)@@G@@@A@@@@ .  X3 COUNTS NON-STAR SUBSCRIPTS   @^@@@@ .  F  BIT MASK FOR SBW QX
)@@G@@@D@@@@ .  A10 SAVES GETC STATE H1 IS A1 MOD AND H2 IS X1 MOD@F@@@@XGETSDQY
)@@G@@   LOCAL  . ENTRY HERE ASSUMES A8 CONTAINS LAST GETC VALUE  @D@@@@      QZ
)@@G@@   LINK  SXGBC .       CREATE META CODE POINTER @A@@@@         STORE A3,RA
)@@G@@A10 .      SAVE IT@G@@@@         LINK  BPTRDC        . USE POINTER IN A8RB
)@@G@@ TO RESET GETC ROUTINE  @D@@@@         LOAD  X4,A8 .       X4  = REPRESERC
)@@G@@NTATIVE SD  @^@@@@         GOTO  $+2 .    @#@@@@XGETD0   LOCAL .  @F@@@@RD
)@@G@@         LOAD  X6,0777,I     . CLEAR NUMBER OF DIMENSIONS COUNTER @B@@@@RE
)@@G@@         LOAD  F,0,I         . CLEAR SBW  @E@@@@         LOAD  X3,0,I   RF
)@@G@@     . NUM OF NON-STAR SS'S = 0     @ @@@@         USING SDSECT,X4     .RG
)@@G@@@C@@@@         IF    SDSTRU,ON,SDCLS4 THEN,XGETB1     @F@@@@         IF RH
)@@G@@   SDARRY,OFF,SDCLS2 THEN,JMP1 . -> SCALER EXPRESSION @E@@@@         LOARI
)@@G@@D  X6,SDNDIM     .  X6 = MAX NUM DIMS TO EXPECT @#@@@@XGETB1   LABEL .  RJ
)@@G@@@F@@@@         GETC                . LOOK AHEAD ONE META-CODE SYMBOL    RK
)@@G@@@ @@@@         SUB   X1,1,I        .@A@@@@         AND   A8,XGMSK1-LFDGERL
)@@G@@  .   @#@@@@         GETC  .  @G@@@@         IF    A9,NE,ACLBRK,I THEN,XRM
)@@G@@GETB9 . ARGUMENT LIST? -> NO,DONE   @C@@@@         LOAD  A7,XGMSK2     .RN
)@@G@@ BIT MASK FOR SBW @C@@@@         GETC  .             SKIP SD POINTER    RO
)@@G@@@#@@@@XGETB4   LABEL .  @^@@@@         LINK  XGIGNR   @B@@@@         IF RP
)@@G@@   A9,EQ,ACSTAR,I THEN,XGETB3 @F@@@@         OR    F,A7          . SET BRQ
)@@G@@IT FOR NON/STAR SUBSCRIPT     @B@@@@         LOAD  F,A6 .        LOAD NERR
)@@G@@W SBW @E@@@@         ADD   X3,1,I        . COUNT NUMBER OF NON-STAR SS'SRS
)@@G@@@#@@@@XGETB3   LABEL .  @ @@@@         SRB   A7,1          .@^@@@@      RT
)@@G@@   LINK  XGIGNR   @F@@@@         IF    A9,EQ,ACCOMA,I THEN,XGETB4 . -> ERU
)@@G@@ND OF SUBSCRIPT   @F@@@@         IF    A9,NE,ACRBRK,I THEN,XGIGNR . SKIPRV
)@@G@@ TO END OF SUB    @ @@@@         LOAD  A2,X6         .@B@@@@         IF RW
)@@G@@   A2,EQ,X3 THEN,JMP1      .  @#@@@@XGETB9   LABEL .  @H@@@@         LINRX
)@@G@@K  XGETAG        . -> ALLOCATE AGGREGATE EXPRESSION STACK ENTRY   @E@@@@RY
)@@G@@         STORE X4,SGDXLS     . SET UP REPRESENTATIVE SD     @ @@@@      RZ
)@@G@@   STORE X4,SGDXEL     .@B@@@@         STORE F,SGDXSW      . SET SBW    SA
)@@G@@@D@@@@         STORE X3,SGDANS     . SET NON-STAR SUBSCRIPT @E@@@@      SB
)@@G@@   MOVE  SGDXDV,SDA1BS-FH1       . AW FOR DV OF SD    @E@@@@         STOSC
)@@G@@RE A10,SGDFMC    . START OF BETA-CODE EXPRESSION@G@@@@         JMP   . -SD
)@@G@@> RETURN TO CALLER INDICATING AGGREGATE EXPRESSION    @#@@@@XGIGNR   LLOSE
)@@G@@C  .  @ @@@@         GETC                .@G@@@@         AND   A8,XGMSK1SF
)@@G@@-LFDGE     . MASK OUT UNWANTED BITS    ******   @E@@@@         IF    A9,SG
)@@G@@NE,ACLBRK,I THEN,LJMP . -> NOT (, RETURN  @G@@@@         LOAD  A6,-1,I  SH
)@@G@@      . RESET BRACKET COUNTER TO ZERO  (-1)     @#@@@@XGIGN1   LABEL .  SI
)@@G@@@E@@@@         ADD   A6,1,I        . ENTER NEXT NEXTING LEVEL     @#@@@@SJ
)@@G@@XGIGN2   LABEL .  @#@@@@         GETC     @G@@@@         AND   A8,XGMSK1SK
)@@G@@-LFDGE     . MASK OUT UNWANTED BITS     ******* @B@@@@         IF    A9,SL
)@@G@@EQ,ACLBRK,I THEN,XGIGN1 @D@@@@         IF    A9,NE,ACRBRK,I THEN,XGIGN2 SM
)@@G@@. MOVE ON   @E@@@@         LOOP  A6,XGIGN2     . -> LEAVE ONE LEVEL OF NSN
)@@G@@ESTING@G@@@@         GOTO  XGIGNR        . -> BACK TO LEVEL 0, CONTINUE SO
)@@G@@LOOKING     @#@@@@XGETAG   LOCAL .  @B@@@@         XGPUSH 'SIZE',DXGAXSLSP
)@@G@@T        .  @D@@@@         LOAD  X2,DXGXPR     . OUTER ARRAY EXPRESSION SQ
)@@G@@@E@@@@         STORE X2,SGDXNX     . SAVE FOR LATE RESTORATION    @H@@@@SR
)@@G@@         STORE X7,DXGXPR     . POINT TO THIS AGGREGATE EXPRESSION STACK SS
)@@G@@ENTRY @A@@@@         JMP   . -> RETURN TO CALLER@D@@@@XGRVR4   LABEL .  ST
)@@G@@           END OF LEAF EXPRESSION   @I@@@@         LOAD  X11,DXGXPR    .SU
)@@G@@ BASE OF CURRENT AGGREGATE EXPRESSION STACK ENTRY     @C@@@@         LOASV
)@@G@@D  X11,SGDAXR,X11  .  RETURN ADDRESS@A@@@@         GOTO  0,X11          SW
)@@G@@.     @B@@@@/ . ** AGGREGATE EXPRESSION DRIVER **     @C@@@@ .  X1 SCRATSX
)@@G@@CH AND LOOP COUNTER (SAVED AT START)@E@@@@ .  X2 SCRATCH, TEMP POINTER TSY
)@@G@@O SD AND TALLY CELL COUNTER   @#@@@@ .  X3 SCRATCH    @[@@@@ .  X6@A@@@@SZ
)@@G@@ .  A7 HOLDS SELECTOR BITS WORD     @A@@@@ .  X4 TEMPORARY SGD STACK POITA
)@@G@@NTER  @ @@@@ .  X5 ADDRESS OF MASTER SD   @A@@@@ .  A10 AND X8 SCRATCH FTB
)@@G@@OR SHIFTING @F@@@@XGSAX    LLOC                . AGGREGATE EXPRESSION SETC
)@@G@@QUENCER     @G@@@@         MOVE  DXGSTT,XGSVAL*01000+XGSVR4,I . AGGREGATTD
)@@G@@E EXPRESSION STATE@B@@@@         MOVE  DXGMSK,XGACCX           .  @B@@@@TE
)@@G@@XGSAX0   LABEL .   ENTRY FROM SOME BIF'S  @E@@@@         LOAD  X4,DXGXPRTF
)@@G@@     . X4  -> AGGREGATE STACK ENTRY @E@@@@         STORE X11,SGDAXR,X4  TG
)@@G@@         . SAVE RETURN ADDRESS@E@@@@         LOAD  X5,SGDXLS,X4  . ADDR TH
)@@G@@OF SD OF MASTER VARIABLE@E@@@@         USING SDSECT,X5     . COMPUTE MAXTI
)@@G@@IMUM DIMENSIONS   @E@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,XGSAXO . -TJ
)@@G@@> ARRAY     @ @@@@         LOAD  X3,SDMXDM,X5  .@B@@@@         GOTO  XGSTK
)@@G@@AX2        . -> MERGE   @ @@@@XGSAXO   LABEL               .@E@@@@      TL
)@@G@@   LOAD  X3,SDNDIM,X5 .  NUMBER OF ARRAY DIMENSIONS   @G@@@@XGSAX2   LOCTM
)@@G@@AL .             SAVE RETURN ADDRESS FOR POSSIBLE LATER USE @H@@@@      TN
)@@G@@   SUB   X3,SGDANS,X4 .          X3=MAXIMUM NUMBER OF VARYING SUBSCRIP  TO
)@@G@@@ @@@@         LOAD  A8,W1U+1,X3 .  @ @@@@         ADD   A8,W1U,X3 .    TP
)@@G@@@E@@@@         GTMP  R,A8          . ALLOCATE TEMP FOR TALLY CELLS@E@@@@TQ
)@@G@@         STORE A8,SGDXTC,X4  . OFFSET FOR SUBROUTINE ADDRESS@A@@@@      TR
)@@G@@   ADD   A8,W1XU+1,X3     .   @E@@@@         STORE A8,SGDXTI,X4  . OFFSETS
)@@G@@T TO TALLY CELL INDICIES@C@@@@ . * TO NEXT ELEMENT IN AGGREGATE EXPRESSITT
)@@G@@ON    @#@@@@XGBAX4   LABEL .  @ @@@@         USING SGDSCT,X4     .@F@@@@TU
)@@G@@         TN    SGDFMC-SGDAID,X4   . TEST BY-NAME FLAG      ****** @E@@@@TV
)@@G@@         GOTO  XGBX4A        . -> NOT IN BY-NAME EXPANSION  @E@@@@      TW
)@@G@@   LINK  BCKPGC        . RE-GETC CURRENT META-CODE    @#@@@@         GETTX
)@@G@@C  .  @B@@@@         IF    A8,NE,X5 THEN,XGEAXA .     @#@@@@         GETTY
)@@G@@C  .  @A@@@@         AND   A8,XGMSK1-LFDGE .    @C@@@@         IF    A9,TZ
)@@G@@NE,ACSTXI,I THEN,XGBX4B .     @C@@@@         GETC  . SKIP TO START OF EXUA
)@@G@@PRESSION    @D@@@@         STORE X1,DXGXBS     . SET EXPRESSION BASE    UB
)@@G@@@E@@@@         STORE X1,SGDFMC+FH2,X4        . SAVE LIST POINTER  @F@@@@UC
)@@G@@         LINK  SXGBC .       CREATE META CODE POINTER FOR LIST    @E@@@@UD
)@@G@@         STORE A3,SGDFMC,X4 .          SAVE LIST POINTER    @A@@@@      UE
)@@G@@   STORE A1,SGDFMC+FH2,X4    .@C@@@@XGBX4B   LABEL               . SET BUF
)@@G@@Y-NAME FLAG @B@@@@         SET   0400,ON,SGDFMC+FQ1      .  @#@@@@XGBX4AUG
)@@G@@   LABEL .  @G@@@@         LOAD  X2,SDNDIM,X5  . NUMBER OF DIMENSIONS INUH
)@@G@@ THIS ELEMENT     @F@@@@         SUB   X2,SGDANS     .  X2 = NUMBER OF VUI
)@@G@@ARYING BOUNDS     @G@@@@         STORE X2,SGDXNC     . BECOMES CURRENT NUJ
)@@G@@UMBER OF DIMENSIONS     @E@@@@         SUB   X2,SGDXND     . COMPUTE CHAUK
)@@G@@NGE FROM INHERITED@D@@@@         IF    X2,ZERO THEN,XGBX01 . -> NO CHANGUL
)@@G@@E     @D@@@@         LOAD  A7,SGDXSW     . SELECTOR BITS WORD     @F@@@@UM
)@@G@@         LOAD  X8,SGDXND     . NUMBER OF INHERITED DIMENSIONS     @B@@@@UN
)@@G@@         LOAD  A9,X8 .       SAVE AND TEST@D@@@@         IF  A9,EQ,0,I TUO
)@@G@@HEN,XGBX4C . -> AT TOP LEVEL  @E@@@@         ADD   X8,SGDANS     . ACCOUUP
)@@G@@NT FOR CONSTANT BOUNDS  @ @@@@XGBX4C   LABEL               .@ @@@@      UQ
)@@G@@   LOAD  X3,X8         .@G@@@@         ADD   X3,W1XU+1,X8 .          X3=UR
)@@G@@OFFSET TO NEW BOUNDS PAIR - 2 @C@@@@         SLB   A7,0,X8       . POSITUS
)@@G@@ION SBW     @H@@@@         IF    SUBSCR,OFF,DCGONF THEN,XGBX1A . -> SUBSUT
)@@G@@CRIPT RANGE DISABLED    @C@@@@         LOADA F,R14ETY      . FORM AW FORUU
)@@G@@ TCV  @ @@@@         MOVE  AGR10D,SGDXTC .@E@@@@         GENM           UV
)@@G@@     . TC CHECK ROUTINE TO VECTOR   @B@@@@         GINST OPLA,AGRA3,AGPTUW
)@@G@@F,U 'NO' .  @B@@@@         GINST OPSA,AGRA3,AGXR10       .  @D@@@@      UX
)@@G@@   GFIN  . MOVE TALLY CHECK ADDRESS INTO VECTOR @#@@@@XGBX1A   LABEL .  UY
)@@G@@@C@@@@         SUB   X2,1,I .      SET LOOP COUNTS    @F@@@@         LOAUZ
)@@G@@D  A10,X2        . SAVE NUMBER OF NEW SUBSCRIPTS - 1  @F@@@@         MOVVA
)@@G@@E  AGTMP1+FH1,SGDXDV+FH1 . SET BASE FIELD FOR DV AR   @F@@@@         ADDVB
)@@G@@   X3,SDA1DP,X5  . OFFSET TO FIRST NEW BOUNDS IN DV   @E@@@@         ADDVC
)@@G@@   A9,SGDXTC,X4  . FIRST NEW TALLY CELL SLOT    @#@@@@XGBAX2   LABEL .  VD
)@@G@@@C@@@@         ADD   X3,2,I      . TO NEXT SLOT IN DV @F@@@@         JNSVE
)@@G@@   A7,XGBAX2 .   -> CARRY = CONSTANT SUBSCRIPT, SKIP  @D@@@@         ADDVF
)@@G@@   A9,1,I        . ADD NEW TALLY CELL     @D@@@@         STORE A9,AGR10DVG
)@@G@@     . FORM TALLY CELL AW     @E@@@@         STORE X3,AGTMP1+FH2 .      VH
)@@G@@   FORM AW FOR MASTER DV@C@@@@         GENM  . COPY CHECR ROUTINE ADDRESVI
)@@G@@S     @F@@@@         GINST OPLA,AGRA3,AGTMP1     . PICK UP BOUNDS FM MASVJ
)@@G@@TER DV@G@@@@         GINST OPSA,AGRA3,AGXR10     . SET BOUNDS INTO TCV LVK
)@@G@@OWER PART   @#@@@@         GFIN  .  @F@@@@         LOOP  X2,XGBAX2     .VL
)@@G@@ -> REPEAT FOR EACH NEW * INDEX     @G@@@@         LOAD  X3,SGDXND,X4 . VM
)@@G@@         NUMBER OF INHERITED DIMENSIONS   @F@@@@         ADD   X3,SGDXTIVN
)@@G@@,X4  . OFFSET TO FIRST NEW * INDEX IN TCV @#@@@@XGBX2A   LABEL .  @C@@@@VO
)@@G@@         SUB   X7,1,I        . -1 NW STACK ENTRY@E@@@@         STORE X3,VP
)@@G@@AGR10D     . FORM AW FOR TALLY CELL BOUND @F@@@@         GEN   .        VQ
)@@G@@     CLEAR TALLY CELL INDEX OFFSET TO ZERO@H@@@@         GINST OPSZ,AGRXVR
)@@G@@0,AGXR10 'NO' . 'AGRX0' USED AS PLACEHOLDER FOR IGEN  @G@@@@         GMAVS
)@@G@@RK   SGDAID,X7 . . SET CURRENT LOCATION IN STACK FOR LOOP   @D@@@@      VT
)@@G@@   ADD   X3,1,I        . TO NEXT TALLY CELL     @B@@@@         LOOP  A10VU
)@@G@@,XGBX2A     . -> REPEAT @G@@@@         LOAD  A2,DCGTLV     . CHECK THE CVV
)@@G@@OMPILE STACK FOR OVERFLOW     @^@@@@         USING WORD,X7 .@D@@@@      VW
)@@G@@   IF    A2,GE,W1U THEN,XG2FUL . OVERFLOW, QUIT @#@@@@XGBX01   LABEL .  VX
)@@G@@@D@@@@         LMCP  SGDFMC+FH2,X4 . RESET GETC ROUTINE     @E@@@@      VY
)@@G@@   LINK BCKPGC .       MOVE GETC ROUTINE BACK ONE     @ @@@@         USIVZ
)@@G@@NG SDSECT,X5     .@G@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,XGBX03 . -WA
)@@G@@> BASE ELEMENT FOUND    @ @@@@         USING SGDSCT,X4 .    @H@@@@      WB
)@@G@@   MOVE  SGDXND,SGDXNC           . INHERIT CURRENT NUM OF DIMENSIONS    WC
)@@G@@@E@@@@         LOAD  X5,SDSON,X5   . FOLLOW POINTER TO SON SD     @D@@@@WD
)@@G@@         STORE X5,SGDXEL,X4  . SAVE ADDRESS OF SD     @D@@@@         GOTWE
)@@G@@O  XGBAX4        . -> TEST SON FOR SON    @#@@@@XGBX03   LABEL .  @D@@@@WF
)@@G@@         LOAD  A9,1,I        . INCREMENT DEPTH COUNTER@ @@@@         ADDWG
)@@G@@   A9,SGDXDP,X4  .@ @@@@         STORE A9,SGDXDP,X4  .@E@@@@         MOVWH
)@@G@@E  DXGLHS,0,I     . CLEAR LEFT HAND SIDE COUNTER@E@@@@         POP   1 .WI
)@@G@@           DO NOT USE SAVED RETURN ADDRESS@F@@@@         GOTO  XGNXT0   WJ
)@@G@@     . -> EVALUATE EXPR FOR NEW ELEMENT   @A@@@@ . ** END OF AGGREGATE EWK
)@@G@@XPRESSION **@#@@@@ .  A9 SCRATCH    @A@@@@ .  A7 SCRATCH FOR COMPUTING OWL
)@@G@@FFSET @ @@@@         USING SGDSCT,X4     .@#@@@@XGEAX    LOCAL .  @E@@@@WM
)@@G@@         LOAD  X4,DXGXPR     . FIND AGG EXPR STACK ENTRY    @E@@@@      WN
)@@G@@   LOAD  X2,SGDXNC,X4  . CURRENT NUMBER OF DIMENSIONS @F@@@@         TP WO
)@@G@@   SGDFMC-SGDAID,X4 . TEST BY-NAME FLAG    *******    @H@@@@         GETWP
)@@G@@C  . POINT  GETC TO NEXT LISTA SYLLABLE IF IN BY-NAME EXPRESSIO   @#@@@@WQ
)@@G@@XGEAX5   LABEL .  @G@@@@         SUB   X2,SGDXND,X4  . FIND AGGREGATE EXWR
)@@G@@PRESSION STACK ENTRY    @A@@@@ .  X2 = NUMBER OF DIMENSIONS ENDING@ @@@@WS
)@@G@@         LOAD  X3,SGDXNC,X4  .@ @@@@         LOADA A7,AGRX10 .    @^@@@@WT
)@@G@@         SLB   A7,18 .  @ @@@@         ADD   A7,W1U,X3 .    @F@@@@      WU
)@@G@@   ADD   A7,SGDXTC,X4  . OFFSET TO TALLY CELL UPPER BOUND   @F@@@@      WV
)@@G@@   ADD   X3,SGDXTI,X4  .  X3 = OFFSET TO TALLY CELL INDEX   @G@@@@      WW
)@@G@@   GOTO  XGEAX9 .      -> COMPUTE CHANGE FROM INHERITED DIMENSIONS@#@@@@WX
)@@G@@XGEAX2   LABEL .  @G@@@@         SUB   X3,1,I        . TO NEXT TALLY CELWY
)@@G@@L INDEX (RIGHT-TO-LEFT) @C@@@@         STORE A7,AGTMP1     . SET BOUND AWZ
)@@G@@W     @D@@@@         STORE X3,AGR10D     . PUT OFFSET INTO AW     @#@@@@XA
)@@G@@         GENM  .  @G@@@@         GINST OPLA,AGRA1,AGXR10 .      GET CURRXB
)@@G@@ENT TALLY CELL INDEX    @F@@@@         GINST OPAU,AGRA1,1,I .        INCXC
)@@G@@REMENT TALLY CELL INDEX @G@@@@         GINST OPSA,AGRA2,AGXR10 .     SETXD
)@@G@@ INCREMENTED TALLY CELL INDEX @E@@@@ . FAKE 'AGRA1' WITH 'AGRR13' FOR USXE
)@@G@@E AS AN INDEX REGISTER  @H@@@@         GINST OPTLEM,AGRR13,AGTMP1,H1 . HXF
)@@G@@AS UPPER BOUND ALREADY BEEN REACHED @F@@@@         GJUMP SGDAID        .XG
)@@G@@ BRANCH TO INNER LOOP IF NOT HIGH   @#@@@@         GFIN  .  @D@@@@      XH
)@@G@@   ADD   X7,1,I        . POP ENTRY FROM STACK   @D@@@@         SUB   A7,XI
)@@G@@1,I        . TO NEXT BOUND IN LIST  @H@@@@XGEAX9   LABEL .             MXJ
)@@G@@ERGE TO PROCESS TCV'S ADDED MORE THAN INHERITED @E@@@@         LOOP  X2,XK
)@@G@@XGEAX2     . ->REPEAT FOR EACH TALLY CELL @#@@@@XGEAX1   LABEL .  @E@@@@XL
)@@G@@         LOAD  X5,SGDXEL,X4  . SD OF ELEMENT JUST PROCESSED @E@@@@XGEAXAXM
)@@G@@   LABEL . MERGE POINT FROM XGBAX4 (BY-NAME REJECTION)@ @@@@         USIXN
)@@G@@NG SDSECT,X5     .@ @@@@         LOAD  A3,X5         .@G@@@@         IF XO
)@@G@@   A3,EQ,SGDXLS THEN,XGEAX7 . -> THIS IS THE LAST ELEMENT   @D@@@@      XP
)@@G@@   LOAD  A9,SDDAD,X5   . SAVE FATHER POINTER    @E@@@@         LOAD  X5,XQ
)@@G@@SDBROT,X5  . FOLLOW POINTER TO BROTHER    @C@@@@         STORE X5,SGDXELXR
)@@G@@,X4  . SAVE SD POINTER  @E@@@@         IF    X5,NZERO THEN,XGBAX4 . -> PXS
)@@G@@ROCESS BROTHER    @E@@@@         LOAD  X5,A9         . FOLLOW POINTER TOXT
)@@G@@ FATHER     @C@@@@         STORE X5,SGDXEL     . SAVE SD POINTER  @E@@@@XU
)@@G@@         LOAD  X2,SDNDIM . GET DIMENSIONALITY OF NEW ELEMENT@F@@@@      XV
)@@G@@   SUB   X2,SGDANS     .  X2 = NUMBER OF VARYING DIMENSIONS @E@@@@      XW
)@@G@@   STORE X2,SGDXNC     . CURRENT NUMBER OF DIMENSIONS @G@@@@         MOVXX
)@@G@@E  X3,0,I        . 0 INHERITED DIMENSIONS IF AT LEVEL 0     @E@@@@      XY
)@@G@@   IF    A9,EQ,SGDXLS THEN,XGEAX6 . -> BACK TO LEVEL 0@B@@@@XGEAX3   LABXZ
)@@G@@EL . FIND FATHER OF CURRENT SD@ @@@@         USING SDSECT,X5     .@ @@@@YA
)@@G@@         LOAD  X6,SDDAD,X5   .@F@@@@         LOAD  X3,SDNDIM,X6  . HIS DYB
)@@G@@IMENSIONS ARE NUMBER INHERITED@E@@@@         SUB   X3,SGDANS,X4  .  X3 =YC
)@@G@@ NUM OF VARYING DIMS    @ @@@@XGEAX6   LABEL               .@F@@@@      YD
)@@G@@   STORE X3,SGDXND,X4  . SET NUM OF INHERITED DIMENSIONS    @B@@@@      YE
)@@G@@   GOTO  XGEAX5        . -> LOOP    @#@@@@XGEAX7   LABEL .  @ @@@@      YF
)@@G@@   LOAD  A8,SGDXTC     .@E@@@@         FTMP  R,A8          . FREE TALLY YG
)@@G@@CELL VECTOR (TCV) @#@@@@XGEAX8   LABEL .  @ @@@@         USING SGDSCT,X7YH
)@@G@@     .@ @@@@         LOAD  X2,SGDXNX,X7  .@F@@@@         STORE X2,DXGXPRYI
)@@G@@     . POP POINTER TO PREVIOUS AGG EXP STK@ @@@@         LOAD  A3,SGDFMCYJ
)@@G@@     .@F@@@@         XGPOP 'SIZE',DXGAXSLT         . POP AGG EXPR STACK YK
)@@G@@ENTRY @H@@@@         JP    A3,JMP        . -> RETURN TO CALLER, NOT IN BYL
)@@G@@Y-NAME ******     @ @@@@         LINK  BCKPGC        .@#@@@@         GETYM
)@@G@@C  .  @#@@@@XGEA8A   LABEL .  @G@@@@         AND   A8,XGMSK1-LFDGE . MASYN
)@@G@@K OUT LOW ORDER BYTE     *******    @B@@@@         GETC  . SKIP TO NEXT YO
)@@G@@SYLLABLE    @I@@@@         IF     A9,NE,ACBYNE,I THEN,XGEA8A . -> CONTINYP
)@@G@@UE TO LOOP TO END OF <LIST    @F@@@@         LINK  SCGSBC        . POINTYQ
)@@G@@ TO ORIGINAL POS OF BY-NAME   @C@@@@         JMP   .             -> RETUYR
)@@G@@RN TO CALLER@G@@@@XGEA8C   LOCAL               . ENTRY POINT TO XGEA8A FYS
)@@G@@ROM BIF ROUTINES  @ @@@@         GOTO  XGEAX8        .@E@@@@XGEA8B   LOCYT
)@@G@@AL               . PUT RETURN ADDRESS ON STACK  @B@@@@         GETC  . SYU
)@@G@@KIP TO NEXT SYLLABLE    @G@@@@         LINK  SCGSBC        . POINT TO ORYV
)@@G@@GINAL POSITION OF BY-NAME     @C@@@@         JMP                 . RETURYW
)@@G@@N TO CALLER @^@@@@ . **ASSIGNMENT COMMA   @#@@@@XGACMA   LABEL .  @ @@@@YX
)@@G@@         USING SGDSCT,X7 .    @I@@@@         LOAD  A10,DCGSLT,I  . LEFT YY
)@@G@@HAND SIDES ARE COUNTED IN UNITS OF STACK ENT    @F@@@@         . CHECK FYZ
)@@G@@OR ...PA->,... TO ADJUST STACK SIZE COUNTER     @C@@@@         IF      SZA
)@@G@@GDPTR,OFF,SGDID THEN,XGACMB   @I@@@@         ADD     A10,DCGSLT,I      .ZB
)@@G@@ ADD IN ANOTHER STACK SIZE FOR EXPLICIT PTR     @#@@@@XGACMB   LABEL    ZC
)@@G@@@ @@@@         ADD   A10,DXGLHS    .@F@@@@         STORE A10,DXGLHS . INZD
)@@G@@CREMENT LEFT HAND SIDE SIZE COUNTER @^@@@@         GOTO  XGLOOP  .@A@@@@ZE
)@@G@@ . ** PROCESS END OF EXPRESSION     @#@@@@XGENX0   LABEL .  @ @@@@      ZF
)@@G@@   USING SGDSCT,X7 .    @ @@@@         LINK  XGSAX         .@B@@@@      ZG
)@@G@@   IF    A1,EQ,KLCH2W THEN,XGENXA . @D@@@@         LOAD  A8,W1H1,X1 .  GZH
)@@G@@ET THE CURRENT CODE     @F@@@@         OR,U  A8,2 .        SET FLAG FOR ZI
)@@G@@AGGREGATE EXPRESSION    @E@@@@         STORE A9,W1H1,X1 .  RESTORE META-ZJ
)@@G@@CODE WITH FLAG    @^@@@@         GOTO  XGENDX   @G@@@@XGENXA   LABEL .  ZK
)@@G@@           CURRENT META CODE IS IN H2 OF PREVIOUS WORD@D@@@@         SUBZL
)@@G@@   X1,1,I .      BACK UP WORD POINTER     @D@@@@         LOAD  A8,W1H2,XZM
)@@G@@1 .  GET THE CURRENT META CODE@B@@@@         OR,U  A8,2 .        SET FLAZN
)@@G@@G     @C@@@@         STORE A9,W1H2,*X1 . RESTORE META-CODE  @#@@@@XGRSNGZO
)@@G@@   LABEL .  @#@@@@XGRFLL   LABEL .  @#@@@@XGENDX   LABEL .  @C@@@@      ZP
)@@G@@   JNB   A8,XGENX1 .   -> NOT IN I/O LIST @H@@@@         IF    012,OFF,SZQ
)@@G@@GDID THEN,XGENX3 . PSEUDO VARIABLE? , NO CALL I/O     @E@@@@         LINZR
)@@G@@K  XGPUSH        . GET STACK ENTRY FOR TEMP     @E@@@@ . $     MOVE SGDRZS
)@@G@@SD,PLCSDARC-TVDSECT,I . SET SD PTR FIELD  @H@@@@.        IF    9,ON,SGDIZT
)@@G@@D+DCGSLT THEN,XGENX4 . -> COMPLEX PSEUDO VARIABLE     @B@@@@ . *STRING OZU
)@@G@@R UNSPECIFIED PSEUDO VARIABLE @#@@@@         GENM     @#@@@@         GLIZV
)@@G@@T 3   @ @@@@         LOAD  A1,256,I .     @^@@@@         LOAD  A7,80,I  ZW
)@@G@@@^@@@@         STORE A7,0,X4  @ @@@@         GGETGR AGARL1 'X' .  @A@@@@ZX
)@@G@@         GINST OPLX,AGARL1,AGRA1 .  @#@@@@         GFIN     @ @@@@      ZY
)@@G@@   LOADA X2,AGARL1 .    @^@@@@         STORE X2,SGDRBS@E@@@@         MOVZZ
)@@G@@E  SGDAID+FH1,SD0STR*01000+SDARST++SDFXVR,I .   @^@@@@         LINK  PLGAA
)@@G@@IOL . @F@@@@         MOVE  AGRL1,AGSTK . TEMP IS IN STACK (SO AS TO POP AB
)@@G@@IT)   @ @@@@XGENX5   LABEL               .@B@@@@         GASGN SGDAID+DCAC
)@@G@@GSLT R,X7      .  @ @@@@         XGPOP               .@ @@@@         GOTAD
)@@G@@O  XGENX6        .@D@@@@XGENX4   LABEL .             COMPLEX PSEUDO-VARIAE
)@@G@@ABLE  @ @@@@.          LOAD  A8,2,I .     @^@@@@.          GTMP  R,A8 . AF
)@@G@@@A@@@@.          STORE A8,SGDRDS,X7 .     @ @@@@.          LOAD  A8,2,I AG
)@@G@@.     @^@@@@.          GTMP  R,A8 . @A@@@@.          STORE A8,SGDIDS,X7 AH
)@@G@@.     @A@@@@.          LOAD  X2,AGRX10+FH1 .    @A@@@@.          STORE XAI
)@@G@@2,SGDRBS,X7 .     @A@@@@.          STORE X2,SGDIBS,X7 .     @A@@@@.     AJ
)@@G@@     MOVE  SGDAID,XGCON4 .    @E@@@@.          LINK  PLGIOL .      -> LIAK
)@@G@@NK TO I/O PROCESSOR     @A@@@@.          LOAD  A6,AGXR10+FH1 .    @D@@@@AL
)@@G@@.          STORE A6,SGDRBS,X7 . MAKE TEMPS FREEABLE   @A@@@@.          SAM
)@@G@@TORE A6,SGDIBS,X7 .     @ @@@@.          GOTO  XGENX5 .     @#@@@@XGENX3AN
)@@G@@   LABEL .  @^@@@@         LINK  PLGIOL . @#@@@@XGENX6   LABEL .  @#@@@@AO
)@@G@@         XGPOP    @#@@@@XGENX1   LABEL .  @E@@@@         LINK  BCKPGC   AP
)@@G@@     . RE-GETC CURRENT META-CODE    @#@@@@         GETC  .  @G@@@@      AQ
)@@G@@   IF    02,OFF,A8 THEN,XGEND . -> NOT IN AGGREGATE EXPRESSION    @G@@@@AR
)@@G@@         LINK  XGEAX         . -> TRY FOR END OF AGGREGATE EXPRESSION   AS
)@@G@@@^@@@@         GOTO XGEND     @ @@@@. ** START BY-NAME EXPRESSION @#@@@@AT
)@@G@@XGSBNX   LABEL .  @F@@@@         GETC  . MOVE TO NEXT GAMMA CODE - A POIAU
)@@G@@NTER TO <LISTA>   @E@@@@         LINK  SCGSBC        . MOVE GETC ROUTINEAV
)@@G@@ TO POINTER @A@@@@         AND   A8,XGMSK1-LFDGE  .   @F@@@@         LOAAW
)@@G@@DA X11,XGEND     . PREPARE TO CANCEL XGEN IF NO LISTA @G@@@@         IF AX
)@@G@@   A9,EQ,ACBYNE,I THEN,XGEA8B . -> NULL BY NAME EXPRESSION  @F@@@@      AY
)@@G@@   LOAD  X4,A8         . LOAD REPRESENTATIVE SD POINTER     @C@@@@      AZ
)@@G@@   LINK  SXGBC .       SAVE GETC STATE    @^@@@@         STORE A3,A10 . BA
)@@G@@@E@@@@         LOR   A10,XGMSK2    . MASK FOR BY-NAME EXPRESSION  @#@@@@BB
)@@G@@XGSBN2   LABEL  . @D@@@@         LOAD  X3,A8         . PICK UP LEAF SD PBC
)@@G@@OINTER@B@@@@         GETC  . SKIP TO FIRST EXPRESSION @A@@@@         ANDBD
)@@G@@   A8,XGMSK1-LFDGE .    @C@@@@         IF    A9,NE,ACSTXI,I THEN,XGSBN2 BE
)@@G@@.     @F@@@@         LINK  XGIGNR        . -> SKIP TO NEXT LEVEL 0 SYMBOBF
)@@G@@L     @G@@@@         IF    A8,NE,X3 THEN,XGIGNR . -> LOOK AGAIN FOR LEAFBG
)@@G@@ VARIABLE   @D@@@@         LINK  XGETD0        . -> DETERMINE SBW, ETC. BH
)@@G@@@F@@@@         LMCP  R,A10 .       RESET GETC FOR BY-NAME EXPRESSION    BI
)@@G@@@B@@@@         LINK  BCKPGC .      BACK UP GETC @^@@@@         GOTO  XGEBJ
)@@G@@NX0 . @A@@@@ . **START EXPRESSION SYLLABLE (IO) @#@@@@XGSEX1   LABEL .  BK
)@@G@@@E@@@@         STORE X1,DXGXBS     . SET BASE FOR THIS EXPRESSION @E@@@@BL
)@@G@@         GETC                . SKIP TO DESCRIPTOR HALFWORD  @D@@@@      BM
)@@G@@   LINK  XGETSD      . -> FIND REPRESENTATIVE SD@D@@@@         GOTO  XGEBN
)@@G@@NX0        . -> AGGREGATE EXPRESSION@H@@@@         LMCP R,A10 .        RBO
)@@G@@ESET META-CODE POINTER FOR BY-NAME EXPRESSION   @E@@@@         GOTO  XGNBP
)@@G@@EXT        . -> PROCESS SCALER EXPRESSION @ @@@@ . *START EXPRESSION SYLBQ
)@@G@@LABLE @#@@@@XGSEXP   LABEL .  @E@@@@         SUB   X1,1,I .      GO BACKBR
)@@G@@ TO FIND BASE ADDRESS   @#@@@@         GETC .   @E@@@@         STORE X1,BS
)@@G@@DXGXBS     . SET EXPRESSION BASE ADDRESS  @#@@@@         GETC .   @^@@@@BT
)@@G@@         GOTO XGNXT0    @E@@@@         END   .             EXPRESSION GEBU
)@@G@@NERATION DRIVER   ___LOAD  A10,DCGSLT,I  . LEFT HAND SIDES ARE COUNTED IBV
)@@G@@N UNITS OF STACK ENT    @F@@@@         . CHECK F*[S@@[*SDFF*+@@@@@@C@]@[BW
)@@G@@.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    +@@@@[@F@@@] 0)^@)CTJE[TBX
)@@G@@ELDC9CE))AC9A85^[]FC)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^+@@@@@@[@]@[.     BY
)@@G@@+@@@@[@[@@@] 0)^@)+@@@@@@D@]@[.   QUESTIONS CONCERNING THIS SHOULD BE DIBZ
)@@G@@RECTED TO:  +@@@@[@H@@@] 0)^@)EDPC(NE-DD9IES)CTJD1#C(MD1DD1B^[OD[DES)ETCCA
)@@G@@D9PD-^^[]C*)C-DEL CTOC(^^[OD8'+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@CB
)@@G@@@ @]@[.        MARVIN V. ZELKOWITZ  +@@@@[@B@@@] 0)^@)^@)^@)^[HCDME1DD0)CC
)@@G@@E0,^[UC(GDTJE9DE-U+@@@@@@B@]@[.        DEPARTMENT OF COMPUTER SCIENCE   CD
)@@G@@+@@@@[@E@@@] 0)^@)^@)^@)^[^C(KCDME-HC(IE))D9A^[#D9HE[PE- EK)ET#DD D1#C*)CE
)@@G@@+@@@@@@A@]@[.        UNIVERSITY OF MARYLAND     +@@@@[@C@@@] 0)^@)^@)^@)CF
)@@G@@^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC))+@@@@@@B@]@[.        COLLEGE PARK, MCG
)@@G@@ARYLAND 20742     +@@@@[@E@@@] 0)^@)^@)^@)^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGCH
)@@G@@CDIC))AK0A84AK)^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@G@]@[.     CI
)@@G@@   PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY+@@@@[CJ
)@@G@@@M@@@] 0)^@)^@)^@)^[KC(MD(DETNDDJD0)E-J^[PET ^[OD[ ET ^[GDDNE-DD1BES)CDICK
)@@G@@C))E-CC*)CTJD(KE(OC(M^[KELJC9MCDHES)E-CC(T+@@@@@@E@]@[.   REPRESENT IS GCL
)@@G@@RANTED UNDER THE FOLLOWING CONDITIONS:    +@@@@[@I@@@] 0)^@)EL E[MC(NC(ICM
)@@G@@E))DDN^[BEL[D1OC(^^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1B^[#D9IC-DE-DD9IES'+@@@@@CN
)@@G@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@G@]@[.        1. UNLIMITED USE MAY CO
)@@G@@BE MADE OF THE PROGRAMS REPRESENTED BY    +@@@@[@L@@@] 0)^@)^@)^@)^@1 0)CP
)@@G@@E(ID-DD(DE- C))E(NC*)D([FC)CL ^[HCD^C*)D9A^[OD[ ^[KELJC9MCDHES)EL E[MC(NCQ
)@@G@@C(IE- C))CLT+@@@@@@G@]@[.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OCR
)@@G@@R UNIVERSITY OF MARYLAND+@@@@[@M@@@] 0)^@)E-CC(NC*)D-DETODDIC9N^[KELJE1DCS
)@@G@@C- C))E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JEK)E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^CT
)@@G@@+@@@@@@E@]@[.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   CU
)@@G@@+@@@@[@J@@@] 0)^@)E[G 81^[#D9HE[DD- EK)EL D([DDIES)CDNETJCTDCDOC(^^[RDDOCV
)@@G@@D@)E-CC(NC*)E[MD9BEL[D(N 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@CW
)@@G@@@F@]@[.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDED:   CX
)@@G@@+@@@@[@K@@@] 0)^@)^@)^@)^@2 0)D(JC-DC1DCT[E-DD9IES)D([FC)CL ^[HCD^C*)E-JCY
)@@G@@^[OD[ ^[GDDNE-DD1BES)E[MD9QDD^C(^BK)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)CZ
)@@G@@+@@@@@@G@]@[.        (A) ANY RESULTING PROGRAM, OR REPORT, PAPER OR DOCUDA
)@@G@@MENTATION   +@@@@[@M@@@] 0)^@)^@)^@)^@*CC(^[[D1T^[MC(NE(GE-DD1B^[KELJC9MDB
)@@G@@CDH ))D9M^[MC(KD9ME)?^[KCDKC(M^[JEK)C-JCTPD( D1OCDODDJD0)^@)+@@@@@@G@]@[DC
)@@G@@.        DESCRIBING SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM DD
)@@G@@+@@@@[@M@@@] 0)^@)^@)^@)^[^C(NCTMDD]DDIC8)ETPCTC^[KELJC9MCDH^[RDDGD))CTGDE
)@@G@@C([ELGFC)DDIC-DCT[E- ^[OD[[E))E-CC*)E[MD9BEL[D*)+@@@@@@E@]@[.        IS DF
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  +@@@@[@J@@@] 0)^@)^@)^@)DG
)@@G@@^[DES)CC)C-DCDGC(#E))D9A^[KD-PD*)D9M^[DES)C- ELDE1 C))C1MD9H^[KD-PD*?^[[DH
)@@G@@D1^^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@G@]@[.        (B) ALL SDI
)@@G@@UCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     +@@@@[@L@@@] 0)^@)DJ
)@@G@@^@)^@)^@*CK(^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DD9IES?^[JE-CC(M^[OD[[D0)E-MDDQDK
)@@G@@DD[D))CTJELMC(#E-DD9IES)+@@@@@@F@]@[.        OF ERRORS IN THE SOURCE PRODL
)@@G@@GRAMS, SHALL BE REPORTED AND  +@@@@[@K@@@] 0)^@)^@)^@)^[JC0)C(MELJELN^[DDM
)@@G@@D0)E-CC*)ETJE(MCT ^[KELJC9MCDHES?^[ND[[D-G^[]C*)EL E[JELOC(^^[[D1^+@@@@@DN
)@@G@@@G@]@[.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTDO
)@@G@@ED    +@@@@[@L@@@] 0)^@)^@)^@)^[[^[]ELDC(A^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)DP
)@@G@@C1 CDOE(MC*)CD^C- C))ETCCDGD))CL ^[NE(]D(DE-OC(^+@@@@@@C@]@[.        TO DQ
)@@G@@THE UNIVERSITY OF MARYLAND, AND     +@@@@[@F@@@] 0)^@)^@)^@)^[OD8)E-CC*)DR
)@@G@@E(IDDQC(METDE-T^[JC0)D([ELTD-[D1^ ))CDIC))+@@@@@@[@]@[.     +@@@@[@[@@@]DS
)@@G@@ 0)^@)+@@@@@@F@]@[.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SDT
)@@G@@HALL BE SOLD+@@@@[@L@@@] 0)^@)^@)^@)^@*CS(^[ID8)E[MD9BEL[D(N^[^C(MDDQC(^DU
)@@G@@^[AELJD*)E-CC(NC*)D-DETODDIC9N^[ND[[D-G^[]C*)ETJD-^^@)+@@@@@@G@]@[.     DV
)@@G@@   WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  +@@@@[DW
)@@G@@@M@@@] 0)^@)^@)^@)^[RDDOD[JE(O^[RELDE-OC(I^[[E[KELJE1[D))C1MD9H^[OD[ ^[PDX
)@@G@@D1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC)?^[[D1^^@)+@@@@@@[@]@[.     +@@@@[@[@@@]DY
)@@G@@ 0)^@)+@@@@@@F@]@[.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTDZ
)@@G@@ED TO OTHER +@@@@[@L@@@] 0)^@)^@)^@)^@*C)(^[#D9KDD ES)D9A^[OD[ ET ^[KELJEA
)@@G@@C9MCDHES)D([FC)CL ^[OEL[D1ND(DE-OC(^^[OD8)D9OD[ EK)^@)+@@@@@@G@]@[.     EB
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     +@@@@[EC
)@@G@@@L@@@] 0)^@)^@)^@)^[GD9#CDODDJD1N^[KELJE1DC- C))E-CCDO^[NE(#D@)E-MCDIETHED
)@@G@@DDOE-[D-N^[#D- CDMD-T^[DD1^DD#CDOC*)+@@@@@@G@]@[.        WHETHER THE PROEE
)@@G@@GRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     +@@@@[@L@@@] 0)^@)^@)^@)EF
)@@G@@^[RD[ E-CC(M^[OD[ ^[KELJC9MCDHES)CDMC*)C(SCD#E))CTJE[DC(N^[JC0)E-CC*)E(IEG
)@@G@@DDQC(METDE-T^[JC0)+@@@@@@E@]@[.        MARYLAND PLUM COMPILER OR ARE MODEH
)@@G@@IFICATIONS TO IT. +@@@@[@J@@@] 0)^@)^@)^@)^[HCDMFDGCDIC))E[GE(H^[#D9HE[DEI
)@@G@@D- EK)D9M^[[EL ^[HD9^DDADD#CDODDJD1N^[OD8)DDO 0)+@@@@@@[@]@[.     +@@@@[EJ
)@@G@@@[@@@] 0)^@)+@@@@@@G@]@[.        3. THESE CONDITIONS ONLY APPLY TO THE PEK
)@@G@@LUM COMPILER ITSELF,    +@@@@[@L@@@] 0)^@)^@)^@)^@3 0)E-CC(NC*)CTJD1^DDOEL
)@@G@@DDJD1N^[JD1GFC)CDKE[GFC)E-J^[OD[ ^[KD-PD*)CTJD(KDDGC(M^[DE-NC(GC0?+@@@@@EM
)@@G@@@F@]@[.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN USING PLUM. EN
)@@G@@+@@@@[@L@@@] 0)^@)CDIC))CDMC*)D1JE))D( CDIE))E-J^[[E[KD-T^[OD8)CDIFC)E[MEO
)@@G@@D9BEL[D*)E9MDDOE- D0)E(NDDIC8)E[GE(H 0)^@)+@@@@@@E@]@[.   THE PURPOSE OFEP
)@@G@@ THESE CONDITIONS IS TO ALLOW ANY USER TO +@@@@[@J@@@] 0)^@)E-CC*)E[PELKEQ
)@@G@@D9NC*)D9A^[OD[ ET ^[#D9IC-DE-DD9IES)DDN^[OD8)CDGD-JE8)CDIFC)E(NC(M^[OD8)ER
)@@G@@+@@@@@@F@]@[.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRES
)@@G@@ODUCT +@@@@[@L@@@] 0)^@)C(SE[ ELDD( D1O^[RDDOD@)E-CC*)CTJD(KDDGC(M^[[ES)ET
)@@G@@D-JD1B^[[ES)E-CC*)EL ETPD-ODDIC8)E[MD9^E(#E))^@)+@@@@@@G@]@[.   IS NOT SEU
)@@G@@OLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DEVELOPED   +@@@@[@M@@@]EV
)@@G@@ 0)^@)DDN^[ID9O^[ND9GC))CDIC))CDN^[GD9IC8)CDN^[DE))DDN^[FD1JE9I^[OD[[E))EW
)@@G@@E-CC*)E[MD9^E(#E))C- E1 D-JE[ C))^@)+@@@@@@#@]@[.   FROM PLUM.    +@@@@[EX
)@@G@@@^@@@] 0)^@)C1MD9H^[KD-PD*,^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@EY
)@@G@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@EZ
)@@G@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@FA
)@@G@@@[@]@[/.    +@@@@[@[@@@] 8,^@)+@@@@@@A@]@[MSG*     PROC  *1 .     NUMBERFB
)@@G@@,WORDS+@@@@[@D@@@]D(NC8%^@)^@)^[KELJCS)^@%AC) 0)^@)^@)D1PD(]C(M -RD9MC-NFC
)@@G@@+@@@@@@ @]@[ZM*(MSG(1,1)) EQU 6*($-PART1) +@@@@[@C@^@]FLH K*D(NC8*AC?AC(FD
)@@G@@ C)C(LE*)A0% @= (KCDME)1 C)^@)@C@@@^FLH K*D(NC8*AC?AC( C)C(LE*)A)% @= (KFE
)@@G@@CDME)1 C)^@)+@@@@@@ @]@[ZX*(MSG(1,1)) EQU   MSG(1,2)  +@@@@[@B@@@]FLS K*FF
)@@G@@D(NC8*AC?AC( C)C(LE*)^@)D(NC8*AC?AK(+@@@@@@#@]@[         END .    +@@@@[FG
)@@G@@@^@@@]^@)^@)^@)^@)^[ D1^^@,^@)+@@@@@@#@]@[PT2*     PROC .   +@@@@[@^@@@]FH
)@@G@@E[OAK%^@)^@)^[KELJCS) 0)+@@@@@@^@]@[FM       FORM  6,12,6,12+@@@@[@A@@@]FI
)@@G@@C1H^@)^@)^@)^[AD9MD*)^@6 )1AK?A0?AC2+@@@@@@G@]@[K        DO    PT2(1,1) FJ
)@@G@@, FM +ZX(2*K-2),ZM(2*K-2),ZX(2*K-1),ZM(2*K-1)   +@@@@[@M@@@]DS)^@)^@)^@)FK
)@@G@@^[^D8)^@)^[KE)2 @1 )1 C) ))C1H^@:FLS @2 LF *2 C?FLH @2 LF *2 C?FLS @2 LFFL
)@@G@@ *1 C?FLH @2 LF *1 C)^@)+@@@@@@#@]@[         END .    +@@@@[@^@@@]^@)^@)FM
)@@G@@^@)^@)^[ D1^^@,^@)+@@@@@@#@]@[         AXR$     +@@@@[@^@@@]^@)^@)^@)^@)FN
)@@G@@^[[F[M^))^@)+@@@@@@#@]@[         DCLRG    +@@@@[@^@@@]^@)^@)^@)^@)^[^CTGFO
)@@G@@ELB^@)+@@@@@@#@]@[MSGS     CSECT 3  +@@@@[@^@@@]D(NC9N^@)^@)^[#ET CTO^@3FP
)@@G@@+@@@@@@#@]@[MSG01*   LABEL .  +@@@@[@^@@@]D(NC82AC%^@)^[GCD]C(G^@,+@@@@@FQ
)@@G@@@^@]@[         +PART2,PART1 . +@@@@[@A@@@]^@)^@)^@)^@)^@:E[[ELOAK?E[[ELOFR
)@@G@@AC) 0)+@@@@@@#@]@[PART1   LABEL .   +@@@@[@^@@@]E[[ELOAC)^@)D-[CL D)) 0)FS
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@)A@?AS)^@)@B@@@]^@$ET\IL2JC-^[IH94^[(H(0H->H(>FT
)@@G@@H14G(=^@$^@)@ @@@]^@)^@)^@)^@)^[!IT$^@)A)?AS)^@)@ @@@]^@$E-\H8)H(5GT*^[\FU
)@@G@@I(4I[5I))^8)@ @@@ ^@)^@)^@)^@)^[!IT$^@)^@8AK?BC)@I@@@ ^@$ET0G(<HD&HD>G))FV
)@@G@@H90G(2GD,G-3^[!GD9^[,H94^[+G*)I(3G(=^[7HD4H@)H90G(2GD4H92^[@C0)^8)@ @@@ FW
)@@G@@^@)^@)^@)^@)^[!IT$^@)^@8AS?AC0@I@@@ ^@$E(,GD2JC)H90G(2GD4H92^[@C1=H9>IS)FX
)@@G@@H1\I))H(-I-<H@)G--I--^[4JD0G*)H9&^[\I[>IL-H1=^@$@ @@@ ^@)^@)^@)^@)^[!IT$FY
)@@G@@^@)^@8A)?BC)@J@@@ ^@$D90G(2GD,G-3^[&H92^[\I[>IL-I-\IK)C[AGD2G*)H9&^[(H1<FZ
)@@G@@H9!I[-I-(GL?G*)G--I--^[4JD0G(3^@$^@)@ @@@]^@)^@)^@)^@)^[!IT$^@)B@7 )4^@)GA
)@@G@@@A@@@]^@$^(PHD3^[,H94^[=G(<H--IL>G))^8)^@)@ @@@]^@)^@)^@)^@)^[!IT$^@8B@?GB
)@@G@@AK)^@)@^@@@]^@$E-9I[>^[>IL2H92^@$^@)@ @@@]^@)^@)^@)^@)^[!IT$^@8BC?AK)^@)GC
)@@G@@@ @@@]^@$D90G(2GD,G))G(2IL\IK)^8)^@)@ @@@]^@)^@)^@)^@)^[!IT$^@9A@?A0)^@)GD
)@@G@@@H@@@]^@$CD2IL-JC)H92^[3I-2I(<I-5IL>^[>J[0IL>IT3HD\H0)H1\I))HD!I[?G(!G(,GE
)@@G@@I->G))^8)^@)@ @@@]^@)^@)^@)^@)^[!IT$^@9AC?AS)^@)@A@@@]^@$CT\H(0HD?G(2^[>GF
)@@G@@IL2H92 0)ET D([^@$@ @@@]^@)^@)^@)^@)^[!IT$^@9AK?A))^@)@C@@@]^@$DD,I1-H-(GG
)@@G@@G))H15H(+G(2^[\G0)GD2G95H(>H14IS)^8)@ @@@]^@)^@)^@)^@)^[!IT$^@9AS?A*)^@)GH
)@@G@@@E@@@]^@$DD,I1-H-(G))I-\HT>H0,^[NC(HCC)GT\H(0HD?G(2^[>IL2H92^@$^@)@ @@@]GI
)@@G@@^@)^@)^@)^@)^[!IT$^@9A)?AS)^@)@A@@@]^@$ET D([^[4GD+H->^[\I1>IL&H-\I8)^8)GJ
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@9A*?AK)^@)@ @@@]^@)^@)^@)^@)^[!IT$^@1A@6 )2^@)GK
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@1A@7 )2^@)@ @@@]^@)^@)^@)^@)^[!IT$^@1A@8 )2^@)GL
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@1A@9 )2^@)@ @@@]^@)^@)^@)^@)^[!IT$^@1AC0 )2^@)GM
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@1AC1 )2^@)@ @@@]^@)^@)^@)^@)^[!IT$^@)AC1AK?AK)GN
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@1AC3 )2^@)@ @@@]^@)^@)^@)^@)^[!IT$^@1AC4 )2^@)GO
)@@G@@@ @@@]^@$DD,I1-H-(G))H(>IT3GD$G*)^8)@ @@@]^@)^@)^@)^@)^[!IT$^@9A0?A*)^@)GP
)@@G@@@D@@@]^@$F-QI(3G(=^[&H92^[(H16GD?HD=^[>J[0IL>IT3HD\H0)^8)^@)@ @@@]^@)^@)GQ
)@@G@@^@)^@)^[!IT$^@9A8?AK)^@)@B@@@]^@$E(,HD!I[?G(!G(,I->G))G1>GD4I(2G*)^8)^@)GR
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@9B@?A))^@)@ @@@]^@$F-PI(3G(=^[-IS)GD2IL-JC)^8)GS
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@9BC?BC)^@)@I@@@]^@$D1\I))I[2H90G(2^[,I(!GL>IK)GT
)@@G@@H9&^[-IL$I(!G(,I-3^[\IK)IT5GL3GT2HD0I-3^[&H92^[WE*)^8)@ @@@]^@)^@)^@)^@)GU
)@@G@@^[!IT$^@1A@0 )3^@)@B@@@]^@$DD?H->G9-H))GT\H(0H->J@)GT\H(0GD2G*)^8)@ @@@]GV
)@@G@@^@)^@)^@)^@)^[!IT$^@1A@1 )4^@)@B@@@]^@$ET4IL5GT4I(2G(3^[=H8)H1\I))H(-I-<GW
)@@G@@H@)^8)@ @@@]^@)^@)^@)^@)^[!IT$^@1A@2 )4^@)@B@@@]^@$C-(H(>H13HD\H13^[=H8)GX
)@@G@@H1\I))H(-I-<H@)^8)@ @#@]^@)^@)^@)^@)^[!IT$^@1A@3 )2^@)@ @@@#^@)^@)^@)^@)GY
)@@G@@^[!IT$^@1A@3 )7^@)@A@#@]^@$DD,I1-H-(G))GD3IT(G9,H(>H14^@$^@)@F@@@#^@$CD3GZ
)@@G@@IT(G9,HD,G8)GD,^[-IL2GD9^[4H8)GC)IT<GD?GD2^[6GD2HD-GL?G*)^8)@ @#@]^@)^@)HA
)@@G@@^@)^@)^[!IT$^@1A@4 )3^@)@ @@@#^@)^@)^@)^@)^[!IT$^@1A@4 )4^@)@A@#@]^@$DD,HB
)@@G@@I1-H-(G))I[-IL-H(>I->IK)F-P^@$@B@@@#^@$DD,I1-H-(G))I[-IL-H(>I->IK)G1\IK)HC
)@@G@@F-P^@$@ @@@]^@)^@)^@)^@)^[!IT$^@1AC5 )2^@)@A@@@]^@$DD,I1-H-(G))IT5GL3GT2HD
)@@G@@HD0I))^8)^@)@ @#@]^@)^@)^@)^@)^[!IT$^@1AC6 )7^@)@ @@@#^@)^@)^@)^@)^[!IT$HE
)@@G@@^@1AC6 )9^@)@D@#@]^@$F-PHD3^[5IT>G))GD3^[-^[0IT>I(=H8)I1-IL(GD+H->^@$^@)HF
)@@G@@@H@@@#^@$CL5HD?I-(H0)G15H1<I-(H9,^[WE((IS)I(3G(=^[-IS)GC)I[3G(5G-\^[6GD2HG
)@@G@@HD-GL?G*)^8)@ @@@]^@)^@)^@)^@)^[!IT$^@1AC7 )7^@)@F@@@]^@$F-PHD3^[,H94^[3HH
)@@G@@I[>GT(G1(G(=^[-IS)I[\HD,I->IK)I1-IL(GD+H->^@$^@)@ @@@]^@)^@)^@)^@)^[!IT$HI
)@@G@@^@1AC8 )7^@)@D@@@]^@$F-PHD3^[-H(+HD$I(\I(3 0)D9,G*)GD4^[YE-5IT>G))^8)^@)HJ
)@@G@@@ @@@]^@)^@)^@)^@)^[!IT$^@1AC9 )3^@)@B@@@]^@$ET5GL3GT2HD0I->G))H--GL>H))HK
)@@G@@G(2IL\IK)^8)@ @@@]^@)^@)^@)^@)^[!IT$^@1AK0 )5^@)@C@@@]^@$D9,H-9^[\H1>^[0HL
)@@G@@H9(H14G(2^[0G(2^[\I[>IL-H1=^@$@ @@@]^@)^@)^@)^@)^[!IT$^@1AK1 )7^@)@D@@@]HM
)@@G@@^@$F-AHD3^[5IT>G))GD3^[-^[+GD3G(=^[6GD2HD-GL?G*)^8)^@)+@@@@@@#@]@[      HN
)@@G@@   MSG   0,2@#@]@[         MSG   5,2@#@]@[         MSG   6,2@#@]@[      HO
)@@G@@   MSG   7,2@#@]@[ 'NOT ASSIGNED '  @#@]@[         MSG   1,3@^@]@[ 'INVAHP
)@@G@@LID OPTION @C '   @#@]@[         MSG   2,3@^@]@[ 'TOO MANY MESSAGES '   HQ
)@@G@@@#@]@[         MSG   3,2@]@]@[ 'IO ERROR '@#@]@[         MSG   4,3@^@]@[HR
)@@G@@ 'TOO MUCH OUTPUT '     @#@]@[PART2    LABEL .  +@@@@[@^@@@]E[[ELOAK)^@)HS
)@@G@@^[GCD]C(G^@,+@@@@@@#@]@[         PT2   4 .+@@@@[@ @@@]^@)^@)^@)^@)^[KE)2HT
)@@G@@^@)^@6AC) 0)+@@@@@@#@]@[         END .    +@@@@[@^@@@]^@)^@)^@)^@)^[ D1^HU
)@@G@@^@,^@)___@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@]HV
)@@G@@ 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@] 0)^@)+@@@@@@[@]@[.     +@@@@[@[@@@]HW
)@@G@@*[S@@[*SDFF*@G@@@J 0)^@)CTJE[TELDC9CE))AC9A86^[]FC)E-CC*)E(IDDQC(METDE-THX
)@@G@@^[JC0)D([ELTD-[D1^@[@@@J 0)^@)@H@@@J 0)^@)EDPC(NE-DD9IES)CTJD1#C(MD1DD1BHY
)@@G@@^[OD[DES)ETCD9PD-^^[]C*)C-DEL CTOC(^^[OD8'@[@@@J 0)^@)@B@@@J 0)^@)^@)^@)HZ
)@@G@@^[HCDME1DD0)E0,^[UC(GDTJE9DE-U@E@@@J 0)^@)^@)^@)^[^C(KCDME-HC(IE))D9A^[#IA
)@@G@@D9HE[PE- EK)ET#DD D1#C*)@C@@@J 0)^@)^@)^@)^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGIB
)@@G@@CDIC))@E@@@J 0)^@)^@)^@)^[#D9GD- C9 ^[KCDMDS?^[HCDMFDGCDIC))AK0A84AK)^@)IC
)@@G@@@[@@@J 0)^@)@M@@@J 0)^@)^@)^@)^[KC(MD(DETNDDJD0)E-J^[PET ^[OD[ ET ^[GDDNID
)@@G@@E-DD1BES)CDIC))E-CC*)CTJD(KE(OC(M^[KELJC9MCDHES)E-CC(T@I@@@J 0)^@)EL E[MIE
)@@G@@C(NC(IE))DDN^[BEL[D1OC(^^[PD1^C(M^[OD[ ^[AD9GD-JE9DD1B^[#D9IC-DE-DD9IES'IF
)@@G@@@[@@@J 0)^@)@L@@@J 0)^@)^@)^@)^@1 0)E(ID-DD(DE- C))E(NC*)D([FC)CL ^[HCD^IG
)@@G@@C*)D9A^[OD[ ^[KELJC9MCDHES)EL E[MC(NC(IE- C))CLT@M@@@J 0)^@)E-CC(NC*)D-DIH
)@@G@@ETODDIC9N^[KELJE1DC- C))E-CCDO^[OD[ ^[ICDHC*)E[GE(H^[JEK)E(IDDQC(METDE-TII
)@@G@@^[JC0)D([ELTD-[D1^@J@@@J 0)^@)E[G 81^[#D9HE[DD- EK)EL D([DDIES)CDNETJCTDIJ
)@@G@@CDOC(^^[RDDOD@)E-CC(NC*)E[MD9BEL[D(N 0)^@)@[@@@J 0)^@)@K@@@J 0)^@)^@)^@)IK
)@@G@@^@2 0)D(JC-DC1DCT[E-DD9IES)D([FC)CL ^[HCD^C*)E-J^[OD[ ^[GDDNE-DD1BES)E[MIL
)@@G@@D9QDD^C(^BK)@[@@@J 0)^@)@M@@@J 0)^@)^@)^@)^@*CC(^[[D1T^[MC(NE(GE-DD1B^[KIM
)@@G@@ELJC9MCDH ))D9M^[MC(KD9ME)?^[KCDKC(M^[JEK)C-JCTPD( D1OCDODDJD0)^@)@M@@@JIN
)@@G@@ 0)^@)^@)^@)^[^C(NCTMDD]DDIC8)ETPCTC^[KELJC9MCDH^[RDDGD))CTGC([ELGFC)DDIIO
)@@G@@C-DCT[E- ^[OD[[E))E-CC*)E[MD9BEL[D*)@J@@@J 0)^@)^@)^@)^[DES)CC)C-DCDGC(#IP
)@@G@@E))D9A^[KD-PD*)D9M^[DES)C- ELDE1 C))C1MD9H^[KD-PD*?^[[D1^^@)@[@@@J 0)^@)IQ
)@@G@@@L@@@J 0)^@)^@)^@)^@*CK(^[[D-G^[NE(#D@)D(JC-DC1DCT[E-DD9IES?^[JE-CC(M^[OIR
)@@G@@D[[D0)E-MDDQDD[D))CTJELMC(#E-DD9IES)@K@@@J 0)^@)^@)^@)^[JC0)C(MELJELN^[DIS
)@@G@@D0)E-CC*)ETJE(MCT ^[KELJC9MCDHES?^[ND[[D-G^[]C*)EL E[JELOC(^^[[D1^@L@@@JIT
)@@G@@ 0)^@)^@)^@)^[[^[]ELDC(A^[^C(NCTMDDKE-DD9I^[JC0)E-CC*)C1 CDOE(MC*)CD^C- IU
)@@G@@C))ETCCDGD))CL ^[NE(]D(DE-OC(^@F@@@J 0)^@)^@)^@)^[OD8)E-CC*)E(IDDQC(METDIV
)@@G@@E-T^[JC0)D([ELTD-[D1^ ))CDIC))@[@@@J 0)^@)@L@@@J 0)^@)^@)^@)^@*CS(^[ID8)IW
)@@G@@E[MD9BEL[D(N^[^C(MDDQC(^^[AELJD*)E-CC(NC*)D-DETODDIC9N^[ND[[D-G^[]C*)ETJIX
)@@G@@D-^^@)@M@@@J 0)^@)^@)^@)^[RDDOD[JE(O^[RELDE-OC(I^[[E[KELJE1[D))C1MD9H^[OIY
)@@G@@D[ ^[PD1DE1 ELNDDOFC)D9A^[HCDMFDGCDIC)?^[[D1^^@)@[@@@J 0)^@)@L@@@J 0)^@)IZ
)@@G@@^@)^@)^@*C)(^[#D9KDD ES)D9A^[OD[ ET ^[KELJC9MCDHES)D([FC)CL ^[OEL[D1ND(DJA
)@@G@@E-OC(^^[OD8)D9OD[ EK)^@)@L@@@J 0)^@)^@)^@)^[GD9#CDODDJD1N^[KELJE1DC- C))JB
)@@G@@E-CCDO^[NE(#D@)E-MCDIETHDDOE-[D-N^[#D- CDMD-T^[DD1^DD#CDOC*)@L@@@J 0)^@)JC
)@@G@@^@)^@)^[RD[ E-CC(M^[OD[ ^[KELJC9MCDHES)CDMC*)C(SCD#E))CTJE[DC(N^[JC0)E-CJD
)@@G@@C*)E(IDDQC(METDE-T^[JC0)@J@@@J 0)^@)^@)^@)^[HCDMFDGCDIC))E[GE(H^[#D9HE[DJE
)@@G@@D- EK)D9M^[[EL ^[HD9^DDADD#CDODDJD1N^[OD8)DDO 0)@[@@@J 0)^@)@L@@@J 0)^@)JF
)@@G@@^@)^@)^@3 0)E-CC(NC*)CTJD1^DDODDJD1N^[JD1GFC)CDKE[GFC)E-J^[OD[ ^[KD-PD*)JG
)@@G@@CTJD(KDDGC(M^[DE-NC(GC0?@L@@@J 0)^@)CDIC))CDMC*)D1JE))D( CDIE))E-J^[[E[KJH
)@@G@@D-T^[OD8)CDIFC)E[MD9BEL[D*)E9MDDOE- D0)E(NDDIC8)E[GE(H 0)^@)@J@@@J 0)^@)JI
)@@G@@E-CC*)E[PELKD9NC*)D9A^[OD[ ET ^[#D9IC-DE-DD9IES)DDN^[OD8)CDGD-JE8)CDIFC)JJ
)@@G@@E(NC(M^[OD8)@L@@@J 0)^@)C(SE[ ELDD( D1O^[RDDOD@)E-CC*)CTJD(KDDGC(M^[[ES)JK
)@@G@@D-JD1B^[[ES)E-CC*)EL ETPD-ODDIC8)E[MD9^E(#E))^@)@M@@@J 0)^@)DDN^[ID9O^[NJL
)@@G@@D9GC))CDIC))CDN^[GD9IC8)CDN^[DE))DDN^[FD1JE9I^[OD[[E))E-CC*)E[MD9^E(#E))JM
)@@G@@C- E1 D-JE[ C))^@)@^@@@J 0)^@)C1MD9H^[KD-PD*,^@)@[@@@J 0)^@)@[@@@J 0)^@)JN
)@@G@@@[@@@J 0)^@)@[@@@J 0)^@)@[@@@J 0)^@)@[@@@J 8,^@)@ @@@ID(NC8%^@)^@)^[KELJJO
)@@G@@CS)^@%AC) 0)@C@@@IFLH K*D(NC8*AC?AC( C)C(LE*)A)% @= (KCDME)1 C) 0)@C@@@IJP
)@@G@@FLS K*D(NC8*AC?AC( C)^[ EDP^[HETB @1 )2 C) 0)^@)@^@@@I^@)^@)^@)^@)^[ D1^JQ
)@@G@@^@,^@)@^@@@IE[OAK%^@)^@)^[KELJCS) 0)@B@@@IC1H^@)^@)^@)^[AD9MD*)A0?AC2 )6JR
)@@G@@ )1AK) 0)^@)@M@@@IDS)^@)^@)^@)^[^D8)^@)^[KE)2 @1 )1 C) ))C1H^@:FLS @2 LFJS
)@@G@@ *2 C?FLH @2 LF *2 C?FLS @2 LF *1 C?FLH @2 LF *1 C) 0)@^@@@I^@)^@)^@)^@)JT
)@@G@@^[ D1^^@,^@)@^@@@I^@)^@)^@)^@)^[[F[M^)) 0)@^@@@I^@)^@)^@)^@)^[^CTGELB^@,JU
)@@G@@@ @@@ID(NC9N^@)^@)^[#ET CTO^@3^@,^@)@ @@@ID(NC84AC%^@)^@)^[GCD]C(G^@,^@)JV
)@@G@@@A@@@I^@)^@)^@)^@)^@:E[[ELOAK?E[[ELOAC) 0)@^@@@IE[[ELOAC)^@)^[GCD]C(G^@,JW
)@@G@@@ @@@I^@)^@)^@)^@)^[HETB^@)^@0 )4^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@4A0?A))JX
)@@G@@ 0)^@)@D@@@I^@$ET\IL2JC-^[AG(-I-5IL>^[,H94^[(H(0H->H(>H14G(=^@$^@,@ @@@JJY
)@@G@@^@)^@)^@)^@)^[HETB^@8AS?AK)^@)@ @@@J^@)^@)^@)^@)^[HETB^@9AC?AK)^@)@^@@@JJZ
)@@G@@^@$D1\I))GD3IT(G9,G(=^@$@A@J@I^@)^@)^@)^@)^[HETB^@)^@5AK?A*) 0)^@)@D@J@IKA
)@@G@@^@$E-\H8)H(-H19^[&HD?G(3 0)ET9IT0IL(H14^[5IT>G))^8) 0)@ @J@I^@)^@)^@)^@)KB
)@@G@@^[HETB^@)^@1 )2^@,@ @@@J^@)^@)^@)^@)^[HETB^@)^@1 )7^@,@B@@@J^@$B-#CDGD))KC
)@@G@@F-ACDO^[YE(AELJD*)F1QB0)^8) 0)@ @J@I^@)^@)^@)^@)^[HETB^@)^@2 )2^@,@ @@@JKD
)@@G@@^@)^@)^@)^@)^[HETB^@)^@2 )8^@,@D@@@J^@$B), 0, 1MC(OE(MD0)E-J^[WC1[E))F1QKE
)@@G@@C1MD9H^[YE*"^@$^@,@ @J@I^@)^@)^@)^@)^[HETB^@)^@5 )2^@,@ @J@I^@)^@)^@)^@)KF
)@@G@@^[HETB^@)^@6 )2^@,@ @J@I^@)^@)^@)^@)^[HETB^@)^@7 )2^@,@A@J@I^@)^@)^@)^@)KG
)@@G@@^[HETB^@)^@1AS?AK) 0)^@)@A@J@I^@)^@)^@)^@)^[HETB^@)^@1A0?AK) 0)^@)@A@J@IKH
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4A*?AK) 0)^@)@A@J@I^@)^@)^@)^@)^[HETB^@)^@1A@3 )2KI
)@@G@@^@,^@)@ @J@I^@$D1\I))GD3IT(G9,G(=^@$^@,^@)@ @@@I^@)^@)^@)^@)^[HETB^@)^@3KJ
)@@G@@ )2^@,@^@@@I^@$DC\D8)G(2IL\IK)^8) 0)@ @@@I^@)^@)^@)^@)^[HETB^@)^@4 )2^@,KK
)@@G@@@ @@@I^@$D(-J[(H(5H*)H95I-0I(4^@$^@,@ @@@J^@)^@)^@)^@)^[HETB^@)^@5 )3^@,KL
)@@G@@@A@@@J^@$F-PIL>GT\IL=^[\I1>IL&H-\I8)^8) 0)@ @@@J^@)^@)^@)^@)^[HETB^@)^@6KM
)@@G@@ )6^@,@D@@@J^@$C1(H->^[WE((IS)DT FD C),^[FC(T @0 C)I(3G(=^@$^@,^@)@ @@@JKN
)@@G@@^@)^@)^@)^@)^[HETB^@)^@7 )6^@,@D@@@J^@$C1(H->^[WE(,H94^[FC(TC(^ 0)DT FC)KO
)@@G@@HD$H1\IL>G))^8) 0)@ @@@I^@)^@)^@)^@)^[HETB^@)^@8 )5^@,@C@@@I^@$A00^[+HD4KP
)@@G@@IS)I(3G(=^[&H92^[,I(!GL>IK)^8) 0)^@)@ @@@I^@)^@)^@)^@)^[HETB^@)^@9 )5^@,KQ
)@@G@@@C@@@I^@$AC7^[=HD$HD4IS)I(3G(=^[&H92^[,I(!GL>IK)^8) 0)@A@@@I^@)^@)^@)^@)KR
)@@G@@^[HETB^@)^@1A@?A)) 0)^@)@B@@@I^@$D15H(+G(2^[\I(4^[\G0)IL-H1$G*)^8) 0)^@)KS
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@1AC?AS) 0)^@)@ @@@I^@$D1-H(>^[4H9\^[?H9,G8)KT
)@@G@@^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@1AK?AK) 0)^@)@ @@@I^@$DD?H->G9-H))IT9KU
)@@G@@H(+H9?^@$^@,@A@@@J^@)^@)^@)^@)^[HETB^@)^@1AS?A0) 0)^@)@E@@@J^@$EL CTJEL^KV
)@@G@@^[&HD?G*)I(3G(=^[&H92^[NE-MC([D*)DC\D8)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETBKW
)@@G@@^@)^@1A)?A)) 0)^@)@D@@@I^@$D15H(+G(2^[-GT2H93IS)H-(H1>^[+H95H1=GD2JC)^8)KX
)@@G@@ 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@1A*?A)) 0)^@)@D@@@I^@$ET4IL(H1$^[-GT2KY
)@@G@@H93IS)H-(H1>^[+H95H1=GD2JC)^8) 0)^@)@A@@@J^@)^@)^@)^@)^[HETB^@)^@1A0?A0)KZ
)@@G@@ 0)^@)@E@@@J^@$ETOEL CDH^[&HD?G*)I(3G(=^[&H92^[MC(#D9MC))DC\D8)^8) 0)^@)LA
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@1A8?AC) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2LB
)@@G@@A@?AC) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2AC?AC) 0)^@)@#@@@I^@$D15H(+G(2LC
)@@G@@^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@1B@?AC) 0)^@)@A@@@I^@)^@)^@)^@)^[HETBLD
)@@G@@^@)^@1BC?AC) 0)^@)@^@@@I^@$C(8I[\H1>H14^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETBLE
)@@G@@^@)^@2AK?A*) 0)^@)@E@@@I^@$CL5HD?I-(H0)G15H1<I-(H9,^[5IT>G))GD3^[6GD2HD-LF
)@@G@@GL?G*)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2AS?AK) 0)^@)@ @@@I^@$D1\IL!GD?LG
)@@G@@^[>J[(I))^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2A)?AK) 0)^@)@ @@@I^@$E[2LH
)@@G@@H9$IL-H*)IT4H90^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2A*?A0) 0)^@)@C@@@ILI
)@@G@@^@$C[]G1(H->^[,H94^[-^[0IL(H14^[&HD?G*)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETBLJ
)@@G@@^@)^@2A0?A0) 0)^@)@B@@@I^@$C[]G1(H->^[WC1(IS)H1\I))H90G(,^@$^@,^@)@A@@@ILK
)@@G@@^@)^@)^@)^@)^[HETB^@)^@2A8?A)) 0)^@)@C@@@I^@$DD?H->G9-H))G1\IL!GD4^[?GD+LL
)@@G@@G(?^[WCK)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2B@?A0) 0)^@)@C@@@I^@$C1(LM
)@@G@@H->^[WE(,H94^[\I[>H0)G1\IK)HD,I[5I))^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@2LN
)@@G@@BC?AS) 0)^@)@ @@@I^@$C1(H->^[WE1>IL2H92^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETBLO
)@@G@@^@)^@3A@?AS) 0)^@)@A@J@I^@$^(PH90I-(H9,^[(H16GD?HD=^@$^@,^@)@A@@@J^@$C[PLP
)@@G@@H90I-(H9,^[(H16GD?HD=^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3AC?A)) 0)^@)LQ
)@@G@@@A@J@I^@$^(PHD3^[(H16GD?HD=^[,GD!G*)^8) 0)@A@@@J^@$B9(IS)HD,I1-H-(G))H1-LR
)@@G@@H(>^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3AK?AS) 0)^@)@ @@@I^@$C(,G))H9&LS
)@@G@@^[3I-2HD,G8)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3AS?AS) 0)^@)@ @J@I^@$C[PLT
)@@G@@HD3^[(H-?G($GD?^@$^@,^@)@ @@@J^@$B9(IS)HD?H->G9-H))^8) 0)^@)@A@@@I^@)^@)LU
)@@G@@^@)^@)^[HETB^@)^@3A)?A*) 0)^@)@B@@@I^@$F-PH1\I))H90G(,^[&H92^[\I(4I[5I))LV
)@@G@@^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3A*?A8) 0)^@)@E@@@I^@$CD4I->H(0I))I-\LW
)@@G@@^[2G(-G))I[-IT4^[>H1=^[\G0)G1(H->^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3LX
)@@G@@A0?A8) 0)^@)@E@@@I^@$CD4I->H(0I))I-\^[2G(-G))I[-IT4^[>H1=^[\G0)IT4IL(H1$LY
)@@G@@^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@3A8?AS) 0)^@)@A@@@I^@$F-AIT4IL5GT4I(2LZ
)@@G@@G*)G(2IL\IK)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3B@?A0) 0)^@)@C@@@I^@$F-PMA
)@@G@@H1\I))GD?H-\I9>G))HD,^[$G(4^[?HD3I))^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@3MB
)@@G@@BC?AS) 0)^@)@ @@@I^@$F-PGD2IL-JC)G(2IL\IK)^8) 0)@A@J@I^@)^@)^@)^@)^[HETBMC
)@@G@@^@)^@4A@?AK) 0)^@)@A@@@J^@)^@)^@)^@)^[HETB^@)^@4A@?AS) 0)^@)@ @J@I^@$C(2MD
)@@G@@IL\IK)I-\HT>H0)^8) 0)^@)@ @@@J^@$C(2IL\IK)I-\HT>H0)B8)^8) 0)@A@@@I^@)^@)ME
)@@G@@^@)^@)^[HETB^@)^@4AC?A*) 0)^@)@B@J@I^@$F-PGL\I(,G))G(2IL\IK,^[YE95IT>G))MF
)@@G@@^8) 0)@B@@@J^@$C[PGL\I(,G))G(2IL\IK,^[YE95IT>G))^8) 0)@A@@@I^@)^@)^@)^@)MG
)@@G@@^[HETB^@)^@4AK?AS) 0)^@)@ @@@I^@$F-PGL\I(,G))G(2IL\IK)^8) 0)@A@@@I^@)^@)MH
)@@G@@^@)^@)^[HETB^@)^@4AS?AS) 0)^@)@ @@@I^@$F-PH1-H(>^[>IL2H92^@$^@,^@)@A@@@IMI
)@@G@@^@)^@)^@)^@)^[HETB^@)^@4A)?A*) 0)^@)@A@J@I^@$F-PH1\I))HD,^[$G(4^[?HD3I))MJ
)@@G@@^8) 0)@A@@@J^@$F-PH1\I))HD,^[BC(O^[?HD3I))^8) 0)@A@@@J^@)^@)^@)^@)^[HETBMK
)@@G@@^@)^@4A*?A0) 0)^@)@D@@@J^@$F-BH1\I))GD?H-\I9>G))HD,^[MC(#D9MC))DC\D8)^8)ML
)@@G@@ 0)^@)@[@@@J 0)^@)@H@@@J 0)^@)^@)^@)^[!IT$^[,I(!GL>IK)A)6^[(IS)I-*G*)IT-MM
)@@G@@H(>^[-IS)H(>IT3GD$G*)A@) 0)^@)@[@@@J 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@4MN
)@@G@@A8?A)) 0)^@)@D@@@I^@$E(,HT,H97H0)H1-H(> 0)ET4IL(H1$^[-IT3I(!G(=^@)^8) 0)MO
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@4B@?AK) 0)^@)@A@@@I^@$C->H->I->G))IT4GD4G(!MP
)@@G@@G(,I))^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@4BC?A)) 0)^@)@C@@@I^@$EL5H0)I-(MQ
)@@G@@H(>^[3I--GT:^[\I1>IL&H-\I8)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@5A@?AK)MR
)@@G@@ 0)^@)@B@@@I^@$ET4IL(H1$^[5H1(H1(I-(GD?HD'G(=^@$^@,^@)@A@@@I^@)^@)^@)^@)MS
)@@G@@^[HETB^@)^@5AC?B@) 0)^@)@H@@@I^@$DD?H->G9-H))GT*GD2GD<I->IK)HD,^[+HD4^[3MT
)@@G@@I-2HD,G8)GT*GD,G9>G))I-\^@1^@$^@,^@)@A@@@J^@)^@)^@)^@)^[HETB^@)^@5AK?A*)MU
)@@G@@ 0)^@)@D@@@J^@$E-\H8)H(-H19^[&HD?G(3 0)ETTETKELDD1O^[5IT>G))^8) 0)@A@@@JMV
)@@G@@^@)^@)^@)^@)^[HETB^@)^@5AS?A0) 0)^@)@A@J@I^@)^@)^@)^@)^[HETB^@)^@5AS?A0)MW
)@@G@@ 0)^@)@E@J@I^@$DD!I[2H90G(2^[-IL$I(!G(,I))I-\^[2GD,G),^@,A*)I(3G(=^@$^@,MX
)@@G@@@E@@@J^@$DD!I[2H90G(2^[-IL$I(!G(,I))I-\^[MCDIC),^@,A*)I(3G(=^@$^@,@A@@@IMY
)@@G@@^@)^@)^@)^@)^[HETB^@)^@5A)?AC5^@,^@)@K@J@I^@$E[2H9$IL-H*)IT4GD4HD3I-(GT3MZ
)@@G@@^@*I9\IL=IS(BK)E[2H9$IL-H*'^[YE0)ET9H(+H9?^[4GD+H->BK)F1O^@$^@,^@)@J@@@JNA
)@@G@@^@$E[2H9$IL-H*)IT4GD4HD3I-(GT3^@*I9\IL=IS(BK)E[2H9$IL-H*'^[YE1NJD!GL\H))NB
)@@G@@I--GL?G*'^[YE)$^@,@G@J@I^@$ET4GD4HD<IS'^[YE*)EL5H14HD!G*)IT4GD<HS'^[YE8)NC
)@@G@@E(,I(3G(=BK)F1S^@$^@,^@)@F@@@J^@$ET\I(2GT>BK)F1PEL5H14HD!G*)IT4GD<HS'^[YND
)@@G@@E9PH15IT>G)'^[YF@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@5A*?A0) 0)^@)@I@@@INE
)@@G@@^@$D(-I-*G(!GD4HD<GD?^[+I((H-4^[(H0)G15H1<I-(H9, 0)ET4GD4G(!G(,I))HD$H1\NF
)@@G@@IL>G))^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@5A0?AK) 0)^@)@A@@@I^@$E(,G->G1(NG
)@@G@@H1>G))G(,I-2JC)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@5A8?AS) 0)^@)@A@@@INH
)@@G@@^@$F-BI(3G(=^[2G(<I(2IT(I1>H-9^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@5B@?AC)NI
)@@G@@ 0)^@)@]@@@I^@$F-B^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@5BC?BC) 0)^@)@F@@@INJ
)@@G@@^@$F1OHD3^[(H(0IL\I[>IK)H->H1$I-*^[&H92^[WC*,^@8A@)I(3G(=^@$^@,^@)@A@@@INK
)@@G@@^@)^@)^@)^@)^[HETB^@)^@6A@?AC0^@,^@)@H@@@I^@$D-\I9>IK)GL\I(,G))H9,^[3I(+NL
)@@G@@IT<IL(I[4^[YD1\G0)F- B0)I(0I[>IK)GL\I(,G))^8) 0)@A@@@I^@)^@)^@)^@)^[HETBNM
)@@G@@^@)^@6AC?AC0^@,^@)@J@@@I^@$EL>I-5IL,^[&IL\H*)F-DGD4^[?HD,G*)F1MIL>ID5HD2NN
)@@G@@G(3^[<H9,I1>IL3HD\H0,^@0^[5IT>G))^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@6NO
)@@G@@AK?AC7^@,^@)@O@M@I^@$EL>I-5IL,^[&IL\H*)F-DGD4^[?HD,G*)F1MG-\G(3^[,H94^[2NP
)@@G@@G(4I(2H0)I1-H-5G*)G(8I[>GT4G(=^[-I))H-(H1>^[YCS,^@0^[5IT>G))^8) 0)@O@@@MNQ
)@@G@@^@$EL>I-5IL,^[&IL\H*)F-DGD4^[?HD,G*)F1NG-\G(3^[,H94^[2G(4I(2H0)I1-H-5G*)NR
)@@G@@G(8I[>GT4G(=^[-I))H-(H1>^[YCS,^@0^[5IT>G))^8) 0)@A@@@I^@)^@)^@)^@)^[HETBNS
)@@G@@^@)^@6AS?AC5^@,^@)@M@J@I^@$EL>I-5IL,^[&IL\H*)F-DGD4^[?HD,G*)F1MIL>I-5IL,NT
)@@G@@IS)GC)I1-H-5G*)I-\^[<GD?H))IT4GD4G(!G(,I))GD4^[?HD,G*)F1#^@$@N@@@J^@$EL>NU
)@@G@@I-5IL,^[&IL\H*)F-DGD4^[?HD,G*)F1MIL>I-5IL,IS)GC)I1-H-5G*)I-\^[#CDGD))IT4NV
)@@G@@GD4G(!G(,I))GD4^[?HD,G*)F1#^8) 0)^@)@[@J@I^@,^@)@A@@@I^@)^@)^@)^@)^[HETBNW
)@@G@@^@)^@6A)?A)) 0)^@)@C@J@I^@$E(,G->G1(H1>G))H--GL>H))HD,^[$H94H8)^8) 0)^@)NX
)@@G@@@C@@@J^@$E(,G->G1(H1>G))H--GL>H))HD,^[BD9OD8)^8) 0)^@)@A@@@I^@)^@)^@)^@)NY
)@@G@@^[HETB^@)^@6A*?A)) 0)^@)@B@J@I^@$C1\IL!GD4^[?GD+G(?^[(H0)G9\I-\^@$^@,^@)NZ
)@@G@@@B@@@J^@$C1JELHCDO^[?GD+G(?^[(H0)C9JE-J^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETBOA
)@@G@@^@)^@6A0?BC) 0)^@)@F@@@I^@$D--GL>H))F-JHD,^[?HD,G*)F1#H1\I))HD,^[-GT4HD6OB
)@@G@@G*)GL?H9<HS)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@6A8?AC1^@,^@)@M@J@I^@$F-^OC
)@@G@@HD,I1\HT>G))G1\IK)HD,HD4HD-H-(JL-I-(H9,^[(H0)F1#I->IL!HD,GD4G(3^[(H0)GC)OD
)@@G@@G9\I-\^[3I--I->H(>H14^@$^@,^@)@M@@@J^@$F-^HD,I1\HT>G))G1\IK)HD,HD4HD-H-(OE
)@@G@@JL-I-(H9,^[(H0)F1#I->IL!HD,GD4G(3^[(H0)GC)C9JE-J^[3I--I->H(>H14^@$^@,^@)OF
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@6B@?AC1^@,^@)@J@J@I^@$CD4I->H(0I->G))G9\I-\OG
)@@G@@^[4H8)H--GL>H))F-JHD,I-\^[(H1-GT4HD6G*)G-\^[-I))H-(H1>^[YCS)^8) 0)@J@@@JOH
)@@G@@^@$CD4I->H(0I->G))G9\I-\^[4H8)H--GL>H))F-JHD,I-\^[(H1-GT4HD6G*)C-J^[-I))OI
)@@G@@H-(H1>^[YCS)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@6BC?A8) 0)^@)@J@@@I^@$D(5OJ
)@@G@@H-4HD0H-(G(2^[\I1>IL&H-\I8)G-5IL(H1$^[(H1(I-(GD?HD'GD4HD\H0)H9&^[-IL2GD9OK
)@@G@@^[WC*)^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7A@?A8) 0)^@)@F@@@I^@$C(8I->H14OL
)@@G@@IS)H9&^[WC-=H8)H1\I))H(-I-<H@)G(8I[2G(3IT(H9,^@$^@,^@)@A@@@I^@)^@)^@)^@)OM
)@@G@@^[HETB^@)^@7AC?A8) 0)^@)@F@@@I^@$CL\I(,G-3^[\G0)F-^G-\^[,H94^[!GD4GT*^[>ON
)@@G@@J[0IL>IT3HD\H0)^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7AK?AS) 0)^@)@A@@@IOO
)@@G@@^@$F-^H1\I))GD?H-\GT-I->G))^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7AS?A8)OP
)@@G@@ 0)^@)@E@@@I^@$D->H1$I-*^[YEL\G0)F- HD!I[2H90G(2 0)B@0^[5IT>G))^8) 0)^@)OQ
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@7A)?B@) 0)^@)@E@@@I^@$E(0I[>IK)GL\I(,G))F1LOR
)@@G@@B))H-\I9>IK)GL\I(,G))H9&^@1^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7A*?BC)OS
)@@G@@ 0)^@)@G@@@I^@$F1LHD3^[4H9\^[?GD2G9>^[?G(,G94H@)H92^[+H95H1= 0)AC0^[5IT>OT
)@@G@@G))^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7A0?B@) 0)^@)@E@@@I^@$ET5GL3GT2OU
)@@G@@HD0I))F1]H9&^[WD1(IS)H95I))H9&^[+H95H1=^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETBOV
)@@G@@^@)^@7A8?A8) 0)^@)@E@@@I^@$ET5GL3GT2HD0I))HD3^[\I(4^[\G0)GL\I(,G-3^[(H0)OW
)@@G@@F-^^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7B@?AS) 0)^@)@B@J@I^@$DD,I1-H-(OX
)@@G@@G))G1\IL!GD4^[\I[4HD\H0$^@,^@)@B@@@J^@$DD,I1-H-(G))C1JELHCDO^[\I[4HD\H0$OY
)@@G@@^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@7BC?AK) 0)^@)@A@@@I^@$DD!I[?HD>G))GT\OZ
)@@G@@H16G(2IT(H9,^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@8A@?AK) 0)^@)@^@@@I^@$ET(PA
)@@G@@JL>^[>IL2H92^@$^@,@A@@@I^@)^@)^@)^@)^[HETB^@)^@8AC?AK) 0)^@)@A@@@I^@$CT\PB
)@@G@@H16G(2IT(H9,^[>IL2H92^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@8AK?A)) 0)^@)PC
)@@G@@@C@@@I^@$DD?H->G9-H))GT*GD2GD<I->IK,^@0^[5IT>G))^8) 0)@A@J@I^@)^@)^@)^@)PD
)@@G@@^[HETB^@)^@8AS?AS) 0)^@)@ @J@I^@$F-AH90I-(H9,^[>IL2H92^@$^@,@A@@@I^@)^@)PE
)@@G@@^@)^@)^[HETB^@)^@8A)?A*) 0)^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@8A*?A*) 0)^@)PF
)@@G@@@C@@@I^@$C(2IL\IK)HD,^[\I[>H1(H1$^[&HD?G*)F- ^@$^@,^@)@A@@@I^@)^@)^@)^@)PG
)@@G@@^[HETB^@)^@8A0?AC) 0)^@)@#@@@I^@$ET(G9,GD?^@$^@,@A@@@I^@)^@)^@)^@)^[HETBPH
)@@G@@^@)^@8A8?AC) 0)^@)@^@@@I^@$CL2G(-HT0H9(H14^@$^@,@A@@@I^@)^@)^@)^@)^[HETBPI
)@@G@@^@)^@8B@?BC) 0)^@)@K@@@I^@$C1(J[>G))G->GT(H(-H))H96G(2G1?H97 0)D15H(+G(2PJ
)@@G@@^[<H9,IT(IT4HD,G8)H9&^[YC1,HD,G(3^[5IT>G))^8) 0)@]@J@IETKCD#C*) 0)@A@@@IPK
)@@G@@^@)^@)^@)^@)^[HETB^@)^@8BC?BC) 0)^@)@K@@@I^@$C1(J[>G))GL(H1-IL9^[\I1>IL&PL
)@@G@@H-\I8,^[II(!GL>IK)GT\H13HD3I-(H1$^[\G0)F1AH9,G(3^[5IT>G))^8) 0)^@)@A@@@IPM
)@@G@@^@)^@)^@)^@)^[HETB^@)^@9A@?AC0^@,^@)@L@@@I^@$ET(JL>^[>IL2H92^[<H9,I1>IL4PN
)@@G@@HD,G8)G1?H9-I))H92^[&HD8G(=^[=G(<HD!GD?^[4H8)G1(J[>G))GL(H1-IL9^@$^@,^@)PO
)@@G@@@A@J@I^@)^@)^@)^@)^[HETB^@)^@9AC?A0) 0)^@)@E@J@I^@$C(,G-&HD?G*,^[AHD?G*)PP
)@@G@@H1\I))H90G(,^[&H92^[(H10I(4^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@9AK?A*)PQ
)@@G@@ 0)^@)@D@@@I^@$C1(J[>G))GL(H1-IL9^[\I1>IL&H-\I8,^@1^[5IT>G))^8) 0)@A@@@IPR
)@@G@@^@)^@)^@)^@)^[HETB^@)^@9AS?A0) 0)^@)@D@@@I^@$D96G(2G1?H97^[(H0)G15H1<I-(PS
)@@G@@H9,^[@E*0^[5IT>G))^8) 0)@A@@@I^@)^@)^@)^@)^[HETB^@)^@9A)?A8) 0)^@)@F@@@IPT
)@@G@@^@$DD?H->G9-H))GD2G95H(>H14^[&H92^[&I(,GT4HD\H0)C[PA@)I(3G(=^@$^@,@A@@@JPU
)@@G@@^@)^@)^@)^@)^[HETB^@)^@9A*?A)) 0)^@)@D@@@J^@$CT\H(0H->J@)G15H1<I-(H9,^[,PV
)@@G@@H94^[(H13I--H-?G(=^@$^@,@G@@@I^@)^@)^@)^@)^[HETB^@)^@9A0?A0) 0)^@)^@)^@)PW
)@@G@@^@)E9[D-FCL[CTF^[#D9HD([D1^^@,@C@@@I^@$CD4^[?HD,G*)F1PHD,^[0IL\GT>G-5IL>PX
)@@G@@^[WE0)^8) 0)@G@@@I^@)^@)^@)^@)^[HETB^@)^@9A8?A8) 0)^@)^@)^@)^@)E9[D-FCL[PY
)@@G@@CTF^[#D9HD([D1^^@,@G@@@I^@$CT-H-?G(=^[&IL\H*)IT4GD4G(!G(,I))F1PHD,^[0IL\PZ
)@@G@@GT>G-5IL>^[WE0)^8) 0)^@)@A@J@I^@)^@)^@)^@)^[HETB^@)^@9A*?A)) 0)^@)@D@J@IQA
)@@G@@^@$CT\H(0H->J@)G15H1<I-(H9,^[,H94^[(H13I--H-?G(=^@$^@,@A@@@I^@)^@)^@)^@)QB
)@@G@@^[HETB^@)^@9B@?A0) 0)^@)@C@J@I^@$C@)H95I))H9&^[2GD,G9>^[(H0)IT5GL3I-2^@$QC
)@@G@@^@,^@)@C@@@J^@$C[AH95I))H9&^[2GD,G9>^[(H0)ETPCLNE-M^@$^@,^@)@A@@@I^@)^@)QD
)@@G@@^@)^@)^[HETB^@)^@9BC?AC2^@,^@)@G@@@I^@$C[PHD3^[,H94^[7HD4H[(H0)IL-H1$G*)QE
)@@G@@AC)I-\^[@E0,^@1^[(IS)I(3G(=^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@1A@0 )6QF
)@@G@@^@,^@)@E@@@I^@$CD4I->H(0I->G))G-(I1(IT(H9,^[+JC)A@,^@1^[5IT>G),^@$^@,^@)QG
)@@G@@@A@@@I^@)^@)^@)^@)^[HETB^@)^@1A@1 )5^@,^@)@F@@@I^@$C9\I-\^[(H-?G($GD?^[?QH
)@@G@@GD+G(? 0)C(8G(<I(4HD\H0)H[-H-4G(=^@$^@,^@)@A@@@I^@)^@)^@)^@)^[HETB^@)^@1QI
)@@G@@A@2 )6^@,^@)@H@@@I^@$CT-H-?^[4H8)HD?H->G9-H))G15H1<I-(H9, 0)C(8G(<I(4HD\QJ
)@@G@@H0)GT\H14HD,I(>IS)^8) 0)@A@@@J^@)^@)^@)^@)^[HETB^@)^@1A@3 )6^@,^@)@F@@@JQK
)@@G@@^@$D1>G9-I-(I1>^[<H95H14^[(H0)GL5HD?I-(H0)G15H1<I-(H9,^[@E*)^8) 0)@A@@@JQL
)@@G@@^@)^@)^@)^@)^[HETB^@)^@1A@4 )6^@,^@)@G@@@J^@$ETTETDD0\ETTETKELDD1O^[,H94QM
)@@G@@^[-H-?H97G(=^[(H0)EL CTJEL^^[D 9J^@$^@,^@)@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)QN
)@@G@@^@1A@5 )5^@,@D@@@J^@$DD?H->G9-H))H92^[IE(GD))I[\HD,I->IK)I(3G(= 0)^8) 0)QO
)@@G@@@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1A@6 )5^@,@D@@@J^@$DD?H->G9-H))H92^[IE(GQP
)@@G@@D-J^[\G1&IT>I))I(3G(= 0)^8) 0)@B@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1A@7 )1A@)QQ
)@@G@@ 0)^@)@H@M@J^@$D1\I-*HD,G8)I[\HD,I-3^[4H8)F-GGD,JC)H-\H1$G(2 0)DD4^[7HD?QR
)@@G@@H))GL>^[&IL>G(=^@$@H@@@M^@$D1\I-*HD,G8)I[\HD,I-3^[4H8)F-LGD,JC)H-\H1$G(2QS
)@@G@@ 0)DD4^[7HD?H))GL>^[&IL>G(=^@$@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1A@8 )6^@,QT
)@@G@@@E@@@J^@$ET4IL5GT4I(2G(3^[=H8)H1\I))H[-I1>^[3GD!G*)G(?G(!G(,I-3^@$@A@@@JQU
)@@G@@^@)^@)^@)^@)^[!IT$^@)^@)^@1A@9 )8^@,@E@@@J^@$E1-H-5G*)H9&^[0H9(H14G(2^[WQV
)@@G@@D1=H9>IS)H1\I))H(-I-<H@)F-J^@$@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1AC0 )7^@,QW
)@@G@@@I@@@J^@$DD?H->G9-H))H9&G13G(4^[4H8)I[\HD,I->IK)GT\H16G(2IT(H9, 0)D1PD-GQX
)@@G@@^[5IT>G))^8) 0)^@)@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1AC1 )7^@,@I@@@J^@$DD?QY
)@@G@@H->G9-H))I[\HD,I->IK)I-\^[\G1&IT>I))GT\H16G(2IT(H9, 0)D1PD-GD8)I(3G(=^@$QZ
)@@G@@^@,^@)@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1AC2 )7^@,@E@@@J^@$E92H9,G8)GD2G(-RA
)@@G@@^[3I[>GT(G1(G(=^[(H0)C1MC( ^[3I-!I))^8) 0)@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)RB
)@@G@@^@1AC3 )7^@,@H@@@J^@$CD4I->H(0I))I-\^[&IL>G*)ETOCDODD#^[\IK)CDPE-JD([E-DRC
)@@G@@CS)I1-IL(GD+H->^@$^@,^@)@A@@@J^@)^@)^@)^@)^[!IT$^@)^@)^@1AC4 )5^@,@E@@@JRD
)@@G@@^@$CD2G(-^[&I(?H)?^[-H-?H9<GD4HD\H0)H1\I))I[\IT3HD+H->^@$^@,@A@@@J^@)^@)RE
)@@G@@^@)^@)^[!IT$^@)^@)^@1AC5 )8^@,@H@@@J^@$CD4I->H(0I))I-\^[&IL>G*)IT4H92GD$RF
)@@G@@G*)I-*GD4^[7GD3^[,H94^[-H-?H9<GD4G(=^@$^@)@A@L@K^@)^@)^@)^@)^[HETB^@)^@)RG
)@@G@@^@1AC6 )8^@,@B@@@L^@)^@)^@)^@)^[HETB^@)^@)^@1AC6 )1A@) 0)^@)@I@L@K^@)^@)RH
)@@G@@^@)^@)^@$C[PHD3^[(G9,H92G(=^[(H0)I[2H9$IL-H*)G1(H->^[\IK)EL CTJEL^^[D 9JRI
)@@G@@^@$^@)@K@@@L^@)^@)^@)^@)^@$C[PH90I-(H9,^[(IS)HD$H1\IL>G))HD,^[0IL\G92GD!RJ
)@@G@@^[&HD?G*)H92^[MC(#D9MC))DC\D8)^8)^@)@^@@@IE[[ELOAK)^@)^[GCD]C(G^@,@ @J@IRK
)@@G@@^@)^@)^@)^@)^[KE)2^@)A*2^@,^@)@ @L@J^@)^@)^@)^@)^[KE)2^@)A*8^@,^@)@ @@@LRL
)@@G@@^@)^@)^@)^@)^[KE)2^@)A*9^@,^@)@^@@@I^@)^@)^@)^@)^[ D1^^@,^@)___D->H1$I-*RM
)@@G@@^[YEL\G0)F- HD!I[2H90G(2 0)B@0^[5IT>G))^8) 0)^@)@A@@@I^@)^@)^@)^@)^[HETBRN
)@@G@@^@)^@7A)?B@) 0)^@)@E@@@I^@$E(0I[>IK)GL\I(,G))F1LB))H-\I9>IK)GL\I(,G))H9&RO
)@@G@@*[S@@@*SDFF*@C@@@'.   COPYRIGHT 1976 BY THE UNIVERSITY OF MARYLAND@[@@@'RP
)@@G@@.     @D@@@'.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@'RQ
)@@G@@.     @ @@@'.        MARVIN V. ZELKOWITZ  @B@@@'.        DEPARTMENT OF CRR
)@@G@@OMPUTER SCIENCE   @A@@@'.        UNIVERSITY OF MARYLAND     @B@@@'.     RS
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@'.     @G@@@'.        PERMISSIORT
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@'.   REPRESENRU
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@'.     @G@@@'.     RV
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@'RW
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDRX
)@@G@@@E@@@'.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@'RY
)@@G@@.     @F@@@'.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDRZ
)@@G@@ED:   @[@@@'.     @G@@@'.        (A) ANY RESULTING PROGRAM, OR REPORT, PSA
)@@G@@APER OR DOCUMENTATION   @G@@@'.        DESCRIBING SUCH PROGRAM WILL CLEASB
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@'.        IS A DIALECT OF PLUM OR IS SC
)@@G@@DERIVED FROM PLUM, AND  @[@@@'.     @G@@@'.        (B) ALL SUCH MODIFICASD
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@'.        OF ERRORS IN THSE
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@'.        A BRIEF DESCRIPSF
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@'.        TO THE UNSG
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@'.     @F@@@'.        (C) NO PROGRAMSSH
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@'.        WITHOUT WRITTENSI
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@'.     @F@@@'.     SJ
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@'.     SK
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@'SL
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     SM
)@@G@@@E@@@'.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@'SN
)@@G@@.     @G@@@'.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERSO
)@@G@@ ITSELF,    @F@@@'.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN SP
)@@G@@USING PLUM. @E@@@'.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USSQ
)@@G@@ER TO @F@@@'.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRSR
)@@G@@ODUCT @G@@@'.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT SS
)@@G@@DEVELOPED   @#@@@'.   FROM PLUM.    @[@@@'.     @[@@@'.     @[@@@'.     ST
)@@G@@@[@@@'.     @[@@@'.     @[@@@'/.    @#@@@9/        AXR$  .  @#@@@9      SU
)@@G@@   DCLRG  . @[@@@9 .    @^@@@9 .       SETUP DSECTS   @B@@@9 .       ADDSV
)@@G@@ PLTVDS,PLCGST,PLDSAW,PLCSAW  @#@@@9         UNLIST . @#@@@9@ADD,P PLTVDSW
)@@G@@S     @#@@@9@ADD,P PLCGST     @#@@@9         LIST .   @#@@@9@ADD,P PLDSASX
)@@G@@W .   @#@@@9         PLAC  .  @]@@@9        PLAR@#@@@9         PLSD  .  SY
)@@G@@@#@@@9         PLCGD  . @#@@@9         PLWORD  .@#@@@9         PLIG .   SZ
)@@G@@@#@@@9@ADD,P PLCSAW     @^@@@9/CGDRVR   CSECT 3 .     @ @@@9 .  LABELS TTA
)@@G@@HAT WILL STAY HERE@E@@@9ERCGPRM EQU  27 . PARAMETER IN I/O LIST OR CHECKTB
)@@G@@ PREFIX     @B@@@9ERCGSL EQU 28 . STRING LENGTH OUT OF RANGE@D@@@9ERVG02TC
)@@G@@ EQU 34 . VBLE HAS A '*' FOR BOUND OR LENGTH    @H@@@'ERBLOC   EQU     3TD
)@@G@@9 .              BEGIN BLOCK HAS NO VARS, SHOULD USE DO;    @C@@@9ERVG03TE
)@@G@@ EQU 35 .  ''   '' NON-'*'  ''      ''    @E@@@9ERVG01 EQU 36 . CONSTANTTF
)@@G@@ BND OR LNGTH FIELD EXCEEDS 32767   @A@@@9ERVG04 EQU 33 . INIT NOT IMPLETG
)@@G@@MENTED@B@@@9ERCXBD EQU 30 . LOWER BOUND > UPPER BOUND @B@@@9ERCXMP EQU 3TH
)@@G@@2 . UB REQUIRES TOO MUCH SPACE@B@@@9ERCXV0 EQU 31 . LB   ''        ''   TI
)@@G@@  ''  @F@@@9ERXGRN   EQU   52 .              NONSTANDARD PL/1 OPTION USETJ
)@@G@@D     @E@@@9EXCLS0   EQU     37 .              UNEXPECTED BITS IN SD    TK
)@@G@@@]@@@9      CEND .@H@@@9KKHWMX   SF    +0202177777700 . CHECK FOR HALFWOTL
)@@G@@RD OVERFLOW OF FLOAT CNST     @F@@@9KKMASK   SF    +017000000 .        MTM
)@@G@@ASK FOR  X FIELD OF INSTRT    @E@@@9KKLXUX   SF    +013742 .            TN
)@@G@@OPCODE FUDGE FOR LX,U X2@E@@@9KKLMJX   SF    +036262 .            OPCODETO
)@@G@@ FUDGE FOR LMJ X2 @C@@@9KKXFLD   SF    +01000000 .         MASK FOR X1  TP
)@@G@@@H@@@9KKSNSM   SAC   +010000,0777777 . ARRAY V.O. INITIALIZATION INTERRUTQ
)@@G@@PT WORD     @E@@@9FIXER    SFW 0 . CREATE DUMMY STACK ELEMENT FOR INITIATR
)@@G@@L     @ @@@9         +SD0ART,SDDCBN,0,17 .@B@@@9KBXHMP   EQU   17 . HALFTS
)@@G@@WORD MAX PRECISION@C@@@9MXSTLN   EQU   01000 . MAXIMUM STRING LENGTH    TT
)@@G@@@B@@@9KBXMXP EQU  35 . MAX PREC. FOR FIXED BIN  @B@@@9ICSCHF EQU 0200 . TU
)@@G@@ CHECK/NOCHECK PRESENT  @F@@@9FLGSIE   EQU   01 .                SINGLE TV
)@@G@@ITERATION ENCOUNTERED   @F@@@9FLGNIF   EQU   02 .                NEGITIVTW
)@@G@@E CONSTANT ITER FACT    @E@@@9DDGCHK   INSERT  5,'CHE','CK  ' .  CHECK ITX
)@@G@@S NONSTANDARD PL1 @[@@@9 .    @[@@@9.     @#@@@9. =============== @E@@@9TY
)@@G@@        LIT .      SUBSEQUENT LITERALS ARE UNDER L.C. 3     @^@@@9      TZ
)@@G@@ USING SGDSCT,X7 .@#@@@9 . ---------------@^@@@9 . INITIALIZE DRIVER    UA
)@@G@@@#@@@9 . ---------------@#@@@9PLCGDR* LABEL .   @E@@@9         MOVE  DLTUB
)@@G@@OPT,5,I .  SET ASSEMBLY LISTING OPTIONS   @D@@@9         MOVE    DXGFL3,UC
)@@G@@0,I .      SET JUNK FOR ZELK. @E@@@9       GFIX  ADPCSE .  START OF CODEUD
)@@G@@ GEN AREA (END OF SD'S) @C@@@9         LOAD  A8,ADPCBC .   START B-CODE UE
)@@G@@AREA  @E@@@9         STORE A8,DCGGNB .   END OF CODE GENERATION AREA    UF
)@@G@@@C@@@9       GMARK DPGSLC .  START OF STATIC INIT AREA@F@@@9         LOAUG
)@@G@@DXI X10,1,I . SET GENERATED CODE POINTER INCREMENTOR  @C@@@9       MOVE UH
)@@G@@DCGFL2,0,I .     CLEAR CODEGEN FLAGS@E@@@9CGSTR1 LABEL .               MUI
)@@G@@ERGE AFTER SETTING LINE COUNT @C@@@9         LOADA A9,DCGTST .   TEMP STUJ
)@@G@@ACK START   @E@@@9         AU,U  A9,1 .        SET A10 TO BOTTOM OF TEMPUK
)@@G@@ STACK@E@@@9       MOVE  DCGBPT-FH1,ZERO,DCGBSZ . CLEAR BLOCK STATUS    UL
)@@G@@@D@@@9         STORE A10,DCGTLV .   SET BOTTOM OF TEMP STACK@E@@@9RGINMVUM
)@@G@@   LABEL .             ENTRY POINT TO REINITIALIZE    @A@@@9       MOVE UN
)@@G@@ DCGINT,RGCORE,RGSIZE . @C@@@9         LOAD  X9,ADBK0S .   EXTERNAL (0) UO
)@@G@@BLOCK @D@@@9       STORE X9,DCGBPT .   SET OUTER BLOCK POINTER    @^@@@9UP
)@@G@@       USING SDSECT,X9 .@F@@@9         STORE A9,SDBKAW,X9 .          SETUQ
)@@G@@ FAKE AW FOR OUTER BLOCK@B@@@9       MOVE  SDCHLD,0,I .  EMPTY CHECKLISTUR
)@@G@@@E@@@9       MOVE  DCGSNO,0,I .    INITIALIZE STATEMENT NUMBER    @D@@@9US
)@@G@@       MOVE ADPCLC,0,I .     STATIC LABEL CHAIN HEAD  @F@@@9       MOVE UT
)@@G@@ DBGSCL,0,I .    EMPTY SCALAR INITIALIZATION CHAIN    @D@@@'         MOVUU
)@@G@@E    DBGPTC,0,I . EMPTY STATIC PTR CHAIN  @F@@@9       MOVE  DXGTPS,XGSAUV
)@@G@@NY,I . SET TO ACCEPT ANY OPERAND TYPE     @E@@@9       MOVE  DCGELB,0,I UW
)@@G@@.    ENTRY LABEL LIST STARTS EMPTY  @E@@@9       LOADA X7,DCGCST . STARTUX
)@@G@@ OF CHECK LIST OVERFLOW STACK @E@@@9         LOADXI X7,1,I .     SET INCUY
)@@G@@REMENTOR FOR XGPUSH     @F@@@9       STORE X7,DCGSTL .     SET STARTING UZ
)@@G@@COMPILE STACK LEVEL     @D@@@'         LOADXI X1,1,I .      SET GETC INCVA
)@@G@@REMENT REG. @G@@@9         STORE X7,DXGXPR .   INITIALIZE AGGREGATE STACVB
)@@G@@K ENTRY POINTER   @D@@@9       MOVE  SDDOOF,ARSTSZ,I . RESET BLOCK 0 DO VC
)@@G@@OFFSET@ @@@9         STORE A6,SDBSLD,X9 . @ @@@9        USING SDSECT,X5 VD
)@@G@@.     @E@@@9       LOAD  X5,ADPCSS .     START OF STATIC VARIABLE CHAIN VE
)@@G@@@D@@@9       IF  X5,ZERO  THEN,BGNSTV . -> NO STATIC VBLES  @G@@@9      VF
)@@G@@   LOAD  A14,AGSTK .   PUT STATIC FIXED VARIABLES IN COMPILED CODE@E@@@9VG
)@@G@@         ADD   A14,W1XU,X10 . NEXT ADDRESS FOR VARIABLES    @]@@@9 . ---VH
)@@G@@---   @ @@@9 . STATIC STORAGE ALLOCATION  @]@@@9 . ------   @#@@@9CGSTSTVI
)@@G@@ LABEL .    @G@@@9       IF SDMEMS,ON,SDCLS2  THEN,CGSTAL . ->VBLE MEMBEVJ
)@@G@@R OF STRUCTURE    @D@@@'         LOAD    F,SDCLS0,X5 . THIS IS ASSUMED LVK
)@@G@@ATER  @F@@@9       LOAD  A2,SDCLS0,X5 .  USE TYPE OF SD AS INDEX TO BRANVL
)@@G@@CH    @C@'@9         AND,U A2,7 .        GET RELAVENT BITS  @C@@@'      VM
)@@G@@   AND,U A2,017 .        GET RELAVENT BITS@A@@@9       LOAD  A2,BGTPTB+FVN
)@@G@@H1,A3 .     @C@@@9       LINK  0,A2 .  ALLOCATE ACCORDING TO TYPE @#@@@9VO
)@@G@@CGSTAL LABEL .    @C@@@9       LSDP  X5,SDSTCH,X5 .  NEXT STATIC ID     VP
)@@G@@@D@@@9       IF  X5,NZERO  THEN,CGSTST . -> DETERMINE TYPE  @I@@@9      VQ
)@@G@@   GFIX  A14 .         RESET GENERATED CODE POINTER BEYOND FIXED ALLOCATVR
)@@G@@IO    @E@@@9         GMARK DPGSLC .      UPDATE CODE GENERATION START   VS
)@@G@@@G@@@9         GMARK ADPCSE .      INCLUDE NEWLY ALLOCATED LOCS WITH SD'VT
)@@G@@S     @E@@@9BGNSTV   LABEL .             MERGE FROM NO STATIC VARIABLES VU
)@@G@@@E@@@9         LOAD  A14,ARSTSZ,I .          FAKE FIXED LENGTH    @^@@@9VV
)@@G@@       GOTO BGALEN .    @^@@@9 . -------------------  @ @@@9 .  CHANGE OVW
)@@G@@F BLOCK STATUS    @H@@@9 .  (BRANCHED TO FROM DGPRC5,DGBGN1.  IF PROC, OVX
)@@G@@N ENTRY X2=S.D. POINTER TO    @ @@@9 .   START OF ENTRIES CHAIN.) @^@@@9VY
)@@G@@ . -------------------  @#@@@9DGBLCK* LABEL .   @D@@@9       LINK DGBRCHVZ
)@@G@@ .     GEN BR. AROUND BLOCK BODY    @C@@@9       LOAD  A14,SDCHLD,X9 .  WA
)@@G@@   START C/NC LIST@A@@@9       SET   CGRCHB,ON,DCGFL2 .     @E@@@9      WB
)@@G@@   STORE A8,A10 .      SAVE POINTER TO PROCEDURE BLOCK@C@@@9       STOREWC
)@@G@@ X7,SDFXLN,X9 .    SAVE STACK LEVEL @C@@@9       STORE X1,ADPCBC .     SWD
)@@G@@AVE META CODE PTR @H@@@9        LOADXM X1,DCGGNB .  START OF G-CODE FOR WE
)@@G@@THIS STATEMENT WITH BUFFER    @D@@@9         ADD   X1,10,I .     REMOVE WF
)@@G@@BUFFER LENGTH     @C@@@9         LOAD  A1,KLCH2W .   RESET GETC TO H1   WG
)@@G@@@]@@@9      GETC .@G@@@9       IF  ICTCHF,OFF,A8  THEN,DGB2EN . -> NO CHWH
)@@G@@ECK/NOCHECK PREFIXES    @B@'@9         NONPL1 XGFCHK,DDGCHK,DGBXXQ .    WI
)@@G@@@#@@@9DGBXXQ   LABEL .  @G@@@'         ADD     X1,2,I .          SKIP STWJ
)@@G@@MT#,COND L.P.,PREFIX FLAGS    @A@@@9 . LOOP TO CHECK OR NOCHECK PREFIXESWK
)@@G@@@#@@@9DGB2LC LABEL .    @#@@@9       GETC .     @G@@@9       IF  A8,LT,AWL
)@@G@@CCHK,I  THEN,DGB2LC . -> TRY NEXT META-CODE SYLLABLE  @E@@@9       IF  AWM
)@@G@@8,NE,ACCHK,I  THEN,DGB2NC .  -> NO CHECK PREFIX @E@/@'         MOVE    FWN
)@@G@@,0,I .           SAY NEXT SD IS WITH CHECK@F@@@/         MOVE    A2,0,I WO
)@@G@@.           SAY NEXT SD IS WITH CHECK     @B@'@9       LOAD  F,SDCLS3 . WP
)@@G@@ (USED AT DGB2CE) @B@@@9       GOTO  DGB2CK .    CHECK PREFIX     @#@@@9WQ
)@@G@@DGB2NC LABEL .    @D@@@9       IF  A8,NE,ACNCHK,I  THEN,DGB2EN . -> NO NWR
)@@G@@OCHECK@C@'@9       LOADN F,SDCLS3 .    (USED AT DGB2CE)     @F@/@'      WS
)@@G@@   MOVE    F,1,I .           SAY NEXT SD IS WITH NOCHECK    @F@@@/      WT
)@@G@@   MOVE    A2,1,I .           SAY NEXT SD IS WITH NOCHECK   @^@'@9      WU
)@@G@@ GOTO  DGB2CK .   @C@@@9DGB2CK LABEL .               POINT TO FIRST ITEMWV
)@@G@@@ @'@9       GETC .        ACRPAR   @ @@@'       GETC .        ACLPAR   WW
)@@G@@@B@@@'         NONPL1 XGFCHK,DDGCHK,DGBSCR .    @#@@@9DGBSCR   LABEL .  WX
)@@G@@@ @@@9       GETC .        ACSTEX   @^@@@9       GETC .        SD @#@@@9WY
)@@G@@DGB2CL LABEL .    @F@@@9       LOAD  X5,A8 .         IDENTIFIERS'S SD (AWZ
)@@G@@8=R15) (X8=R8)    @^@@@9       LOAD  X8,A8 .    @B@/@'         IF      FXA
)@@G@@,EQ,0,I  THEN,DGB222 .  @B@@@/         IF      A2,EQ,0,I  THEN,DGB222 . XB
)@@G@@@C@@@'       LOADN F,SDCLS3,X5 .    (USED AT DGB2CE)  @ @@@'         GOTXC
)@@G@@O    DGB2CS .     @#@@@'DGB222   LABEL .  @C@@@'       LOAD  F,SDCLS3,X5XD
)@@G@@ .  (USED AT DGB2CE)    @#@@@9DGB2CS LABEL .    @D@@@9       LOAD  A8,X5XE
)@@G@@ .         SAVE FOR LINK IN CHAIN   @C@@@9 .     LSDP  X5,X5 .         EXF
)@@G@@XPAND SD POINTER  @^@@@9       USING SDSECT,X5 .@F@@@9.      IF  SDPARM,XG
)@@G@@OFF,SDCLS2  THEN,DGB2C1 . -> NOT A PARAMETER    @D@@@9.      IF  A8,NE,XXH
)@@G@@8  THEN,DGB2C1 . -> NOT A MAJOR NAME@E@@@9.        CHECK PREFIX NOT REALXI
)@@G@@LY AN ERROR *****FIX IT ***** @H@@@9.      EXERR ERCGPRM LEVEL,0 . '*** XJ
)@@G@@IS A PARM IN AN I/O LIST OR CHK PRFX'     @#@@@9DGB2C1 LABEL .    @^@@@9XK
)@@G@@       USING SDSECT,X5 .@F@@@9       IF  SDSTRU,OFF,SDCLS4  THEN,DGB2CE XL
)@@G@@. -> NOT A STRUCTURE    @D@@@9       LOAD  X5,SDSON,X5 . DO FIRST SON INXM
)@@G@@ STRUCTURE  @^@@@9       GOTO DGB2CS .    @[@@@9 .    @#@@@9DGB2CE LABELXN
)@@G@@ .    @I@;@9       IF SDCHCK,ON  THEN,DGB2CK . (F LOADED AT DGB2LC/NC) TXO
)@@G@@HIS OCC. OF VBLE IN     @I@@@;       IF SDCHCK,ON  THEN,DGB2CB . (F LOADXP
)@@G@@ED AT DGB2LC/NC) THIS OCC. OF VBLE IN     @I@@@9             .   THE CHEXQ
)@@G@@CK/NOCHECK PREFIX DOESN'T CHANGE THE STATUS OF THE VBLE     @ @@@9      XR
)@@G@@LOAD  A3,SDCLS3,X5 .    @H@@@9       XOR,U A3,SDCHCK   .      FLIP CHECKXS
)@@G@@ BIT             ***************    @ @@@9       STORE A4,SDCLS3,X5 .   XT
)@@G@@@F@@@9       IF  SDCHK2,OFF,SDCLS3  THEN,DGB2NW . -> FIRST TIME FOR VBLEXU
)@@G@@@E@@@9         SUB   X7,1,I .      PUSH CHECKLIST OVERFLOW STACK  @G@@@9XV
)@@G@@       LOAD  A6,SDCHLT,X5 . SAVE PREVIOUS LINK IN CHECK OVERFLOW STACK  XW
)@@G@@@ @@@9       STORE A6,W1H1,X7 .     @^@@@9       LOADN A14,A14 .  @#@@@9XX
)@@G@@DGB2NW LABEL .    @D@@@9       SET   SDCHK2,ON,SDCLS3 .  => VBLE ON CHECXY
)@@G@@KLIST @ @@@9       STORE A14,SDCHLT,X5 .  @^@@@9       LOAD  A14,A8 .   XZ
)@@G@@@C@@@9DGB2CB LABEL .               BACK TO ORIGINAL SD@E@@@9       IF  AYA
)@@G@@8,EQ,X8  THEN,DGB2ND . -> FINISHED WITH ENTRY   @D@@@9         LOAD  A8,YB
)@@G@@SDDAD .    SAVE POINTER TO FATHER SD@C@@@9       LOAD  X5,SDBROT .    BRYC
)@@G@@OTHER, IF ANY     @D@@@9         IF    X5,NZERO THEN,DGB2CS . -> GOOD BRYD
)@@G@@OTHER @B@@@9       LSDP  X5,A8 .   FIND FATHER SD     @E@@@9       GOTO YE
)@@G@@ DGB2CB .        -> SEE IF FATHER HAS BROTHER   @[@@@9 .    @#@@@9DGB2NDYF
)@@G@@ LABEL .    @A@@@9         GETC .              ACENEX @C@@@9         GETYG
)@@G@@C .              ACCOMA OR ACRPAR   @E@@@9         IF    A8,NE,ACCOMA,I YH
)@@G@@THEN,DGB2LC ELSE,DGBSCR .     @[@@@9 .    @E@@@9 .  SAVE STATUS OF OUTERYI
)@@G@@ BLOCK; AND INITIALIZE NEW BLOCK    @[@@@9 .    @^@@@9       USING SDSECYJ
)@@G@@T,X9 .@#@@@9DGB2EN LABEL .    @ @@@9       XGPUSH  'SIZE',DCGBSZ .@^@@@9YK
)@@G@@       USING WORD,X7 .  @F@@@9       MOVE  W1,DCGBPT-FH1,DCGBSZ .    SAVYL
)@@G@@E OUTER BLOCK'S STATUS  @E@@@9       MOVE  DCGBPT-FH1,ZERO,DCGBSZ .  CLEYM
)@@G@@AR STATUS INFO    @C@@@9         STORE X9,DCGBPT .   SAVE BLOCK POINTER YN
)@@G@@@D@@@9         STORE X7,DCGSTL .   STARTING STACK LEVEL     @E@@@9      YO
)@@G@@   LOAD  X8,DCGTLV .   CURRENT TEMPORARY STACK LEVEL  @G@@@9         STOYP
)@@G@@RE X8,DCGTSK .   FIRST ENTRY IN TEMP STACK AT BLOCK ENTRY   @D@@@9      YQ
)@@G@@ LSDP  X9,A10 .  SD OF NEW BLOCK (SAVED ABOVE)  @F@@@'         MOVE    DYR
)@@G@@CGONF,SDSTON .   COPY NEW CONDITION PREFIX FLAGS@C@@@9       STORE A14,SYS
)@@G@@DCHLD .  TOP OF CHECKLIST     @D@@@9       STORE X2,SDECHN . START OF ENYT
)@@G@@TRY CHAIN  IN PROC@C@@@9       STORE A7,SDNMEN .  # OF ENTRIES  IF PROC YU
)@@G@@@E@@@9         LOAD  X8,W1XU+1,X8 .  FIRST WORD ABOVE TEMP STACK  @F@@@9YV
)@@G@@         STORE X8,SDBKAW,X9 .          SET POINTER TO BLOCK AW    @D@@@9YW
)@@G@@         LOAD  X4,W1U+1,X8 .   X4 -> BLOCK'S AW+1     @G@@@9         LOAYX
)@@G@@D  A3,SDBSLD,X9 .          A3 = OFFSET IN AR OF STATIC LINK @E@@@9      YY
)@@G@@   STORE A3,W1H2,X4 .    OFFSET OF RETURNED VALUE     @D@@@9         STOYZ
)@@G@@RE X8,W1H1,X4 .   POINT TO PROPER REGISTER@D@@@9         ADD   A3,1,I . ZA
)@@G@@  ALLOCATE TWO WORD FOR RETURN@C@@@9BGPMWS   LABEL .             CREATE ZB
)@@G@@PARAMETER AW@D@@@9         ADD   A3,1,I .      ADVANCE OFFSET IN AR     ZC
)@@G@@@F@@@9         ADD   X4,1,I .      ADVANCE POINTER TO NEXT FREE AW SLOT ZD
)@@G@@@E@@@9         STORE A3,W1H2,X4 .  OFFSET OF PARAMETER LINK IN AR @D@@@9ZE
)@@G@@         STORE X8,W1H1,X4 .  USE STATIC LINK FOR BLOCK@E@@@9         IF ZF
)@@G@@   A3,LT,SDNMPM THEN,BGPMWS . -> MORE PARAMETERS@C@@@9BGINIT   LABEL .  ZG
)@@G@@           SET UP VALUES IN SD@G@@@9         ADD   A3,2,I .      ADVANCEZH
)@@G@@ OFFSET TO DO STACK         ***???* @I@@@9         ADD   X4,1,I .      FZI
)@@G@@IND ADDRESS OF NEXT AVAILABLE TEMPORARY ALLOCATOR     @F@@@9       STOREZJ
)@@G@@ A3,SDDOOF,X9 .        OFFSET TO BEGINING OF DO STACK @D@@@9       STOREZK
)@@G@@ X4,DCGTLV .     INITIALIZE TEMP STACK    @H@@@9       STORE A3,DCGLOF .ZL
)@@G@@     FIRST IN DO STACK IS FOR LABELS NOT IN ANY DO    @C@@@9         LOAZM
)@@G@@D   A14,SDMXDO,X9 .    DO STACK SIZE@ @@@9       STORE A14,DCGNBT .     ZN
)@@G@@@F@@@9         ADD   A14,W1U+1,A3 .  OFFSET TO FIRST FREE BYTE IN AR    ZO
)@@G@@@^@@@9       LINK  BGDSPY .   @ @@@9 . ----------------------     @ @@@9ZP
)@@G@@ . CODEGEN:  STORAGE ALLOCATOR@ @@@9 . ----------------------     @F@@@9ZQ
)@@G@@         LOAD  X5,SDECHN,X9 .            DO PARAMETER LIST SD'S   @F@@@9ZR
)@@G@@         IF    X5,ZERO THEN,DG0006 . -> BLOCK ENTRY, NO PARAM'S   @#@@@9ZS
)@@G@@DG0005   LABEL .  @^@@@9         LINK  DGENCH . @ @@@9         USING SDSZT
)@@G@@ECT,X5 .    @F@'@9         IF    SDENCH,ZERO THEN,DG0006 . -> NO MORE ENZU
)@@G@@TRY POINTS  @F@@@'         IF    SDENCH,ZERO THEN,DG0006X . -> NO MORE EZV
)@@G@@NTRY POINTS @ @@@9         LOAD  X5,SDENCH .    @G@@@9         GOTO  DG0ZW
)@@G@@005 .                  -> PROCESS NEXT ENTRY POINT    @#@@@9DG0006   LABZX
)@@G@@EL .  @ @@@9         USING SDSECT,X9 .    @G@@@'         IF SDNXDC,NZEROZY
)@@G@@ THEN,DG0006X  . -> SOME VARS WERE DECLARED     @F@@@'         IF      SZZ
)@@G@@D3OBK,ON,SDCLS3  THEN,DG0006X . ON UNIT BLOCK   @D@@@'         EXERR ERBAA
)@@G@@LOC LEVEL,1 . SHOULD USE DO GROUP   @G@@@'DG0006X  LABEL .              AB
)@@G@@     HERE IF ANY VARS IN BLOCK OR IF PROC @E@@@9       MOVE  DBGSCL,0,I AC
)@@G@@. EMPTY SCALAR INITIALIZATION CHAIN @E@@@'         MOVE    DBGPTC,0,I . AD
)@@G@@     EMPTY SCALAR PTR CHAIN   @ @@@9         LOADA X11,BGNXTL .   @^@@@9AE
)@@G@@       LOAD  X5,X9 .    @ @@@9       LOADXI X2,SDBKAW .     @^@@@9      AF
)@@G@@ LOADXM X2,0,I .  @C@@@9       ADD   A14,X2 .   MAKE A14 INTO ADDR WORD AG
)@@G@@@ @@@9         USING SDSECT,X5 .    @#@@@9BGNXTL LABEL .    @^@@@9      AH
)@@G@@ LSDP  X5,SDNXDC .@G@@@9       IF  X5,ZERO  THEN,BGALEN . -> ALL VBLES IAI
)@@G@@N BLOCK ARE ALLOCATED   @C@@@9       LOAD  F,SDCLS0 .      STORAGE CLASSAJ
)@@G@@?     @D@'@9       IF  SD0AUT,OFF  THEN,BGNXTL . -> NOT AUTOMATIC @G@@@'AK
)@@G@@       IF  SD0AUT+SD0BSD+SD0CNT,OFF  THEN,BGNXTL . -> NOT AUTOMATIC     AL
)@@G@@@F@@@9       IF  SDMEMS+SDPARM,OFF,SDCLS2  THEN,BG0001 . -> GO ALLOCATE AM
)@@G@@@I@@@9       IF  15-SD0ENT,ON  THEN,BGNXTL . -> ALLOCATE MEMOS WITH RESTAN
)@@G@@ OF STRUCTURE     @F@@@9 .                           -> ALLOCATE PARMS WAO
)@@G@@ITH ENTRY POINT   @#@@@9BG0001 LABEL .    @^@@@9       LOAD  A2,SDCLS0 .AP
)@@G@@@^@'@9         AND,U A2,7 .   @^@@@'         AND,U A2,017 . @G@@@9      AQ
)@@G@@ LOAD  A2,BGTPTB+FH1,A3 .  SDCLS0 BITS GIVE PROPER TABLE ENTRY    @^@@@9AR
)@@G@@       GOTO  0,A2 .     @[@@@9 .    @I@@@9BGTPTB LABEL .     H1 IS NORMAAS
)@@G@@L VARIABLE TABLE, H2 IS MEMBER OF STRUCTURE TABLE     @H@@@9FILL(1) SAC AT
)@@G@@ BGLJMP,BGBOMB . 0  IGNORE UNKNOWN TYPE, BOMB ON UNKNOWN TYPE     @H@@@9AU
)@@G@@FILL(1) SAC  BGARBL,BGSTAB . 1  ARITHMETIC DATA TYPE, ARITH MEMBER OF STAV
)@@G@@RU.   @F@@@9FILL(1) SAC  BGNTRY,BGBOMB . 2  ENTRY NAME, UNEXPECTED ENTRYAW
)@@G@@ NAME @E@@@9FILL(1) SAC  BGSTRU,BGSTR3 . 3  STRUCTURE, SUBSTRUCTURE     AX
)@@G@@@F@@@9FILL(1) SAC  BGSTRI,BGSTRI . 4  STRING, STRING MEMBER OF STRU.    AY
)@@G@@@D@@@9FILL(1) SAC  BGARBL,BGSTAB . 5  LABEL,  LABEL     "   @F@@@9FILL(1AZ
)@@G@@) SAC  BGFILE,BGBOMB . 6  FILE,  FILE CAN'T BE STRU MEMBER .@D@'@9FILL(1BA
)@@G@@) SAC  BGARBL,BGBOMB . 7 POINTER, PTR     "     @C@@@'FILL(1) SAC  BGARBBB
)@@G@@L,BGSTAB . 7  POINTER, PTR    @C@@@'FILL(1) SAC  BGBOMB,BGBOMB . 10 BLOCBC
)@@G@@K IS ILLEGAL@E@@@'FILL(1) SAC  BGSTRI,BGSTRI . 11 AREA,HANDLE LIKE STRINBD
)@@G@@GS    @[@@@9 .    @#@@@9BGBOMB LOCAL .    @E@@@9         EXERR EXCLS0 LEBE
)@@G@@VEL,2 . UNEXPECTED BITS IN SDCLS0   @D@'@9         UNSTK X11 .         RBF
)@@G@@ESTORE RETURN REGISTER  @B@'@9         LJMP .              TRY AGAIN    BG
)@@G@@@E@@@'         GOTO    BGNTR0 .          RETURN, UNSTACKING X11   @]@@@9BH
)@@G@@ . -------  @F@@@9 . N.B.  BELOW, A14 CONTAINS BASE AND OFFSET TO FIRST BI
)@@G@@FREE BYTE   @]@@@9 . -------  @#@@@9BGARBL LABEL .    @ @@@9         USIBJ
)@@G@@NG SDSECT,X5 .    @F@@@9       IF  SDARRY,ON,SDCLS2  THEN,BGSTRI . ->ARIBK
)@@G@@TH OR LABEL ARRAY @ @'@9 .  ARITH OR LABEL SCALAR     @[@@@'.     @A@@@'BL
)@@G@@ .  ARITH OR LABEL OR POINTER SCALAR@B@@@'.                (NOT STRUCTURBM
)@@G@@E MEMBER!)  @[@@@'.     @G@@@'         IF SD0BSD++SD0CNT,OFF THEN,BGARB1BN
)@@G@@ . -> NOT BASED IS NORMAL!    @E@@@'         LOAD    A3,SDCLS0 .       SBO
)@@G@@EE IF PTR TO SET BIT ON @ @@@'         AND,U   A3,SD0PTR .  @E@@@'      BP
)@@G@@   IF A4,NE,SD0PTR,I THEN,BGARBL1 . -> IF NOT PTR     @A@@@'         SETBQ
)@@G@@ SD5PTR,ON,SDCLS5 .     @#@@@'BGARBL1   LABEL . @F@@@'         IF SD3BSDBR
)@@G@@,OFF,SDCLS3 THEN,BGARB3 . VAR DCLD  A BASED;    @F@@@'         IF SD0BSDBS
)@@G@@,OFF THEN,BGARB3 . -> SKIP IF VAR IS CNTRLD     @#@@@'         LOCAL .  BT
)@@G@@@E@@@'         LMCP    R,SDBPTR,X5 . GET SD OF IMPLIED PTR IN A8  @ @@@'BU
)@@G@@         STORE   A8,SDBPTR .  @^@@@'         UNSTK   X11 .  @#@@@'BGARB3BV
)@@G@@   LABEL .  @D@@@'         MOVE  SDPROF,0,I .         DISP. FROM POINTERBW
)@@G@@@E@@@'         MOVE    SDLCOF-FH2,0,I . SET OFFSET FROM POINTER!  @G@@@'BX
)@@G@@         GOTO    BGARB2 .          DON'T NEED SPACE IN AREC FOR IT!     BY
)@@G@@@E@@@'BGARB1   LABEL .                   HERE FOR NORMAL VARIABLE @D@@@9BZ
)@@G@@       STORE A14,SDLCOF,X5 . LOCATION OF OFFSET IN AR @ @@@9       STORECA
)@@G@@ A14,SDA1BS-FH1 . @G@@@9         ADD   A14,SDRTC .   WORDS NEEDED FOR VACB
)@@G@@RIABLE SET BY FIRST PASS@D@@@'         AND,U     F,07 .          SEE IF CC
)@@G@@VAR IS A PTR@D@@@'         IF A6,NE,7,I THEN,BGARB2 . -> IF NOT PTR     CD
)@@G@@@E@@@'         MOVE    SDPTRC,DBGPTC .   PUT PTR ON FRONT OF LIST @ @@@'CE
)@@G@@         STORE   X5,DBGPTC .  @F@@@'BGARB2   LABEL .                   MCF
)@@G@@ERGE LANE FROM BASED VARS     @G@@@9       IF  SDINTL,OFF,SDCLS3  THEN,LCG
)@@G@@JMP . -> NO INITIALIZATION NEEDED   @E@@@9       MOVE  SDENBK,DBGSCL . ACH
)@@G@@DD THIS SD TO CHAIN OF SCALERS@D@@@9       STORE X5,DBGSCL .     WHICH NCI
)@@G@@EED INITIALIZATION@#@@@9       LJMP .     @[@@@9 .    @D@@@9BGARPR LABELCJ
)@@G@@ .               IS PARAMETER AN ARRAY?   @G@@@9       IF  SDARRY,OFF,SDCK
)@@G@@CLS2  THEN,BGNTR4 . ->SCALAR PRM, NO ALLOCATION @G@'@9         MOVE  SDNCL
)@@G@@SPS,0,I . ARITHMATIC ARRAYS HAVE NO STRING LEAVES     @#@@@9BGSTRI LLOC CM
)@@G@@.     @E@@@9       STORE A14,SDLCOF .    SET OFFSET TO STRING DV IN AR  CN
)@@G@@@D@@@9       STORE A14,SDA1BS-FH1 .SET AW FOR VARIABLES     @H@@@'      CO
)@@G@@   IF      SD0BSD++SD0CNT,OFF  THEN,BGSTRS . ->ANOTHER NORMAL VARIABLE  CP
)@@G@@@F@@@'         MOVE    SDPROF,0,I .      ASSUME NOT MEMBER OF STRUCTURE CQ
)@@G@@@G@@@'         IF SDMEMS,OFF,SDCLS2 THEN,BGSTRS1 . -> NOT MEMBER OF STRUCR
)@@G@@CTURE @C@@@'         LOAD    A2,DBGWC1 .       GET ROOT SD  @F@@@'      CS
)@@G@@   LOAD    A3,SDCLS0 .       SEE IF PTR ARRAY IN STRUCTURE  @ @@@'      CT
)@@G@@   AND,U   A3,SD0PTR .  @B@@@'         IF A4,NE,SD0PTR,I THEN,BGSTRS2 . CU
)@@G@@@ @@@'         USING   SDSECT,A2 .  @H@@@'         SET     SD5PTR,ON,SDCCV
)@@G@@LS5 . SET BIT IN ROOT SD SAYING PTR PRESENT     @ @@@'         USING SDSCW
)@@G@@ECT,X5 .    @#@@@'BGSTRS2  LABEL .  @F@@@'         LOAD    A2,SDA1BS-FH1CX
)@@G@@,A2 . GET ADDRESS OF TOP OF D.V.    @H@@@'         SUB     A2,A14 .     CY
)@@G@@     GET -(OFFSET FROM TOP OF STRUCTURE D.V.)   @C@@@'         LMA     ACZ
)@@G@@2,A2 .           ELIMINATE -0 @G@@@'         STORE   A2,SDPROF .       SDA
)@@G@@ET OFFSET FROM START OF STRUCT DV   @#@@@9BGSTRS LABEL .    @D@'@9      DB
)@@G@@   LOAD    A3,SDDVA,X5 .     POINT TO D. V.     @E@@@'         LOAD    ADC
)@@G@@3,SDDVA,X5 .     POINT TO D. V. TEMPLATE  @D@'@9         ADD     A14,W1QDD
)@@G@@1,A3 .     ADD SIZE OF D. V.+1@E@@@'         LOAD    A4,SDDVSZ,A3 .    GDE
)@@G@@ET SIZE OF TEMPLATE     @D@@@'         SUB     A4,1,I .          GET SIZDF
)@@G@@E OF D.V.   @E@@@'         STORE   A4,SDDVLG .       SET LENGTH OF D.V. DG
)@@G@@IN SD @F@@@'         ADD     A14,A4 .          ADD SIZE INTO AREC POSITIDH
)@@G@@ON    @E@'@9         SUB   A14,1,I .          ADJUST TO ACTUAL D.V. SIZEDI
)@@G@@@#@@@9       LJMP .     @E@@@'BGSTRS1  LABEL . FIX UP SDBPTR FOR BASED SDJ
)@@G@@TRINGS & ARRAYS   @E@@@'         LOAD    A3,SDCLS0 .       SEE IF BASED DK
)@@G@@PTR ARRAY   @ @@@'         AND,U   A3,SD0PTR .  @E@@@'         IF A4,NE,DL
)@@G@@SD0PTR,I THEN,BGSTRS3 . -> NOT PTR ARRA   @A@@@'         SET     SD5PTR,DM
)@@G@@ON,SDCLS5 . @#@@@'BGSTRS3  LABEL .  @F@@@'         IF SD3BSD,OFF,SDCLS3 DN
)@@G@@THEN,BGSTRS . VAR DCLD  'A BASED;'  @D@@@'         IF SD0BSD,OFF THEN,BGDO
)@@G@@STRS . -> IF CNTRLD     @#@@@'         LOCAL .  @ @@@'         LMCP    RDP
)@@G@@,SDBPTR,X5 .@ @@@'        STORE    A8,SDBPTR .  @^@@@'         UNSTK   XDQ
)@@G@@11 .  @ @@@'         GOTO    BGSTRS .     @^@@@9 . ------------------   DR
)@@G@@@#@@@9 . STRUCTURES     @^@@@9 . ------------------   @#@@@9BGSTRU LOCALDS
)@@G@@  .   @C@@@9         STORE X5,DBGWC1 .   SAVE SD POINTER    @A@@@'      DT
)@@G@@   IF SD0BSD,OFF THEN,BGSTR3 .@C@@@'         IF SD3BSD,OFF,SDCLS3 THEN,BDU
)@@G@@GSTR3 .     @#@@@'         LOCAL .  @A@@@'         LMCP    R,SDBPTR,X5  DV
)@@G@@.     @ @@@'         STORE   A8,SDBPTR .  @^@@@'         UNSTK   X11 .  DW
)@@G@@@#@@@9BGSTR3 LABEL .    @E@@@9       STORE A14,SDLCOF .    SET OFFSET OFDX
)@@G@@ VARIABLE IN AR   @E@@@9       STORE A14,SDA1BS-FH1 .SET AW FOR STRUCTURDY
)@@G@@E VARIABLE  @[@@@..     @B@@@.. COMPUTE DISPL FOR BASED SUBSTRUCTURES   DZ
)@@G@@@[@@@..     @F@@@.         IF SD0BSD++SD0CNT,OFF,SDCLS0 THEN,BGSTR3A . -EA
)@@G@@> NOT BSD   @C@@@.         LOAD    A2,DBGWC1 .       GET ROOT SD  @A@@@.EB
)@@G@@         LOAD    A2,SDA1BS-FH1,A2 . @ @@@.         SUB     A2,A14 .     EC
)@@G@@@ @@@.         STOREN  A2,SDPROF .  @^@@@.BGSTR3A          LABEL .@A@@@9ED
)@@G@@       LSDP  X5,SDSON .   FIND SON  @#@@@9BGSTR1 LABEL .    @E@@@9      EE
)@@G@@ LOAD  A2,SDCLS0 .     USE SD TYPE AS INDEX INTO TABLE@^@'@9         ANDEF
)@@G@@,U A2,7 .   @^@@@'         AND,U A2,017 . @E@@@9       LOAD  A2,BGTPTB+FEG
)@@G@@H2,A3 .  CLS0 GIVES INDEX INTO TABLE@D@@@9       LINK  0,A2 .       ALLOEH
)@@G@@CATE ACCORDING TO TYPE  @[@@@9 .    @F@@@9BGSTR2 LABEL .               REI
)@@G@@ETURN TO HERE IF NOT SUBSTRUCTURE   @E@@@9         IF    SDBROT,NZERO THEJ
)@@G@@EN,BGSTR4 . -> HAS BROTHER SD @[@@@'.     @C@@@'.        IF NOT AT LEAF EK
)@@G@@THEN COMPUTE DV LENGTH  @[@@@'.     @E@@@'         IF SD0STU,OFF,SDCLS0 EL
)@@G@@THEN,BGSTR2A . -> AT A LEAF   @F@@@'         LOAD    A3,A14 .          GEM
)@@G@@ET CURRENT POSITION IN AREC   @D@@@'         SUB     A3,SDA1BS-FH1 .   GEN
)@@G@@ET START OF D.V.  @D@@@'         STORE   A3,SDDVLG .       SET LENGTH OFEO
)@@G@@ D.V. @G@@@'BGSTR2A  LABEL .                   EITHER LEAF OR D.V. LEGNTEP
)@@G@@H COMPUTED  @ @@@9         LSDP  X5,SDDAD,X5 .  @G@@@9         IF    X5,EQ
)@@G@@NZERO THEN,BGSTR2 . -> HAS FATHER, LOOK FOR BROTHER   @E@@@9         LOAER
)@@G@@D  X5,DBGWC1 .   RELOAD ORIGINAL SD POINTER     @E@'@9         UNSTK X11ES
)@@G@@ .         PUT RETURN ADDRESS BACK IN X11 @E@'@9BGLJMP   LABEL .        ET
)@@G@@     DO NOTHING BUT RETURN LABEL    @#@'@9       LJMP .     @E@@@'      EU
)@@G@@   GOTO    BGNTR0 .          RETURN, UNSTACKING X11   @#@@@9BGSTR4   LABEV
)@@G@@EL .  @ @@@9         LSDP  X5,SDBROT,X5 . @^@@@9         GOTO  BGSTR1 . EW
)@@G@@@[@@@9 .    @ @@@9 . ANOTHER MEMBER OF STRUCTURE@[@@@9 .    @#@@@9BGSTABEX
)@@G@@ LABEL .    @G@@@9       IF  SDARRY,ON,SDCLS2  THEN,BGSTRI . -> GO ALLOCEY
)@@G@@ATE FOR ARRAY     @ @@@9       STORE A14,SDLCOF .     @ @@@9       STOREEZ
)@@G@@ A14,SDA1BS-FH1 . @E@@@9       ADD   A14,1,I .     ONE WORD FOR SCALAR IFA
)@@G@@N STRUCTURE @G@@@'         IF SD0BSD++SD0CNT,OFF THEN,LJMP . -> NORMAL VFB
)@@G@@ARIABLE AGAIN     @C@@@'         LOAD    A2,DBGWC1 .       GET ROOT SD  FC
)@@G@@@ @@@'         LOAD    A3,SDCLS0 .  @ @@@'         AND,U A3,SD0PTR .    FD
)@@G@@@D@@@'         IF A4,NE,SD0PTR,I THEN,BGSTAB1 . -> NOT PTR  @ @@@'      FE
)@@G@@   USING   SDSECT,A2 .  @A@@@'         SET     SD5PTR,ON,SDCLS5 . @ @@@'FF
)@@G@@         USING   SDSECT,X5 .  @#@@@'BGSTAB1  LABEL .  @G@@@'         LOAFG
)@@G@@D    A2,SDA1BS-FH1,A2 . GET ADDRSS OF D.V. OF ROOT IN AREC  @G@@@'      FH
)@@G@@   SUB     A2,A14 .          GET -(OFFSET FROM TOP OF ROOT D.V.)  @^@@@'FI
)@@G@@         LMA     A2,A2  @E@@@'         SUB     A2,1,I . CORRECT FOR HAVIFJ
)@@G@@NG ADDED TO A14   @G@@@'         STORE   A2,SDPROF .       SET OFFSET FRFK
)@@G@@OM WHERE POINTER IS!    @#@@@9       LJMP .     @[@@@9 .    @C@@@9BGNTRYFL
)@@G@@ LOCAL .               SAVE RETURN POINT  @F@@@9       IF  SDARST,OFF,SDFM
)@@G@@CLS1  THEN,BGNTR0 . -> RETURNS ARITH VALUE@G@@@9         LINK  BGSTRI . FN
)@@G@@     PROCESS ENTRY NAME WHICH RETURNS A STRING  @#@@@9BGNTR0 LABEL .    FO
)@@G@@@B@'@9         UNSTK X11 .           RESET X 11 @B@@@'         UNSTK X11FP
)@@G@@ .           RESET X11  @F@@@'BGLJMP   LABEL .                   DO NOTHFQ
)@@G@@ING BUT RETURN LABEL    @B@@@9         LJMP .                -> RETURN  FR
)@@G@@@[@@@9.     @[@@@9.     @[@@@9.     @A@@@9.         DO PARAMETER LIST SDFS
)@@G@@'S    @[@@@9.     @#@@@9DGENCH   LOCAL .  @D@@@9         STORE X5,DBGWC2FT
)@@G@@ .      SAVE ENTRY POINT SD   @C@@@9         LOADA X11,BGNTR3 .  SET RETFU
)@@G@@URN POINT   @E@@@9         LOAD  X8,DCGTSK . COMPUTE AW BASE FOR PARAMETFV
)@@G@@ERS   @ @@@9         SUB   X8,SDBSLD,X9 . @^@@@9         ADD   X8,1,I . FW
)@@G@@@^@@@9       LSDP  X2,SDPLST .@E@@@9       IF  X2,ZERO  THEN,BGNTND . ->FX
)@@G@@END OF PARMATER LIST    @#@@@9BGNTR1 LABEL .    @B@@@9       LSDP  X5,ELFY
)@@G@@WSD,X2 .  PARAMETER'S SD@G@@@9       IF  SDLCOF,NZERO  THEN,BGNTR2 . ->PFZ
)@@G@@ARM ALLOCATED BEFORE, SKIP IT @D@@@9       LOAD  A15,SDPROF,X5 . FORM AWGA
)@@G@@ FOR PARAMETER    @^@@@9       ADD   A15,X8 .   @^@@@9       SLB   A15,1GB
)@@G@@8 .   @^@@@9       LOAD  A2,SDCLS0 .@^@'@9         AND,U A2,7 .   @^@@@'GC
)@@G@@         AND,U A2,017 . @E@@@9      LOAD  A2,BGNTTB+FH1,A3 .  GET ENTRY GD
)@@G@@POINT FROM TABLE  @^@@@9       GOTO  0,A2 .     @#@@@9BGNTR3 LABEL .    GE
)@@G@@@D@@@9       MOVE  SDA2BS-FH1,SDA1BS-FH1 . FIXUP PARM SD    @#@@@9BGNTR4GF
)@@G@@ LABEL .    @B@@@9       STORE  A15,SDA1BS-FH1 . SET PARM AW@#@@@9BGNTR2GG
)@@G@@ LABEL .    @D@@@9       LSDP  X2,ELWNXT,X2 . FOLLOW PARM LIST CHAIN    GH
)@@G@@@D@@@9       IF  X2,NZERO  THEN,BGNTR1 . -> THERES MOR PARMS@#@@@9BGNTNDGI
)@@G@@ LABEL .    @D@'@9         UNSTK X11 .         RESTORE RETURN ADDRESS   GJ
)@@G@@@C@@@9         LOAD  X5,DBGWC2 .   RESTORE SD POINTER @D@'@9       LJMP GK
)@@G@@.    DONE WITH ENTRY PARAMETER PROCESSING @E@@@'         GOTO    BGNTR0 GL
)@@G@@.          RETURN, UNSTACKING X11   @[@@@9 .    @I@@@9BGNTTB LABEL .    GM
)@@G@@H1 IS PARAMETER TYPE BRANCHING TABLE, H2 FOR STRUCTURE PARAME     @D@@@9GN
)@@G@@FILL(1) SAC  BGBOMB,BGBOMB . 0 BOMB ON UNKNOWN TYPE   @E@@@9FILL(1) SAC GO
)@@G@@ BGARPR,BGSTAB . 1 ARITHMETIC PARAMETER, MEMBER @G@@@9FILL(1) SAC  BGNTRGP
)@@G@@4,BGBOMB . 2 ENTRY PARM, ENTRY UNEXPECTED IN STRUCTURE@E@@@9FILL(1) SAC GQ
)@@G@@ BGESTR,BGEST3 . 3 STRUCTURE PARM, SUB-STRU.    @F@'@9FILL(1) SAC  BGESTGR
)@@G@@6,BGEST5 . 4 STRING PARM, STRING STRUCTURE LEAF @F@@@'FILL(1) SAC  BGSTRGS
)@@G@@I,BGSTRI . 4 STRING PARM, STRING STRUCTURE LEAF @C@@@9FILL(1) SAC  BGARPGT
)@@G@@R,BGSTAB . 5 LABEL  '     '   @F@@@9FILL(1) SAC  BGNTR4,BGBOMB . 6 FILE GU
)@@G@@PARM, FILE NAME UNEXPECTED    @D@'@9FILL(1) SAC  BGBOMB,BGBOMB . 7 POINTGV
)@@G@@ER NOT EXPECTED   @B@@@'FILL(1) SAC  BGARPR,BGSTAB . 7 POINTER    @D@@@'GW
)@@G@@FILL(1)  SAC     BGBOMB,BGBOMB . 10 BLOCK NOT EXPECTED@E@@@'FILL(1)  SACGX
)@@G@@     BGSTRI,BGSTRI . 11 AREA,HANDLE LIKE STRINGS@[@@@9 .    @#@@@9BGFILEGY
)@@G@@ LABEL .    @D@@@9         LOADXI X5,AGRX0 .   FORM FILE SD ADDRESS AW  GZ
)@@G@@@D@@@9         STORE X5,SDA1BS-FH1,X5 .      PUT INTO SD    @C@@@9      HA
)@@G@@   LJMP .              -> RETURN TO CALLER@[@@@9 .    @C@'@9BGESTR LOCALHB
)@@G@@ .               SAVE RETURN ADDRESS@#@@@'BGESTR   LABEL .  @C@@@9      HC
)@@G@@   STORE X5,DBGWC1 .   SAVE SD POINTER    @F@'@9         LOAD  A12,0,I .HD
)@@G@@     CLEAR NUMBER OF STRING LEAVES COUNTER@E@'@9       LOAD  A13,A14 .  HE
)@@G@@  SAVE OFFSET TO FIRST WORD OF DV   @E@@@'       LOAD  A13,A14 .    SAVEHF
)@@G@@ OFFSET TO FIRST WORD OF DV   @[@@@'.     @B@@@'.        PROBABLY SOME EHG
)@@G@@RRORS HERE!!!     @[@@@'.     @ @'@9         LOAD  X11,BGEST2 .   @#@@@9HH
)@@G@@BGEST3 LABEL .    @ @@@9       STORE A14,SDLCOF .     @ @@@9       STOREHI
)@@G@@ A15,SDA1BS-FH1 . @ @@@9       STORE A14,SDA2BS-FH1 . @B@@@9       LSDP HJ
)@@G@@ X5,SDSON,X5 .   FIND SON     @#@@@9BGEST1 LABEL .    @^@@@9       ADD  HK
)@@G@@ A15,A14 .  @F@@@9         SUB   A15,13 .      AW FOR STRUCTURE MEMBER PHL
)@@G@@ARAMETER    @C@@@9         LOAD  A13,A14 .     SAVE LAST OFFSET   @^@@@9HM
)@@G@@       LOAD  A2,SDCLS0 .@^@'@9         AND,U A2,7 .   @^@@@'         ANDHN
)@@G@@,U A2,017 . @D@@@9       LOAD  A2,BGNTTB+FH2,A3 .  GO THROUGH TABLE     HO
)@@G@@@D@@@9       LINK  0,A2 .    RETURN ADDR WILL BE BGEST2     @#@@@9BGEST2HP
)@@G@@ LABEL .    @F@@@9       MOVE  SDA2BS-FH1,SDA1BS-FH1 .   FIX UP SD FOR PHQ
)@@G@@ARAMETER    @ @@@9       STORE A15,SDA1BS-FH1 . @#@@@9BGEST4 LABEL .    HR
)@@G@@@D@@@9       LOAD  A2,SDDAD,X5 .    SAVE PTR FOR FATHER     @ @@@9      HS
)@@G@@ LSDP  X5,SDBROT,X5 .   @E@@@9       IF  X5,NZERO  THEN,BGEST1 .  ->ALLOHT
)@@G@@CATE FOR BROTHER  @B@@@9       LSDP  X5,W1XU,A2 .   FIND FATHER   @G@@@9HU
)@@G@@       IF  X5,NZERO  THEN,BGEST4 . ->ALLOCATE FOR BROTHER OF FATHER     HV
)@@G@@@D@'@9         UNSTK X11 .         RESTORE RETURN ADDRESS   @E@@@9      HW
)@@G@@   LOAD  X5,DBGWC1 .   RESTORE ORIGINAL SD POINTER    @H@'@9         STOHX
)@@G@@RE A12,SDNSPS,X5 . SET NUMBER OF STRING LEAVES OF STRUCTURE PARAM @B@@@9HY
)@@G@@       GOTO  BGNTR2 . ->TO ENTRY LOOP     @D@'@9BGEST5   LABEL .        HZ
)@@G@@     STRING STRUCTURE LEAF    @F@'@9         ADD   A12,1,I .     INCREMEIA
)@@G@@NT COUNT OF STRING LEAVES     @E@'@9         GOTO  BGSTRI .      -> MERGIB
)@@G@@E WITH STRING PROCESSING@#@'@9BGEST6   LABEL .  @F@'@9         MOVE  SDNIC
)@@G@@SPS,1,I . STRING PARAMETERS COUNT 1 STRING LEAF @E@'@9         GOTO  BGSID
)@@G@@TRI .      -> MERGE WITH STRING PROCESSING@[@'@9 .    @]@@@' . -------  IE
)@@G@@@A@@@' . SET UP FOR BLOCK STARTS HERE     @]@@@' . -------  @ @@@9      IF
)@@G@@   USING SDSECT,X9 .    @#@@@9BGALEN LABEL .    @D@@@9       STORE A14,DIG
)@@G@@TGTBT . OFFSET OF LOWEST TEMP CELL  @C@@@9       STORE A14,DTGMAX . NOW,IH
)@@G@@ ALSO HIGHEST     @F@@@9         LOAD  X11,DCGTLV .  SET LEVEL OF TEMP AII
)@@G@@LLOCATOR STACK    @ @@@9         USING TGDSCT,X11 .   @E@@@9       STOREIJ
)@@G@@ A14,TGFSET,X11 .  SET SIZE ZERO TEMP INTO STACK@ @@@9         MOVE  TGSIK
)@@G@@IZE,0,I .   @]@@@9 . -------  @C@@@9 . GENERATE INITIALIZATION CODE FOR IL
)@@G@@SCALARS     @]@@@9 . -------  @D@@@9         LOAD  R11,DCGSNO .  SAVE STIM
)@@G@@ATEMENT NUMBER    @ @@@9         STORE R11,DCGSNS .   @ @@@9         USIIN
)@@G@@NG SDSECT,X9 .    @F@@@9       GMARK SDSCIN .        INITIALIZATION ROUTIO
)@@G@@INE STARTS HERE   @E@@@'         MOVE    SDPTRB,DBGPTC . SAVE PTR LISTHDIP
)@@G@@ IN BLK SD  @^@@@9       LOAD  X5,DBGSCL  @D@@@9       MOVE  DCGLST,0177IQ
)@@G@@777,I . INDICATE NEW STMT     @D@'@9.         THE FOLLOWING LINE WAS DEEIR
)@@G@@MED UNNECESSARY   @D@'@9.       MOVE DCGSNS,DCGSNO .  SAVE STATEMENT NUMIS
)@@G@@BER   @C@@@9         LINK  BGALN1 .      JUMP INTO LOOP     @D@@@9      IT
)@@G@@   LOADA X11,$ .       RELOAD RETURN ADDRESS    @F@@@9       MOVE  DCGLSIU
)@@G@@T,DCGSNO . STATEMENT NUMBER OF LAST STATEMENT   @B@@@9       LOAD  X5,SDIV
)@@G@@ENBK,X5 .  FOLLOW CHAIN @#@@@9BGALN1 LABEL .    @G@'@9         IF    X5,IW
)@@G@@NZERO THEN,CGNTSC . -> GEN INITIALIZE SCALER CODE     @G@@@'         IF IX
)@@G@@   X5,NZERO THEN,CGNTSC . -> GEN INITIALIZE SCALAR CODE     @#@@@9BGNOSTIY
)@@G@@ LABEL .    @E@@@9       GEN .                 GENERATE RETURN TO EXNTRYIZ
)@@G@@ AFTER@E@@@9         GSUB  EXSCIE .      DOING SCALER INITIALIZATION    JA
)@@G@@@]@@@9 . -------- @A@@@9 . INIT DOPE VECTORS, STRING LENGTHS@]@@@9 . ---JB
)@@G@@----- @ @@@9       LSDP  X5,SDDVC,X9 .    @E@@@9       IF  X5,ZERO  THENJC
)@@G@@,BGNDVN . ->AREN'T ANY IN THIS BLOCK@D@@@9       MOVE  DCGLST,0177777,I JD
)@@G@@.    FORCE NEW STMT LOC.@#@@@'VGDVLP   LABEL .  @#@'@9VGDVLP LABEL .    JE
)@@G@@@^@@@'       USING SDSECT,X5 .@C@@@'       LOAD  X4,SDDVA,X5 . ADDR(DV TJF
)@@G@@EMPLATE)    @I@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,VGDV17JG
)@@G@@ . SKIP IF NOT BASED OR CONTRO@H@@@'         LINK    BGDUNSPY .        SJH
)@@G@@ET ADDRESS WORDS FOR BASED-CONTROLLED     @G@@@'         XGPUSH   'SIZE'JI
)@@G@@,1 .       GET WORD FOR JUMP AROUND INIT CODE   @#@@@'         GEN .    JJ
)@@G@@@G@@@'         GJUMP   SGDAID .          GENERATE JUMP ARROUND INIT+D.V.JK
)@@G@@ CODE @F@@@'         GMARK   SDALFD .          SAVE ADDR TO BEGIN OF D.VJL
)@@G@@. CODE@#@@@'         GEN .    @^@@@'         GLIT    1 .    @#@@@'      JM
)@@G@@   LOCAL .  @D@@@'         LOAD    A3,SDDVLG,X5 .    GET SIZE OF DV     JN
)@@G@@@B@@@'         STORE   A3,AGX0OF . SAVE SIZE    @#@@@'         GEN .    JO
)@@G@@@E@@@'         GINST   OPLR,AGRX1,AGXR0,U . GET SIZE TO TRANSFER  @ @@@'JP
)@@G@@         LOAD    X4,SDDVA,X5 .@C@@@'         LOAD    A6,W1U+1,X4 .     GJQ
)@@G@@ET ADDRESS  @E@@@'         STORE   A6,AGX0OF .       PUT WHERE CAN GET IJR
)@@G@@T     @F@@@'         LOADXI  A3,SDBKAW,X9 .    SET TO GO THRU STATIC LINJS
)@@G@@KS    @E@@@'         LOADXM  A3,SDLCOF,X5 .    GET LOCAL OFFSET OF DV   JT
)@@G@@@D@@@'         STORE   A3,AGXTMP .       SET FOR CODE GEN   @#@@@'      JU
)@@G@@   GENM .   @E@@@'         GINST   OPLA,AGRA3,AGXTMP,U 'NO' . GET INTO XJV
)@@G@@ REG. @E@@@'         GINST   OPLA,AGRA2,AGXR0,U 'NO' . GET INTO X REG.  JW
)@@G@@@^@@@'         GLIT    3 .    @^@@@'         LXI,U   A3,1 . @^@@@'      JX
)@@G@@   LXI,U   A2,1 . @D@@@'         BT      A3,0,*A2 .        MOVE DV TEMPLJY
)@@G@@ATE   @#@@@'         GFIN .   @#@@@'VGDV17 LABEL .    @C@'@9       LOAD JZ
)@@G@@ X4,SDDVA,X5 . ADDR(DV TEMPLATE)    @C@@@9       GMARK DBGWC1 . SAVE STAKA
)@@G@@RT OF DV INIT CODE@F@@@9         MOVE  DBGWC1+1,KKSNSM .       SET FOR AKB
)@@G@@DDRESS INTERUPT   @^@'@9       USING SDSECT,X5 .@F@@@9         LOAD  R11KC
)@@G@@,SDDCNM,X5 .         STATEMENT NUMBER OF DECLARE@E@@@9         STORE R11KD
)@@G@@,DCGSNO .  SET CURRENT STATEMENT NUMBER   @H@@@'         IF      SD0ARE,KE
)@@G@@ISON,SDCLS0  THEN,VGDV17A . AREAS LOOK LIKE STRINGS   @E@@@9       IF  SKF
)@@G@@DARST,OFF,SDCLS1  THEN,VGDV01 . ->NON-STRING    @[@@@9 . ---@A@@@9 . EVAKG
)@@G@@LUATE STRING LENGTH EXPRS     @[@@@9 . ---@#@@@'VGDV17A  LABEL .  @D@'@9KH
)@@G@@         LOADXI X1,1,I .    MAKE SURE INCR PART IS 1  @D@@@9         USIKI
)@@G@@NG SDDV,X4 .     DOPE VECTOR TEMPLATE     @F@@@9         LMCP  SDDVSM,X4KJ
)@@G@@ .   POINT TO META-CODE FOR STRING LENGTH @E@@@9       LINK  VGCVBD .  RKK
)@@G@@ETURNS LENGTH IN X2, COND CODE IN A3@F@@@9       IF  A3,EQ,VGNCON,I  THEKL
)@@G@@N,VGDV02 . ->LENGTH NON-CONSTANT    @E@@@9         IF    A2,GE,1,I THEN,KM
)@@G@@VGDV33 . LENGTH OK IF > 0     @H@@@9       EXERR  ERCGSL  LEVEL,2 . 'LENKN
)@@G@@GTH OF XX IS OUTOFRANGE.  80 IS USED'     @E@@@9 . 'LENGTH OF ', SDX5, 'KO
)@@G@@ IS NOT IN PROPER RANGE(', NUMA2,   @^@@@9 . ').  80 IS USED.'    @^@@@9KP
)@@G@@       LOAD  A2,80,I .  @#@@@9VGDV33 LABEL .    @F@@@9       STORE A2,SDKQ
)@@G@@DVSL,X4 .  SET STRING LENGTH IN DV TEMPLATE     @^@@@9       GOTO VGDV30KR
)@@G@@ .    @#@@@9VGDV02 LABEL .    @C@@@9       LOAD  A11,SDLCOF,X5 .  START KS
)@@G@@OF DV IN AR @E@@@9       ADD   A11,1,I .       OFFSET TO STRING LENGTH FKT
)@@G@@IELDS @D@@@'         LINK    VGVGEH .          FIX UP ADDRESSING  @F@'@9KU
)@@G@@         STORE A11,AGR10D .  FORM ADDRESS WORD FOR STRING LENGTH  @G@@@'KV
)@@G@@         STORE A11,AGXTMP+FH2 .  FORM ADDRESS WORD FOR STRING LENGTH    KW
)@@G@@@^@@@9       USING SDSECT,X5  @E@@@9       SET SDLNXP,ON,SDCLS2 .  MARK KX
)@@G@@LENGTH TO BE EVALUATED  @#@@@9       GENM .     @E@@@9       GIFR  VGDV0KY
)@@G@@3,AGPTX2 .  -> LENGTH ALREADY IN REGISTER @B@@@9       GLOAD AGPTX2 .  AKZ
)@@G@@SSURE IN REGISTER @#@@@9VGDV03 GLBL .     @C@'@9       GINST OPSA,AGPTX2LA
)@@G@@,AGXR10 .  MOVE INTO DV @C@@@'       GINST OPSA,AGPTX2,AGXTMP .  MOVE INLB
)@@G@@TO DV @#@@@9       GFIN .     @#@@@9VGDV30 LABEL .    @ @@@9         LOALC
)@@G@@D  F,SDCLS1,X5 .  @F@@@9         IF    SDFXVR,OFF THEN,VGDVS2 . -> FIXEDLD
)@@G@@ LENGTH STRING    @H@@@9         MOVE  DBGWC1+1+FS1,ARDVUN++ARDVVR,I . MLE
)@@G@@ARK VARYING UNALLOCATED STRING@D@@@9         LOAD  A2,0,I .      SET ZERLF
)@@G@@O CURRENT LENGTH  @E@@@9VGDVS2   LABEL .             DETERMINE TYPE OF SLG
)@@G@@TRING DATA  @F@@@9         STORE A2,SDDVSM,X4 .          SET CURRENT LENLH
)@@G@@GTH FIELD   @E@@@9       IF  SDARRY,OFF,SDCLS2  THEN,VGDV36 . ->SCALAR SLI
)@@G@@TRING @#@@@9VGDV01 LABEL .    @G@'@9       IF  SDARRY,OFF,SDCLS2  THEN,VLJ
)@@G@@GDV05 . ->SCALAR MEM OF STRUCTURE   @H@@@'       IF  SDARRY,ON,SDCLS2  TLK
)@@G@@HEN,VGDV01A . ->NOT SCALAR MEM OF STRUCTURE     @G@@@'         IF      SLL
)@@G@@D0BSD+SD0CNT,OFF,SDCLS0 THEN,VGDV05 . NOT BASED/CNTRLD@#@@@'         GENLM
)@@G@@ .    @^@@@'         GLIT    1 .    @#@@@'         JMP .    @E@@@'      LN
)@@G@@   GOTO    VGDV05 .          SCALAR MEM OF STRUCTURE  @#@@@'VGDV01A  LABLO
)@@G@@EL .  @[@@@9 . ---@H@@@9 . EVAL BOUNDS EXPR FOR ARRAY (FIND LARGEST DIMELP
)@@G@@NSIONED STRUCTURE CONTAINING  @ @@@9 . THIS BASE ELEMENT AS A SON)@[@@@9LQ
)@@G@@ . ---@^@@@9         LOAD  X3,0,I . @#@@@9VGDV07 LABEL .    @B@@@9      LR
)@@G@@ LOAD  X4,X5 .  X4=SD PTR TO SON    @ @@@9       LSDP  X5,SDDAD,X5 .    LS
)@@G@@@F@@@9       IF  X5,ZERO  THEN,VGDV06 . ->NO FATHER, MAJOR STRUCURE     LT
)@@G@@@G@@@9       IF  SDNDIM,ZERO  THEN,VGDV06 . -> SUPER STRUC., NOT DIMENSILU
)@@G@@ONED  @ @@@9       LOAD  A3,SDLCOF,X4 .   @^@@@9       USING SDSECT,X5 .LV
)@@G@@@F@@@9       IF  A3,EQ,SDLCOF  THEN,VGDV07 . ->X4 IS FIRST SON OF X5    LW
)@@G@@@H@@@9 . NOW, X4 IS SD PTR TO LARGEST STRUCTURE CONTAINING THE ORIG. BASLX
)@@G@@E ELEMENT   @E@@@9 . AS THE FIRST NON-STRUCTURE SON (THIS MAY BE ORIGINALY
)@@G@@L SD) @#@@@9VGDV08 LABEL .    @G@@@9       LOAD X3,SDNDIM,X5 .  # OF DIMLZ
)@@G@@ENSIONS INHERITED FROM DAD (NID)    @#@@@9VGDV06 LABEL .    @F@@@9      MA
)@@G@@   ADD   X3,W1U,X3 .   NUMBER OF INHERITED DIMENSIONS (NID) @#@@@9VGDV77MB
)@@G@@   LABEL .  @H@@@9         LOAD  A7,SDNDIM,X4 .          NUMBER DIMENSIOMC
)@@G@@NS IN CURRENT SD (NCD)  @ @@@9         ADD   A7,SDNDIM,X4 . @]@@@9 . ---MD
)@@G@@---   @C@@@9 . FIND META-CODE FOR SUBSCRIPT BNDS ON NCD     @]@@@9 . ---ME
)@@G@@---   @^@@@9       USING SDSECT,X4 .@E@'@9       IF  SDSTRU,OFF,SDCLS4  MF
)@@G@@THEN,VGDV09 . ->BASE ELEMENT  @G@@@9       LOAD  A8,SDSTRB,X4 . FOR A STMG
)@@G@@RU. THIS POINTS TO M-CODE FOR BOUNDS@F@@@'       IF  SDSTRU,ON,SDCLS4  TMH
)@@G@@HEN,VGDV10 . ->NOT BASE ELEMENT     @^@'@9       GOTO VGDV10 .    @[@'@9MI
)@@G@@ .    @#@'@9VGDV09 LABEL .    @ @@@9       LOAD  X2,SDDVA,X4 .    @E@@@9MJ
)@@G@@       LOAD  A8,SDDVBM,X2 . FOR NON-STRU. M-CODE IS HERE    @#@@@9VGDV10MK
)@@G@@ LABEL .    @E@@@9         LMCP  R,A8 .        POINT TO FIRST BOUND EXPRML
)@@G@@ESSION@C@@@9       LOAD  X5,X4 . SAVE CURRENT SD POINTER    @ @@@9      MM
)@@G@@   USING SDSECT,X5 .    @B@@@9.  A8  [0(R11)] = CURRENT META-CODE SYMBOLMN
)@@G@@@D@@@9.  X3  [R3]     = NUMBER OF INHERINTED DIMENSIONS     @C@@@9.  X4 MO
)@@G@@         = SD POINTER OF ROOT OF SUBTREE  @A@@@9.  X5  [R5]     = CURRENMP
)@@G@@T SD POINTER@B@@@9.  A7  [R0]     = DIMENSIONS IN CURRENT SD@F@@@9.     MQ
)@@G@@            AT ENTRY EITHER  ACDIML OR ACDIMU IS THE CURRENT@D@@@9.     MR
)@@G@@            META-CODE JUST  GETC'ED INTO A8     @G@@@9.  A10         = VMS
)@@G@@ALUE OF EXTENT - 1, LOWER BOUND PAIR FOR DV TEMPLATE  @E@@@9.  X2  [R2] MT
)@@G@@    = POINTER TO AW FOR VARIABLE SUBSCRIPT BOUND@D@@@9.  A2  [R2]      =MU
)@@G@@ VALUE FOR CONSTANT SUBSCRIPT BOUND @E@@@9.  A9            = SCRATCH FORMV
)@@G@@ CONSTANT EXTENT-1 CALCULATION@D@@@9.  A10           = VALUE FOR CONSTANMW
)@@G@@T LOWER BOUND     @E@@@9.  A9            = IN SOME CASES  POINTS TO LOWEMX
)@@G@@R BOUND AW  @E@@@9VGDV11   LABEL .                   DETERMINE LOWER BOUMY
)@@G@@ND    @B@@@9         GETC .     READ ACLB OR ACUB     @H@@@9         IF MZ
)@@G@@     A7,EQ,X3 THEN,VGDV12 . -> REPEAT UNTIL N1D=NCD,THEN TO SON   @G@@@9NA
)@@G@@         ADD   X3,2,I .      ADVANCE TO NEXT MULTIPLIER-BOUNDS PAIR     NB
)@@G@@@G@@@9         DLN     A9,KKD0-(IN 63,0,1,0) . SET DOUBLEWORD ZERO AS DENC
)@@G@@FAULT @D@@@9.                                  FOR UNKNOWN BOUNDS @C@@@9ND
)@@G@@         IF      A8,EQ,ACDMLB,I THEN,VGDVL1 .   @F@@@9         LOAD    ANE
)@@G@@10,1,I .         SET DEFAULT LOWER BOUND OF ONE @B@@@9         GOTO    VNF
)@@G@@GDVLO .          ->MERGE@B@@@9VGDVL1   LABEL . LOWER BOUND WAS GIVEN .  NG
)@@G@@@F@@@9         LINK    VGCVBD .          EVALUATE LOWER BOUND EXPRESSIONNH
)@@G@@@G@@@9         IF      A3,NE,VGCON,I THEN,VGDVLV . ->VARIABLE LOWER BOUNNI
)@@G@@D     @C@@@9         GETC .                    SKIP ACCOLN  @C@@@9      NJ
)@@G@@   GETC .                    SKIP ACDMUB  @D@@@9         LOAD  A10,A2 . NK
)@@G@@     SAVE CONSTANT LOWER BOUND@C@@@9VGDVLO   LABEL . CONSTANT LOWER BOUNNL
)@@G@@D KNOWN     @F@@@9         LINK    VGCVBD .          EVALUATE UPPER BOUNNM
)@@G@@D EXPRESSION@G@@@9         IF      A3,NE,VGCON,I THEN,VGDVUV . ->VARIABLNN
)@@G@@E UPPER BOUND     @C@@@9         GETC .   IGNORE ","       SKIP ACCOMA  NO
)@@G@@@D@@@9         LOAD    A9,A2 .           SAVE UPPER BOUND   @D@@@9      NP
)@@G@@   SUB     A9,A10 .          DETERMINE EXTENT-1 @F@@@9         LOAD    ANQ
)@@G@@3,W1U,X3 .       OFFSET TO CURRENT MULTIPLER .  @E@@@9         SRB     ANR
)@@G@@3,1 .            COMPUTE SUBSCRIPT NUMBER @E@@@9         JP      A9,VGDVNS
)@@G@@EK .       ->EXTENT IS OK SO FAR    @E@@@9         EXERR   ERCXBD  LEVELNT
)@@G@@,2 . LOWER BOUND>UPPER BOUND  @H@@@9 . 'LOWER BOUND OF ', SDX5, ' IS GRENU
)@@G@@ATER THAN LOWER BOUND FOR SUBSCRIPT',     @ @@@9 . NUMA3, '  (1:10) IS UNV
)@@G@@SED.' @D@@@9         GOTO    VGDVER .          ->REPAIR BOUNDS    @B@@@9NW
)@@G@@VGDVEK   LABEL . CONSTANT EXTENT OK,SO FAR@ @@@9         USING   WORD,0 NX
)@@G@@.     @[@@@9.     @[@@@9.     @G@@@9.                THE PROCS WON'T ALLNY
)@@G@@OW MORE THAN 16 BITS IN U FIELD...  @E@@@9.                THEREFORE THENZ
)@@G@@ FOLLOWING ASM CHEATS DO THIS @[@@@9.     @G@@@9.        IF      A9,LT,WOA
)@@G@@1U+0400000 THEN,VGDVES . EXTENT SMALL ENOUGH    @ @@@9         TLE,U   AOB
)@@G@@9,0400000 . @^@@@9         GOTO    VGDVES @D@@@9         EXERR   ERCXMP OC
)@@G@@ LEVEL,2 . EXTENT TOO LARGE   @G@@@9.        'EXTENT OF SUBSCRIPT',  NUMOD
)@@G@@A3,   'OF ',SDX5,' IS TOO LARGE.'   @ @@@9.        ' (0:10) IS USED.'   OE
)@@G@@@B@@@9VGDVER   LABEL . REPAIR FAULTY BOUNDS     @E@@@9         LOAD    AOF
)@@G@@9,10,I .         REPAIR VALUE FOR EXTENT-1@E@@@9         GOTO    VGDVES OG
)@@G@@.          ->SET CONSTANT EXTENT    @D@@@9VGDVUV   LABEL . CONSTANT LOWEOH
)@@G@@R BOUND, VARIABLE UPPER @ @@@9         GETC .   IGNORE ","  @F@@@9      OI
)@@G@@   IF      A10,NE,1,I THEN,VGDVNO . ->LOWER BOUND NOT ONE   @D@@@9      OJ
)@@G@@   MOVE    AGTMP1,0,I . PREPARE A CLEAN LABEL AW@#@@@9         GENM .   OK
)@@G@@@E@@@9         GIFR    VGDVJG,AGPTX2 .   UPPER BOUND IN REGISTER? @F@@@9OL
)@@G@@         GLOAD   AGPTX2,1 .        PUT UPPER BOUND IN REGISTER .  @G@@@9OM
)@@G@@VGDVJG   GLBL .                    MERGE WHEN UPPER BOUND IN REGISTER   ON
)@@G@@@E@@@9         GJGD    AGPTX2,AGTMP1 .   COMPUTE THE EXTENT -1    @F@@@9OO
)@@G@@         GSUB    EXJGDE .          ->REPAIR THE EXTENT IF NEEDED  @D@@@9OP
)@@G@@         GLABEL  AGTMP1 .          FIX LABEL FOR JGD .@H@@@9         GFIOQ
)@@G@@N .                    PROPER EXTENT-1 NOW IN REGISTER AGPTX2     @E@@@9OR
)@@G@@         GOTO    VGDVUH .          ->EXTENT-1 IN REGISTER   @C@@@9VGDVNOOS
)@@G@@   LABEL . CONSTANT LOWER BOUND NOT ONE   @#@@@9         GENM .   @E@@@9OT
)@@G@@         GIFR    VGDVOL,AGPTX2 .   ->UPPER BOUND IN REGISTER@H@@@9      OU
)@@G@@   GLOAD   AGPTX2,1 .        OTHER WISE PUT UPPER BOUND INTO REGISTER   OV
)@@G@@@#@@@9VGDVOL   GLBL .   @#@@@9         GFIN .   @F@@@9         IF      AOW
)@@G@@10,EQ,0,I THEN,VGDVUH . UPPER BOUND = EXTENT-1  @E@@@9         STORE   AOX
)@@G@@10,AGX0OF .      SET CONSTANT LOWER BOUND @D@@@9         GEN  .         OY
)@@G@@           COMPUTE EXTENT-1   @E@@@9         GINST   OPAA,AGPTX2,AGXR0,XOZ
)@@G@@U 'NO' . (UPPER-LOWER)  @E@@@9VGDVUH   LABEL . CONSTANT LOWER BOUND,VARIPA
)@@G@@ABLE UPPER BOUND  @B@@@9.                                  X2->AW @F@@@9PB
)@@G@@         MOVE    DGFLGZ,1,I .      SET FLAG TO STORE EXTENT-1 ONLY@#@@@9PC
)@@G@@VGDVES   LABEL .  @E@@@9         SLB     A10,18 .          LEFT JUSTIFY PD
)@@G@@LOWER BOUND @H@@@9         SRBD    A9,18 .           PACK EXTENT-1 AND LPE
)@@G@@OWER BOUND INTO A10     @ @@@9         GOTO    VGDV14 .     @B@@@9VGDVLVPF
)@@G@@   LABEL . VARIABLE LOWER BOUND     @C@@@9         GETC .               PG
)@@G@@     SKIP ACCOLN  @C@@@9         GETC .                     SKIP ACDMUB PH
)@@G@@@E@@@9         SUB     X7,DCGSLT,I .     PUSH A FAKE STACK ITEM . @B@@@9PI
)@@G@@.        LOWER BOUND IS THEN AGRL1 AGAIN .@E@@@9         LINK    VGCVBD PJ
)@@G@@.          EVALUATE UPPER BOUND     @F@@@9         LOAD    X8,AGXR0 .  TPK
)@@G@@HIS PUTS POINTER TO AGRX0 IN H1     @A@@@9         LOADXM  X8,0400000,I PL
)@@G@@.     @D@@@9         STORE   X8,AGTMP1 .       SET DEBUG TEST AW  @G@'@9PM
)@@G@@         MOVE    DGFLGZ,DGOPT3 .   PUT DEBUG OPTION WHERE ACCESSABLE    PN
)@@G@@@G@@@'         MOVE    DGFLGZ,DCGONF .   PUT CONDITION FLAGS WHERE ACCESPO
)@@G@@SABLE @C@@@9         MOVE  AGLBL,0,I .   INITIALIZE LABEL AW@G@@@9      PP
)@@G@@   IF      A3,EQ,VGNCON,I THEN,VGDVVU . ->VARIABLE UPPER BOUND    @D@@@9PQ
)@@G@@         STORE   A2,AGX0OF .       SET AW FOR CONSTANT@F@@@9         GENPR
)@@G@@M .                    X2->AW OF AGRL1 BEFORE POP     @G@@@9         GGEPS
)@@G@@TGR  AGPTX2,1 .        GET AN 'A' REGISTER FOR UPPER BOUND  @G@@@9      PT
)@@G@@   GINST   OPLA,AGPTX2,AGXR0,XU 'NO' . LOAD CONSTANT UPPER BOUND  @F@@@9PU
)@@G@@         GMODE   'S' .             SET FLAG TO PACK FOR IGEN CODE @B@@@9PV
)@@G@@         GGOTO   VGDVUR .          ->MERGE@C@@@9VGDVVU   LABEL . VARIABLPW
)@@G@@E UPPER AND LOWER BOUNDS@F@@@9         GENM .                    X2->AW PX
)@@G@@FOR VARIABLE UPPER BOUND@E@@@9         GIFR    VGDVUR,AGPTX2 .   ->UPPERPY
)@@G@@ BOUND IN REGISTER@F@@@9         GLOAD   AGPTX2,1 .        PUT UPPER BOUPZ
)@@G@@ND INTO REGISTER  @C@@@9VGDVUR   GLBL .  NOW UPPER BOUND IS IN REGISTER QA
)@@G@@@F@@@9         GINST   OPANA,AGPTX2,AGRL1 'NO' . COMPUTE THE EXTENT-1   QB
)@@G@@@E@'@9         GBOFF   VGDVND,0400 .     ->NO DEBUGGING REQUESTED @E@@@'QC
)@@G@@         GBOFF   VGDVND,02   .     ->NO SUBSCRIPTRANGE SET  @G@@@9      QD
)@@G@@   GINST   OPTLE,AGPTX2,AGTMP1,U 'NO' . ->VALUE FITS IN HALF WORD @F@@@9QE
)@@G@@         GCJMP   OPJP,AGPTX2,AGLBL 'NO' .->EXTENT NOT NEGATIVE    @F@@@9QF
)@@G@@         GSUB    EXJGDE .          ->REPAIR EXTENT WHERE NEEDED   @E@@@9QG
)@@G@@         GLABEL  AGLBL .           SET TARGET UP FOR JP     @D@@@9VGDVNDQH
)@@G@@   GLBL .  MERGE HERE AFTER CHECKING EXTENT-1   @F@@@9         GBR     VQI
)@@G@@GDVST,SDSTRU,OFF,AGPTX5,Q1 . ->NOT A STRUCTURE  @G@@@9         GSHIN   OQJ
)@@G@@PLSSL,AGPTX2,18,I . PUT EXTENT-1 INTO H1 OF REGISTER  @G@@@9         GINQK
)@@G@@ST   072,AGPTX2,AGRL1,04 . GENERATE AH LOWER BOUND TO H2    @F@@@9      QL
)@@G@@   GFIN    'POP' .           GET RID OF FAKE STACK ELEMENT  @F@@@9      QM
)@@G@@   MOVE    DGFLGZ,2,I .      BOUNDS PAIR IN ONE REGISTER    @ @@@9      QN
)@@G@@   GOTO    VGDV14 .     @D@@@9         GMODE 'M' .         SET FOR PACKEQO
)@@G@@D IGEN CODE @H@@@9VGDVST   GLBL .                    WHEN NOT STRUCTURE QP
)@@G@@TWO REGISTERS CONTAIN   @E@@@9.                                  EXTENT-QQ
)@@G@@1,AND LOWER BOUND @E@@@9         GIFR    VGDV95,AGRL1 .    ->LOWER BOUNDQR
)@@G@@ IN REG     @F@@@9         GLOAD   AGRL1,1 .         PUT LOWER BOUND IN QS
)@@G@@'A' REG     @A@@@9VGDV95   GLBL .  BOTH PARTS IN REGS @#@@@9         GFIQT
)@@G@@N .   @F@@@9         MOVE    DGFLGZ,4,I .      BOUNDS PAIR IN TWO REGISTQU
)@@G@@ERS   @E@@@9         LOADA   A9,AGRL1,X7 .     A9-> LOWER BOUND REGISTERQV
)@@G@@@F@@@9         XGPOP   'SIZE',DCGSLT .   GET RID OF FAKE STACK ELEMENT  QW
)@@G@@@G@@@9. ----------------------------------------------------------------QX
)@@G@@----- @C@@@9. GENERATE CODE TO PUT BOUND INTO DOPE VECTOR . @G@@@9. ----QY
)@@G@@----------------------------------------------------------------- @#@@@9QZ
)@@G@@VGDV14   LABEL .  @H@@@9         LOAD    A8,X4 .              POINTER TORA
)@@G@@ ORIGINAL SD FOR COMPARISION  @E@@@9VGDV15   LABEL .           MERGE WHERB
)@@G@@N SETTING BOUNDS OF SON @F@@@9         IF    SDSTRU,ON,SDCLS4 THEN,VGDV9RC
)@@G@@7 . -> FIND SON OF SON  @D@@@9         LOAD    X8,SDDVA,X5 .     DV TEMPRD
)@@G@@LATE ADDRESS@H@@@9         ADD     X8,W1U+1,X3 .     OFFSET IN DV TEMPLARE
)@@G@@TE TO BOUNDS PAIR-1     @E@@@9         STORE   A10,W1+1,X8 .      SET TERF
)@@G@@MPLATE BOUNDS PAIR@G@@@9         JP      A10,VGDV96 .      ->CONSTANT BORG
)@@G@@UNDS TO CODE GENERATED  @F@@@9         LOAD    A2,SDLCOF,X5 .    OFFSET RH
)@@G@@IN AR TO START OF DV    @F@@@9         ADD     A2,W1U+1,X3 .     OFFSET RI
)@@G@@IN AR DV TO BOUNDS PAIR @D@@@'         LINK    VGVGEH .          FIX UP RJ
)@@G@@ADDRESSING  @E@'@9         STORE   A2,AGR10D .       PREPARE AW FOR BOUNRK
)@@G@@DS    @E@@@'         STORE   A2,AGXTMP+FH2 .       PREPARE AW FOR BOUNDSRL
)@@G@@@H@@@9         GENM .                    GENERATE APPROPRIATE STORE INSTRM
)@@G@@RUTIONS     @E@@@9         GBOFF   VGDV81,04 .       ->BOUNDS IN ONE REGRN
)@@G@@ISTER @G@'@9         GINST   OPSA,AGPTX2,AGXR10,H1  . SET EXTENT-1 AND FRO
)@@G@@REE REGISTER@G@@@'         GINST   OPSA,AGPTX2,AGXTMP,H1  . SET EXTENT-1RP
)@@G@@ AND FREE REGISTER@H@'@9         GINST   OPSA,AGPTA9,AGXR10,H2  . SET LORQ
)@@G@@WER BOUND AND FREE REGISTER   @H@@@'         GINST   OPSA,AGPTA9,AGXTMP,RR
)@@G@@H2  . SET LOWER BOUND AND FREE REGISTER   @G@@@9         GFIN .         RS
)@@G@@           BOUNDS IN ONE DV ONLY (SDSTRU IS OFF)@G@@@9         GETC .   RT
)@@G@@                  ABSORB ACCOMA BEFORE NEXT DIM PAIR  @G@@@9         GOTRU
)@@G@@O    VGDV11 .           ->NODE WAS LEAF, MORE DIMENSIONS?   @E@@@9      RV
)@@G@@   GMODE 'M' .                SET FOR PACKED IGEN CODE@B@@@9VGDV81   GLBRW
)@@G@@L .  BOUNDS IN ONE REGISTER   @E@@@9         GBOFF   VGDV82,02 .       -RX
)@@G@@>CONSTANT LOWER BOUND   @D@'@9         GINST   OPSA,AGPTX2,AGXR10 'NO' .RY
)@@G@@ BOUND PAIR @D@@@'         GINST   OPSA,AGPTX2,AGXTMP 'NO' . BOUND PAIR RZ
)@@G@@@ @@@9         GGOTO   VGDV84 .     @B@@@9VGDV82   GLBL .  CONSTANT LOWESA
)@@G@@R BOUND     @E@'@9         GINST   OPSA,AGPTX2,AGXR10,H1 'NO' . SET EXTESB
)@@G@@NT-1  @E@@@'         GINST   OPSA,AGPTX2,AGXTMP,H1 'NO' . SET EXTENT-1  SC
)@@G@@@F@@@9VGDV84   GLBL .                    MERGE AFTER STORING BOUNDS     SD
)@@G@@@#@@@9         GFIN .   @H@@@9VGDV96   LABEL .                   MERGE FSE
)@@G@@ROM SETTING CONSTANT BOUNDS PAIR    @ @@@9         USING SDSECT,X5 .    SF
)@@G@@@F@@@9         IF      A8,EQ,X5 THEN,VGDV55 . BACK TO ORIGINAL,FREE REGSSG
)@@G@@@F@@@9         IF    SDBROT,ZERO THEN,VGDV71 . -> NO BROTHER, FIND DAD  SH
)@@G@@@G@@@9         LSDP    X5,SDBROT,X5 .    ->PREPARE TO SET BOUNDS INTO BRSI
)@@G@@OTHER @D@@@9         GOTO    VGDV15 .          ->PROCESS BROTHER  @C@@@9SJ
)@@G@@VGDV97   LABEL .                   FIND SON     @C@@@9         LSDP    XSK
)@@G@@5,SDSON,X5 .     ->LOOK AT SON@B@@@9         GOTO  VGDV15 .      PROCESSSL
)@@G@@ SON  @C@@@9VGDV71   LABEL .                   EXAMINE DAD  @C@@@9      SM
)@@G@@   LOAD    X5,SDDAD,X5 .     ->GET FATHER @E@@@9         GOTO    VGDV96 SN
)@@G@@.          LOOK AT BROTHER OF FATHER@F@@@9VGDV12   LABEL .              SO
)@@G@@     CURRENT NODE'S DIMENSIONS DONE @ @@@9         USING   SDSECT,X5 .  SP
)@@G@@@G@@@9         IF      SDSTRU,OFF,SDCLS4 THEN,VGDV48 . ->HAVE REACHED LESQ
)@@G@@AF .  @E@@@9         LOAD    X4,SDSON,X5 .     PREPARE TO LOOK AT SON   SR
)@@G@@@F@@@9         GOTO    VGDV77 .          ->FIND DIMENSIONS OF SON .     SS
)@@G@@@H@@@9VGDV55   LABEL .                   FREE REGISTERS AFTER BOUNDS PAIST
)@@G@@R STORED    @H@@@9         JP      A10,VGDV11 .      CONSTANT EXTENT,NO SU
)@@G@@FREE NEEDED,MORE DIMS?  @B@@@9         GEN . FREE REGISTER THAT WAS USEDSV
)@@G@@@D@@@9         GFREE   AGPTX2 .          FREE EXTENT REG    @H@@@9      SW
)@@G@@   GOTO    VGDV11 .          ->LOOK FOR MORE DIMENSIONS IN CURRENT NODE SX
)@@G@@@F@@@9. --------------------------------------------------------------- SY
)@@G@@@A@@@9. FIGURE OUT THE VO AND THE MPLRS   @F@@@9. ----------------------SZ
)@@G@@----------------------------------------- @C@@@9 . UNKNOWN BOUNDS AND EXTA
)@@G@@TENTS ARE MARKED BY -0. @B@@@9.  A15   = MULTIPLIER AND ARRAY SIZE .    TB
)@@G@@@A@@@9.  A13-A14       = V.O. STORAGE     @D@@@9.  A11-A12       = V.O. TC
)@@G@@COMPUTATION WITH LOWER BOUND  @B@@@9.  A9-A10        = EXTENT COMPUTATIOTD
)@@G@@N     @A@@@9.  X8    = -> TO CURRENT MULTIPLIER @F@@@9. ----------------TE
)@@G@@----------------------------------------------- @#@@@9VGDV48   LABEL .  TF
)@@G@@@ @@@9         LOAD  X8,SDDVA,X5 .  @F@@@9         ADD   X8,W1U+1,X3 . DTG
)@@G@@V TEMPLATE LAST MULTIPLIER ADDRESS  @F@@@9         SLBD    A13,72 .     TH
)@@G@@     CLEAR VIRTUAL ORIGIN STORAGE . @F@@@9         LOAD    A15,SDRTC,X5 TI
)@@G@@.    DATA WIDTH IS FIRST MULTPLIER  @G@@@9         LOADXI  X8,-2,I .    TJ
)@@G@@     SET TO DECREMENT THROUGH MULTIPLIERS @F@@@9         LOAD    F,SDCLSTK
)@@G@@2,X5 .     GET BOUND EXPRESSION FLAGS     @#@@@9VGDV47   LABEL .  @F@@@9TL
)@@G@@         STORE   A15,W1,X8 .   SET MULTIPLIER INTO DV TEMPLATE    @#@@@9TM
)@@G@@VGDV49   LABEL .  @H@@@9         LOAD    A11,W1XH2+1,*X8 .   GET LOWER BTN
)@@G@@OUND AND MOVE POINTER DOWN    @G@@@9         TNZ     A11 .             STO
)@@G@@KIP IF LOWER BOUND KNOWN NOT ZERO   @E@@@9         JN      A11,VGDV39 . TP
)@@G@@     ->UNKNOWN LOWER BOUND    @E@@@9         MPY     A11,A15 .         LTQ
)@@G@@OWER BOUND*MULTIPLIER   @D@@@9         DAN     A13,A11 .         VIRTUALTR
)@@G@@ ORIGIN     @E@@@9         DLSC    A2,A13 .          CHECK FOR V.O. OVERTS
)@@G@@FLOW  @E@@@9         IF      A4,GE,37,I THEN,VGDV46 . ->VO WITHIN RANGE TT
)@@G@@@E@@@9         LOAD    A3,X3  .          GET MULTIPLIER  OFFSET   @F@@@9TU
)@@G@@         SRB     A3,1 .             CORRECT TO SUBSCRIPT NUMBER . @E@@@9TV
)@@G@@         EXERR   ERCXV0  LEVEL,2 . VIRITUAL ORIGIN OVERFLOW @D@@@9 . SDXTW
)@@G@@5, 'REQUIRES TOO MUCH SPACE.  LOWER BOUND ',    @A@@@9 . NUMA3, ' IS ADJTX
)@@G@@USTED TO ZERO. '  @[@@@9.     @E@@@9         DA      A13,A11 .         ATY
)@@G@@PPLY CORRECTION TO V.O. @ @@@9         USING   WORD,X8 .    @D@@@9      TZ
)@@G@@   MOVE    W1H2+3,0,I .      RESET LOWER BOUND  @F@@@9VGDV46   LABEL .  UA
)@@G@@                 VIRTUAL ORIGIN WITHIN RANGE    @E@@@9         TP      3UB
)@@G@@,X8 .            SKIP IF EXTENT-1 KNOWN   @D@@@9         GOTO    VGDV39 UC
)@@G@@.          ->EXTENT UNKNOWN   @C@@@9         LOAD    A10,W1H1+3,X8 .   EUD
)@@G@@XTENT-1     @D@@@9         STORE   A15,A9 .          SAVE OLD MULTIPLER UE
)@@G@@@D@@@9         ADD     A10,1,I .         COMPUTE EXTENT     @D@@@9      UF
)@@G@@   MPYS    A15,A10 .         MPLR=MPLR*EXTENT   @F@@@9         TLE,U   AUG
)@@G@@15,0400000 .      SKIP IF MULTIPLIER TOO LARGE  @E@@@9         GOTO    VUH
)@@G@@GDV29 .          ->CHECK FOR MORE BOUNDS  @E@@@9         LOAD    A3,X3 .UI
)@@G@@           GET MULTIPLIER OFFSET    @F@@@9         SRB     A3,1 .       UJ
)@@G@@     CONVERT TO SUBSCRIPT NUMBER    @D@@@9         EXERR   ERCXMP  LEVELUK
)@@G@@,2 . MULT TOO LARGE .   @[@@@9.     @D@@@9 . SDX5, ' REQUIRES TOO MUCH SUL
)@@G@@PACE.  UPPER BOUND ',   @A@@@9 . NUMA3, ' IS SET TO LOWER BOUND.' @[@@@9UM
)@@G@@.     @G@@@9         LOAD    A15,A9 .          RETURN MULTIPLIER TO FORMUN
)@@G@@ER VALUE    @ @@@9         USING   WORD,X8 .    @E@@@9         MOVE    WUO
)@@G@@1H1+3,0,I .      SET CORRECTION EXTENT-1  @B@@@9VGDV29   LABEL . CHECK FUP
)@@G@@OR MORE BOUNDS    @G@@@9         SUB     X3,2,I .          DECREMENT TO UQ
)@@G@@NEXT MULTIPLIER OFFSET  @B@@@9         IF      X3,ZERO THEN,VGDV28 .    UR
)@@G@@@D@@@9         IF      SDBDEX,ON THEN,VGDV49 ELSE,VGDV47 .  @D@@@9VGDV39US
)@@G@@   LABEL .                   UNKNOWN EXTENT     @E@@@9         SET     SUT
)@@G@@DBDEX,ON .SET FLAG FOR BOUNDS COMPUTATION @G@@@9         SUB     X3,2,I UU
)@@G@@.          DECREMENT TO NEXT MULTIPLIER OFFSET  @G@@@9         IF      XUV
)@@G@@3,NZERO THEN,VGDV49 . ->PROCEED TO NEXT BOUND WITHOUT @D@@@9.           UW
)@@G@@                       RESETTING MPLR     @D@@@9VGDV28   LABEL .        UX
)@@G@@           ALL BOUNDS CHECKED @D@@@9         STORE   F,SDCLS2,X5 .     RUY
)@@G@@ESTORE BOUND FLAGS@#@@@9VGDV36 LABEL .    @^@@@9       USING SDSECT,X5 .UZ
)@@G@@@I@'@9       IF  SDBDEX+SDLNXP,OFF,SDCLS2  THEN,VGDV05 . -> CONSTANT BOUVA
)@@G@@NDS AND STRING    @E@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,VB
)@@G@@VGDV09 .    @#@@@'         GEN .    @^@@@'         GLIT    1 .    @#@@@'VC
)@@G@@         JMP .    @G@'@9       GEN .                 RETURN TO EXNTRY AFVD
)@@G@@TER DV INITIALIZATION   @G@'@9         GSUB  EXADVE .      FOR NON-CONSTVE
)@@G@@ANT BOUNDS OR STRING LENGTHS  @ @@@'         GOTO    VGDV05 .     @#@@@'VF
)@@G@@VGDV09   LABEL .  @I@@@'       IF  SDBDEX+SDLNXP,OFF,SDCLS2  THEN,VGDV05VG
)@@G@@ . -> CONSTANT BOUNDS AND STRING    @G@@@'         GEN .                VH
)@@G@@     RETURN TO EXNTRY AFTER D.V. INIT     @G@@@'         GSUB  EXADVE . VI
)@@G@@     FOR NON-CONSTANT BOUNDS OR STRING LENGTHS  @#@@@9VGDV05 LABEL .    VJ
)@@G@@@^@@@9         USING SDDV,X4 .@C@@@9         LOAD  X4,SDDVA,X5 . DOPE VEVK
)@@G@@CTOR ADDRESS@ @@@9         LOADD A3,DBGWC1 .    @G@@@9         STORE A3,VL
)@@G@@SDDVBD,X4 .          SET INITIALIZATION CODE ADDRESS  @I@@@9         STOVM
)@@G@@RE A4,SDDVMX,X4 .          SET STRING FLAG, UNALLOCATED FLAG, AND AD    VN
)@@G@@@#@@@9VGDV37 LABEL .    @^@@@9       USING SDSECT,X5 .@F@'@9       IF  SVO
)@@G@@DINTL,OFF,SDCLS3  THEN,VGDVNL . -> NO INITIALIZATION  @F@@@'       IF  SVP
)@@G@@DINTL,OFF,SDCLS3  THEN,VGDVNL . -> NO INITIALIZATION  @F@@@9         IF VQ
)@@G@@SDARRY,OFF,SDCLS2 THEN,VGSTRN . STRING INITIALIZATION @E@'@9         LOAVR
)@@G@@D  A3,SDCLS0,X5 .      LOAD UP STORAGE CLASS    @E@'@9         AND,U A3,VS
)@@G@@017 .        GET RID OF STORAGE CLASS     @G@'@9         IF A4,EQ,SD0LABVT
)@@G@@,I THEN,VGLABL .  LABEL ARRAY TO BE INITIAL     @F@@@9         LMCP  SDIVU
)@@G@@NTM,X5           . GET INITIALIZATION B-CODE    @F@@@9.        IF A8,EQ,VV
)@@G@@ACCALL,I THEN,VGLABL   . INITIALIZED BY CALL    @[@@@9.     @E@@@9.     VW
)@@G@@   INITIALIZATION OF ARRAYS STARTS HERE, 1ST ESTABLISH@E@@@9.        A PVX
)@@G@@ROLOGUE ROUTINE TO STEP THORUGH THE ELEMENTS OF @^@@@9.        THE ARRAYVY
)@@G@@.     @[@@@9.     @E@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,VZ
)@@G@@VGDV04 .    @E@@@'         GMARK   SDALSI .          SAVE BEGIN OF ARRAYWA
)@@G@@ INIT.@#@@@'         GEN .    @^@@@'         GLIT    1 .    @#@@@'      WB
)@@G@@   LOCAL .  @#@@@'VGDV04   LABEL .  @G@@@9         XGPUSH .          GETWC
)@@G@@ STACK SPACE FOR INITIALIZATION OF ARRAY  @F@@@9         GMARK DBGWC1 . WD
)@@G@@           SAVE START OF INITIAL CODE     @C@@@9         STORE   F,ITRFLWE
)@@G@@G .        SAVE F REG   @F@@@9         MOVE  AGX0OF,SDRTC        . GET SWF
)@@G@@IZE OF ARRAY ELEMENT    @#@'@9         GENM .   @E@'@9         GINST OPLWG
)@@G@@XI,AGRX1,AGXR0,U 'NO'   . LOAD INCREMENT  @#@'@9         GFIN .   @[@@@9WH
)@@G@@.     @A@@@9.        FIND LOCAL DISP OF V.O.    @[@@@9.     @F@@@9      WI
)@@G@@   LOAD  X3,SDLCOF,X5        . GET LOCAL OFFSET OF DV IN AR @E@@@9      WJ
)@@G@@   LOAD  A6,SDA1BS-FH1,X5 .    GET AW FOR ARRAY DV    @ @@@9         STOWK
)@@G@@RE A6,AGTMP1 .    @ @@@'         STORE A6,AGTMP2 .    @ @'@9         STOWL
)@@G@@RE A6,AGTMP2 .    @#@'@9         GEN .    @#@@@'         GENM .   @E@@@'WM
)@@G@@         GINST OPLXI,AGRX1,AGXR0,U 'NO'   . LOAD INCREMENT  @E@'@9      WN
)@@G@@   GINST OPLXM,AGRX1,AGTMP1 'N0' .  GET THE V.O. IN X1@E@@@'         GINWO
)@@G@@ST OPLXM,AGRX1,AGTMP1 'NO' .  GET THE V.O. IN X1@I@@@'         GSHIFT  AWP
)@@G@@GRA5 .           SET A5 ADDRESS WORD TO POINT TO A6***********    @#@@@'WQ
)@@G@@         GFIN .   @D@@@9         ADD   X3,2,I              . X3-> MULTIPWR
)@@G@@LIER  @D@@@9         MOVE  ITRNUM,SDNDIM . MOVE #DIMS INTO STACK  @G@@@9WS
)@@G@@         LOADA X6,SDDVML,X4         . X6-> COMPILE TIME BOUND PAIRS     WT
)@@G@@@^@@@9         LOADXI X6,2,I .@F@@@9         LOAD  A4,0,I              .WU
)@@G@@ A4-> CURRENT SUM[LB(I)*MP(I)]@G@@@9         LOAD  A9,1,I              .WV
)@@G@@ A9-> CURRENT PRODUCT[EXTENT(I)+1]  @[@@@9.     @D@@@9.        X3 -> CURWW
)@@G@@RENT OFFSET OF MULTIPLIER REAL TIME.@B@@@9.        X6-> COMPILE TIME MULWX
)@@G@@TIPLIERS    @A@@@9.        A4-> CURRENT ELEMENT OFFSET@B@@@9.        A9-WY
)@@G@@> CURRENT #ELEMENTS COMPUTED  @#@@@9.        X4-> SDDV@ @@@9.        X5-WZ
)@@G@@> SD OF ARRAY     @[@@@9.     @E@@@9.         LOOP THROUGH THE ARRAY, GAXA
)@@G@@THER ALL CONSTANT PAIRS @[@@@9.     @C@@@9VGOVER   LABEL .              XB
)@@G@@      TOP OF LOOP @^@@@9         USING WORD,X6 .@ @@@9         LOAD  A2,XC
)@@G@@W1,X6 .     @D@'@9         IF A2,LT,0,I THEN,VGNONC . UNKNOWN MULTIPLIERXD
)@@G@@@D@@@'         IF A2,LE,0,I THEN,VGNONC . UNKNOWN MULTIPLIER@ @@@9      XE
)@@G@@   LOAD  A2,W1+1,X6 .   @E@'@9         IF A2,LT,0,I THEN,VGNONC . UNKNOWXF
)@@G@@N BOUNDS PAIR     @E@@@'         IF A2,LE,0,I THEN,VGNONC . UNKNOWN BOUNXG
)@@G@@DS PAIR     @E@'@9         LOAD  A3,W1H2+1           . GET THE LOWER BOUXH
)@@G@@ND    @E@@@'         LOAD  A3,W1XH2+1           . GET THE LOWER BOUND   XI
)@@G@@@D@@@9         LOAD  A7,W1H1+1            GET THE EXTENT-1  @C@@@9      XJ
)@@G@@   ADD   A7,1,I              . EXTENT     @^@@@9         MPYS  A9,A7 .  XK
)@@G@@@F@@@9         MPYS   A3,W1,*X6           . MULTIPLIER LB BY MULTIPLIER XL
)@@G@@@E@@@9         ADD   A4,A3               . ADD TO ALREADY KNOWN   @D@@@9XM
)@@G@@         ADD   X3,2,I               . X3-> NEXT SET   @D@@@9         LOAXN
)@@G@@D A7,ITRNUM        . GET #DIMS THUS FAR.  @C@@@9         SUB   A7,1,I   XO
)@@G@@           . # LEFT     @D@@@9         STORE A7,ITRNUM       . RESTORE UXP
)@@G@@PDATED COUNT@D@@@9         IF A7,NE,0,I THEN,VGOVER . MORE DIMS TO GO.  XQ
)@@G@@@D@@@9         STORE A4,AGX0OF           . STORE INTO OFFSET@E@@@'      XR
)@@G@@   MOVE    AGTMP1,AGXR0 .    MOVE TO AUX ADDR WORD    @#@'@9         GENXS
)@@G@@ .    @F@'@9         GINST OPAX,AGRX1,AGXR0,U 'NO' . X1-> V.O.+SUM(LB*MPXT
)@@G@@)     @ @@@9         STORE A9,AGX0OF .    @#@@@9         GENM .   @E@'@9XU
)@@G@@         GINST OPLA,AGRA3,AGXR0,U 'NO' . A3-> PROD(EXTNTS)  @#@'@9      XV
)@@G@@   GLIT 1   @^@'@9         SA      A3,A6 .@F@@@'         GINST OPAX,AGRXXW
)@@G@@1,AGTMP1,XU 'NO' . X1-> V.O.+SUM(LB*MP)   @B@@@'         GINST OPLA,AGRAXX
)@@G@@5,AGXR0,U 'NO'    @#@@@9         GFIN .   @G@@@9         GOTO VGSTRT .  XY
)@@G@@           MERGE FOR CREATION OF PROLOGUE CODE. @H@@@9VGNONC   LABEL .  XZ
)@@G@@                 UNKNOWN MULTIPLIER OR BOUNDS ENCOUNTERED   @[@@@9.     YA
)@@G@@@C@@@9.        GEN WHAT CONSTANTS ARE KNOWN THUS FAR  @[@@@9.     @D@@@9YB
)@@G@@         STORE A4,AGX0OF .         SUM(LB*MP) THUS FAR@D@@@'         IF YC
)@@G@@A4,EQ,0,I THEN,VGNONX . -> DON'T ADD 0    @#@@@9         GEN .    @B@@@9YD
)@@G@@         GINST OPAX,AGRX1,AGXR0,U 'NO'    @#@@@'VGNONX   LABEL .  @E@@@9YE
)@@G@@         STORE A9,AGX0OF           . PROD(EXTENTS) THUS FAR @#@'@9      YF
)@@G@@   GEN .    @#@@@'         GENM .   @B@'@9         GINST OPLA,AGRA3,AGXRYG
)@@G@@0,U 'NO'    @G@@@'         GINST OPLA,AGRA5,AGXR0,U 'NO' . GET PROD OF EYH
)@@G@@XTENTS INTO A6    @^@@@'         GLIT    1 .    @I@@@'         LA,U    AYI
)@@G@@1,1 .            GET ''EXTENT CORRECTOR'' INTO A1 BEFORE LOOP     @#@@@'YJ
)@@G@@         GFIN .   @[@@@9.     @G@@@9VGNNBK   LABEL .            TOP OF UYK
)@@G@@NKNOWN MULTIPLIER AND BOUND LOOP    @H@@@9         STORE X3,AGTMP1+FH2  YL
)@@G@@     . X3-> RUN TIME MULTIPLIER THAT STOPED COMS@D@@@9         ADD   X3,YM
)@@G@@1,I              . POINT BOUNDS PAIR@F@@@9         STORE X3,AGTMP2+FH2  YN
)@@G@@     . RUN TIME AW FOR BOUNDS PAIR  @#@@@9         GENM .   @B@@@9      YO
)@@G@@   GINST OPLA,AGRA2,AGTMP1   'NO' . @D@@@9         GINST OPMSI,AGRA2,AGTYP
)@@G@@MP2,XH2 'NO' . LB*MP    @B@@@9         GINST OPAX,AGRX1,AGRA2 'NO' .    YQ
)@@G@@@#@'@9         GLIT 1   @^@'@9         LA,U  A1,1     @E@'@9         GINYR
)@@G@@ST OPAA,AGRA1,AGTMP2,H1 'NO' . EXTENT IN A1     @E@@@'         GINST OPAYS
)@@G@@U,AGRA1,AGTMP2,H1 'NO' . EXTENT IN A1     @F@'@9         GINST OPMSI,AGRYT
)@@G@@A3,AGRA1,U 'NO' . TIMES THE REST THUS FAR @F@@@'         GINST OPMSI,AGRYU
)@@G@@A5,AGRA2 'NO' . TIMES THE REST THUS FAR   @#@@@9         GFIN .   @H@@@9YV
)@@G@@         ADD   X3,1,I              . POINT X3 TO NEXT RUN TIME MULTIPLIEYW
)@@G@@R     @B@@@9         LOAD  A7,ITRNUM       . #OF DIMS @E@@@9         SUBYX
)@@G@@   A7,1,I               . # OF DIMS LEFT IN A7  @C@@@9         STORE A7,YY
)@@G@@ITRNUM       . STORE UPDATED  @C@@@9         IF A7,NE,0,I THEN,VGNNBK . YZ
)@@G@@MORE TO GO  @[@@@9.     @B@@@9.        ALL MULTIPLIERS AND BOUNDS GENED ZA
)@@G@@@[@@@9.     @#@'@9         GEN .    @#@'@9         GLIT 1 . @^@'@9      ZB
)@@G@@   SA      A3,A6 .@[@'@9.     @F@@@9VGSTRT   LABEL .                    ZC
)@@G@@MERGE FOR END OF PROLOGUE.    @[@@@9.     @D@@@9.        ITRTOP AW FOR LZD
)@@G@@ABEL TO TOP OF INITIAL LIST   @D@@@9.        ITREND AW FOR LABEL TO END ZE
)@@G@@OF INITIAL LIST   @C@@@9.        ITRPRO AW FOR LABEL ENTRY TO PROLOGUE  ZF
)@@G@@@[@@@9.     @B@@@9.         GENERATE REMAINING PROLOGUE     @[@@@9.     ZG
)@@G@@@G@@@9         LOAD  A7,KKLXUX .         LOAD A7 WITH LX,U X2 OPCODE FUDZH
)@@G@@GE    @#@@@9         GENM .   @I@@@'         GSHIFT  AGRA5 .           PZI
)@@G@@OINT A5 ADDRESS WORD BACK AT A5 ************    @H@@@9         GJUMP ITRZJ
)@@G@@TOP .            SET UP ADDRESS PORTION TO INITIAL LIST     @E@@@9      ZK
)@@G@@   GAPPN VGINFG .            CHANGE JUMP TO A LA,U    @F@@@9         GLAZL
)@@G@@BEL ITRPRO .           ENTRY TO PROLOGUE STARTS HERE  @#@@@9         GLIZM
)@@G@@T  1 .@ @@@9         JGD     A6,0,X2 .    @I@@@9         GJUMP ITREND . ZN
)@@G@@           ARRAY ELEMENTS EXHAUSTED,GOTO END OF INITIAL     @E@@@9      ZO
)@@G@@   GLABEL ITRTOP .           START OF INITIAL LIST    @#@@@9         GFIZP
)@@G@@N .   @F@@@9         LOAD  X4,X7 .             SAVE A POINTER TO LABEL EZQ
)@@G@@NTRIES@[@@@9.     @B@@@9.        INITIAL PROLOGUE ROUTINE DONE    @B@@@9ZR
)@@G@@.        START INITIALIZATION OF ARRAY    @[@@@9.     @H@@@9         XGPZS
)@@G@@USH .                  CREATE STACK ENTRY FOR SINGLE ELMT OF ARRAY@F@@@9ZT
)@@G@@         MOVE  SGDAID+FH2,SD2SP .  COPY SCALE AND PREC FROM ARRAY @D@@@9ZU
)@@G@@         MOVE  SGDCLS,SDCLS1 .     COPY ATTRIBUTES    @D@@@9         LOAZV
)@@G@@D  A3,SDCLS0 .         GET STORAGE CLASS  @G@@@9         AND,U A3,15 .  ZW
)@@G@@           MASK OUT GARABAGE BITS(LIKE CHECK)   @D@@@9         STORE A4,ZX
)@@G@@SGDID .          STORE IN STACK     @F@'@9         LOADA A3,AGRX1 .     ZY
)@@G@@      GET THE ADDRESS BASE OF X1    @F@@@'         LOADA A5,AGRX1 .     ZZ
)@@G@@      GET THE ADDRESS BASE OF X1    @E@'@9         STORE A3,AGRL1+FH1 . AA
)@@G@@      STORE INTO STACK AW     @E@@@'         STORE A5,AGRL1+FH1 .       AB
)@@G@@STORE INTO STACK AW     @D@@@'.                                   ADDRESAC
)@@G@@S IS 0,X1   @G@@@'         IF    SDRLCX,OFF,SDCLS1 THEN,VGNTLB . -> NOT AD
)@@G@@LABEL OR COMPLEX  @G@@@'         STORE A5,AGIM1+FH1 .       SETUP 0,X1 FAE
)@@G@@OR NOW AS IMAG ADDRESS  @E@@@'         LOAD  A3,SDRTC .           GET SIAF
)@@G@@ZE OF COMPLEX ITEM@D@@@'         SRB   A3,1 .               SIZE OF REALAG
)@@G@@ PART @E@@@'         STORE A3,AGIM1+FH2 .       IMAG IS AT SDRTC/2,X1   AH
)@@G@@@#@@@'VGNTLB   LABEL .  @^@'@9         LOADA A3,AGAW .@ @'@9         STOAI
)@@G@@RE A3,AGIM1+FH1 . @C@'@9.        MOVE  AGIM1+FH2,KKDO .    **??**??**   AJ
)@@G@@@[@@@9.     @[@@@9.     @D@@@9.        REGISTER USAGE THROUGHOUT LIST PRAK
)@@G@@OCESSING    @A@@@9.              X5 -> SD OF ARRAY    @C@@@9.           AL
)@@G@@   X4 -> PROLOGUE OF STACK ENTRY    @ @@@9.              X7 -> STACK    AM
)@@G@@@B@@@9.              A3,A6,A7,A8 USED AS SCRATCH@[@@@9.     @[@@@9.     AN
)@@G@@@A@@@9.        PROCESS TOKENS IN LIST     @[@@@9.     @D@@@9         LOAAO
)@@G@@D  F,0,I .             CLEAR FLAG REGISTER@#@@@9VGDOIT   LABEL .  @#@@@9AP
)@@G@@         GETC .   @ @@@9VGAFTR   LABEL . BYPASS GETC  @D@@@9         IF AQ
)@@G@@A8,NE,ACCOMA,I THEN,VGNTST .  NOT A COMMA @G@@@9.         IF FLGNIF,ON  AR
)@@G@@THEN,VGDOIT . NEG ITER FACT,IGNORE ALL ITEMS    @G@@@9         IF FLGSIEAS
)@@G@@,OFF THEN,VGDOIT ELSE,VGITON . TEST FOR SINGLE ITER   @#@@@9VGNTST   LABAT
)@@G@@EL .  @D@@@9         IF A8,NE,ACRPAR,I THEN,VGITER . NOT A ')'    @G@@@9AU
)@@G@@         IF FLGNIF,OFF  THEN,VGNOTN . TEST FOR SCAN OF END OF NEG ITER  AV
)@@G@@@B@@@9         SET     FLGNIF,OFF . RESET FLAG  @F@@@9         GOTO VGDOAW
)@@G@@IT .             LOOK FOR NEXT ITEM IN LIST     @C@@@9VGNOTN   LABEL .  AX
)@@G@@NORMAL ENTRY TO ")" HANDLER   @ @@@9         USING   SGDSCT,X4 .  @G@@@9AY
)@@G@@         IF ITRNUM,NZERO  THEN,VGITON . NOT DONE YET(LEVELS EXISTS)     AZ
)@@G@@@#@@@9         XGPOP .  @ @@@9         USING   SGDSCT,X7 .  @#@'@9      BA
)@@G@@   GENM .   @#@@@'         GEN .    @ @@@9         GLABEL  ITREND .     BB
)@@G@@@H@@@'         IF      SD0BSD+SD0CNT,ON,SDCLS0  THEN,VGDV13 . BASED OR CBC
)@@G@@ONTROLLED   @#@@@'         GEN .    @ @@@9         GSUB    EXAYIN .     BD
)@@G@@@#@@@'VGDV13   LABEL .  @#@'@9         GFIN .   @C@@@9         LOAD F,ITBE
)@@G@@RFLG .           RESTORE FLAGS@#@@@9         XGPOP .  @F@@@9         LOABF
)@@G@@D    A3,DBGWC1 .       LOAD UP START OF INITIAL CODE  @D@@@9         STOBG
)@@G@@RE   A3,SDINTM,X5 . AND SAVE IN THE SD    @F@@@9         GOTO    VGDVNL BH
)@@G@@.          GET NEXT DV TO BE INITIALIZED  @[@@@9.     @D@@@9VGINFG   LLOBI
)@@G@@C .                    GAPPN TO PROLOGUE  @^@@@9         SUB   X10,1,I .BJ
)@@G@@@C@@@9         LOAD  A7,DCGSV4+1 .       GET OPCODE   @D@@@9         LOABK
)@@G@@D  A8,W1,X10 .         GET INSTRUCTION    @E@@@9         SLB   A8,14 .  BL
)@@G@@            SHIFT OFF OLD OPCODE    @D@@@9         SRBD  A7,14 .        BM
)@@G@@     SHIFT ON NEW OPCODE@E@@@9         STORE A8,W1,*X10 .        STORE BBN
)@@G@@ACK INTO CODE     @B@@@9         LJMP .                    DONE   @[@@@9BO
)@@G@@.     @E@@@9VGITON   LABEL .                   SOME LEVEL OF ITERATION  BP
)@@G@@@#@@@9         GEN .    @#@@@9         GLIT  1 .@ @@@9         JGD     ABQ
)@@G@@5,0,X3 .    @ @@@9         USING SGDSCT,X4 .    @ @@@9         LOAD  A6,BR
)@@G@@ITRNUM .    @E@@@9         IF A6,EQ,1,I THEN,VGITMG . ONLY 1 LEVEL THUS BS
)@@G@@FAR   @[@@@9.     @ @@@9.        MORE THAN 1 LEVEL    @ @@@9.        RESBT
)@@G@@TORE OUTER LEVEL  @[@@@9.     @ @@@9         USING SGDSCT,X7 .    @#@@@9BU
)@@G@@         GENM .   @F@@@9         GINST   OPLA,AGRA5,ITRARL 'NO' . RESTORBV
)@@G@@E OUTER COUNT     @F@@@9         GINST OPLX,AGRX3,ITRREG 'NO' . RESTORE BW
)@@G@@OUTER RETURN LABEL@C@@@9         GFREE ITRARL,1 .          FREE TEMPS   BX
)@@G@@@ @@@9         GFREE ITRREG,1 .     @#@@@9         GFIN .   @H@@@9VGITMGBY
)@@G@@   LABEL .                   MERGE FROM NESTED AND 1 LEVEL ITERATION    BZ
)@@G@@@#@@@9         GEN .    @E@@@9         GLABEL  ITREND .           END  OCA
)@@G@@F ITER FACTOR LIST@F@@@9         XGPOP .      POP OFF STACK ENTRY FOR NECB
)@@G@@STED ITERATION    @ @@@9         USING SGDSCT,X4 .    @F@@@9         LOACC
)@@G@@D  A3,ITRNUM .         GET THE EXISTING ITER LEVEL    @C@@@9         SUBCD
)@@G@@   A3,1,I .             UPDATE IT   @E@@@9         STORE A3,ITRNUM .    CE
)@@G@@     RESTORE BACK IN STACK    @F@@@9         IF FLGSIE,OFF THEN,VGDOIT .CF
)@@G@@ NOT SINGLE ITERATION RETURN  @[@@@9.     @D@@@9.        SINGLE ITERATIOCG
)@@G@@N FACTOR JUST ACCOUNTED FOR   @D@@@9.        TURN FLAG OFF AND RESCAN JUCH
)@@G@@ST READ TOKEN     @G@@@9.       (I.E IF ','-THEN IGNORE IT IF ')'-THEN SCI
)@@G@@HOULD BE END OF INITIAL)@[@@@9.     @ @@@9         SET   FLGSIE,OFF .   CJ
)@@G@@@D@@@9         GOTO VGAFTR .             SKIP NEXT GETC     @[@@@9.     CK
)@@G@@@#@@@9VGITER   LABEL .  @D@@@9         IF A8,NE,ACLPAR,I THEN,VGSTAR . NCL
)@@G@@OT A "("    @E@@@9         IF FLGNIF,OFF THEN,VGITCN . NOT IN A NEG ITERCM
)@@G@@ LIAS @[@@@9.     @D@@@9. NESTED WITHIN A NEGATIVE CONSTANT ITER FACT LICN
)@@G@@ST    @^@@@9.   IGNORE ALL OF IT    @[@@@9.     @C@@@9         ADD     XCO
)@@G@@1,1,I .           2 GETC'S    @#@@@9         GETC .   @G@@@9         IF CP
)@@G@@A8,NE,ACLLST,I THEN,VGDOIT  . SINGLE ELEMENT IN LIST DONE.  @#@@@9VGIPR1CQ
)@@G@@   LABEL .  @#@@@9         GETC .   @G@@@9         IF A8,NE,ACRPAR,I THECR
)@@G@@N,VGIPR1 ELSE,VGDOIT . PURGE SELF OF LIST @[@@@9.     @#@@@9VGITCN   LABCS
)@@G@@EL .  @G@@@9         XGPUSH .                   CREATE STACK ENTRIES FORCT
)@@G@@ ITERATION  @E@@@9         GMARK   A7 .              NOTE START OF GEN'DCU
)@@G@@ CODE.@B@@@9         GETC .  READIN ITER FACTOR TOKEN @C@@@9         XGECV
)@@G@@N    I .               EVALUATE IT  @G@@@9         IF SDVRCN,OFF,SGDCLS CW
)@@G@@THEN,VG1NCN . NOT A CONSTANT ITER FACT    @G@@@9         IF SGDSGN,OFF,SCX
)@@G@@GDCLS THEN,VG1NCN . NOT A NEGATIVE CONSTANT FACT@[@@@9.     @C@@@9. NEGACY
)@@G@@TIVE CONSTANT ITERATION FACTOR ENCOUNTERED@C@@@9.        SET FLAG TO IGNCZ
)@@G@@ORE THIS COMMING LIST   @[@@@9.     @G@@@9         XGPOP   'SIZE',2*DCGSDA
)@@G@@LT .  POP OFF BOTH ITER AND FACT ENTRIES  @B@@@9         GFIX    A7 . REDB
)@@G@@SET ANY CODE GEN'D@ @@@9         GETC .   READ IN ")" @B@@@9         GETDC
)@@G@@C .   READ IN START OF LIST   @G@@@9         IF A8,NE,ACLLST,I THEN,VGDODD
)@@G@@IT . ONLY SINGL E ITEM ALL DONE     @G@@@9         SET     FLGNIF,ON .  DE
)@@G@@     LIST COMMING, SET FLAG TO IGNORE IT  @E@@@9         GOTO    VGDOIT DF
)@@G@@.          GET FIRST ITEM IN LIST   @[@@@9.     @E@@@9VG1NCN   LABEL . VDG
)@@G@@ALID NON-NEGITIVE CONSTANT ITER FACTOR    @E@@@9         IF ITRNUM,ZERO DH
)@@G@@THEN,VG1ITER .  1ST LEVEL ITERATION @ @@@9         USING   SGDSCT,X7 .  DI
)@@G@@@[@@@9.     @D@@@9.        NESTED ITERATIONS: MUST SAVE OUTER  LEVEL    DJ
)@@G@@@[@@@9.     @#@@@9         GENM .   @C@@@9         GGETT   ITRARL+DCGSLTDK
)@@G@@,1 . GET A TEMP   @D@@@9         GGETT   ITRREG+DCGSLT,1 . GET ANOTHER TDL
)@@G@@EMP . @E@@@9         GINST   OPSA,AGRA5,ITRARL+DCGSLT .  SAVE OUTER'S A5DM
)@@G@@@E@@@9         GINST   OPSX,AGRX3,ITRREG+DCGSLT . SAVE OUTER'S X3 @#@@@9DN
)@@G@@         GFIN .   @#@@@9VG1ITER  LABEL .  @E@@@9         LOAD    A7,DCGTDO
)@@G@@LV .       SAVE TEMP STACK LEVEL    @F@@@9         GASGN 'TEMP' R,X7 'ATDP
)@@G@@TR',FIXER 'COND' . CONVERT ITER FACT@D@@@'         MOVE    AGXTMP,0,I . DQ
)@@G@@     CLEAR WORD FOR JUMP@#@'@9         GEN .    @#@@@'         GENM .   DR
)@@G@@@F@@@9         GINST   OPLA,AGRA5,AGRL1 . LOAD UP COUNTER WITH ITER FAC DS
)@@G@@@E@@@'         GJGD    AGRA5,AGXTMP .    JUMP AND SUBTRACT ONE    @#@@@'DT
)@@G@@         GFIN .   @G@@@9         IF SDVRCN,ON,SGDCLS THEN,VG1NCON . POS DU
)@@G@@CONS NO TEST NEEDED     @A@'@9         GENM .  GEN TEST FOR EXPERS@A@@@'DV
)@@G@@         GEN .  GEN TEST FOR EXPERS @I@@@'         GJUMP   ITREND+DCGSLTDW
)@@G@@ .   ABOVE JGD WILL FAIL IF ITER EXPR IS ZERO,OR N    @F@'@9         GCJDX
)@@G@@MP   OPJN,AGRA5,ITREND+DCGSLT . IF EXPR IS NEGATIVE OR@G@'@9         GCJDY
)@@G@@MP   OPJZ,AGRA5,ITREND+DCGSLT . IF EXPR IS 0 THEN SKIP LIST.@#@'@9      DZ
)@@G@@   GFIN .   @F@@@9VG1NCON  LABEL .                   MERGE WITH EXPRES AEA
)@@G@@ND POS CONST@E@@@9         GMARK   A3 .              GET CURRENT CODE AREB
)@@G@@RDESS @E@'@9         ADD     A3,2,I .          POINT TO TOP OF LOOP     EC
)@@G@@@E@@@'         ADD     A3,1,I .          POINT TO TOP OF LOOP     @F@@@9ED
)@@G@@         STORE   A3,AGX0OF .       PUT WHERE ICODE CAN GET IT     @#@@@9EE
)@@G@@         GENM .   @E@@@'         GLABEL  AGXTMP .          FIX ABOVE JGDEF
)@@G@@ ADDRESSES  @#@'@9         GLIT 1 . @^@'@9         ANA,U   A5,1 . @F@@@9EG
)@@G@@         GINST   OPLX,AGRX3,AGXR0,U 'NO' . POINT TO TOP OF LOOP   @^@@@9EH
)@@G@@         GFIN    'POP' .@E@@@9         STORE   A7,DCGTLV .       RESTOREEI
)@@G@@ TEMP STACK LEVEL.@[@@@9.     @ @@@9         USING SGDSCT,X4 .    @D@@@9EJ
)@@G@@         LOAD  A6,ITRNUM .         LOAD UP ITER COUNT @E@@@9         ADDEK
)@@G@@   A6,1,I .            INCREMENT EXISTING COUNT @D@@@9         STORE A6,EL
)@@G@@ITRNUM .         RESTORE IN STACK   @C@@@9         GETC .               EM
)@@G@@     GET THE ')'  @E@@@9         GETC .                    GET THE '(' OEN
)@@G@@F THE LIST  @E@@@9         IF A8,EQ,ACLLST,I THEN,VGDOIT . REAL '(' FOUNEO
)@@G@@D     @F@@@9         SET   FLGSIE,ON .         NOT '(' MUST BE SINGLE ITEP
)@@G@@ER    @D@@@9         GOTO  VGAFTR .            PROCESS SINGLE ITEM@[@@@9EQ
)@@G@@.     @#@@@9VGSTAR   LABEL .  @D@@@9         IF A8,NE,ACSTAR,I THEN,VGASER
)@@G@@GN . NOT AN '*'   @F@@@9         IF FLGNIF,ON THEN,VGDOIT . IN NEG CON FES
)@@G@@ACT LIST IGNORED  @D@@@9         LOAD    X6,X7 .           SAVE STACK POET
)@@G@@INTER @F@@@9         LOAD    X7,X4 .           POINT STACK TO INITIAL ENEU
)@@G@@TRY   @G@@@9         LOAD  A7,KKLMJX .         LOAD A7 WITH LMJ X2 OPCODEV
)@@G@@E FUDGE     @#@@@9         GENM .   @#@@@9         GLIT 1 . @I@@@9      EW
)@@G@@   NOP   A0,0,*X1 .          DO NOTHING BUT INCREMENT ARRAY ELEMENT POINEX
)@@G@@TER   @^@@@9         GJUMP ITRPRO . @D@@@9         GAPPN VGINFG .       EY
)@@G@@     FIX UP THE OPCODE  @#@@@9         GFIN .   @E@@@9         LOAD    XEZ
)@@G@@7,X6 .           RESTORE STACK POINTER    @F@@@9         GOTO  VGDOIT . FA
)@@G@@           PROCESS NEXT TOKEN IN LIST     @[@@@9.     @#@@@9VGASGN   LABFB
)@@G@@EL .  @[@@@9.     @E@@@9.        MUST BE AN ASSIGNMENT TO AN ELEMENT OF FC
)@@G@@TE ARRAY    @[@@@9.     @F@@@9         IF FLGNIF,ON THEN,VGDOIT . IN NEGFD
)@@G@@ CON FACT LIST IGNORED  @E@@@9         XGEN  I .                 EVALUATFE
)@@G@@E THE EXPRESSION  @ @@@9         USING SGDSCT,X4 .    @^@@@9         GMAFF
)@@G@@RK A7 .     @F@@@9         SUB   X4,DCGSLT,I .       X4-> ARRAY ELEMENT FG
)@@G@@STACK ENTRY @C@@@9         GASGN R,X4 R,X7 .         DO THE ASSGNT@C@@@9FH
)@@G@@         ADD   X4,DCGSLT,I .       RESTORE X4   @^@@@9         GMARK A8 FI
)@@G@@.     @H@@@9         LOAD  A6,A8 .             LOAD UPPER BOUND OF CODE FJ
)@@G@@GENED FOR ASSGNT  @F@@@9         SUB   A6,A7 .             A6-> AMOUNT OFK
)@@G@@F CODE FOR ASSGNT @E@@@9         LOAD  X3,A7 .             X3-> START OFFL
)@@G@@ GENED CODE @E@@@9         SUB     X3,1,I .  X3 -> 1 BEFORE START OF CODFM
)@@G@@E     @E@@@9         LOAD  R1,A6 .             SET THE REPEAT COUNT     FN
)@@G@@@D@@@9         LOAD  A6,KKXFLD .         GET THE X1 MASK    @E@@@9      FO
)@@G@@   LOAD  R2,KKMASK .         GET THE X FIELD MASK     @G@@@9         MSEFP
)@@G@@   A6,1,*X3 .          SEARCH FOR USE OF X1 IN GENED CODE   @F@@@9      FQ
)@@G@@   GOTO  BGBOMB .            NOT FOUND *Y O U   L O S E*    @E@@@9      FR
)@@G@@   LOAD  A6,W1,X3 .          FETCH THE INSTRUCTION    @F@@@9         OR,FS
)@@G@@U  A6,0400000 .        SET THE AUTO INCREMENT BIT ON  @F@@@9         STOFT
)@@G@@RE A7,W1,X3 .          RESTORE THE FIXED INSTRUCTION  @G@@@9         LOAFU
)@@G@@D  A7,KKLMJX .         LOAD A7 WITH OPCODE FUDGE OF LMJ X2  @E@@@9      FV
)@@G@@   LOAD  X6,X7 .              SAVE THE STACK POINTER  @F@@@9         LOAFW
)@@G@@D  X7,X4 .              ADJUST STKPTR TO INITIAL ENTRY@#@@@9         GENFX
)@@G@@M .   @^@@@9         GJUMP ITRPRO . @D@@@9         GAPPN VGINFG .       FY
)@@G@@     FUDGE THE OPCODE   @#@@@9         GFIN .   @D@@@9         LOAD  X7,FZ
)@@G@@X6 .              RESTORE STKPTR    @F@@@9         XGPOP   .            GA
)@@G@@     POP OFF ASSIGNED EXPRESSION    @E@@@9         GOTO  VGDOIT .       GB
)@@G@@     PICK UP NEXT ITEM IN LIST@[@@@9.     @ @@@9         USING SGDSCT,X7GC
)@@G@@ .    @[@@@9.     @D@@@9VGLABL   LABEL . NOT IMPLEMENTED YET *Y O U   L GD
)@@G@@O S E*@[@@@9.     @C@'@9.        MORE TO COME HERE (EVENTUALLY ?!?!)    GE
)@@G@@@[@'@9.     @I@@@9 . ---------------------------------------------------GF
)@@G@@--------------------------    @E@'@9       EXERR ERVG04 LEVEL,2 . 'INIT GG
)@@G@@NOT YET IMPLEMENTED'    @E@@@'.      EXERR ERVG04 LEVEL,2 . 'INIT NOT YEGH
)@@G@@T IMPLEMENTED'    @I@@@9 . ---------------------------------------------GI
)@@G@@--------------------------------    @[@@@9 .    @#@@@9VGDVNL LABEL .    GJ
)@@G@@@H@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,VGDVNL2 . BASED ORGK
)@@G@@ CONTROLLED @G@@@'         IF      SDINTL,OFF,SDCLS3  THEN,VGDVNL1 . NOTGL
)@@G@@HING INITIALIZED  @#@@@'         GEN .    @^@@@'         GLIT    1 .    GM
)@@G@@@#@@@'         JMP .    @#@@@'VGDVNL1  LABEL .  @#@@@'         GEN .    GN
)@@G@@@D@@@'         GLABEL  SGDAID .          FIX UP FORWARD JUMP@F@@@'      GO
)@@G@@   XGPOP  'SIZE',1 .         GET RID OF WORD FOR FWRD JMP   @F@@@'      GP
)@@G@@   LINK    BGDSPY .          FIX UP A.W.'S FOR BASED STRG   @#@@@'VGDVNLGQ
)@@G@@2   LABEL . @E@@@'       LSDP  X5,SDDVCH,X5 .  TO NEXT SD WITH DOPE VECTGR
)@@G@@OR    @H@@@'       IF  X5,NZERO  THEN,VGDVLP . ->REPEAT FOR EACH AGGREGAGS
)@@G@@TE VBLE; ELSE...  @E@'@9       LSDP  X5,SDDVCH,X5 .  TO NEXT SD WITH DOPGT
)@@G@@E VECTOR    @H@'@9       IF  X5,NZERO  THEN,VGDVLP . ->REPEAT FOR EACH AGU
)@@G@@GGREGATE VBLE; ELSE...  @^@@@9 . -----------------    @ @@@9 . PREPARE TGV
)@@G@@O EXIT BLOCK INIT @^@@@9 . -----------------    @^@@@9       USING SDSECGW
)@@G@@T,X9 .@#@@@9BGNDVN LABEL .    @ @@@9       STORE X10,DBGWC1 .     @F@@@9GX
)@@G@@         STORE X10,SDADD,X9 .          SET BLOCK ENTRY ADDRESS    @E@@@9GY
)@@G@@       IF  SDBGPR,OFF,SDCLS1  THEN,BGEXIT . ->NOT PROC-BLOCK@C@@@9      GZ
)@@G@@ LINK  DGNTRY . ->DEFINE ENTRY POINTS     @[@@@9 .    @#@@@9BGEXIT LABELHA
)@@G@@ .    @D@@@9         LOAD  R11,DCGSNS .  RESET STATEMENT NUMBER   @D@@@9HB
)@@G@@         STORE R11,DCGSNO .  USE ENTRY POINT NUMBER   @E@@@9       MOVE HC
)@@G@@ DCGLST,0177777,I  . FORCE NEW STATEMENT NUMBER @F@@@9         LOADXM X1HD
)@@G@@,ADPCBC .  SET UP GETC TO CURRENT META CODE     @^@@@9         SETGC 2,0HE
)@@G@@,X1 . @D@@@9       GOTO  PGNXT0 . GO GEN CODE FOR WHAT'S IN BLOCK @]@@@'HF
)@@G@@ . -------  @ @@@' . GEN INIT CODE FOR A SCALAR @]@@@' . -------  @C@'@9HG
)@@G@@CGNTSC   LOCAL .             SAVE RETURN ADDRESS@C@@@'CGNTSC   LOCAL .  HH
)@@G@@           SAVE RETURN ADDRESS@E@@@9         LOADXI X1,1,I .    SET AUTOHI
)@@G@@ INCREMENT FOR GETC.    @G@@@9         LMCP  SDINTM,X5 .   POINT TO INITHJ
)@@G@@IALIZATION META-CODE AND GETC @C@@@9.                POINTING TO ACLLST HK
)@@G@@OR ACCALL   @D@@@9.        AND,U A8,0777000 .   SAVE ACLLST OR ACCALL   HL
)@@G@@@#@@@9         GETC .   @G@'@9         IF    A8,EQ,ACSTAR,I THEN,JMP . -HM
)@@G@@> STAR, NO INITIALIZATION     @G@@@'         IF    A8,EQ,ACSTAR,I THEN,JHN
)@@G@@MP . -> STAR, NO INITIALIZATION     @ @@@'         USING   SDSECT,X5 .  HO
)@@G@@@E@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,VGDV21 .    @G@@@'HP
)@@G@@         IF      SD5STR,ON,SDCLS5 THEN,VGDV21A . ALREADY GEN THIS CODE  HQ
)@@G@@@H@@@'         LINK    BGDUNSPY .        SET UP ADDRESS WORDS FOR BASED-HR
)@@G@@CONTROLLED  @ @@@'         XGPUSH  'SIZE',1 .   @#@@@'         GEN .    HS
)@@G@@@ @@@'         GJUMP   SGDAID .     @#@@@'VGDV21A  LABEL .  @E@@@'      HT
)@@G@@   GMARK   SDALSI .          SAVE START OF INIT CODE  @#@@@'         GENHU
)@@G@@ .    @^@@@'         GLIT    1 .    @A@@@'         LOCAL . BEGIN TO INITHV
)@@G@@ CODE @#@@@'VGDV21   LABEL .  @B@@@9         LOAD  R10,A8 .         SAVEHW
)@@G@@ !-   @H@@@9         LOAD  R11,SDDCNM,X5 .         SET STATEMENT NUMBER HX
)@@G@@OF INITIALIZATION @D@@@9         STORE R11,DCGSNO .  SET STATEMENT NUMBEHY
)@@G@@R     @F@@@9         LINK  PGMVIS .      -> RESET STATEMENT CODE GENERATHZ
)@@G@@OR    @E@@@'         STORE   R11,DCGLST .      SAVE STATEMENT NUMBER    IA
)@@G@@@H@@@9.    IF    A9,EQ,(ACCALL/IC)*IC,I THEN,DGCALL+1 . ->GEN CALL TO USIB
)@@G@@ER SUBROUT  @A@@@9.      CALL IN INIT NOT IN ANSI PL/1@[@@@'.     @C@@@'IC
)@@G@@.        IF      BASED/CONTROLLED  THEN,MESSY!  @[@@@'.     @B@@@9      ID
)@@G@@   LOAD  A8,W1XU,X5 .  SD FOR SCALER@E@@@9         XGEN  I 'SINGLE' .  MIE
)@@G@@AKE STACK ITEM FOR ELEMENT    @E@@@9         SET   SGDCHR,OFF,SGDID .   IF
)@@G@@   SET CHECK FLAG OFF   @^@@@9         LOAD  A8,R10 . @C@@@9         XGEIG
)@@G@@N  I .         EVALUATE CONSTANT    @F@@@9         GASGN SGDAID+DCGSLT SIH
)@@G@@GDAID .  ASSIGN VALUE TO SCALER     @D@'@9         XGPOP 'SIZE',2*DCGSLTII
)@@G@@ .       CLEAR STACK    @D@@@'         XGPOP 'SIZE',2*DCGSLT .       CLEIJ
)@@G@@AR STACK    @H@@@'         IF      SD0BSD+SD0CNT,OFF,SDCLS0  THEN,JMP . IK
)@@G@@NOT BASED OR CONTROLLED @G@@@'         IF      SD5STR,ON,SDCLS5 THEN,JMPIL
)@@G@@ . WILL GEN THIS CODE LATER   @#@@@'         GENM .   @^@@@'         GLIIM
)@@G@@T    1 .    @#@@@'         JMP .    @ @@@'         GLABEL  SGDAID .     IN
)@@G@@@#@@@'         GFIN .   @ @@@'         XGPOP  'SIZE',1 .    @G@@@'      IO
)@@G@@   LINK    BGDSPY .          FIX UP A.W.'S FOR BASED OR CONTROLLED@#@@@'IP
)@@G@@CGIN21   LABEL .  @A@@@9         JMP . -> RETURN TO CALLER  @^@@@9      IQ
)@@G@@ USING SGDSCT,X7 .@E@@@9VGSTRN   LABEL .                   STRING INITIAIR
)@@G@@LIZATION    @F@@@9         GMARK DBGWC1 .            SAVE START OF INITIIS
)@@G@@AL CODE     @E@@@'         SET     SD5STR,ON,SDCLS5 . SET FLAG = STRING IT
)@@G@@INIT  @^@@@9         LINK  CGNTSC . @A@@@'         SET     SD5STR,OFF,SDIU
)@@G@@CLS5 .@F@@@9         LOAD  A3,DBGWC1 .          PICK UP START OF INITIALIV
)@@G@@ CODE @F@@@9         STORE A3,SDINTM,X5 .       AND PUT IT IN THE SD FORIW
)@@G@@ EXEC @D@@@'         IF      SD0BSD+SD0CNT,ON,SDCLS0 THEN,VGDVNL .@#@@@9IX
)@@G@@         GEN .    @D@@@9         GSUB  EXAYIN .            RETURN TO EXEIY
)@@G@@C     @F@@@9         GOTO  VGDVNL .            GET NEXT DV TO BE INITIALIZ
)@@G@@IZED  @^@@@9/ . ==================  @E@@@9 . SUBROUTINE FINDS BOUNDS WHIJA
)@@G@@CH MUST FIT INTO A HALFWORD   @^@@@9 . -----------------    @G@@@9VGCVBDJB
)@@G@@ LOCAL . ON RETURN A3=COND CODE (0->CONSTANT BOUND;1->NON-CONST)  @#@@@9JC
)@@G@@       GETC .     @D@@@9        IF  A8,NE,ACSTAR,I  THEN,VGCVB2 . -> NONJD
)@@G@@-'*'  @^@@@9       USING SDSECT,X5 .@E@@@9       IF  SDPARM,ON,SDCLS2  TJE
)@@G@@HEN,VGCVB3 . ->PARM WITH '*'  @^@@@9       LOAD  F,SDCLS5 . @F@@@9      JF
)@@G@@ IF  SD5MSG,ON  THEN,VGCVB3 . ->ERROR MESSAGE ALREADY GIVEN @C@@@9      JG
)@@G@@ SET   SD5MSG,ON . SET FLAG AND GIVE ERROR@^@@@9       STORE F,SDCLS5 . JH
)@@G@@@G@@@9       EXERR ERVG02 LEVEL,2 . 'VBLE HAS A * BOUND OR LENGTH. 10 ISJI
)@@G@@ USED'@G@@@9 . 'VARIABLE ', SDX5, ' HAS A * BOUND OR LENGTH FIELD.  10 IJJ
)@@G@@S USED'     @[@@@9 .    @#@@@9VGCVB3 LABEL .    @^@@@9       LOAD  A2,10JK
)@@G@@,I .  @G@@@9       LOAD  A3,VGCON,I .  SET DEFAULT AND SET CONDITION FORJL
)@@G@@ CONSTANT   @C@@@9         LOADA X2,AGRL1,X7 . POINT TO FAKE AW   @ @@@9JM
)@@G@@         SUB   X2,DCGSLT,I .  @^@@@9       JMP . RETURN     @[@@@9 .    JN
)@@G@@@[@@@9 .    @E@@@9VGCVB2 LABEL .               NON-STAR BOUND OR LENGTH JO
)@@G@@FIELD @F@@@9       IF  SDPARM,OFF,SDCLS2  THEN,VGCVB8 . ->NON-PARM,NON-'JP
)@@G@@*'    @^@@@9       LOAD  F,SDCLS5 . @E@@@9       IF  SD5MSG,ON  THEN,VGCJQ
)@@G@@VB4 . ->MESSAGE ALREADY GIVEN @D@@@9       SET   SD5MSG,ON . SET FLAG ANJR
)@@G@@D GIVE MESSAGE    @^@@@9       STORE F,SDCLS5 . @E@@@9       EXERR ERVG0JS
)@@G@@3 LEVEL,2 . 'VBLE HAS A NON-STAR BOUND    @[@@@9 .    @#@@@9VGCVB4 LABELJT
)@@G@@ .    @#@@@9       GETC .     @G@@@9       IF  A8,NE,ACENEX,I  THEN,VGCVJU
)@@G@@B4 . ->GETC'S UNTIL END OF EXPR.    @C@@@9       GOTO VGCVB3 . EXIT WITHJV
)@@G@@ CONSTANT FLAG SET@[@@@9 .    @[@@@9 .    @#@@@9VGCVB8 LABEL .    @ @@@9JW
)@@G@@         USING SDSECT,X5 .    @F@@@9       IF  SD0STA,OFF,SDCLS0  THEN,VJX
)@@G@@GCVB1 . ->NOT STATIC VBLE     @C@@@9       MOVE  DXGTPS,XGSTAT,I . CONSTJY
)@@G@@ANTS ONLY   @#@@@9       XGEN I .   @D@@@9       MOVE  DXGTPS,XGSANY,I .JZ
)@@G@@ RESET CLASS TO ANY     @^@@@9       GOTO VGCVB0 .    @[@@@9 .    @#@@@9KA
)@@G@@VGCVB1 LABEL .    @#@@@9       XGEN  I .  @G@@@9VGCVB0* LLOC .  XGEN ENTKB
)@@G@@ERS HERE(IT STACKS RET ADDR BEFORE ENTERING)    @^@@@9       USING SGDSCKC
)@@G@@T,X7 .@E@@@9       IF  SDVRCN,ON,SGDCLS  THEN,VGCNBD . ->CONSTANT FOUND KD
)@@G@@@F@@@9         STORE X3,DBGWC2 .   SAVE REGISTERS ACROSS CGCONV CALL    KE
)@@G@@@ @@@9         STORE X4,DBGWC2+1 .  @C@@@9       MOVE  DGGSTK,0,I .  FAKKF
)@@G@@E A STACK ENTRY   @B@@@9        MOVE  DGGCLS,SDDCBN,I .  FIXED BIN@F@@@9KG
)@@G@@       CGCONV  DGGSTK R,X7 .  CONVERT TO FIXED BINARY IF NEEDED   @E@@@9KH
)@@G@@         LOAD  A3,DGGSCP .     SIGNED SCALE AND PRECISION   @E@@@9      KI
)@@G@@   DSA   A3,9 .        SIGNED SCALE RIGHT JUSTIFIED   @D@@@9         SRBKJ
)@@G@@   A4,36-9 .     RIGHT JUSTIFIED PRECISION@D@@@9         SUB   A4,A3 .  KK
)@@G@@     PRECISION OF INTEGER PART@D@@@9         TLE,U A4,18 .       -> PRECKL
)@@G@@ISION TOO LARGE   @E@@@9         TG,U  A4,0 .        -> PRECISION IN PROKM
)@@G@@PER RANGE   @G@@@9         LOAD  A4,KBXHMP,I . LOAD MAX PREC FOR A BINARKN
)@@G@@Y FIXED HALFWORD  @E@@@9         STORE A4,DGGSCP . SET NEW SCALE (=0) ANKO
)@@G@@D PRECISION @C@@@9       CGCONV R,X2 R,X3 . CONVERT TO INTEGER    @#@@@9KP
)@@G@@VGCVB6 LABEL .    @^@@@9       LOAD  A3,SGDPRE .@F@@@9       IF  A3,LT,KKQ
)@@G@@BXHMP+1,I  THEN,VGCVB7 . -> WILL FIT IN HALFWORD@F@@@9         LOAD  A6,KR
)@@G@@0400000,I .          SET COMPARISON CONSTANT    @ @@@9         STORE A6,KS
)@@G@@AGX0OF .    @#@@@9       GENM .     @E@@@9       GIFR  VGCVBG,AGRL1 .  -KT
)@@G@@> OPERAND ALREADY IN REGISTER @C@@@9       GLOAD AGRL1 .   ASSURE THAT IKU
)@@G@@TS A REG AW @#@@@9VGCVBG GLBL .     @F@@@9         GINST OPTG,AGRL1,AGXRKV
)@@G@@0,XU 'NO' . SKIP IF NUMBER TOO SMALL@G@@@9         GINST OPTG,AGRL1,AGXRKW
)@@G@@0,U  'NO' . SKIP IF NUMBER NOT TOO LARGE  @E@@@9         GSUB  EXHWOV . KX
)@@G@@     ROUTINE FOR OVERFLOW CORRECTION@#@@@9       GFIN .     @#@@@9VGCVB7KY
)@@G@@ LABEL .    @D@@@9         LOAD  X3,DBGWC2 .   RESTORE SCRATCH REGISTER KZ
)@@G@@@B@@@9         LOAD  X4,DBGWC2+1 . AFTER CGCONV @E@@@9       LOAD  A3,VGLA
)@@G@@NCON,I .  SET COND CODE FOR NOT EQUAL     @A@@@9       GOTO  VGBDEX .  ALB
)@@G@@ND RETURN   @[@@@9 .    @#@@@9VGCNBD LABEL .    @D@@@9       LSDP  X2,SGLC
)@@G@@DRSD,X7 .  GET ADDR OF CONSTANTS SD @F@@@9VGFXIT   LABEL .             DLD
)@@G@@O IT THE LONG WAY WITH LARGE SCALE  @G@@@9         DFU   A2,SDFLPT-(SDCLLE
)@@G@@S4-FQ1),X2 . UNPACK FLOATING CONSTANT     @G@@@9         IF    A2,LT,020LF
)@@G@@01,I THEN,VGZRCN . -> CONSTANT TRUNCATES TO ZERO@H@@@9         IF    A2,LG
)@@G@@GE,02022,I THEN,VGTOBG . -> FLOATING CONSTANT TOO LARGE     @E@@@9      LH
)@@G@@   STOREN A2,X2 .      SET SHIFT COUNT FOR SCALING    @D@@@9         DSALI
)@@G@@   A3,02074,X2 . RIGHT JUSTIFY INTEGER    @C@@@9         LOAD  A2,A4 .  LJ
)@@G@@     SET FOR RETURN     @^@@@9         GOTO  VGSGNT . @F@@@9VGZRCN   LABLK
)@@G@@EL .             CONSTANT MAGNATUDE SMALLER THAN 1    @E@@@9         LOALL
)@@G@@D  A2,0,I .      SET ZERO AS RETURNED VALUE     @^@@@9         GOTO  VGSLM
)@@G@@GN1 . @A@@@9 . BOUND TOO LARGE. WRITE ERROR     @#@@@9VGTOBG LABEL .    LN
)@@G@@@I@@@9      EXERR ERVG01 LEVEL,2 . 'CONSTANT BOUND OR LENGTH EXCEEDS 327LO
)@@G@@67, 10 IS USED    @[@@@9 .    @#@@@9VGDFLT LABEL .    @B@@@9       LOAD LP
)@@G@@ A2,10,I . SET DEFAULT VALUE  @C@@@9       GOTO VGSGNT . SET SIGN SAME ALQ
)@@G@@S ORIGINAL  @[@@@9 .    @#@@@9VGSGNT LABEL .    @F@@@9       IF  SGDSGN,LR
)@@G@@OFF,SGDCLS  THEN,VGSGN1 . ->POSITIVE CONSTNT    @^@@@9       LOADN A2,A2LS
)@@G@@ .    @#@@@9VGSGN1 LABEL .    @D@@@9       LOAD  A3,VGCON,I . SET COND CLT
)@@G@@ODE FOR RETURN    @C@@@9         ADD   A2,0,I .      ENSURE CLEAN ZERO  LU
)@@G@@@E@@@9VGBDEX LABEL .               RETURN REMOVING STACK ITEM     @D@@@9LV
)@@G@@         LOADA X2,AGRL1,X7 . POINT TO AW OF RESULT    @#@@@9       XGPOPLW
)@@G@@ .    @]@@@9       JMP .@A@@@'/.  ROUTINE TO UNDO WHAT BGDSPY DOES@#@@@'LX
)@@G@@BGDUNSPY LLOC .   @F@@@'         LOAD    A3,X9 .           START HERE ATLY
)@@G@@ CURRENT BLOCK SD @#@@@'BGDUN1   LABEL .  @D@@@'         LOAD    X4,SDBKLZ
)@@G@@AW,A3 .    GET ADDRESS WORD   @ @@@'         USING   WORD,X4 .    @E@@@'MA
)@@G@@         MOVE    W1H1,AGRX10,I .   SAY TO USE STATIC LINKS  @D@@@'      MB
)@@G@@   LOAD    A6,SDBSLD,A3 .    GET STATIC DEPTH   @E@@@'         SUB     AMC
)@@G@@6,1,I .          ZELK SAYS IT'S 1 TOO BIG @E@@@'         STORE   A6,W1H2MD
)@@G@@,X4 .      SET STATIC LINK POINTER  @D@@@'         LOAD    A3,SDBKLK,A3 ME
)@@G@@.    MOVE OUT ONE BLOCK @G@@@'         IF      A3,ZERO  THEN,LJMP ELSE,BMF
)@@G@@GDUN1 . IF ZERO THEN DONE     @[@@@'.     @C@@@'.        ROUTINE TO FIX MG
)@@G@@UP BLOCK ADDRESSING     @[@@@'.     @#@@@'VGVGEH   LLOC .   @E@@@'      MH
)@@G@@   LOAD    A3,SDBKAW,X9 .    GET BLOCK ADDRESS WORD   @D@@@'         MOVMI
)@@G@@E    AGXTMP,AGXR10 .   ASSUME TO USE X10  @ @@@'         USING   WORD,A3MJ
)@@G@@ .    @E@@@'         IF      W1H1,ZERO  THEN,LJMP . IS BLOCK USING X10  MK
)@@G@@@E@@@'         STORE   A3,AGXTMP+FH1 .   NOPE! -> USE STATIC LINKS@#@@@'ML
)@@G@@         LJMP .   @E@@@9       END .                 MAIN CODE GENERATIOMM
)@@G@@N SETUPS    ___@@9      *[S@@@*SDFF*@C@@@S.   COPYRIGHT 1975 BY UNIVERSIMN
)@@G@@TY OF MARYLAND    @[@@@S.     @D@@@S.   QUESTIONS CONCERNING THIS SHOULDMO
)@@G@@ BE DIRECTED TO:  @[@@@S.     @ @@@S.        MARVIN V. ZELKOWITZ  @B@@@SMP
)@@G@@.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@S.        UNIVERSITY OF MMQ
)@@G@@ARYLAND     @B@@@S.        COLLEGE PARK, MARYLAND 20742     @[@@@S.     MR
)@@G@@@G@@@S.        PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMMS
)@@G@@S THEY@E@@@S.   REPRESENT IS GRANTED UNDER THE FOLLOWING CONDITIONS:    MT
)@@G@@@[@@@S.     @G@@@S.        1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS MU
)@@G@@REPRESENTED BY    @G@@@S.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OMV
)@@G@@R UNIVERSITY OF MARYLAND@E@@@S.   PL/1 COMPILER REMAINS ASSOCIATED WITH MW
)@@G@@THESE PROGRAMS.   @[@@@S.     @F@@@S.        2. MODIFICATIONS MAY BE MADMX
)@@G@@E TO THE LISTINGS PROVIDED:   @[@@@S.     @G@@@S.        (A) ANY RESULTIMY
)@@G@@NG PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   @G@@@S.        DESCRIBINMZ
)@@G@@G SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM @E@@@S.        IS NA
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  @[@@@S.     @G@@@S.     NB
)@@G@@   (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@SNC
)@@G@@.        OF ERRORS IN THE SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@SND
)@@G@@.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTED    NE
)@@G@@@C@@@S.        TO THE UNIVERSITY OF MARYLAND, AND     @[@@@S.     @F@@@SNF
)@@G@@.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@SNG
)@@G@@.        WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  NH
)@@G@@@[@@@S.     @F@@@S.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTNI
)@@G@@ED TO OTHER @G@@@S.        LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLENJ
)@@G@@ARLY INDICATE     @G@@@S.        WHETHER THE PROGRAMS ARE EXACT COPIES ONK
)@@G@@F THE UNIVERSITY OF     @E@@@S.        MARYLAND PLUM COMPILER OR ARE MODNL
)@@G@@IFICATIONS TO IT. @[@@@S.     @G@@@S.        3. THESE CONDITIONS ONLY APNM
)@@G@@PLY TO THE PLUM COMPILER ITSELF,    @F@@@S.   AND ARE NOT MEANT TO APPLYNN
)@@G@@ TO ANY PROGRAM WRITTEN USING PLUM. @E@@@S.   THE PURPOSE OF THESE CONDINO
)@@G@@TIONS IS TO ALLOW ANY USER TO @F@@@S.   EXPERIMENT WITH THE COMPILER AS NP
)@@G@@LONG AS THE RESULTING PRODUCT @G@@@S.   IS NOT SOLD AND AS LONG AS IT ISNQ
)@@G@@ KNOWN THAT THE PRODUCT DEVELOPED   @#@@@S.   FROM PLUM.    @[@@@S.     NR
)@@G@@@[@@@S.     @[@@@S.     @[@@@S.     @[@@@S.     @[@@@S/.    @]@@@R      NS
)@@G@@ AXR$ @]@@@R       DCLRG@]@@@R       REGS @]@@@R       ALREG@#@@@R      NT
)@@G@@   UNLIST . @#@@@R@ADD,P PLTVDS     @#@@@R@ADD,P PLCGST     @#@@@R@ADD,PNU
)@@G@@ PLDSAW     @]@@@R   CEND     @#@@@R         LIST .   @#@@@R/      PLWORNV
)@@G@@D     @]@@@R       PLCGD@]@@@R       PLSD @]@@@R       PLIG @A@@@RGGKNSTNW
)@@G@@ CSECT 3     . MY CONSTANTS   @C@@@RK332S9 EQU  DCVDTB       . LOG 10/LONX
)@@G@@G 2  * 2**14@G@@@RKKSCL  EQU   14          . HOW FAR TO SHIFT CONVERSIONNY
)@@G@@ CONSTANT (K332S9)@B@@@RKBXMXP EQU   35    . MAX PREC FOR BIN FIX @B@@@RNZ
)@@G@@KDXMXP EQU   18    . MAX PREC FOR DEC FIX @C@@@RKBFMXP EQU   60    . MAXOA
)@@G@@ PREC FOR BIN FLOAT     @C@@@RKSFTMX EQU   36    . SINGLE WORD MAX SHIFTOB
)@@G@@ COUNT@C@@@RCGMSK1 SAC SDFXFL++SDDCBN++SDRLCX,0777777 .     @^@@@RCGMSK2OC
)@@G@@ SF 0777777777 .  @]@@@R       CEND @[@@@R.     @[@@@R.     @H@@@R.    GOD
)@@G@@ENM AND GENMR SPECIALY DEFINED FOR CGCONV SO X2 DOESN'T GET CLOBBERED   OE
)@@G@@@#@@@RP      PROC  *1 . @#@@@RCGENR*  NAME 1 .  @#@@@RCGENMR* NAME 2 .  OF
)@@G@@@^@@@R       LOAD  A10,X2 .   @C@@@R       DO   P(0,0)=1 , GENR P(1,1),POG
)@@G@@(1,2) .     @C@@@R       DO   P(0,0)=2 , GENMR P(1,1),P(1,2) .    @^@@@ROH
)@@G@@       STORE A10,X2 .   @]@@@R       END .@[@@@R.     @B@@@R/.   TO USE:OI
)@@G@@       CGCONV  TARGET   SOURCE@B@@@R.                          A(TARGET)OJ
)@@G@@->X2  @B@@@R.                          A(SOURCE)->X3  @[@@@R.     @I@@@ROK
)@@G@@.    ACTION:       CONVERTS AN ENTRY (THE SOURCE OR RIGHT) TO THE TYPE AOL
)@@G@@ND PRE-     @D@@@R.            CISION (P,Q) OF THE TARGET (OR LEFT).    OM
)@@G@@@H@@@R.                  IF THE TYPES AND PRECISIONS (P,Q) ARE THE SAME,ON
)@@G@@ NO CODE    @ @@@R.            IS GENERATED.    @H@@@R.                 OO
)@@G@@ IF THE (P,Q) OF THE TARGET IS ZERO, THEN THE IMPLIED PL/1  @F@@@R.     OP
)@@G@@       PRECISION IS COMPUTED AND ASSIGNED TO THE SOURCE.    @[@@@R.     OQ
)@@G@@@C@@@R.    UPON RETURN:  X2    POINTS TO THE TARGET.  @C@@@R.           OR
)@@G@@       X3    POINTS TO THE SOURCE   @G@@@R.                  X4  = 0 -> OS
)@@G@@TARGET IS REAL (FLOAT BIN/DEC, FIXED DEC) @H@@@R.                       OT
)@@G@@ 1 -> TARGET IS COMPLEX (FLOAT BIN/DEC, FIXED DEC)    @D@@@R.           OU
)@@G@@             2 -> TARGET IS REAL FIXED BIN@E@@@R.                       OV
)@@G@@ 3 -> TARGET IS COMPLEX FIXED BIN   @[@@@R.     @H@@@R.                 OW
)@@G@@ SET FLAGS IGBNFX OR IGDCFX IN DGFLGZ ACCORDING TO WHETHER  @H@@@R.     OX
)@@G@@       THE TYPE OF THE TARGET IS FIXED DEC OR FIXED BIN RESPECTIVELY.   OY
)@@G@@@I@@@R.                  SET SDEXPR IN SGDID IFF SOURCE IS CONSTANT OR TOZ
)@@G@@HE SOURCE TYPE    @B@@@R.            OR PRECISION WAS MODIFIED.   @G@@@RPA
)@@G@@. -*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*-    PB
)@@G@@@[@@@R.     @F@@@R.    INTERNALLY:   INITIALLY, X5 USED FOR BRANCH TABLEPC
)@@G@@ CGNTAB     @ @@@R.            1 = LEFT DECIMAL @B@@@R.            2 =  PD
)@@G@@             RIGHT FIX  @C@@@R.            4 =               RIGHT DECIMPE
)@@G@@AL    @ @@@R.            8 = LEFT FLOAT   @[@@@R.     @H@@@R.           PF
)@@G@@       THROUGHOUT, X4 IS USED FOR REAL/COMPLEX  BRANCH TABLES     @B@@@RPG
)@@G@@.            0 = LEFT REAL    RIGHT REAL  @C@@@R.            1 = LEFT REPH
)@@G@@AL    RIGHT COMPLEX     @B@@@R.            2 = LEFT COMPLEX RIGHT REAL  PI
)@@G@@@C@@@R.            3 = LEFT COMPLEX RIGHT COMPLEX     @[@@@R.     @H@@@RPJ
)@@G@@.                  ABBREV FOR FIXED IS 'X', SO THAT E.G. CGBXDF IS FOR TPK
)@@G@@HE    @F@@@R.            CODE THAT CONVERTS TO FIXED BIN FROM FLOAT DECIPL
)@@G@@MAL.  @G@@@R.                  'FUNNY FLOAT' IS THE SAME AS FIXED DECIMAPM
)@@G@@L FORMAT    @I@@@R. -*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--PN
)@@G@@*--*--*--*--*--*--*--*--*-    @#@@@RCGSCT1 CSECT  3 . @^@@@R/CGCV*  GNTRPO
)@@G@@   3      . @G@@@R       LOAD  F,SGDCLS,X3     . PUT CLASS INTO F-REG FOPP
)@@G@@R EZ REFERENCE    @A@@@R       SET IGDCFX+IGBNFX,OFF,DGFLGZ @I@@@R      PQ
)@@G@@ LOAD  A10,0,I    . A10->X4 UPON RETURN TO CALLER. ITS STORED IN SAVEAREPR
)@@G@@A     @D@@@R       LOAD  X4,0,I      . CLEAR BRANCH TABLE REGISTER@D@@@RPS
)@@G@@       LOAD  X5,0,I      . CLEAR BRANCH TABLE REGISTER@^@@@R       USINGPT
)@@G@@ SGDSCT,X2  @F@@@R       IF    SDRLCX,OFF,SGDCLS  THEN,CGN001    . ->NOTPU
)@@G@@ COMPLEX    @F@@@R       ADD   X4,2,I  . FOR REAL/COMPLEX BRANCH TABLE  PV
)@@G@@LEFT COMPLEX@E@@@R       ADD   A10,1,I    . RETURN REGISTER WILL SAY COMPW
)@@G@@PLEX  @]@@@RCGN001 LABEL@E@@@R       IF    SDDCBN,OFF,SGDCLS  THEN,CGN01PX
)@@G@@0   . LEFT IS DEC @E@@@R       IF    SDFXFL,OFF,SGDCLS  THEN,CGN013   . PY
)@@G@@LEFT IS BX  @]@@@RCGN002 LABEL@B@@@R       ADD   X5,8,I    . FOR BRANCH PZ
)@@G@@TABLE @]@@@RCGN003 LABEL@B@@@R       LOAD  A3,W1,X3   . GET W1 OF STACK QA
)@@G@@@D@@@RTFUDGE EQU   +(IN 0,0,1,0)     .  ELIMINTAE T-FLAG    @H@@@R      QB
)@@G@@ STORE A10,DCGSV3+9    . RETURN 0-3 IN X4 FOR USE IN BRANCH TABLE(S).   QC
)@@G@@@I@@@R       AND   A3,CGMSK1-TFUDGE  . REMOVE FROM SGDCLS ALL BITS BUT RQD
)@@G@@LCX,DCBN,FXFT     @E@@@R         LOAD  A2,W1,X2 .    LOAD THE LEFT STACKQE
)@@G@@ DESCRIPTION@F@@@R         AND   A2,CGMSK2-TFUDGE .      LEAVE ONLY CLASQF
)@@G@@S, Q AND P  @^@@@R       USING WORD,X2    @G@@@R       IF  A4,NE,A3  THEQG
)@@G@@N,CGN005  . TYPER,QR,PR\=TYPEL,QL,PL SO CONTINUE@E@@@S         IF SDFXFLQH
)@@G@@,ON THEN,CGT005 . FLOAT CONSTANTS ARE OK  @E@@@S         IF SDVRCN,ON THQI
)@@G@@EN,CGN005 . IF FIXED CONSTANT FIX AW@D@@@SCGT005   LABEL .              QJ
)@@G@@     NOT FIXED CONSTANT @F@@@R         IF  SGDSGN,ON  THEN,CGN008 . DO TQK
)@@G@@HE STUFF FOR THE SIGN   @D@@@R         GRTN    3 .               ALL DONQL
)@@G@@E,RETURN    @#@@@RCGN005   LABEL .  @F@@@R       IF  SDRLCX,OFF         QM
)@@G@@THEN,CGN004  . -> RIGHT IS REAL     @^@S@R       USING SGDSCT,X3  @F@S@RQN
)@@G@@       SET   SGDEXP,ON,SGDID  . INDICATE CONVERSION TO BE DONE    @G@@@RQO
)@@G@@       ADD   X4,1,I  . FOR REAL/COMPLEX BRANCH TABLE RIGHT IS COMPLEX   QP
)@@G@@@]@@@RCGN004 LABEL@E@@@R       IF  SDDCBN,ON         THEN,CGN006  . ->RIQQ
)@@G@@GHT IS BIN  @F@@@R       ADD   X5,4,I    . FOR BRANCH TABLE             QR
)@@G@@RIGHT IS DEC@]@@@RCGN006 LABEL@E@@@R       IF SDFXFL,ON         THEN,CGNQS
)@@G@@007  . ->RIGHT IS FLOAT @F@@@R       ADD   X5,2,I    . FOR BRANCH TABLE QT
)@@G@@            RIGHT IS FIX@]@@@RCGN007 LABEL@D@@@R       LOADA X1,AGRL1,X3QU
)@@G@@    . X1 <- ADDR(RIGHT AW)    @D@@@R       LOADA X5,CGNTAB,X5  . WHICH CQV
)@@G@@ONVERSION TO GOTO @^@@@R       USING SGDSCT,X2  @E@@@R       IF  SGDPRE,QW
)@@G@@ZERO  THEN,CGN014    . ->IMPLIED PRECISION@ @@@R       LOAD  X5,W1H2,X5 QX
)@@G@@ .    @^@@@R       GOTO  0,X5 .     @#@@@RCGN014 LABEL .    @^@@@R      QY
)@@G@@ LOAD  X5,W1H1,X5 @^@@@R       GOTO  0,X5 .     @[@@@R.     @A@@@RCGN010QZ
)@@G@@ LABEL       . LEFT IS DECIMAL@B@@@R       ADD   X5,1,I    . FOR BRANCH RA
)@@G@@TABLE @^@@@R       USING SGDSCT,X2  @E@@@R       IF  SDFXFL,ON,SGDCLS  TRB
)@@G@@HEN,CGN002  . -> LEFT IS FLOAT@ @@@R       SET  IGDCFX,ON,DGFLGZ  @#@@@RRC
)@@G@@       GOTO CGN003@A@@@RCGN013 LABEL       . LEFT IS FIXED  @E@@@R      RD
)@@G@@ ADD   A10,2,I    . RETURN REGISTER WILL SAY BIN FIX  @E@@@R       SET  RE
)@@G@@ IGBNFX,ON,DGFLGZ     . SET I-CODE BIN FIX FLG  @#@@@R       GOTO CGN003RF
)@@G@@@#@@@RCGTBLE CSECT  3 . @H@@@RCGNTAB  SFW   0 . BRANCH TABLE FOR TYPE OFRG
)@@G@@ CONVERSION.  LH = PREC NOT IMLIED, @A@@@R .              . RH = PREC IMRH
)@@G@@PLIED @A@S@RFILL(1) SAC  CGBXBF,CGBXBF  . 00    @F@@@SFILL(1) SAC  CGBXBRI
)@@G@@F,CGBXBF  . 00   NOTE INPLIED PREC IMPOSSIBLE   @A@@@RFILL(1) SAC  CGDXBRJ
)@@G@@F,CGDXBF  . 01    @A@@@RFILL(1) SAC  CGBXBX,CGN050Y  . 02   @A@@@RFILL(1RK
)@@G@@) SAC  CGDXBX,CGFBX   . 03    @A@S@RFILL(1) SAC  CGBXDF,CGBXDF  . 04    RL
)@@G@@@F@@@SFILL(1) SAC  CGBXDF,CGBXDF  . 04   NOTE IMPLIED PREC IMPOSSIBLE   RM
)@@G@@@A@S@RFILL(1) SAC  CGDXDF,CGDXDF  . 05    @F@@@SFILL(1) SAC  CGDXDF,CGDXRN
)@@G@@DF  . 05   NOTE IMPLIED PREC IMPOSSIBLE   @A@@@RFILL(1) SAC  CGBXDX,CGBURO
)@@G@@DU  . 06    @A@@@RFILL(1) SAC  CGDXDX,CGN050X  . 07   @A@@@RFILL(1) SAC RP
)@@G@@ CGBFBF,CGFUFU  . 08    @A@@@RFILL(1) SAC  CGDFBF,CGFUFU  . 09    @A@@@RRQ
)@@G@@FILL(1) SAC  CGBFBX,CGFBX   . 10    @A@@@RFILL(1) SAC  CGDFBX,CGFBX   . RR
)@@G@@11    @A@@@RFILL(1) SAC  CGBFDF,CGN021  . 12    @A@@@RFILL(1) SAC  CGDFDRS
)@@G@@F,CGFUFU  . 13    @A@@@RFILL(1) SAC  CGBFDX,CGN021  . 14    @A@@@RFILL(1RT
)@@G@@) SAC  CGDFDX,CGN021  . 15    @B@@@R/.           BINARY FLOAT <- BINARY RU
)@@G@@FLOAT @C@@@R.            DECIMAL FLOAT <- DECIMAL FLOAT     @[@@@R.     RV
)@@G@@@]@@@RCGBFBF LABEL@]@@@RCGDFDF LABEL@ @@@R       LOAD  A7,SGDPRE,X3     RW
)@@G@@@D@@@R       STORE A7,SGDPRE,X2   . CHANGE TARGET PRECISION @#@@@R      RX
)@@G@@ GOTO CGFUFU@[@@@R.     @[@@@R.     @B@@@R.            DECIMAL FLOAT <- RY
)@@G@@BINARY FLOAT@[@@@R.     @]@@@RCGDFBF LABEL@B@@@R       LINK  CGCLDP    .RZ
)@@G@@ A7 = CEIL(P/3.32)@D@@@R       STORE A7,SGDPRE,X2  . CHANGE TARGET PRECISA
)@@G@@SION  @C@@@R                         . THEN GOTO CGFUFU     @[@@@R.     SB
)@@G@@@[@@@R.     @G@@@R.            COME HERE TO DETERMINE COMPLEX/REAL OF DESC
)@@G@@C FLT, BIN FLT OR @F@@@R.            DEC FIX.  X4 HOLDS THE APPROPRIATE SD
)@@G@@INDEX (X4=0-3)    @[@@@R.     @C@@@RCGFUFU LABEL       . REAL/COMPLEX BRSE
)@@G@@ANCH TABLE  @C@@@R       LOADA X4,CGN019,X4  . WHERE TO BRANCH TO @ @@@RSF
)@@G@@       LOAD  X4,W1H1,X4 .     @#@@@R       GOTO  0,X4 @#@@@RCGTBLE CSECTSG
)@@G@@  3 . @#@@@RCGN019 SFW   0    @D@@@RFILL(1) SAC   CGRET,CGRET   . LEFT RSH
)@@G@@EAL, RIGHT REAL   @D@@@RFILL(1) SAC   CGFRFC,CGFRFC  . LEFT REAL, RIGHT SI
)@@G@@COMP  @D@@@RFILL(1) SAC   CGFCFR,CGFCFR  . LEFT COMP, RIGHT REAL  @D@@@RSJ
)@@G@@FILL(1) SAC   CGRET,CGN018  . LEFT COMP, RIGHT COMP   @]@@@RCGN018 LABELSK
)@@G@@@B@@@R       ADD X1,1,I  . POINT TO IMAGINARY AW@A@@@R       LOAD  X4,0,SL
)@@G@@I  . FORCE RETURN @D@@@R       GOTO  0,X5   . RETURN TO FROM WHENCE YOU SM
)@@G@@CAME  @C@@@R/.           DECIMAL FLOAT <- DECIMAL FIXED     @[@@@R.     SN
)@@G@@@]@@@RCGDFDX LABEL@ @@@R       LOAD  A7,SGDPRE,X3     @D@@@R       STORESO
)@@G@@ A7,SGDPRE,X2    . CHANGE TARGET PREC     @]@@@RCGN021 LABEL@^@@@R      SP
)@@G@@ USING SGDSCT,X3  @D@@@R       IF  SGDSCL,ZERO    THEN,CGFUFU  . -> SCALSQ
)@@G@@E=0   @]@@@RCGN022 LABEL@F@@@R       IF  SDVRCN,ON         THEN,CGN025  SR
)@@G@@ . RICHT IS A CONSTANT  @D@@@RCGN023 LABEL                 . RIGHT IS A SS
)@@G@@VARIABLE    @C@@@R       LOADN  A7,SGDSCP,X3 .       (GEN /10**QR)@C@@@RST
)@@G@@       SSA   A7,9       . TO GET SIGNED SCALE   @C@@@R       LINK  CGDSFSU
)@@G@@T     . GEN SHIFTING CODE     @]@@@RCGN025 LABEL@B@@@R       LOADA X5,CGSV
)@@G@@N022  . WHERE TO RETURN @D@@@R       LOAD  X4,CGN019,X4    . WHICH ENTRYSW
)@@G@@ OF TABLE   @^@@@R       GOTO  0,X4   .   @[@@@R.     @[@@@R.     @B@@@RSX
)@@G@@.            BINARY FLOAT <- DECIMAL FIXED@B@@@R.            BINARY FLOASY
)@@G@@T <- DECIMAL FLOAT@[@@@R.     @]@@@RCGBFDF LABEL@]@@@RCGBFDX LABEL@B@@@RSZ
)@@G@@       LINK  CGCLMP     . A7<-CEIL(P*3.32)@F@@@R       IF  A7,LT,KBFMXP+TA
)@@G@@1,I  THEN,CGN026     . ->PREC IS OKAY     @C@@@R       LOAD  A7,KBFMXP,ITB
)@@G@@  . USE MAX PREC FOR BF @]@@@RCGN026 LABEL@D@@@R       STORE A7,SGDPRE,XTC
)@@G@@2    . CHANGE TARGET PREC     @E@@@R       GOTO  CGN021 .              FTD
)@@G@@IX UP FOR THE SCALE     @B@@@R/.           RETURN:   CEIL(P/3.32) IN A7 TE
)@@G@@@ @@@R.            DESTROY:  A8     @[@@@R.     @]@@@RCGCLDP LLOC @E@@@RTF
)@@G@@       LOAD  A8,SGDPRE,X3      . GET PRECISION OF SOURCE    @G@@@R      TG
)@@G@@ SLB   A8,KKSCL          . SO P'S SCALE MATCHES THAT OF CONSTANT  @^@@@RTH
)@@G@@       LOAD  A7,0,I     @B@@@R       DIV   A7,K332S9         . CONVERT  TI
)@@G@@@C@@@R       ADD   A7,1,I            . GET CEILING    @]@@@R       LJMP TJ
)@@G@@@[@@@R.     @[@@@R.     @B@@@R.            RETURN:   CEIL(P*3.32) IN A7 TK
)@@G@@@[@@@R.     @]@@@RCGCLMP LLOC @E@@@R       LOAD  A7,SGDPRE,X3      . GETTL
)@@G@@ PRECISION OF SOURCE    @I@@@R       MPYS A7,K332S9          . CONVERT--TM
)@@G@@P=9 BITS, K332S9=15 BITS--> NO OVERFLW    @D@@@R       SRB   A7,KKSCL   TN
)@@G@@       . SHIFT AWAY SCALE     @C@@@R       ADD   A7,1,I             . GETO
)@@G@@T CEILING   @]@@@R       LJMP @B@@@R/.           BINARY FIXED <- DECIMALTP
)@@G@@ FIXED@[@@@R.     @]@@@RCGBXDX LABEL@A@@@R         LOAD    A7,SGDSCP,X3 TQ
)@@G@@.     @C@@@R       SSA   A7,9       . TO GET SIGNED SCALE   @D@@@R      TR
)@@G@@ IF    A7,EQ,0,I  THEN,CGN129    . -> NO SCALE  @C@@@R       MPYS  A7,K3TS
)@@G@@32S9       . QR*3.32*2**9     @E@@@R       SSA   A7,KKSCL        . SHIFTTT
)@@G@@ OUT SCALE OF CONSTANT  @D@@@R       IF    A7,LT,0,I  THEN,CGN029    . -TU
)@@G@@> NEG. SCALE@D@@@R       ADD   A7,1,I     . POSITIVE SCALE, TAKE CEILINGTV
)@@G@@@E@@@R       IF  A7,LT,KBXMXP+1,I  THEN,CGN129     . -> QR IS OKAY@C@@@RTW
)@@G@@       LOAD  A7,KBXMXP,I  . SET SCALE TO MAX.   @^@@@R       GOTO  CGN12TX
)@@G@@9     @#@@@RCGN029 LABEL .    @D@@@R       SUB   A7,1,I     . NEGATIVE STY
)@@G@@CALE, TAKE FLOOR  @E@@@R       IF  A7,GE,-KBXMXP,I  THEN,CGN129     . ->TZ
)@@G@@ QR IS OKAY @C@@@R       LOAD  A7,-KBXMXP,I  . SET SCALE TO MIN   @#@@@RUA
)@@G@@CGN129 LABEL .    @B@S@R       STORE A7,SGDSCL,X3    . SET SCALE  @B@@@SUB
)@@G@@       STORE A7,SGDSCL,X2    . SET SCALE  @B@@@R       LINK  CGCLMP     UC
)@@G@@. CEIL(PR*3.32)   @E@@@R       IF  A7,LT,KBXMXP+1,I  THEN,CGN329     . -UD
)@@G@@> PR IS OKAY@C@@@R       LOAD  A7,KBXMXP,I  . SET PREC. TO MAX.   @#@@@RUE
)@@G@@CGN329 LABEL .    @C@S@R       STORE A7,SGDPRE,X3    . SET PRECISION    UF
)@@G@@@C@@@S       STORE A7,SGDPRE,X2    . SET PRECISION    @[@@@R.     @E@@@RUG
)@@G@@CGBUDU LABEL            . BINARY UNKNOWN <- DECIMAL UNKNOWN @F@@@R      UH
)@@G@@ IF  SDVRCN,OFF         THEN,CGN031   . ->ITS A VARIABLE    @E@@@R      UI
)@@G@@ LOAD  X5,AWOFST,X1 .   X5 <- DISPLACEMENT OF SDFLPT  @#@@@RCGN034 LABELUJ
)@@G@@ .    @^@@@R       USING SGDSCT,X3  @C@@@R       IF  SGDSCL,NZERO   THENUK
)@@G@@,CGBXBF  . ->QR_0 @D@@@R         SUB   X5,2,I .       POINT TO FUNNY FLOUL
)@@G@@AT    @^@@@R       USING WORD,X5 .  @B@@@R       LOAD  A7,W1      . GET UM
)@@G@@W1 OF FXPT  @G@@@R       IF  A7,NE,0,I  THEN,CGN033   . ->NOT AN INTEGERUN
)@@G@@       *******    @C@@@R       ADD   X5,1,I     . INPUT DID CONVERT, SO UO
)@@G@@@E@@@R       STORE X5,AWOFST,X1    . POINT TO INTEGER CONSTANT AND@G@@@RUP
)@@G@@         SET   SDDCBN,ON .     SET BINARY INPUT . QDECIMAL=QBINARY=0    UQ
)@@G@@@C@@@R       GOTO  CGN050     . DO BX-<BX CONVERSION  @#@@@RCGN031 LABELUR
)@@G@@ .    @ @@@R       LOADN  A7,SGDSCP,X3 .  @C@@@R       SSA   A7,9       US
)@@G@@. TO GET SIGNED SCALE   @E@@@R       IF  A7,EQ,0,I  THEN,CGBXDF      . QUT
)@@G@@R=0, SO NO SHIFT  @D@@@R       LINK  CGDSFT     . SHIFT, THEN GO ON TO BUU
)@@G@@XDF   @B@@@R/.           BINARY FIXED <- DECIMAL FLOAT@B@@@R.           UV
)@@G@@ BINARY FIXED <- BINARY FLOAT @[@@@R.     @]@@@RCGBXDF LABEL@]@@@RCGBXBFUW
)@@G@@ LABEL@^@@@R       USING SGDSCT,X2  @D@@@RCGN033   LABEL .              UX
)@@G@@    RIGHT NOT INTEGER   @ @@@R         LOAD    A7,SGDSCP .  @D@@@R      UY
)@@G@@   SSA     A7,9 .            GET SIGNED SCALE   @A@@@R      CGENMR CGFIXUZ
)@@G@@      . 'FIX' IT  @^@@@R         USING SGDSCT,X3@A@@@R         SET   SGDVA
)@@G@@EXP,ON,SGDID .    @ @@@R         USING  SGDSCT,X2 .   @F@@@R         SUBVB
)@@G@@     X10,1,I .         BACK UP ONE LINE **************@F@@@R         STOVC
)@@G@@RE   A7,W1Q1,*X10 .    STORE THE SCALE IN THE CODE    @C@@@R       LOADAVD
)@@G@@ X4,CGN032,X4  . WHERE TO BRANCH TO @ @@@R       LOAD  X4,W1H1,X4 .     VE
)@@G@@@#@@@R       GOTO  0,X4 @#@@@RCGTBLE CSECT  3 . @D@@@RCGN032 SFW  0 .   VF
)@@G@@               ANALYZE REAL/COMPLEX @D@@@RFILL(1) SAC   CGRET,CGRET   . VG
)@@G@@LEFT REAL, RIGHT REAL   @D@@@RFILL(1) SAC   CGFRFC,CGFRFC  . LEFT REAL, VH
)@@G@@RIGHT COMP  @D@@@RFILL(1) SAC   CGFCFR,CGFCFR  . LEFT COMP, RIGHT REAL  VI
)@@G@@@D@@@RFILL(1) SAC   CGN132,CGN232  . LEFT COMP,RIGHT COMP   @D@@@RCGN132VJ
)@@G@@ LABEL .          . COME HERE FROM BXDF, BXBF   @A@@@R       LOAD  X4,0,VK
)@@G@@I  . FORCE RETURN @B@@@R       ADD X1,1,I  . POINT TO IMAGINARY AW@H@@@RVL
)@@G@@       IF  SDFXFL,ON         THEN,CGBXDF  ELSE,CGBUDU  . IS RIGHT FLOAT/VM
)@@G@@FIXED?@C@@@RCGN232 LABEL .          . COME HERE FROM CGN050 @A@@@R      VN
)@@G@@ LOAD  X4,0,I  . FORCE RETURN @B@@@R       ADD X1,1,I  . POINT TO IMAGINVO
)@@G@@ARY AW@H@@@R       IF  SDDCBN,ON         THEN,CGN051  ELSE,CGN034  . IS VP
)@@G@@RIGHT DEC/BIN?    @B@@@R/.           BINARY FIXED <- BINARY FIXED @C@@@RVQ
)@@G@@.            DECIMAL FIXED <- DECIMAL FIXED     @]@@@RCGBXBX LABEL@]@@@RVR
)@@G@@CGDXDX LABEL@F@@@R       LOAD  A7,W1H2,X3      . COME HERE FOR IMPLIED PVS
)@@G@@,Q, SO SET  @F@@@R       STORE A7,W1H2,X2      . THEN AND GO ANALYZE COMVT
)@@G@@PLEX/REAL   @D@@@R         IF    SDVRCN,OFF THEN,CGFUFU . -> VARIABLE   VU
)@@G@@@D@@@R         LOAD  X5,AWOFST,X1 .   POINT TO FLOAT VALUE  @C@@@R      VV
)@@G@@   SUB   X5,2,I .          FUNNY FLOAT PTR@B@@@R         STORE X5,AWOFSTVW
)@@G@@,X1 .    SAVE IT  @^@@@R         USING WORD,X5 .@E@@@R         IF    W1,VX
)@@G@@NZERO THEN,CGFUFU . ->HAVE FUNNY FLOAT    @D@@@R         ADD   X5,1,I . VY
)@@G@@         ONLY HAVE BINARY FORM@ @@@R         STORE  X5,AWOFST,X1 .@D@@@RVZ
)@@G@@         GOTO  CGN066 .          ->CONVERT BX TO DX   @B@@@RCGN050Y   LAWA
)@@G@@BEL .                 BX-BX   @C@@@R         IF    SDVRCN,OFF THEN,CGN05WB
)@@G@@0 . -> DO IT@ @@@R         LOAD  X5,AWOFST,X1 . @E@@@R         SUB   X5,WC
)@@G@@2,I .            POINT TO BINARY VALUE    @^@@@R         USING WORD,X5 .WD
)@@G@@@E@@@R         IF    W1,NZERO THEN,CGN050Z . ->SETUP FIXED DECIMAL@F@@@RWE
)@@G@@         ADD   X5,1,I .            POINT TO ACTUAL BINARY VALUE   @ @@@RWF
)@@G@@         STORE X5,AWOFST,X1 . @^@@@R         GOTO  CGN050 . @D@@@RCGN050WG
)@@G@@Z   LABEL .                  USE FUNNY FLOAT    @E@@@R         SET   SDFWH
)@@G@@XFL,ON .        DO FLOAT TO FIX CONVERSION@^@@@R         GOTO  CGBXBF . WI
)@@G@@@C@@@RCGN050X   LABEL .          DX-DX CONVERSION     @D@@@R         IF WJ
)@@G@@   SDVRCN,OFF THEN,CGN050 .   -> VARIBALE @E@S@R         LOAD  A7,AWOFSTWK
)@@G@@,X1 .      CHANGE FROM FLOAT TO FFT @E@@@S         LOAD  A3,AWOFST,X1 . WL
)@@G@@     CHANGE FROM FLOAT TO FFT @^@S@R         SUB   A7,2,I . @^@@@S      WM
)@@G@@   SUB   A3,2,I . @ @S@R         STORE A7,AWOFST,X1 . @ @@@S         STOWN
)@@G@@RE A3,AWOFST,X1 . @^@@@S         USING WORD,A3 .@D@@@S         IF    W1,WO
)@@G@@NZERO THEN,CGN050 . -> FUNNY FLT, OK@[@@@S.     @B@@@S.         REALLY FWP
)@@G@@IXED BINARY CONSTANT    @[@@@S.     @^@@@S         ADD   A3,1,I . @ @@@SWQ
)@@G@@         STORE A3,AWOFST,X1 . @E@@@S         LOAD  A3,SGDPRE,X3 .     COWR
)@@G@@NVERT DEC P TO BIN P    @ @@@S         MPYS A3,DCVDTB .     @^@@@S      WS
)@@G@@   SRB   A3,14 .  @ @@@S         STORE A3,SGDPRE,X3 . @C@@@S         SETWT
)@@G@@   SDDCBN,ON .        SET BINARY    @ @@@S         SET   SDVRCN,OFF .   WU
)@@G@@@E@@@S         GOTO  CGFBX   .        DO BINARY FIXED -> DEC FIXED@]@@@RWV
)@@G@@CGN050 LABEL@ @@@R       LOAD  A7,SGDSCP,X2     @D@@@R         SSA     AWW
)@@G@@7,9 .            GET SIGNED SCALE   @ @@@R       LOAD  A8,SGDSCP,X3 .   WX
)@@G@@@C@@@R       SSA   A8,9       . TO GET SIGNED SCALE   @B@@@R       SUB  WY
)@@G@@ A7,A8      . COMPUTE QL-QR   @G@@@R         IF      A7,EQ,0,I THEN,CGFUWZ
)@@G@@FU . QR=QL, ANALYSE REAL/COMPLEX    @G@@@R       IF  SDDCBN,OFF         XA
)@@G@@THEN,CGN045   . -> GOT HERE THRU DXDX     @#@@@RCGN051 LABEL .    @B@@@RXB
)@@G@@       LINK  CGISFT     . GEN(*2(QL-QR))  @ @@@R       LOAD  X4,CGN032,XXC
)@@G@@4     @C@@@R       GOTO  0,X4       . ANALYZE REAL/COMPLEX  @[@@@R.     XD
)@@G@@@]@@@RCGN045 LABEL@D@@@R       LOADA X5,CGN045  . FOR RETURN FROM COMP/CXE
)@@G@@OMP   @B@@@RCGN040   LABEL . MERGE HERE FROM CGDXDF   @C@@@R         IF XF
)@@G@@     A7,EQ,0,I THEN,CGN046 . ->QL=0 @C@@@R       LINK  CGDSFT     . GEN XG
)@@G@@(*10**(QL-QR))    @C@@@R       IF  A7,GE,1,I  THEN,CGN044      . QL-QR>0XH
)@@G@@@E@@@RCGN041   LABEL .                   COME HERE FROM CGBXDX    @E@@@RXI
)@@G@@       GEN .                       TRY TO TRUNCATE IF DIVIDE@H@@@R      XJ
)@@G@@ GFLOAT OPDFA,AGPTX1,AGXUNZ . TRUNCATE FRACT PART USING UNNORM'ED ZERO  XK
)@@G@@@^@@@R       GOTO  CGN046     @F@@@RCGN044 LABEL .                     CXL
)@@G@@HECK FOR OVFL IF MULTIPLY     @G@T@R         IF      OOPTD,OFF,DGOPT3 THXM
)@@G@@EN,CGN046 . ONLY CHECK IF D OPT SET @F@V@T         IF      DCONFO,OFF,DCXN
)@@G@@GONF  THEN,CGN046 . FOFL DISABLED   @F@@@V         IF      DCONSI,OFF,DCXO
)@@G@@GONF  THEN,CGN046 . SIZE DISABLED   @E@U@R         GENM .               XP
)@@G@@     GENERATE OVERFLOW CHECK  @E@@@U.        GENM .                    GXQ
)@@G@@ENERATE OVERFLOW CHECK  @C@U@R       GSUB  RTOVCH     . TO RUNTIME CHECKXR
)@@G@@ER    @C@@@U.      GSUB  RTOVCH     . TO RUNTIME CHECKER    @F@U@R      XS
)@@G@@   GINST   00,AGRA3,AGPTX1  'NO' . FUNNY INST FOR SUBROUTINE@F@@@U.     XT
)@@G@@   GINST   00,AGRA3,AGPTX1  'NO' . FUNNY INST FOR SUBROUTINE@#@U@R      XU
)@@G@@ GFIN .     @#@@@U.      GFIN .     @D@U@R         LOAD    A6,SGDPRE,X2 XV
)@@G@@.    GET THE PRESISION  @D@@@U.        LOAD    A6,SGDPRE,X2 .    GET THEXW
)@@G@@ PRESISION  @E@U@R         SUB     X10,1,I .         GO BACK AN INSTRUCTXX
)@@G@@ION   @E@@@U.        SUB     X10,1,I .         GO BACK AN INSTRUCTION   XY
)@@G@@@F@U@R         ADD     A6,A6 .           FIX THE PRE FOR INDEX IN TABLE XZ
)@@G@@@F@@@U.        ADD     A6,A6 .           FIX THE PRE FOR INDEX IN TABLE YA
)@@G@@@G@U@R         STORE   A6,W1Q1,*X10 .          PUT THE SCALE IN CODE FORYB
)@@G@@ SUB  @G@@@U.        STORE   A6,W1Q1,*X10 .          PUT THE SCALE IN COYC
)@@G@@DE FOR SUB  @]@@@RCGN046 LABEL@ @@@R         USING SGDSCT,X3 .    @A@@@RYD
)@@G@@         SET   SGDEXP,ON,SGDID .    @ @@@R       LOAD  X4,CGN019,X4     YE
)@@G@@@B@@@R       GOTO  0,X4  . ANALYZE COMP/REAL    @C@@@R/.           DECIMYF
)@@G@@AL FIXED <- DECIMAL FLOAT     @B@@@R.            DECIMAL FIXED <- BINARYYG
)@@G@@ FLOAT@[@@@R.     @]@@@RCGDXBF LABEL@]@@@RCGDXDF LABEL@^@@@R       USINGYH
)@@G@@ SGDSCT,X2  @ @@@R       LOAD  A7,SGDSCP,X2     @C@@@R       SSA   A7,9 YI
)@@G@@      . TO GET SIGNED SCALE   @D@@@R       LOADA X5,CGDXBF  . FOR RETURNYJ
)@@G@@ FROM COMP/COMP   @ @@@R         GOTO    CGN040 .     @B@@@R/.          YK
)@@G@@ BINARY FLOAT <- BINARY FIXED @B@@@R.            DECIMAL FIXED <- BINARYYL
)@@G@@ FIXED@B@@@R.            DECIMAL FLOAT <- BINARY FIXED@[@@@R.     @]@@@RYM
)@@G@@CGBFBX LABEL@D@@@R       LOAD  A7,SGDPRE,X3    . SET IMPLIED PRECISION  YN
)@@G@@@ @@@R       STORE A7,SGDPRE,X2 .   @#@@@R       GOTO  CGFBX@[@@@R.     YO
)@@G@@@]@@@RCGDXBX LABEL@[@@@R.     @B@@@R       LINK  CGCLDP     . CEIL(P/3.3YP
)@@G@@2)    @ @@@R       STORE A7,SGDPRE,X2 .   @G@@@R. THIS SECTION OF CODE WYQ
)@@G@@AS THE SUBR. CGCNDQ (CALLING CGCNMQ) IN PL/C    @B@@@R. IT COMPUTES CEILYR
)@@G@@ING/FLOOR OF (Q/3.32)   @ @@@R       LOAD  A9,SGDSCL,X3     @B@@@R      YS
)@@G@@ SLB   A9,27 . PUT SIGN IN SIGN BIT @B@@@R       LOADM A8,A9      . DO DYT
)@@G@@IV. ON POS #@F@@@R       SRB   A8,27-KKSCL     . SO Q HAS SAME SCALE AS YU
)@@G@@CONSTNNT    @A@@@R       LOAD  A7,0,I     . FOR DIV.  @^@@@R       DIV  YV
)@@G@@ A7,K332S9  @D@@@R       IF  A7,EQ,0,I  THEN,CGN065      . PREC IS OKAY YW
)@@G@@@H@@@R       IF  A9,GE,1,I  THEN,CGN064      . WHETHER TO TAKE FLOOR OR YX
)@@G@@CEILING     @H@@@R       SUB   A7,2,I     . FLOOR, SO THAT NET RESULT WIYY
)@@G@@LL BE A7-1 (A7-2+1)     @]@@@RCGN064 LABEL@A@@@R       ADD   A7,1,I     YZ
)@@G@@. CEILING   @]@@@RCGN065 LABEL@ @@@R       STORE A7,SGDSCL,X2 .   @#@@@RZA
)@@G@@       GOTO  CGFBX@[@@@R.     @]@@@RCGDFBX LABEL@[@@@R.     @B@@@R      ZB
)@@G@@ LINK  CGCLDP     . CEIL(P/3.32)    @ @@@R       STORE A7,SGDPRE,X2 .   ZC
)@@G@@@C@@@RCGFBX  LABEL       . ANY FLOAT <- BINARY FIXED  @D@@@R         IF ZD
)@@G@@   SDVRCN,OFF THEN,CGN066 . -> VARIABLE   @D@@@R         LOAD  X5,AWOFSTZE
)@@G@@,X1 .   RIGHT PTR TO SOURCE   @D@@@R         SUB   X5,1,I .         POINZF
)@@G@@T TO BINARY VALUE @ @@@R         STORE X5,AWOFST,X1 . @#@@@RCGN066   LABZG
)@@G@@EL .  @C@@@R      CGENMR CGFLOT     . FLOAT THE BIN FIX #   @^@@@R      ZH
)@@G@@ USING SGDSCT,X3  @A@@@R         SET   SGDEXP,ON,SGDID .    @F@@@R      ZI
)@@G@@ LOADN  A7,SGDSCP,X3    . GET NEGATIVE OF SCALE (IN 8 BITS) @D@@@R      ZJ
)@@G@@   SSA     A7,9 .            FIX FOR THE XH2    @C@@@R         IF      AZK
)@@G@@7,EQ,0,I THEN,CGN061 . ->QR=0 @B@@@R       LINK  CGTSFT     . GEN ( /2**ZL
)@@G@@QR)   @#@@@RCGN061 LABEL .    @D@@@R       LOADA X5,CGFBX   . FOR RETURNZM
)@@G@@ FROM COMP/COMP   @^@@@R       USING SGDSCT,X2  @G@@@R       IF  SDFXFL,ZN
)@@G@@ON  THEN,CGN046    . -> TARGET IS FLOAT (IE NOT DX)   @ @@@R       LOAD ZO
)@@G@@ A7,SGDSCP,X2     @C@@@R       SSA   A7,9       . TO GET SIGNED SCALE   ZP
)@@G@@@G@@@R         IF      A7,NE,0,I THEN,CGN040 ELSE,CGN041 . THEY'LL HANDLZQ
)@@G@@E THIS@B@@@R/.           FLOAT REAL<-FLOAT COMPLEX    @]@@@RCGFRFC LABELZR
)@@G@@@ @@@R       LOADA X1,SGDIBS,X3     @]@@@R       GEN  @F@@@R       GFREEZS
)@@G@@ AGPTX1     . FREE TEMPORARA POINTED TO BY IMAGIN AW  @#@@@R       GOTO ZT
)@@G@@ CGRET@[@@@R.     @B@@@R.            FLOAT COMPLEX<-FLOAT REAL    @]@@@RZU
)@@G@@CGFCFR LABEL@D@@@R       LOAD  A7,AGDZRO      . INIT IMAGINARY AW TO 0  ZV
)@@G@@@G@@@R       STORE A7,AGIM1,X3    .  IMAGIN PART OF ENTRY.  NOW TO CGRETZW
)@@G@@...   @^@@@S       USING SGDSCT,X3  @E@@@S       SET   SGDEXP,ON,SGDID  ZX
)@@G@@. INDICATE CONVERSION WAS DONE@[@@@R.     @D@@@R.            COME HERE TZY
)@@G@@O RETURN FROM WHENCE YOU CAME @]@@@RCGRET  LABEL@H@@@R       IF  SGDSGN,ZZ
)@@G@@OFF         THEN,CGRET1   . -> SIGN POSITIVE, NOT MUCH TO DO@#@@@RCGN008AA
)@@G@@   LABEL .  @B@@@R       LOADA X4,CGSGND  . ASSUME DOUBLE   @F@@@R      AB
)@@G@@ IF  2,OFF,DCGSV3+9  THEN,CGRET3    . -> MUST DO DOUBLE NEG @D@@@R      AC
)@@G@@ LOADA X4,CGSGNS  . CHANGE TO SINGLE FOR BIN FIX@#@@@RCGRET3 LABEL .    AD
)@@G@@@B@@@R       LOADA X1,SGDRBS,X3    . REAL PART  @^@@@R      CGENMR R,X4 AE
)@@G@@.     @F@@@R       IF  1,OFF,DCGSV3+9  THEN,CGRET2   . -> ITS NOT COMPLEAF
)@@G@@X     @B@@@R       LOADA X1,SGDIBS,X3    . IMAGIN PART@^@@@R      CGENMRAG
)@@G@@ R,X4 .     @#@@@RCGRET2 LABEL .    @^@S@R       USING SGDSCT,X3  @E@@@RAH
)@@G@@       SET   SGDEXP,ON,SGDID    . ANSWER IS SIGNED EXPR.    @#@@@RCGRET1AI
)@@G@@ LABEL .    @D@@@R       LOAD  A7,W1H2,X2   . RIGHT P,Q <--  LEFT P,Q   AJ
)@@G@@@ @@@R       STORE A7,W1H2,X3   .   @D@@@R         LOAD    F,SGDCLS,X2 .AK
)@@G@@     MOVE THE CLASS BITS@G@@@R       SET   SGDSGN+SDVRCN,OFF         . RAL
)@@G@@EMOVE SIGN AND CONSTANT BITS  @F@@@R       STORE F,SGDCLS,X3     . RESTOAM
)@@G@@RE TARGET CLASS FROM F-REG.   @#@@@R       GRTN  3    @[@@@R.     @D@@@RAN
)@@G@@.            CODE FOR NEGATION OF COVVERTED NUMBER    @^@@@R.           AO
)@@G@@ X1 = A(AW) @B@@@R.            GENMR CGSGND  FOR  DLN A,A   @B@@@R.     AP
)@@G@@       GENMR CGSGNS  FOR  LNA A,A   @[@@@R.     @C@@@R       GMODE 'M'  AQ
)@@G@@ . SET BIT FOR PACKING ICODE  @]@@@RCGSGND GLBL @E@@@R       GIFR  CGSGNAR
)@@G@@1,AGPTX1   . -> IF ALREADY IN REGISTER    @D@@@R         GGETGR  AGXTMP,AS
)@@G@@2 .        GET A FREE REGISTER@E@@@R         GDBLE   OPDLN,AGXTMP,AGPTX1AT
)@@G@@ . LOAD THE NEGATIVE    @F@@@R         GSET    AGPTX1,AGXTMP .   POINT TAU
)@@G@@O THE NEW ADRESS WRD    @#@@@R         GFIN .   @]@@@RCGSGN1 GLBL @F@@@RAV
)@@G@@       GDBLE OPDLN,AGPTX1,AGPTX1 'NO' . DO DOUBLE WORD NEGATE     @]@@@RAW
)@@G@@       GFIN @]@@@RCGSGNS GLBL @E@@@R       GIFR  CGSGN2,AGPTX1   . -> IFAX
)@@G@@ ALREADY IN REGISTER    @A@@@R       GGETGR AGXTMP    . GET A REG.@D@@@RAY
)@@G@@       GINST OPLNA,AGXTMP,AGPTX1  . NEGATIVE LOAD     @ @@@R       GSET AZ
)@@G@@ AGPTX1,AGXTMP  . @#@@@R       GFIN .     @]@@@RCGSGN2 GLBL @F@@@R      BA
)@@G@@ GINST OPLNA,AGPTX1,AGPTX1 'NO'  . DO SINGLE WORD NEGATE    @]@@@R      BB
)@@G@@ GFIN @ @@@R/.           DECIMAL SCALING  @B@@@R.            A7 = SCALE BC
)@@G@@   X1 = A(AW)     @F@@@R.            GENERATES CODE TO MULTIPLY (A7>0) OBD
)@@G@@R DIVIDE (A7<0)   @E@@@R.            THE (FLOATING) AW POINTED TO BY X1 BE
)@@G@@BY10**Q.    @[@@@R.     @#@@@RCGDSFT LOCAL .    @G@@@R       LOAD  A9,A7BF
)@@G@@ .     SAVE A7, IN CASE RETURN HERE FOR COMPLEX-ITIES @H@@@R       ADD  BG
)@@G@@ A9,A9  . FOR INDEX OF CORRECT ENTRY (TABLE IS IN DBLE WORDS)     @C@@@RBH
)@@G@@       IF  A9,GE,0,I  THEN,CGD001 . -> MULTIPLY @A@@@R       LOADM A9,A9BI
)@@G@@      . Q<-ABS(Q) @C@@@R       LOADA A8,CGD006  . ADDR OF DIVISION CODE BJ
)@@G@@@^@@@R       GOTO  CGD002     @]@@@RCGD001 LABEL@C@@@R       LOADA A8,CGBK
)@@G@@D005  . MULTIPLICATION CODE   @]@@@RCGD002 LABEL@B@@@R       LOADA A3,KKBL
)@@G@@PW10-2  . BASE OF TABLE @F@@@R       IF  A9,LT,KFLTSZ+1,I  THEN,CGD003  BM
)@@G@@  . ->Q*2<=TABLE SIZE   @B@@@R       LOADA A3,KFLTSZ-2,X5  . LAST ENTRY BN
)@@G@@@^@@@R       GOTO  CGD004     @]@@@RCGD003 LABEL@D@@@R       ADD   A3,A9BO
)@@G@@      . IF OK, GET PROPER ENTRY     @]@@@RCGD004 LABEL@E@@@R       STOREBP
)@@G@@ A3,AGX0OF  . DISPLACEMANT OF DESIRED POWER     @^@@@R      CGENMR R,A8 BQ
)@@G@@.     @ @@@R         USING SGDSCT,X3 .    @A@@@R         SET   SGDEXP,ONBR
)@@G@@,SGDID .    @C@@@R       SUB   A9,KFLTSZ,I  . NEED WE DO MORE?    @C@@@RBS
)@@G@@       IF  A9,GE,1,I  THEN,CGD002      . WE DO. @]@@@R       JMP .@C@@@RBT
)@@G@@       GMODE 'M'   . SET BIT FOR PACKING ICODE  @]@@@RCGD005 GLBL @B@@@RBU
)@@G@@       GIFR  CGD007,AGPTX1   . IN REG YET?@B@@@R       GLOAD AGPTX1,2   BV
)@@G@@. NO, LOAD IT     @#@@@RCGD007 GLBL .     @F@@@R       GFLOAT  OPDFM,AGPBW
)@@G@@TX1,AGXR0 . MULT BY PROPER POWER OF 10    @#@@@R       GFIN .     @]@@@RBX
)@@G@@CGD006 GLBL @B@@@R       GIFR  CGD008,AGPTX1   . IN REG YET?@B@@@R      BY
)@@G@@ GLOAD AGPTX1,2   . NO, LOAD IT     @#@@@RCGD008 GLBL .     @F@@@R      BZ
)@@G@@ GFLOAT  OPDFD,AGPTX1,AGXR0 .  DIV BY PROPER POWER OF 10    @#@@@R      CA
)@@G@@ GFIN .     @ @@@R/.           BASE TWO SCALING @B@@@R.            A7 = CB
)@@G@@SCALE    X1 = A(AW)     @F@@@R.            GENERATES CODE TO MULTIPLY (ACC
)@@G@@7>0) OR DIVIDE (A7<0)   @C@@@R.            THE AW POINTED TO BY X1 BY 2*CD
)@@G@@*Q.   @[@@@R.     @]@@@RCGTSFT LOCAL@F@@@R         LSSC    A7,6 .       CE
)@@G@@     SHIFT INTO PROPER POSITION     @E@@@R       ADD   A7,0200140,I    .CF
)@@G@@ ADD BIAS, AND FRACTION OF 1  @C@@@R       STORE A7,AGX0OF  . FOR IMMEDICG
)@@G@@ATE LOAD    @]@@@R       GENM @C@@@R       GIFR    CGTSF1,AGPTX1 .   IN CH
)@@G@@A REG YET ? @E@@@R         GGETGR  AGXTMP,2 .        GET A FREE REGISTERCI
)@@G@@ PAIR @F@@@R         GSHIFT  AGXTMP .          'SHIFT ' TO POINT TO EVENCJ
)@@G@@ REG  @F@@@R         GINST   OPLA,AGXTMP,AGXR0,XU . GET THE EXPONENT INTCK
)@@G@@O REG @E@@@R         GSHIFT  AGXTMP .          POINT BACK TO ODD REG    CL
)@@G@@@G@@@R         GSHIN   OPLDSL,AGXTMP,36+18,I . LEFT JUSTIFY NUMBER IN RECM
)@@G@@G PAIR@F@@@R         GFLOAT   OPDFM,AGXTMP,AGPTX1 . MULTIPLY,AND FREE AGCN
)@@G@@PTX1  @D@@@R         GSET    AGPTX1,AGXTMP .   SET NEW POINTER    @E@@@RCO
)@@G@@         GFIN .                    TURN OFF CODE MONSTER    @E@@@R      CP
)@@G@@   GOTO CGTSF2 .                     RETURN TO CODE   @F@@@R         GMOCQ
)@@G@@DE   'M' .             SET BIT PACKING FOR ICODER     @D@@@RCGTSF1   GLBCR
)@@G@@L .                    COME HERE IF IN REG@D@@@R         GINST   OPLA,AGCS
)@@G@@RA2,AGXR0,XU . LOAD EXPONENT  @D@@@R         GSHIN   OPLDSL,AGRA1,36+18,CT
)@@G@@I . SHIFT OVER    @C@@@R         GFLOAT   OPDFM,AGPTX1,AGRA1 . SCALE    CU
)@@G@@@#@@@R         GFIN .   @#@@@RCGTSF2   LABEL .  @ @@@R         USING SGDCV
)@@G@@SCT,X3 .    @A@@@R         SET   SGDEXP,ON,SGDID .    @]@@@R       JMP  CW
)@@G@@@ @@@R/.           INTEGER SCALING  @B@@@R.            A7 = SCALE    X1 CX
)@@G@@= A(AW)     @F@@@R.            GENERATES CODE TO MULTIPLY (A7>0) OR DIVICY
)@@G@@DE (A7<0)   @E@@@R.            THE (BIN FIX) AW POINTED TO BY X1 BY 2**QCZ
)@@G@@.     @[@@@R.     @#@@@RCGISFT LOCAL .    @D@@@R         IF      A7,EQ,0DA
)@@G@@,I THEN,JMP . NO SHIFT NEEDED @D@@@R       LOADM A8,A7      . Q<-ABS(Q) DB
)@@G@@ (LEAVE A7 ALONE) @G@@@R       IF  A8,LT,KSFTMX+1,I  THEN,CGI003     . IDC
)@@G@@TS A LEGAL SHIFT COUNT  @E@@@R       LOAD  A8,KSFTMX,I . MAKE IT MAXIMUMDD
)@@G@@ LEGAL SHIFT COUNT@]@@@RCGI003 LABEL@C@@@R       STORE A8,AGX0OF  . FOR DE
)@@G@@IMMEDIATE SHIFT   @C@@@R       IF  A7,GE,0,I  THEN,CGI001 . -> MULTIPLY DF
)@@G@@@C@@@R       LOADA A3,CGI005  . ADDR OF DIVISION CODE @^@@@R       GOTO DG
)@@G@@ CGI002     @]@@@RCGI001 LABEL@H@T@R         IF      OOPTD,OFF,DGOPT3 THDH
)@@G@@EN,CGI008 . ->NO OVERFLOW CHECK NEEDED    @G@@@T         IF      DCONOV,DI
)@@G@@OFF,DCGONF  THEN,CGI008 . =>OVERFLOW DISABLED   @E@@@R         LOAD    ADJ
)@@G@@3,35,I .        SET UP FOR THE LSC INST   @E@@@R         SUB     A3,SGDPDK
)@@G@@RE,X2 .    SUBTRACT OFF THE PRE     @C@@@R         ADD     A3,A8 .      DL
)@@G@@     ADD THE SCALE@E@@@R         LOADXI  A3,AGXR0+FH1 .    GET ADRESS WODM
)@@G@@RD SETUP    @F@@@R         STORE   A3,AGXTMP .       SET SHIFT COUNT INTDN
)@@G@@O TEMP AW   @F@@@R         LOADA   A3,CGI009 .       SET ADRESS OF 'CHECDO
)@@G@@K' CODE     @B@@@R         GOTO    CGI002 .          ->MERGE@B@@@RCGI008DP
)@@G@@   LABEL . COME HERE IF NOT CHECK   @C@@@R       LOADA A3,CGI004  . MULTDQ
)@@G@@IPLICATION CODE   @]@@@RCGI002 LABEL@^@@@R      CGENMR R,A3 .     @ @@@RDR
)@@G@@         USING SGDSCT,X3 .    @A@@@R         SET   SGDEXP,ON,SGDID .    DS
)@@G@@@]@@@R       JMP .@C@@@R       GMODE 'M'   . SET BIT FOR PACKING ICODE  DT
)@@G@@@C@@@RCGI009   GLBL .  CODE FOR 'CHECK' ON LEFT SHIFT @D@@@R         GIFDU
)@@G@@R    CGISF1,AGPTX1 .   IS IT IN A REG YET @D@@@R         GLOAD   AGPTX1,DV
)@@G@@1 .        NO -> PUT IT IN ONE@C@@@RCGISF1   GLBL .                    -DW
)@@G@@> MERGE HERE@G@@@R         GSHIN   OPLSC,AGRA2,AGPTX1 'NO' . COUNT THE NDX
)@@G@@UMBER OF SIGN BITS@G@@@R         GINST   OPTLE,AGRA3,AGXTMP,XU . TEST TODY
)@@G@@ SEE IF SHIFT COUNT OK  @F@@@R         GSUB    RTOVFL .          ->GREATDZ
)@@G@@ER,ERROR *************  @D@@@R         GGOTO   CGI006 .          ALREADYEA
)@@G@@ IN REG NOW @]@@@RCGI004 GLBL @C@@@R       GIFR  CGI006,AGPTX1   . IS ITEB
)@@G@@ IN A REG ? @B@@@R       GLOAD AGPTX1,1     . NO, PUT IT IN @]@@@RCGI006EC
)@@G@@ GLBL @C@@@R       GSHIN OPLSSC,AGPTX1,AGXR0  . LEFT SHIFT  @]@@@R      ED
)@@G@@ GFIN @]@@@RCGI005 GLBL @C@@@R       GIFR  CGI007,AGPTX1   . IS IT IN A EE
)@@G@@REG ? @B@@@R       GLOAD AGPTX1,1     . NO, PUT IT IN @]@@@RCGI007 GLBL EF
)@@G@@@C@@@R       GSHIN  OPSSA,AGPTX1,AGXR0  . RIGHT SHIFT @]@@@R       GFIN EG
)@@G@@@A@@@R/.           FLOAT TO FIX CONVERSION@]@@@RCGFIX  GLBL @E@@@R      EH
)@@G@@   GFLOAT  OPDFU,AGRA1,AGPTX1 . DFU IT,AND FREE AGPTX1@D@@@R         GGEEI
)@@G@@TGR  AGPTX1,1 .        GET A REGISTER     @C@@@R       GSUB  RTFXFL     EJ
)@@G@@. TO RUNTIME 'FIXER'    @E@@@R       GINST OPSA,AGRA1,AGPTX1    . PUT # EK
)@@G@@INTO TEMPORARY    @[@@@R. NOTE@[@@@R. NOTE@D@@@R. NOTE    ROUTINE RTFXFLEL
)@@G@@ RETURNS FIXED VALUE IN A1    @[@@@R. NOTE@[@@@R. NOTE@#@@@R       GFIN EM
)@@G@@ .    @[@@@R.     @A@@@R.            FIX TO FLOAT CONVERSION@]@@@RCGFLOTEN
)@@G@@ GLBL @#@@@R       GLIT  1    @C@@@R       LA,XU  A1,02074   . SETUP MAXEO
)@@G@@. EXPONENT  @C@@@R         GIFR    CGFLT1,AGPTX1 .   IN A REG YET?@G@@@REP
)@@G@@CGFLT2   GLBL .               EITHER IN EVEN REG,OR NOT IN REG AT ALL   EQ
)@@G@@@E@@@R       GINST OPLA,AGRA3,AGPTX1    . LOAD BIN FIX # INTO A3  @#@@@RER
)@@G@@       GLIT  2    @E@@@R       DSA   A3,36      . PROPAGATE SIGN FOR DOUES
)@@G@@BLE WORD    @B@@@R       DLCF  A1,A3      . DO CONVERSION   @]@@@RCGFLT3ET
)@@G@@ GLBL @ @@@R       GGETGR  AGPTX1,2 .     @A@@@R       GDBLE OPDS,AGRA2,EU
)@@G@@AGPTX1 .    @]@@@R       GFIN @^@@@R         GMODE   'M' .  @C@@@RCGFLT1EV
)@@G@@   GLBL .  COME HERE IF IN REG ALREADY    @E@@@R         GIFE    CGFLT2,EW
)@@G@@AGPTX1 .   IS IT IN A EVEN REG?     @F@@@R         GSHIN   OPDSA,AGPTX1,EX
)@@G@@36,I . ->ODD REG,SIGN FILL LOWER    @F@@@R         GFLOAT  OPDFP,AGRA1,AEY
)@@G@@GPTX1 . LOAD,AND CONVERT TO FLOATING@D@@@R         GGOTO   CGFLT3 .     EZ
)@@G@@     ->GO RESTORE NUM   @F@@@R         GLBL .                    DUMP EXFA
)@@G@@TRA CODE (IF ANY)!!!!   @]@@@R       CEND @]@@@R       END  ___ PROPER PFB
)@@G@@OSITION     @E@@@R      *[S@@@*SDFF*@C@@@%.   COPYRIGHT 1975 BY UNIVERSIFC
)@@G@@TY OF MARYLAND    @[@@@%.     @D@@@%.   QUESTIONS CONCERNING THIS SHOULDFD
)@@G@@ BE DIRECTED TO:  @[@@@%.     @ @@@%.        MARVIN V. ZELKOWITZ  @B@@@%FE
)@@G@@.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@%.        UNIVERSITY OF MFF
)@@G@@ARYLAND     @B@@@%.        COLLEGE PARK, MARYLAND 20742     @[@@@%.     FG
)@@G@@@G@@@%.        PERMISSION TO USE THESE LISTINGS AND THE COMPUTER PROGRAMFH
)@@G@@S THEY@E@@@%.   REPRESENT IS GRANTED UNDER THE FOLLOWING CONDITIONS:    FI
)@@G@@@[@@@%.     @G@@@%.        1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS FJ
)@@G@@REPRESENTED BY    @G@@@%.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OFK
)@@G@@R UNIVERSITY OF MARYLAND@E@@@%.   PL/1 COMPILER REMAINS ASSOCIATED WITH FL
)@@G@@THESE PROGRAMS.   @[@@@%.     @F@@@%.        2. MODIFICATIONS MAY BE MADFM
)@@G@@E TO THE LISTINGS PROVIDED:   @[@@@%.     @G@@@%.        (A) ANY RESULTIFN
)@@G@@NG PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   @G@@@%.        DESCRIBINFO
)@@G@@G SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PROGRAM @E@@@%.        IS FP
)@@G@@A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  @[@@@%.     @G@@@%.     FQ
)@@G@@   (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@%FR
)@@G@@.        OF ERRORS IN THE SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@%FS
)@@G@@.        A BRIEF DESCRIPTION OF THE FEATURE ADDED SHALL BE SUBMITTED    FT
)@@G@@@C@@@%.        TO THE UNIVERSITY OF MARYLAND, AND     @[@@@%.     @F@@@%FU
)@@G@@.        (C) NO PROGRAMS DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@%FV
)@@G@@.        WITHOUT WRITTEN APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  FW
)@@G@@@[@@@%.     @F@@@%.        (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTFX
)@@G@@ED TO OTHER @G@@@%.        LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEFY
)@@G@@ARLY INDICATE     @G@@@%.        WHETHER THE PROGRAMS ARE EXACT COPIES OFZ
)@@G@@F THE UNIVERSITY OF     @E@@@%.        MARYLAND PLUM COMPILER OR ARE MODGA
)@@G@@IFICATIONS TO IT. @[@@@%.     @G@@@%.        3. THESE CONDITIONS ONLY APGB
)@@G@@PLY TO THE PLUM COMPILER ITSELF,    @F@@@%.   AND ARE NOT MEANT TO APPLYGC
)@@G@@ TO ANY PROGRAM WRITTEN USING PLUM. @E@@@%.   THE PURPOSE OF THESE CONDIGD
)@@G@@TIONS IS TO ALLOW ANY USER TO @F@@@%.   EXPERIMENT WITH THE COMPILER AS GE
)@@G@@LONG AS THE RESULTING PRODUCT @G@@@%.   IS NOT SOLD AND AS LONG AS IT ISGF
)@@G@@ KNOWN THAT THE PRODUCT DEVELOPED   @#@@@%.   FROM PLUM.    @[@@@%.     GG
)@@G@@@[@@@%.     @[@@@%.     @[@@@%.     @[@@@%.     @[@@@%/.    @#@@@(      GH
)@@G@@   AXR$ .   @#@@@(         DCLRG    @#@@@(         UNLIST   @#@@@(@ADD,PGI
)@@G@@ PLTVDS     @#@@@(@ADD,P PLCGST     @#@@@(@ADD,P PLDSAW     @#@@@(      GJ
)@@G@@   LIST     @#@@@(         PLWORD   @#@@@(         PLAC     @#@@@(      GK
)@@G@@   PLCGD    @#@@@(         PLSD     @#@@@(         PLIG     @A@@@(. ** AGL
)@@G@@SSIGNMENT CODE GENERATOR**    @^@@@(AGRHSR   EQU   AGPTX3   @^@@@(AGRHSIGM
)@@G@@   EQU   AGPTX4   @D@@@(AGLHSR   EQU   1 .                 (SAME AS AGPTGN
)@@G@@A7)   @D@@@(AGLHSI   EQU   2 .                 (SAME AS AGPTA8)   @G@@@%GO
)@@G@@FLITRG   EQU     A10+1 .           POINT TO SAVE SLOT WHERE A5 GOES     GP
)@@G@@@^@@@(. **ASSIGNMENT DRIVER** @#@@@(XGAS  CSECT 3     @#@@@(DXGF350    SGQ
)@@G@@FW   0@A@@@(          +SD0ART+SGDEXP,SDDCBN,0,35@ @@@(XGASGN*  LABEL    GR
)@@G@@           .@ @@@(         GNTR  7             .@G@@@(         LOADA X5,GS
)@@G@@XGASTB .   [R5] X5 -> TABLE OF ICODE DISPLACEMENTS    @B@@@(         GOTGT
)@@G@@O  XGASM1              . MERGE@E@@@(XGATMR   LABEL . RETURN THROUGH HEREGU
)@@G@@ WHEN A TEMP ASSIGN     @D@@@(         USING   SGDSCT,X3 .       SET UP GV
)@@G@@THE USING   @F@@@(         IF  SGDEXP,OFF,SGDID  THEN,JMP . DON'T TRANSFGW
)@@G@@ER BACK     @[@@@(.     @F@@@(.        TRANSFER THE ''TEMPS'' ADDRESS WOGX
)@@G@@RDS BACK TO THE SOURCE  @A@@@(.        THEY WERE PUT INTO TEMPS   @[@@@(GY
)@@G@@.     @G@@@(         MOVE    SGDAID+1,DXGTMP+1,2 . MOVE  ADDRESS WORDS FGZ
)@@G@@OR  TEMPS   @D@@@(         JMP .                     RETURN TO CALLER   HA
)@@G@@@#@@@:XGATMP0  LOCAL .  @ @@@:         GOTO    XGATMP1 .    @#@@@(XGATMPHB
)@@G@@*   LABEL . @#@@@(         GNTR 7   @#@@@:XGATMP1  LABEL .  @D@@@(      HC
)@@G@@   USING   SGDSCT,X2 .       SET UP THE USING   @G@@@(         MOVE    DHD
)@@G@@XGTMP,SGDAID .   MOVE TYPE,CLASS INTO TEMP WORK AREA  @D@@@(         USIHE
)@@G@@NG   SGDSCT,X3 .       SET UP THE USING   @[@@@(.     @E@@@(.           HF
)@@G@@                        COULD BE UN NECESSARY   @[@@@(.     @G@@@(      HG
)@@G@@   MOVE    DXGTMP+1,SGDAID+1,2 . SAVE ADDRESSES IN CASE NO CHANGES@E@@@(HH
)@@G@@         LOADA X2,DXGTMP .         THE TARGET IS NOW DXGTMP @F@@@(      HI
)@@G@@   SET     SGDCHR,OFF,SGDID . CAN'T CHECK ON A TEMP ASSING  @F@@@(      HJ
)@@G@@   LOADA   X11,XGATMR .      POINT TO THE RETURN ROUTINE    @E@@@(      HK
)@@G@@   LOCAL .                   SET THE RETURN ADDRESS   @G@@@(         LOAHL
)@@G@@DA X5,XGTPTB .         POINT TO THE TABLE OF TEMP ICODES    @#@@@(XGASM1HM
)@@G@@   LABEL .  @G@@@(        SET IGCHEK++IGARRY++IGSTVR++IGCSZE,OFF,DGFLGZ HN
)@@G@@. CLEAR ICODE FLAG@C@@@(         LOADA  X11,XGASND         . SET RETURN HO
)@@G@@@D@@@(         LOAD  A3,SGDID,X2         . GET TARGET TYPE  @E@@@(      HP
)@@G@@   AND,U A3,15               . SAVE ONLY TYPE FIELD   @^@@@(         LOAHQ
)@@G@@D X1,A4     @D@@@(         LOAD  X1,XGTPTB+FH1,X1 . GET ROUTINE OFFSET  HR
)@@G@@@D@@@(         GOTO  0,X1           . GET PROPER ROUTINE    @#@@@(XGAS  HS
)@@G@@    CSECT 3 @E@@@(. * H2 IS TABLE OF I-CODE OFFSETS FOR TEMPORARY ASSIGNHT
)@@G@@MENTS @#@@@(XGTPTB   LABEL .  @A@%@(FILL(1)  SAC   XGASND,0      . 0    HU
)@@G@@@B@@@%FILL(1)  SAC   XGASND,000000           . 0@F@@@(FILL(1)  SAC   XGAHV
)@@G@@RAS,XGTPRF-XGTPTB    . 1  ARITHMATIC ASSIGNMENT @B@@@(FILL(1)  SAC   XGAHW
)@@G@@SND,XGTPTB-XGTPCF    . 2@G@@@(FILL(1)  SAC   XGSTGA,XGTPRX-XGTPTB    . 3HX
)@@G@@  'STRING' P.V. ASSIGNMENT    @F@@@(FILL(1)  SAC   XGSTAS,XGTPTB-XGTPCX HY
)@@G@@   . 4  STRING ASSIGNMENT     @E@@@(FILL(1)  SAC   XGLABA,XGTPLB-XGTPTB HZ
)@@G@@   . 5  LABEL ASSIGNMENT@B@@@(FILL(1)  SAC   XGASND,XGTPLV-XGTPTB    . 6IA
)@@G@@@G@%@(FILL(1)  SAC   XGPTRA,XGSTA1-XGTPTB .  . 7  POINTER ASSIGNMENT,CHAIB
)@@G@@R=XXXX@G@@@%FILL(1)  SAC   XGPTRA,XGSTA1-XGTPTB    . 7  POINTER ASSIGNMEIC
)@@G@@NT,CHAR=XXXX@G@@@(FILL(1)  SAC   XGUSPA,XGSTA2-XGTPTB    . 8 'UNSPEC' P.ID
)@@G@@V. ASSIGN,BIT=CHAR@B@@@(FILL(1)  SAC   XGASND,XGSTA3-XGTPTB    . 9@E@@@(IE
)@@G@@. * H2 IS TABLE OF I-CODE OFFSETS FOR NORMAL ASSIGNMENT     @#@@@(XGASTBIF
)@@G@@   LABEL .  @C@%@(FILL(1)  SAC   XGASND,0                . 10     @C@@@%IG
)@@G@@FILL(1)  SAC   XGASND,000000           . 10     @C@%@(FILL(1)  SAC   XGAIH
)@@G@@SND,XGASRF-XGASTB    . 11     @E@@@%FILL(1)  SAC   XGASND,XGASRF-XGASTB II
)@@G@@   . 11 AREA ASSIGNMENT @F@@@(FILL(1)  SAC   XGSBPV,XGASTB-XGASRF    . 1IJ
)@@G@@2 SUBSTR P. V. ASSIGNMNT@C@@@(FILL(1)  SAC   XGASND,XGARX1-XGASTB    . 1IK
)@@G@@3     @F@@@(FILL(1)  SAC   XGCLCK,XGASTB-XGARX1    . 14  CLOCK PSEUDO VAIL
)@@G@@R     @G@@@(FILL(1)  SAC   XGPNPV,XGASLB-XGASTB    . 15  PAGE NUMBER PSEIM
)@@G@@UDO VAR     @ @%@(FILL(1)  SAC   0,XGASLV-XGASTB@E@@@%FILL(1)  SAC   0,XIN
)@@G@@GASLV-XGASTB . OFFSET=OFFSET,LABEL=LABEL  @C@%@(FILL(1)  SAC   0,XGSTA1-IO
)@@G@@XGASTB .   CHAR = XXXX  @E@@@%FILL(1)  SAC   0,XGSTA1-XGASTB . OFFSET=POIP
)@@G@@INTER,CHAR = XXXX @C@%@(FILL(1)  SAC   0,XGSTA2-XGASTB .   BIT = CHAR   IQ
)@@G@@@E@@@%FILL(1)  SAC   0,XGSTA2-XGASTB . POINTER=OFFSET,BIT = CHAR  @C@%@(IR
)@@G@@FILL(1)  SAC   0,XGSTA3-XGASTB .   BIT = BIT    @G@@@%FILL(1)  SAC   XGPIS
)@@G@@TPT-XGASTB,XGSTA3-XGASTB . POINTER=POINTER,BIT = BIT  @#@@@(         CENIT
)@@G@@D     @D@@@(/XGARAS   LABEL .              ARITHEMATIC ARGUMENT   @ @@@(IU
)@@G@@XGASM0   LOCAL               .@E@%@(         IF      OOPTD,OFF,DGOPT3 THIV
)@@G@@EN,XGASM6 . IF D OPT OFF@H@?@%         IF      DCONFO+DCONSI,OFF,DCGONF IW
)@@G@@ THEN,XGASM6 . FOFL,SIZE DISABLED   @F@@@?         IF      DCONSI,OFF,DCIX
)@@G@@GONF  THEN,XGASM6 . SIZE DISABLED   @ @@@(         LOAD  A7,SGDPRE,X2   IY
)@@G@@@ @@@(         USING   SGDSCT,X3    @E@!@(         IF    A7,LT,SGDPRE THIZ
)@@G@@EN,XGASM6 . IF TARGET BIG ENUF@E@@@!         IF    A7,GE,SGDPRE THEN,XGAJA
)@@G@@SM6 . IF TARGET BIG ENUF@^@@@(         USING SGDSCT,X2@F@@@(         IF JB
)@@G@@   SDFXFL,ON,SGDCLS THEN,XGASM6 . IF TARGET FLOAT     @D@@@(         SETJC
)@@G@@     IGCSZE,ON,DGFLGZ . SET SIZE CHECK ON @D@@@(         LOAD  A9,SGDPREJD
)@@G@@,X2         . GET BIN PREC    @C@@@(         IF    SDDCBN,ON,SGDCLS THENJE
)@@G@@,XGASM6A .  @G@@@(         LSSC  A9,1 .              SET SCALE FOR INDEXJF
)@@G@@ IN KKPW10 TABLE  @E@@@(         GOTO    XGASM6 .          MERGE WITH FIJG
)@@G@@XED BIN     @D@@@(XGASM6A  LABEL .                   CHECK IF PRE = 35  JH
)@@G@@@D@@@(         IF A9,NE,35,I THEN,XGASM6 . CHECK IF PRE < 35@E@@@(      JI
)@@G@@   SET     IGCSZE,OFF,DGFLGZ . DON'T CHECK IF PRE = 35@#@@@(XGASM6   LABJJ
)@@G@@EL .  @F@@@(         CGCONV R,X2 R,X3          . CONVERT LHS TO TYPE OR JK
)@@G@@RHS   @F@@@(         STORE   A9,AGX0OF .       SET PRE FOR RUNTIME ROUTIJL
)@@G@@NE    @^@@@(         ADD   X4,X5 .  @F@%@(         LOAD X1,W1XH2+1,X4   JM
)@@G@@         . X1= OFFSET TO ASS ICODE  @G@@@%         LOAD X1,W1XH2+1,X4   JN
)@@G@@         . X1= OFFSET TO ASSIGNMENT ICODE @^@@@(         SUB   X4,X5 .  JO
)@@G@@@#@@@(XGASM2   LABEL .  @F@@@(         USING SGDSCT,X3     . IS RHS A COJP
)@@G@@NSTANT OR EXPRESSION?   @G@@@(         IF    SGDEXP,ON,SGDID THEN,XGAMLBJQ
)@@G@@ . DON'T EXIT IF EXPRESSION   @D@@@(         LOAD  A7,X5         . TEMP JR
)@@G@@ENTRY POINT USED? @I@@@(         IF    A7,EQ,+(IN 0,0,1,XGTPTB),I THEN,JJS
)@@G@@MP . EXIT IF TEMP ENTRY USED AND    @B@@@(XGAMLB   LABEL .              JT
)@@G@@MERGE POINT @ @@@(         LOAD  A6,X1         .@E@@@(         IF    A6,JU
)@@G@@GE,0,I THEN,XGASM3 . ->NOT COMPLEX IF POS @D@@@(         STORE X2,A10 . JV
)@@G@@          SAVE X2 POINTER     @D@@@(         STORE   X3,A9 .           SJW
)@@G@@AVE X3 POINTER    @F@@@(         STOREN A6,X1 .            POINT TO THE JX
)@@G@@RIGHT OFFSET NOW  @E@@@(         ADD   X1,X5 .             ADD BACK IN TJY
)@@G@@ABLE OFFSET @G@@@(         LOAD    X5,XGASTB+FXH2,X4 .     GET THE POINTJZ
)@@G@@ER TO THE ICODE   @E@@@(         LOADA   X5,XGASTB,X5 .    ADD IN THE TAKA
)@@G@@BLE OFFSET  @[@@@(.     @G@@@(.    REVERSE REAL AND COMPLEX POINTERS FORKB
)@@G@@ ASSINGMENT OF COMPLEX HALVES @[@@@(.     @F@@@(         LOADA A7,SGDIBSKC
)@@G@@,X2 .      POINT TO IMAGINARY AW OF LHS   @E@@@(         LOADA   A8,SGDRKD
)@@G@@BS,X2 .    POINT TO REAL AW OF LHS  @F@@@(         LOADA X4,SGDRBS,X3 . KE
)@@G@@     SET AW OF REAL PART OF RHS     @F@@@(         LOADA   X3,SGDIBS,X3 KF
)@@G@@.    SET AW OF IMAGINARY OF RHS     @^@@@(         GENMR R,X1     @G@@@(KG
)@@G@@.                                  FORCE REAL ASSIGNMENTS NOW WITH ZERO KH
)@@G@@@E@@@(         MOVE  X1,0,I        . X1 <- 0 (THEN X1 <- X1 + X5) @D@@@(KI
)@@G@@         LOAD  X2,A10           . RESET X2 POINTER    @D@@@(         LOAKJ
)@@G@@D    X3,A9 .           RESTORE RHS POINTER@#@@@(XGASM3   LABEL .  @^@@@(KK
)@@G@@         ADD   X1,X5    @#@@@(XGASM5   LABEL .  @^@@@(         USING SGDKL
)@@G@@SCT,X2@G@@@(         IF    SGDCHR,OFF,SGDID THEN,XGASM4 . -> LHS IS NOT KM
)@@G@@CHECKED     @D@@@(         LOAD  X5,X2               . SET PTR TO AW    KN
)@@G@@@E@@@(         SET   IGCHEK,ON,DGFLGZ        . SET FLAG FOR ICODER@D@@@(KO
)@@G@@         LSDP   X4,SGDRSD,X2       . X4GETS SD FOR LHS@^@@@(         USIKP
)@@G@@NG SDSECT,X4@E@@@(         IF    SDARRY,OFF,SDCLS2 THEN,XGASM4 . ARRAY RKQ
)@@G@@EF    @A@@@(         SET   IGARRY,ON,DGFLGZ .   @#@@@(XGASM4   LABEL .  KR
)@@G@@@D@@@(         LOADA A7,SGDRBS,X2        . LEFT REAL AW     @D@@@(      KS
)@@G@@   LOADA A8,SGDIBS,X2        . LEFT IMAG AW     @D@@@(         LOADA X4,KT
)@@G@@SGDIBS,X3 .   AW OF I PART OF RHS   @D@@@(         LOADA X3,SGDRBS,X3 . KU
)@@G@@AW OF REAL PART OF RHS  @^@@@(         GENMR R,X1 .   @^@@@(         LOAKV
)@@G@@D  X2,A10 . @#@@@(         JMP .    @C@@@(XGSTGA   LABEL .              KW
)@@G@@NOT YET INSTALLED @C@%@(XGPTRA   LABEL .              NOT YET INSTALLED KX
)@@G@@@#@@@(XGASND   LABEL .  @E@@@(         STORE   A10,AGX0OF .      RESTOREKY
)@@G@@ SHIFT INFORMATION@#@@@(         GRTN 7   @D@@@(XGLABA   LOCAL          KZ
)@@G@@           . LABEL ASSIGNMENT @F@%@(         LOADXM X1,5+W1XH2,X5       LA
)@@G@@     . OFFSET FOR LAB VAR ASS @G@@@%         LOADXM X1,5+W1XH2,X5       LB
)@@G@@     . OFFSET FOR LAB VAR ASSIGNMENT@ @@@(         USING SGDSCT,X3 .    LC
)@@G@@@F@%@(         IF    SDVRCN,OFF,SGDCLS THEN,XGASM2   . RHS LABEL VAR    LD
)@@G@@@F@@@%         IF    SDVRCN,ON,SGDCLS THEN,XGASM2   . RHS LABEL VAR     LE
)@@G@@@G@@@(         LOADXM X1,6+W1XH2,X5            . OFFSET FOR LABEL CONSTALF
)@@G@@NT    @^@@@(         GOTO  XGASM3   @C@@@%/.       POINTERS AND OFFSETS LG
)@@G@@ARE HANDLED HERE  @[@@@%.     @#@@@%XGPTRA   LOCAL .  @H@@@%         LOALH
)@@G@@D    A7,X5 .           SEE IF THIS SHOULD BE A TEMP ASSIGNMENT    @G@@@%LI
)@@G@@         IF A7,EQ,+(IN 0,0,1,XGASTB),I THEN,XGPTR1 . -> NORAL ASSIGNMENTLJ
)@@G@@@G@@@%         LOADA   X5,XGASTB .       SET TO LOOK LIKE NORMAL ASSIGNMLK
)@@G@@ENT   @G@@@%         GTMP    3 .               GET A 3 WORD TEMP FOR THELL
)@@G@@ ASSIGNMENT @E@@@%         STORE   A8,AGR10D .       MAKE AN ADDRESS WORLM
)@@G@@D     @ @@@%         USING   SGDSCT,X2 .  @E@@@%         LOAD    A7,AGXRLN
)@@G@@10 .       GET THE ADDRESS WORD     @E@@@%         STORE   A7,SGDRBS-FH1LO
)@@G@@ .   SET THE STACK ADDRESS    @E@@@%         ADD     A7,1,I .          SLP
)@@G@@ET TO CLEAR MIDDLE WORD @D@@@%         STORE   A7,AGXTMP .       SAVE FOLQ
)@@G@@R ICODE     @E@@@%         GEN .                     SET THE TEMP AS UNLLR
)@@G@@INKED!@E@@@%         GINST   OPSZ,AGRX0,AGXTMP 'NO' . SET AS UNLINKED!  LS
)@@G@@@ @@@%         ADD     A7,1,I .     @D@@@%         STORE   A7,AGXTMP .  LT
)@@G@@     POINT TO NEXT WORD @E@@@%         GEN .                     SET TEMLU
)@@G@@P POINTER FLAG    @B@@@%         GINST   OPSR,AGRR12,AGXTMP,H2 .  @F@@@%LV
)@@G@@XGPTR1   LABEL .                   HAVE NOW TAKEN CARE OF 'TEMPS' @E@@@%LW
)@@G@@         LOAD    X1,W1H1+6,X5 .    ASSUME OFFSET=OFFSET     @^@@@%      LX
)@@G@@   ON      AD$DR .@E@@@%         IF SDPTOF,ON,SGDCLS THEN,XGPTR2 . -> LHLY
)@@G@@S IS OFFSET @^@@@%         OFF     AD$DR .@F@@@%         LOAD    X1,W1H1LZ
)@@G@@+9,X5 .    NOT OFF=OFF,TRY POINTER=POINTER@C@@@%         USING   SGDSCT,MA
)@@G@@X3 .       POINT TO RHS @G@@@%         IF SDPTOF,OFF,SGDCLS THEN,XGASM3 MB
)@@G@@. -> PTR=PTR,GO JOIN OTHERS   @E@@@%         LOAD    X1,W1H1+8,X5 .    HMC
)@@G@@ERE POINTER=OFFSET!     @H@@@%.        GOTO    XGASM3 .          GO MERGMD
)@@G@@E! (NEXT LINE FORCES YOU THERE)     @^@@@%         ON      AD$DR .@E@@@%ME
)@@G@@XGPTR2   LABEL .                   HERE IF LHS IS OFFSET    @F@@@%      MF
)@@G@@   IF SDPTOF,ON,SGDCLS THEN,XGASM3 . -> RHS IS OFFSET TOO!  @E@@@%      MG
)@@G@@   LOAD    X1,W1H1+7,X5 .    HERE IT IS OFFSET=POINTER@C@@@%         GOTMH
)@@G@@O    XGASM3 .          GO AND MERGE @^@@@%         OFF     AD$DR .@C@@@(MI
)@@G@@/.       STRING ASSINGMENTS ARE HANDLED HERE    @[@@@(.     @[@@@(.     MJ
)@@G@@@E@%@(XGSTAS   LOCAL                     . OFFSET TO STRING ASS   @F@@@%MK
)@@G@@XGSTAS   LOCAL                     . OFFSET TO STRING ASSIGNMENT  @ @@@(ML
)@@G@@         LOAD  X1,7+W1XH2,X5 .@^@@@(         USING SGDSCT,X2@F@@@(      MM
)@@G@@   IF    SDCHBT,OFF,SGDCLS THEN,XGSTS1 . LHS IS CHAR STRING @ @@@(      MN
)@@G@@   LOAD  X1,9+W1XH2,X5 .@ @@@(         USING SGDSCT,X3 .    @E@@@(      MO
)@@G@@   IF    SDCHBT,ON,SGDCLS THEN,XGSTS1 . RHS IS BIT    @ @@@(         LOAMP
)@@G@@DXM X1,8+W1XH2,X5 @#@@@(XGSTS1   LABEL .  @E@@@(         LOAD    A7,X5 .MQ
)@@G@@           GET THE ADDR OF TABLE    @G@@@(         IF  A7,EQ,+(IN 0,0,1,MR
)@@G@@XGASTB),I THEN,XGASM3 . NORMAL ASSIGN?    @F@@@(         IF  SGDEXP,OFF,MS
)@@G@@SGDID  THEN,JMP . DON'T ASSIGN IF NOT EXP @E@@@(         LOAD    A7,AGSTMT
)@@G@@K .        SET LHS TO STRING STACK  @^@@@(         USING SGDSCT,X2@A@@@(MU
)@@G@@         STORE A7,SGDRBS-FH1,X2     @ @@@(         MOVE  SGDRDS,0,I     MV
)@@G@@@ @@@(         SET   SGDEXP,ON,SGDID@D@@@(         GOTO  XGASM3 .       MW
)@@G@@       FINSH ASSIGNMENT @ @@@(/.        CLOCK PSEUDO - VAR  @[@@@(.     MX
)@@G@@@[@@@(.     @#@@@(XGCLCK   LLOC .   @E@@@(         CGCONV DXGF350 R,X3 .MY
)@@G@@     CHANGE TO FIXED BIN 35,0 @C@@@(         LOADA   X4,SGDRDS,X3 .    PMZ
)@@G@@OINT TO RHS @#@@@(         GENM     @A@@@(         GINST OPLA,AGRA3,AGRHNA
)@@G@@SI .  @^@@@(         GSUB  BFCLPV   @#@@@(         GFIN     @D@@@(      NB
)@@G@@   GRTN    7 .               RETURN TO CALLER   @A@@@(/.       PAGE NUMBNC
)@@G@@ER PSEUDO VAR     @#@@@(XGPNPV   LLOC .   @C@@@(         STORE   X2,A9 .ND
)@@G@@           SAVE LHS     @F@@@(         CGCONV  DXGF350  R,X3 .   CONVERTNE
)@@G@@ NUMBER TO FIXED BIN    @C@@@(         LOAD    X2,A9 .           POINT TNF
)@@G@@O LHS @ @@@(         USING   SGDSCT,X2 .  @E@@@(         MOVE    AGX0OF,NG
)@@G@@SGDRSD .   SET TO POINT TO FILE SD  @D@@@(         LOADA   X4,SGDRDS,X3 NH
)@@G@@.    POINT TO RHS AW    @C@@@(         GENM .                    CALL CONI
)@@G@@DER   @D@@@(         GINST   OPLA,AGRA3,AGXR0,U . LOAD ADDR OF SD @D@@@(NJ
)@@G@@         GINST   OPLA,AGRA2,AGRHSI . GET NEW VALUE    @D@@@(         GSUNK
)@@G@@B    BFPNPV .          CALL SUBROUTINE    @#@@@(         GFIN .   @D@@@(NL
)@@G@@         GRTN    7 .                RETURN TO CALLER  @C@@@(/.       CODNM
)@@G@@E TO PREPARE FOR SUBSTR PSEUDO VAR  @[@@@(.     @[@@@(.     @#@@@(XGSBPVNN
)@@G@@   LOCAL .  @ @@@(         USING   SDSECT,X2 .  @E@@@(         LOAD    ANO
)@@G@@9,SGDISD .       GET FLAG ABOUT LENGTH    @E@@@(         IF A9,NE,0,I THNP
)@@G@@EN,XGSBP1 . FLAG IS ON IF NO LENGTH @E@@@(         LOADA   A7,AGRL1+3,X2NQ
)@@G@@ .   POINT TO WHERE LENGTH IS @#@@@(         GENM .   @C@@@(         GSHNR
)@@G@@IFT  AGRA3 .           POINT TO A4  @E@@@(         GINST   OPLA,AGRA3,AGNS
)@@G@@LHSR . GET LENGTH INTO A4     @D@@@(         GSHIFT  AGRA3 .           PNT
)@@G@@OINT BACK TO A3   @#@@@(         GFIN .   @#@@@(XGSBP1   LABEL .  @ @@@%NU
)@@G@@         USING   SGDSCT,X3 .  @F@@@%         IF      SGDEXP,ON,SGDID  THNV
)@@G@@EN,XGSBP3 . SEE IF RHS IS EXPR@C@@@%         LOAD    A9,SGDRSD,X2 .    GNW
)@@G@@ET SD OF LHS@G@@@%         IF      A9,NE,SGDRSD  THEN,XGSBP3 . STR ON LHNX
)@@G@@S<>STR ON RHS     @D@@@:         SET     SGDEXP,ON,SGDID . SAY RHS IS EXNY
)@@G@@PR    @D@@@:         STACK   X2 .              SAVE PTR TO LHS    @F@@@:NZ
)@@G@@.  FAKE A GASGN  'TEMP'  R,X3  'ATTR',R,X3 'COND','IFEXPR'  CALL  @F@@@:OA
)@@G@@.  SINCE A NORMAL GASGN HERE WOULD DESTROY THE DCGSV7 SAVE AREA   @^@@@:OB
)@@G@@.   WITH A SECOND GNTR 7@^@@@:         LOAD    X2,X3 .@ @@@:         LINOC
)@@G@@K    XGATMP0 .    @^@@@:         UNSTK   X2 .   @H@:@%         GASGN   'OD
)@@G@@TEMP'  R,X3  'ATTR',R,X3  'COND','IFEXPR' . PUT RHS IN TEMP @#@@@%XGSBP3OE
)@@G@@   LABEL .  @D@@@(         LOADA   X1,XGSBP2 .       POINT TO ICODE     OF
)@@G@@@E@@@(         GOTO    XGASM5 .          GO TO COMMON ROUTINE     @B@@@(OG
)@@G@@/. **UNSPED PSEUDO-VARIABEL ASSIGNMENT    @[@@@(.     @[@@@(.     @#@@@(OH
)@@G@@XGUSPA   LOCAL .  @ @@@%         USING   SGDSCT,X2 .  @E@@@%         IF OI
)@@G@@A3,EQ,A4 THEN,XGUSP1 . IS IT STRING OR ARITH ARG@E@@@%         LOAD    AOJ
)@@G@@4,SGDCLS .       ARITH, GET BIT COUNT     @E@@@%         OR      A4,GARBOK
)@@G@@G3 .       MAKE INTO LA,U A4,SIZE   @#@@@%         GEN .    @D@@@%      OL
)@@G@@   GLITRG  FLITRG .          GEN CONTENTS OF A5 @C@@@%XGUSP1   LABEL .  OM
)@@G@@                 MERGE HERE   @F@@@(         LOADA   X1,XGASUB .       PON
)@@G@@OINT TO ICODE FOR UNSPEC PV   @C@%@(         LOAD    A5,SGDRSD-FH1 .   GOO
)@@G@@ET JUMP INST@C@@@%         LOAD    A5,SGDIBS-FH1 .   GET JUMP INST@D@@@(OP
)@@G@@         GOTO    XGASM5 .          MERGE WITH NUMBERS @[@@@(.     @A@@@(OQ
)@@G@@.                HERE IS THE ICODE  @[@@@(.     @^@@@(         GMODE   'OR
)@@G@@M' .  @#@@@(XGASUB   GLBL .   @D@@@(         GBAL    XGLA10 .          LOS
)@@G@@OAD A2 AND A3     @D@%@(         GLITRG  A5 .              GENERATE PROPOT
)@@G@@ER LMJ@E@@@%         GLITRG  FLITRG .          GEN POPER LMJ (IN A5)    OU
)@@G@@@B@@@(         GGOTO   XGCKS1 .          FINISH @A@@@(/.       ICODES FOOV
)@@G@@R ASSIGNMENTS     @[@@@(.     @[@@@(.     @#@@@(         GMODE 'M'@#@@@(OW
)@@G@@XGTPCF   GLBL .   @G@@@(         GGETT AGLHSI,2 .          GET TEMPS FOROX
)@@G@@ REAL,THEN IMAGINARY    @G@@@(.                        REMEMBER THAT REAOY
)@@G@@L & IMAG POINTERS ARE SWITCHED@#@@@(XGTPRF   GLBL .   @F@@@(         GGEOZ
)@@G@@TT AGLHSR,2 .          PUT THE NUMBER INTO A TEMP     @#@@@(XGASRF   GLBPA
)@@G@@L .   @D@@@(         GIFR  XGARF2,AGRHSR       . IF RHS IN REG    @C@@@(PB
)@@G@@         GLOAD  AGRHSR,2           . PUT IN REG @#@@@(XGARF2   GLBL .   PC
)@@G@@@ @@@(         GBOFF XGCK1S,IGCSZE  @F@@@(         GSUB    RTOVCH .     PD
)@@G@@     GENERATE THE CALL TO SUBROUTINE@F@@@(         GINST   00,AGRX0,AGRHPE
)@@G@@SR  'NO' . FUNNY INST FOR SUBROUTINE@G@@@(         GAPPN   XGARF3 .     PF
)@@G@@     GO PUT THE PRECISION INTO THE CODE   @E@@@(XGCK1S   GLBL .         PG
)@@G@@           HERE TO FINISH ASSIGNMENT@B@@@(         GDBLE OPDS,AGRHSR,AGLPH
)@@G@@HSR 'NO'    @^@@@(         GGOTO XGCKS1   @#@@@(XGTPCX   GLBL .   @G@@@(PI
)@@G@@         GGETT AGLHSI,1 .          GET TEMPS FOR REAL,THEN IMAGINARY    PJ
)@@G@@@G@@@(.                        REMEMBER THAT REAL & IMAG POINTERS ARE SWPK
)@@G@@ITCHED@#@@@(XGTPRX   GLBL .   @F@@@(         GGETT AGLHSR,1 .          PPL
)@@G@@UT THE NUMBER INTO A TEMP     @#@@@(XGARX1   GLBL .   @ @@@(         GIFPM
)@@G@@R  XGARX2,AGRHSR  @^@@@(         GLOAD AGRHSR,1 @#@@@(XGARX2   GLBL .   PN
)@@G@@@ @@@(         GBOFF XGARX3,IGCSZE  @F@@@(         GINST   OPLA,AGRA3,AGPO
)@@G@@RHSR 'NO' . LOAD INTO SCRATCH REG   @E@@@(         GSHIN OPSSA,AGRA3,AGXPP
)@@G@@R0 . SHIFT BY THE PRESICISION @^@@@(         GLIT    1 .    @D@@@(      PQ
)@@G@@   TZ      A3 .              CHECK FOR OVERFLOW @E@@@(         GSUB    RPR
)@@G@@TSZCK .          GENERATE CALL TO SUB     @E@@@(XGARX3   GLBL .         PS
)@@G@@           MERGE HERE FROM ABOVE    @C@@@(         GINST   OPSA,AGRHSR,APT
)@@G@@GLHSR  'NO' .     @#@@@(XGCKS1   GLBL .   @ @@@(         GBOFF XGCKS2,IGPU
)@@G@@CHEK  @E@@@(         GBOFF XGCKS3,IGARRY                . NOT ARRAY     PV
)@@G@@@B@@@(           GINST OPLA,AGRA3,AGLHSR,U 'NO' @^@%@(         GSUB  EXCPW
)@@G@@HKA   @^@@@%         GSUB  ONCHKA   @^@@@(         GGOTO XGCKS4   @#@@@(PX
)@@G@@XGCKS3   GLBL .   @^@%@(         GSUB  EXCHK    @^@@@%         GSUB  ONCPY
)@@G@@HK    @#@@@(XGCKS4   GLBL .   @^@@@(         GAPPN XGCKS5   @#@@@(      PZ
)@@G@@   GLITRG A8@#@@@(XGCKS2   GLBL .   @^@@@(         GFREE AGRHSR   @#@@@(QA
)@@G@@         GFIN     @#@@@(         GLBL .   @#@@@(XGCKS5   LLOC     @A@@@(QB
)@@G@@         LOAD  A3,DCGSV4+AGLHSI     @ @@@(         LOAD A3,SGDRSD-2,A3  QC
)@@G@@@ @@@(         STORE A3,DCGSV4+2    @#@@@(         LJMP     @G@@@(XGARF3QD
)@@G@@   LLOC .                  PUT THE SCALE INTO THE CODE FOR RTOVCH @C@@@(QE
)@@G@@         LOAD    A6,AGX0OF .       GET THE SCALE@D@@@(         SUB     XQF
)@@G@@10,1,I .         BACK UP ONE LINE   @E@@@(         SA,Q1   A6,0,*X10 .  QG
)@@G@@     STORE IT IN THE CODE     @B@@@(         LJMP .                    RQH
)@@G@@ETURN @^@@@(         GMODE   'M' .  @#@@@(XGTPLB   GLBL .   @^@@@(      QI
)@@G@@   GBAL  XGGETS   @#@@@(XGASLB   GLBL .   @F@@@(         GINST OPLA,AGRAQJ
)@@G@@3,AGRHSI,U 'NO' .                  **??** @B@@@(         GINST OPSA,AGRAQK
)@@G@@3,AGLHSI 'NO'     @B@@@(         GINST OPLA,AGRA3,AGRHSR 'NO'     @B@@@(QL
)@@G@@         GINST OPSA,AGRA3,AGLHSR 'NO'     @^@@@(         GGOTO XGCKS1   QM
)@@G@@@#@@@(XGTPLV   GLBL .   @^@@@(         GBAL  XGGETS   @#@@@(XGASLV   GLBQN
)@@G@@L .   @A@@@(         GDBLE OPDL,AGRA3,AGRHSR    @A@@@(         GDBLE OPDQO
)@@G@@S,AGRA3,AGLHSR    @^@@@(         GGOTO XGCKS1   @#@@@(XGSTA1   GLBL .   QP
)@@G@@@^@@@(         GBAL  XGLA10   @E@@@(         GSUB  EXCCA .             AQQ
)@@G@@SSIGN INTO CHAR STRING  @^@@@(         GGOTO XGCKS1   @#@@@(XGSTA2   GLBQR
)@@G@@L .   @D@@@(         GBAL    XGLA10 .          SET UP POINTERS    @E@@@(QS
)@@G@@         GSUB    EXBCA .           ASSIGN CHAR INTO BIT     @D@@@(      QT
)@@G@@   GGOTO   XGCKS1 .          IS IT CHECKED?     @#@@@(XGSTA3   GLBL .   QU
)@@G@@@^@@@(         GBAL  XGLA10   @D@@@(         GSUB  EXBBA .             AQV
)@@G@@SSIGN BIT INTO BIT@^@@@(         GGOTO XGCKS1   @[@@@(.     @A@@@(.     QW
)@@G@@   ICODE FOR SUBSTR PSEUDO VAR@[@@@(.     @#@@@(XGSBP2   GLBL .   @F@@@(QX
)@@G@@         GBAL    XGLA10 .          LOAD REGS TO POINT TO STRINGS  @E@@@(QY
)@@G@@         GINST   OPLA,AGRA1,AGLHSI . GET CHAR TO START ON   @D@@@(      QZ
)@@G@@   GSUB    BFSBPV .          CALL PSEUDO SUBSTR @F@@@(         GLITRG  ARA
)@@G@@9 .              FLAG IF NEED TO COMPUTE LENGTH @E@@@(         GGOTO   XRB
)@@G@@GCKS1 .          SEE IF VAR IS CHECKED    @#@@@(XGGETS   GLBL .   @^@@@(RC
)@@G@@         GGETT AGLHSR,1 @^@@@(         GGETT AGLHSI,1 @#@@@(         GRTRD
)@@G@@RN    @#@@@(XGLA10   GLBL .   @B@@@(         GINST OPLA,AGRA2,AGLHSR,U 'RE
)@@G@@NO' . @B@@@(         GINST OPLA,AGRA3,AGRHSR,U 'NO' . @#@@@(         GRTRF
)@@G@@RN    @[@@@%.     @C@@@%.        CODE FOR POINTER AND OFFSET ASSIGNMENTSRG
)@@G@@@[@@@%.     @^@@@%         ON      AD$DR .@C@@@%XGOFOF   GLBL .         RH
)@@G@@           OFFSET=OFFSET@D@@@%         GBAL    XGPTR3 .          LOAD CORI
)@@G@@MMON REGS   @F@@@%         GSUB    OFFASG .          CALL OFFSET ASSIGNMRJ
)@@G@@ENT CODE    @E@@@%         GGOTO   XGCKS1 .          MERGE FOR CHECK CONRK
)@@G@@DITION@D@@@%XGOFPT   GLBL .                    OFFSET=POINTER     @E@@@%RL
)@@G@@         GBAL    XGPTR3 .          LOAD COMMON REGISTERS    @E@@@%      RM
)@@G@@   GSUB    PTTOOF .          CALL RUNTIME ROUTINE     @E@@@%         GGORN
)@@G@@TO   XGCKS1 .          MERGE FOR CHECK CONDITION@^@@@%         OFF     ARO
)@@G@@D$DR .@D@@@%XGPTPT   GLBL .                    POINTER=POINTER    @E@@@%RP
)@@G@@         GBAL    XGPTR3 .          LOAD COMMON REGISTERS    @F@@@%      RQ
)@@G@@   GSUB    PTRASG .          CALL POINTER ASSIGNMENT ROUTINE@E@@@%      RR
)@@G@@   GGOTO   XGCKS1 .          MERGE FOR CHECK CONDITION@^@@@%         ON RS
)@@G@@     AD$DR .@E@@@%XGPTOF   GLBL .                    HERE FOR POINTER=OFRT
)@@G@@FSET  @C@@@%         GBAL    XGLA10 .          GET A2,A3    @D@@@%      RU
)@@G@@   GINST   OPLA,AGRA1,AGRHSI . GET AREA ADDRESS @E@@@%         GSUB    ORV
)@@G@@FTOPT .          CALL RUNTIME ROUTINE     @E@@@%         GGOTO   XGCKS1 RW
)@@G@@.          MERGE FOR CHECK CONDITION@^@@@%         OFF     AD$DR .@E@@@%RX
)@@G@@XGPTR3   GLBL .                    HERE TO LOAD COMMON REGS @D@@@%      RY
)@@G@@   GINST   OPLA,AGRA3,AGLHSR,U 'NO' . GET TARGET@F@@@%         GINST   ORZ
)@@G@@PLA,AGRA2,AGRHSR,U 'NO' . GET SOURCE ADDRESS    @D@@@%         GRTRN .  SA
)@@G@@                 RETURN TO ABOVE    @#@@@(         GFIN     @#@@@(      SB
)@@G@@   CEND .   @]@@@(         END___  XGARF3 .     *[S@@@*SDFF*@C@@@'.   COSC
)@@G@@PYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@'.     @D@@@'.   QUESTIONSD
)@@G@@S CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@'.     @ @@@'.        MARSE
)@@G@@VIN V. ZELKOWITZ  @B@@@'.        DEPARTMENT OF COMPUTER SCIENCE   @A@@@'SF
)@@G@@.        UNIVERSITY OF MARYLAND     @B@@@'.        COLLEGE PARK, MARYLANSG
)@@G@@D 20742     @[@@@'.     @G@@@'.        PERMISSION TO USE THESE LISTINGS SH
)@@G@@AND THE COMPUTER PROGRAMS THEY@E@@@'.   REPRESENT IS GRANTED UNDER THE FSI
)@@G@@OLLOWING CONDITIONS:    @[@@@'.     @G@@@'.        1. UNLIMITED USE MAY SJ
)@@G@@BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@'.   THESE LISTINGS PROVISK
)@@G@@DED THAT THE NAME PLUM OR UNIVERSITY OF MARYLAND@E@@@'.   PL/1 COMPILER SL
)@@G@@REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@'.     @F@@@'.        2. SM
)@@G@@MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDED:   @[@@@'.     @G@@@'SN
)@@G@@.        (A) ANY RESULTING PROGRAM, OR REPORT, PAPER OR DOCUMENTATION   SO
)@@G@@@G@@@'.        DESCRIBING SUCH PROGRAM WILL CLEARLY INDICATE THAT THE PRSP
)@@G@@OGRAM @E@@@'.        IS A DIALECT OF PLUM OR IS DERIVED FROM PLUM, AND  SQ
)@@G@@@[@@@'.     @G@@@'.        (B) ALL SUCH MODIFICATIONS, OTHER THAN TRIVIASR
)@@G@@L CORRECTIONS     @F@@@'.        OF ERRORS IN THE SOURCE PROGRAMS, SHALLSS
)@@G@@ BE REPORTED AND  @G@@@'.        A BRIEF DESCRIPTION OF THE FEATURE ADDEST
)@@G@@D SHALL BE SUBMITTED    @C@@@'.        TO THE UNIVERSITY OF MARYLAND, ANSU
)@@G@@D     @[@@@'.     @F@@@'.        (C) NO PROGRAMS DERIVED FROM THESE LISTSV
)@@G@@INGS SHALL BE SOLD@G@@@'.        WITHOUT WRITTEN APPROVAL FROM THE UNIVESW
)@@G@@RSITY OF MARYLAND, AND  @[@@@'.     @F@@@'.        (D) COPIES OF THESE PSX
)@@G@@ROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@'.        LOCATIONS PROVIDED THSY
)@@G@@AT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@'.        WHETHER THE PROSZ
)@@G@@GRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     @E@@@'.        MARYLAND TA
)@@G@@PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@'.     @G@@@'.        3. TB
)@@G@@THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILER ITSELF,    @F@@@'.   ANTC
)@@G@@D ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN USING PLUM. @E@@@'.   THTD
)@@G@@E PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USER TO @F@@@'.   EXPERIMETE
)@@G@@NT WITH THE COMPILER AS LONG AS THE RESULTING PRODUCT @G@@@'.   IS NOT STF
)@@G@@OLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT DEVELOPED   @#@@@'.   FRTG
)@@G@@OM PLUM.    @[@@@'.     @[@@@'.     @[@@@'.     @[@@@'.     @[@@@'.     TH
)@@G@@@[@@@'/.    @]@@@9       AXR$ @]@@@9       DCLRG@]@@@9       REGS @]@@@9TI
)@@G@@       ALREG@ @@@9         UNLIST              .@#@@@9@ADD,P PLTVDS     TJ
)@@G@@@#@@@9@ADD,P PLCGST     @#@@@9@ADD,P PLDSAW     @]@@@9   CEND     @#@@@9TK
)@@G@@         LIST     @#@@@9       PLWORD     @]@@@9       PLCGD@]@@@9      TL
)@@G@@ PLSD @]@@@9       PLIG @A@@@9/GGKNST CSECT 3     . MY CONSTANTS  @C@@@9TM
)@@G@@K332S9 EQU  DCVDTB       . LOG 10/LOG 2  * 2**14@G@@@9KKSCL  EQU   14   TN
)@@G@@       . HOW FAR TO SHIFT CONVERSION CONSTANT (K332S9)@B@@@9KBXMXP EQU  TO
)@@G@@ 35    . MAX PREC FOR BIN FIX @B@@@9KDXMXP EQU   18    . MAX PREC FOR DETP
)@@G@@C FIX @C@@@9KBFMXP EQU   60    . MAX PREC FOR BIN FLOAT     @C@@@9KSFTMXTQ
)@@G@@ EQU   36    . SINGLE WORD MAX SHIFT COUNT@B@@@9KINMXQ EQU   0400    . ITR
)@@G@@NTERNAL MAX SCALE @C@@@9KBXMXS EQU    72    . MAX DOUBLE WORD SHIFT     TS
)@@G@@@^@@@9IGPLUS EQU   02000 .    @^@@@9IGZERO EQU   01000 . .  @I@@@9AGPTAATT
)@@G@@ EQU   4     . USED FOR 'AGPTA10'... HERE USED IN MULTIPLY/DIVIDE I-CODETU
)@@G@@.     @ @@@9GGNEMS SQ    0537  . TNE,U    @]@@@9GGNHMS SQ   @]@@@9GGNLMSTV
)@@G@@ SQ   @D@@@9GGSHFT  SAC   GGSHPR,GGSHMR . REAL MULT/DIVIDE ICODE  @D@@@9TW
)@@G@@FILL(1) SAC   GGSHPC,GGSHMC . COMPLEX MULT/DIV ICODE  @^@@@'GGJNOI   SFWTX
)@@G@@     0 .    @B@@@'         +0746400000003 .          JNO  3 @^@@@'GGSBFBTY
)@@G@@   SFW     0 .    @ @@@'         LINK    RTFOFB .     @^@@@9ERGG09   EQUTZ
)@@G@@   43 .     @^@@@'ERGG55   EQU     55 .   @^@@@9ERGG10   EQU   42 .     UA
)@@G@@@^@@@9ERGG08   EQU   41 .     @^@@@9ERGGMAXP EQU   38 .     @^@'@9ERGG06UB
)@@G@@   EQU   39 .     @^@@@'ERGG06   EQU   18 .     @^@'@9ERGG07   EQU   40 UC
)@@G@@.     @^@@@'ERGG07   EQU   19 .     @#@@@9EXERGG12 EQU  44 .@]@@@9      UD
)@@G@@ CEND @ @@@9/.           ACTION TABLE     @#@@@9XGACTB CSECT 3 .  @#@@@9UE
)@@G@@XGBPLT* LABEL .   @ @@@9FILL(1) SAC   GGTARI,GGSADS . @ @@@9FILL(1) SAC UF
)@@G@@  GGADFR,GGADFC . @ @@@9FILL(1) SAC   GGADBR,GGADBC . @#@@@9XGBMNT* LABEUG
)@@G@@L .   @ @@@9FILL(1) SAC   GGTARI,GGSADS . @ @@@9FILL(1) SAC   GGSUFR,GGSUH
)@@G@@UFC . @ @@@9FILL(1) SAC   GGSUBR,GGSUBC . @#@@@9XGMLTB* LABEL .   @ @@@9UI
)@@G@@FILL(1) SAC   GGTARI,GGSMU .  @ @@@9FILL(1) SAC   GGMUFR,GGMUFC . @ @@@9UJ
)@@G@@FILL(1) SAC   GGMUBR,GGMUBC . @#@@@9XGDVTB* LABEL .   @ @@@9FILL(1) SAC UK
)@@G@@  GGTARI,GGSDV .  @ @@@9FILL(1) SAC   GGDVFR,GGMUFC . @ @@@9FILL(1) SAC UL
)@@G@@  GGDVBR,GGMUBC . @#@@@9XGUPLT* LABEL .   @ @@@9FILL(1) SAC   GGTNOP,GGSUM
)@@G@@NOP . @^@@@9FILL(1) SAC   GGUPLS,0 .@#@@@9XGUMNT* LABEL .   @ @@@9FILL(1UN
)@@G@@) SAC   GGTNEG,GGSNOP . @^@@@9FILL(1) SAC   GGUPLS,0 .@#@@@9XGEXPN* LABEUO
)@@G@@L .   @ @@@9FILL(1) SAC   GGTNOP,GGSEPN . @^@@@9FILL(1) SAC   GGEXPN,0 .UP
)@@G@@@#@@@9XGBADD* LABEL .   @ @@@9FILL(1) SAC   GGTAMD,GGSADD . @ @@@9FILL(1UQ
)@@G@@) SAC   GGADFR,GGADFC . @ @@@9FILL(1) SAC   GGADBR,GGADBC . @#@@@9XGBMULUR
)@@G@@* LABEL .   @ @@@9FILL(1) SAC   GGTAMD,GGSMUL . @ @@@9FILL(1) SAC   GGMUUS
)@@G@@FR,GGMUFC . @ @@@9FILL(1) SAC   GGMUBR,GGMUBC . @#@@@9XGBDIV* LABEL .   UT
)@@G@@@ @@@9FILL(1) SAC   GGTAMD,GGSDIV . @ @@@9FILL(1) SAC   GGDVFR,GGMUFC . UU
)@@G@@@ @@@9FILL(1) SAC   GGDVBR,GGMUBC . @#@@@9XGBSUB*  LABEL .  @ @@@9FILL(1UV
)@@G@@)  SAC   GGTAMD,GGSADD .@ @@@9FILL(1)  SAC   GGSUFR,GGSUFC .@ @@@9FILL(1UW
)@@G@@)   SAC  GGSUBR,GGSUBC .@#@@@'XGRPTR*  LABEL .  @A@@@'FILL(1)  SAC    GGUX
)@@G@@TNOP,GGRPTR .     @ @@@'FILL(1)  SAC     PTRNOP,0     @F@@@9XGMK2A   SFWUY
)@@G@@   0 .                 TARGETTING FOR HBND, HDIM, DIM @D@@@9         +SDUZ
)@@G@@0ART,SDDCBN,0,17 .   FIXED BINARY(17,0)   @#@@@9         CEND .   @D@@@9VA
)@@G@@/.           TARGETING FOR ARITHMETIC OPS (+,-,*,/)   @#@@@9GGTARI* LABEVB
)@@G@@L .   @D@@@9       USING SGDSCT,X7 . AS USUAL, X7 -> TOP OF STACK @#@@@9VC
)@@G@@       GNTR  2    @[@@@9.     @[@@@9.     @D@@@9.        I DON'T THINK TVD
)@@G@@HIS IS NECESSARY PRM 3/21/74  @[@@@9.     @D@@@9.       SET   IGITER,OFFVE
)@@G@@,DGFLGZ    . NO ITERATION     @[@@@9.     @[@@@9.     @#@@@9GGTAR2* LABEVF
)@@G@@L .   @F@@@9         LOAD  A7,0,I .      CREATE ZERO FOR USE AS 0 SHIFT VG
)@@G@@COUNT @ @@@9       LOAD  F,SGDCLS+DCGSLT  @D@@@9       LOR   F,SGDCLS   VH
)@@G@@. TARG TYPE = TYPEL OR TYPER  @F@@@9         STORE F,DGGCLS .    THIS CAVI
)@@G@@LCULATES THE IMPLIED TYPE     @]@@@9GGTAR3 LABEL@E@@@9       SET   SDVRCVJ
)@@G@@N++SDCCNC,OFF      . CLEAR CONSTANT BIT   @F@@@9         STORE A7,DGGSCPVK
)@@G@@ .   SET P, Q (=0 TO GET IMPLIED P, Q)    @I@@@9       CGCONV  DGGSTK R,VL
)@@G@@X7    . CONVERT ARGR TO REQUIRED TYPE (X2 POINTSO DGGID)    @G@@@9      VM
)@@G@@   STORE A7,DGGSCP .   IN TARGET SET P,Q=0 TO GET IMPLIED P,Q     @C@@@9VN
)@@G@@       LOADA X3,SGDAID+DCGSLT . POINT TO OP2    @E@@@9       CGCONV  R,XVO
)@@G@@2  R,X3    . CONVERT ARGL TO REQUIRED TYPE@F@'@9       MOVE  DCGSV2+1,0,VP
)@@G@@I    . CLEAR FUTURE SAVE AREA IN A7 [R0]  @E@@@'       MOVE  DCGSV2+1,0,VQ
)@@G@@I    . CLEAR FUTURE SAVE AREA IN A7 @G@@@9       STORE F,DCGSV2+5   . TAVR
)@@G@@RGET CLASS SET FOR RETURN IN F-REGISTER   @A@@@9       GOTO  GGTRET     VS
)@@G@@. RETURN    @I@@@9 . ---------------------------------------------------VT
)@@G@@--------------------------    @E@@@9 . *** TARGETING FOR 'ADD', 'MULTIPLVU
)@@G@@Y', AND 'DIVIDE' ****   @I@@@9 . ---------------------------------------VV
)@@G@@--------------------------------------    @#@@@9GGTAMD   LABEL .  @#@@@9VW
)@@G@@         GNTR  2 .@ @@@9         USING SGDSCT,X7 .    @H@@@9         LOAVX
)@@G@@D  F,SGDCLS+2*DCGSLT .     PREPARE TO CONVERT TO HIGHEST TYPE     @D@@@9VY
)@@G@@         MOVE  DGGSCL,0,I .   INITIAL SCALE IS ZERO   @C@@@9         LOAVZ
)@@G@@D  A2,60,I .     ASSUME FLOAT CLASS @A@@@9         LOAD  A3,DXGNAR .   3WA
)@@G@@ ARGS?@F@'@9         IF    A3,EQ,3*DCGSLT,I .      -. IF 3 ARGUMENTS, FLWB
)@@G@@OAT   @G@@@'         IF    A3,EQ,3*DCGSLT,I THEN,GGTMD1 . IF 3 ARGUMENTSWC
)@@G@@, FLOAT     @B@@@9         LOAD  A2,35,I .     FIXED CLASS  @I@@@9      WD
)@@G@@   AND,Q2 F,3*DCGSLT,X7 .        'OR' CLASS OF LEFT(1ST) ARG OF 4   ****WE
)@@G@@**    @D@@@9         LINK  GTPR3A .      ENSURE CLASS IS FIXED    @F@'@9WF
)@@G@@         LINK  GTEVCN .      A9[R1]<-VALUE OF Q (SCALE DESIRED)   @E@@@'WG
)@@G@@         LINK  GTEVCN .      A9<-VALUE OF Q (SCALE DESIRED) @C@@@9      WH
)@@G@@   LOAD  A10,A9 .      PREPARE FOR GGSSTQ @C@@@9         LOADA X1,DGGSTKWI
)@@G@@ .   POINT TO TARGET    @E@@@9         LINK  GGSSTQ .       STORE QT CHEWJ
)@@G@@CKING ITS SIZE    @^@@@9         GOTO  GGTMD2 . @#@@@9GGTMD1   LABEL .  WK
)@@G@@@H@@@9         AND,Q2 F,DCGSLT,X7 . 'OR' CLASS OF MIDDLE (2ND) ARG OF 3 WL
)@@G@@*******     @D@@@9         LINK  GTPR2A .      ENSURE CLASS IS FLOAT    WM
)@@G@@@F@'@9GGTMD2   LABEL .             ERGE AFTER (P[,Q]) ARGS ARE POPPED   WN
)@@G@@@F@@@'GGTMD2   LABEL .             MERGE AFTER (P[,Q]) ARGS ARE POPPED  WO
)@@G@@@D@'@9         LINK  GTEVCN .      A9[R1] <- VALUE OF P     @C@@@'      WP
)@@G@@   LINK  GTEVCN .      A9 <- VALUE OF P   @ @'@9         STORE A9,DGGPREWQ
)@@G@@ .    @E@@@'         STORE A9,DGGPRE .         SAVE FOR LATER (STAGING) WR
)@@G@@@D@@@'         LOAD    A7,35,I .         ASSUME FIXED BIN   @D@'@9      WS
)@@G@@   IF    SDDCBN,ON THEN,GGTMD5 . -> IF BINARY   @D@@@'         IF    SDDWT
)@@G@@CBN,ON THEN,GGTMD5 . -> IF BINARY   @G@@@9         LOAD  A7,18,I .     DWU
)@@G@@ECIMAL 8FIXED OR FLOAT) MAX PRECISION     @F@@@9GGTMD5   LABEL .        WV
)@@G@@     MERGE ONCE MAX PRECISION IS KNOWN    @E@@@9         IF    A7,LT,A9 WW
)@@G@@THEN,GGTMD3 . -> MAXP< 8(A2) [0(R3)]@F@@@9         IF    A9,GE,1,I THEN,WX
)@@G@@GGTMD4 . -> PRECISION WITHIN RANGE  @#@@@9GGTMD3   LABEL .  @C@@@9      WY
)@@G@@   STORE A7,DGGPRE .   RESET TO MAX P     @A@@@9         EXERR ERGGMAXP WZ
)@@G@@LEVEL,1 .   @ @@@9 . 'SPECIFIED P IMPROPER'     @C@@@9GGTMD4   LABEL .  XA
)@@G@@           MERGE TO FINISH UP @G@@@9         GENM . REMOVE BIF STACK ENTXB
)@@G@@RY AND MOVE THE OTHER 2 ENTRIES     @B@@@9         GMOVE 3,2 .         CXC
)@@G@@OPY LEFT ARG@C@@@9         GMOVE 2,1 .         COPY RIGHT ARG     @^@@@9XD
)@@G@@         GFIN  'POP' .  @#@@@9         GRTN  2 .@I@@@9 . ---------------XE
)@@G@@--------------------------------------------------------------    @ @@@9XF
)@@G@@ . *** STAGING FOR 'ADD' ***  @I@@@9 . ---------------------------------XG
)@@G@@--------------------------------------------    @#@@@9GGSADD   LABEL .  XH
)@@G@@@#@@@9         GNTR  2 .@D@@@9         LOAD  A7,DGGSCP .    GET REQUESTEXI
)@@G@@D (Q,P)     @D@@@9         GOTO  GGTAR3 .      -> MERGE TO CONVERT ARGS XJ
)@@G@@@I@@@9 . ---------------------------------------------------------------XK
)@@G@@--------------    @B@@@9 . ** SUBROUTINE TO CHECK CLASS OF RESULT @I@@@9XL
)@@G@@ . ---------------------------------------------------------------------XM
)@@G@@--------    @B@@@9 . NOTE: FIXED ARG1'S MUST HAVE 3 ARGS    @B@@@9 .    XN
)@@G@@   FLOAT ARG1'S MUST HAVE 2 ARGS    @B@@@9 . CORRECTION:  NUMBER OF ARGUXO
)@@G@@MENT RULES  @E@@@9 .       SCALE OF RESULT DETERMINED BY NUMBER OF ARGUMXP
)@@G@@ENTS  @#@@@9GTPR2A   LLOC .   @E@@@9         LOAD  F,A6 .        RESTOREXQ
)@@G@@ CLASS TO F-REGISTER    @C@@@9GGTPR2   LOCAL .             SAVE RETURN AXR
)@@G@@DDRESS@B@@@9         IF    SDFXFL,ON THEN,GGTPR4 .    @A@@@9         EXEXS
)@@G@@RR ERGG06 LEVEL,2 .     @C@@@9 . 'RESULT OF PRECISION (X,P) SET TO FLOATXT
)@@G@@'     @D@@@9GGTPR0   LABEL .             MERGE TO MAKE CORRECTION @F@@@9XU
)@@G@@         XOR,U F,SDFXFL .    FLIP SCALE BIT            ********   @E@@@9XV
)@@G@@         LOAD  F,A6 .        RESOTRE CLASS TO F-REGISTER    @D@@@9      XW
)@@G@@   GOTO  GGTPR4 .      -> SET CLASS IN DGGCLS   @#@@@9GTPR3A   LLOC  .  XX
)@@G@@@E@@@9         LOAD  F,A6          . RESOTRE CLASS TO F-REGISTER  @C@@@9XY
)@@G@@GGTPR3   LOCAL .             SAVE RETURN ADDRESS@F@@@9         IF    SDFXZ
)@@G@@XFL,OFF THEN,GGTPR4 . -> IF FIXED, GOT 3 ARGS   @A@@@9         EXERR ERGYA
)@@G@@G07 LEVEL,2 .     @C@@@9 . 'RESULT OF PRECISION (X,P,Q) SET TO FIXED'   YB
)@@G@@@C@@@9         GOTO  GGTPR0 .      -> MAKE CORRECTION @#@@@9GGTPR4   LABYC
)@@G@@EL .  @C@@@9         STORE F,DGGCLS .    SET CLASS IN DGGCLS@E@@@9      YD
)@@G@@   STORE F,DCGSV2+5 .  SAVE F-REGISTER FOR RETURN     @C@@@9         JMPYE
)@@G@@   .             -> RETURN TO CALLER@I@@@9 . ---------------------------YF
)@@G@@--------------------------------------------------    @D@@@9 . SUBROUTINYG
)@@G@@E TO EVALUATE THE CONSTANT AT TOP OF STACK@I@@@9 . ---------------------YH
)@@G@@--------------------------------------------------------    @A@'@9 . VALYI
)@@G@@UE IS RETURNED IN A9 [R1]     @ @@@' . VALUE IS RETURNED IN A9    @B@'@9YJ
)@@G@@ . DESTROYED A10[R2], X1 [R1], AND A8     @ @@@' . DESTROYED A10, X1 , AYK
)@@G@@ND A8 @#@@@9 . ERROR MESSAGES:@B@@@9 .       ERGG08  ARGUMENT NOT A CONSYL
)@@G@@TANT  @C@@@9 .       ERGG09  CONSTANT > 32767 IN MAGNITUDE  @A@@@9 .    YM
)@@G@@   ERGG10  CONSTANT NOT REAL  @ @@@9         USING SGDSCT,X7 .    @C@@@9YN
)@@G@@GTEVCN   LOCAL .             SAVE RETURN ADDRESS@E@@@9         IF    SDVYO
)@@G@@RCN,ON,SGDCLS THEN,GTEVC8 . -> IF CONSTANT@A@@@9         EXERR ERGG08 LEYP
)@@G@@VEL,2 .     @C@@@9 . 'ARGUMENT SHOULD BE CONSTANT.  10 IS USED'   @F@@@9YQ
)@@G@@GTEVC6   LABEL .             MERGE TO RETURN REPLACEMENT VALUE    @B@@@9YR
)@@G@@         LOAD  A9,10,I .     GET VALUE    @D@@@9         GOTO  GTEVC7 . YS
)@@G@@     -> FREE, POP, AND RETURN @A@@@9GTEVC8   LABEL . CONTINUE CHECKING  YT
)@@G@@@E@@@9         IF    SDRLCX,OFF,SGDCLS THEN,GTEVC1 . -> IF REAL   @A@@@9YU
)@@G@@         EXERR ERGG10 LEVEL,2 .     @D@@@9 . 'ARGUMENT SHOULD BE REAL. IYV
)@@G@@MAGINARY PART IS USED'  @#@@@9         GEN .    @D@@@9         GSET  AGRYW
)@@G@@L1,AGIM1 . SET IMAG PART INTO REAL  @#@@@9GTEVC1   LABEL .  @E@@@9      YX
)@@G@@   LOAD  X1,SGDRSD .   GET POINTER TO SD FOR CONSTANT @G@@@9         LOAYY
)@@G@@D  X1,SDLCOF,X1 .          GET LOCATION OF CONSTANT VALUE   @F@@@'      YZ
)@@G@@   SUB   X1,2,I .      -> FIXED FORM OF DECIMAL CONSTANT    @F@@@9      ZA
)@@G@@   IF    SDDCBN,ON,SGDCLS THEN,GTEVC3 . -> IF FIXED BINARY  @ @@@'      ZB
)@@G@@   USING   WORD,X1 .    @F@'@9         ADD   X1,2,I .      -> FIXED FORMZC
)@@G@@ OF DECIMAL CONSTANT    @E@'@9         IF    SGDSCL,NZERO THEN,GTEVC2 . ZD
)@@G@@-> IF NON-INTEGER @E@@@'         IF    W1,NZERO THEN,GTEVC2 . -> IF NON-ZE
)@@G@@INTEGER     @E@'@9         LOADD A9,W1,X1 .    PRESUMED FIXED POINT VALUZF
)@@G@@E     @E@@@'         LOAD  A9,W1+1,X1 .    PRESUMED FIXED POINT VALUE   ZG
)@@G@@@F@'@9         IF    A9,ZERO THEN,GTEVC4 . IF INPUT REALLY SUCCEEDED    ZH
)@@G@@@E@@@'         GOTO    GTEVC4 .          CONTINUE TESTING OF SIZE @#@@@9ZI
)@@G@@GTEVC5   LABEL .  @A@@@9         EXERR ERGG09 LEVEL,2 .     @B@@@9 . 'ABZJ
)@@G@@S (ARGUMENT) > 32767, 10 IS USED'   @^@@@9         GOTO  GTEVC6 . @#@@@9ZK
)@@G@@GTEVC2   LABEL .  @D@'@9         DFU   A8,0,X1 .      GET CONSTANT UNPACZL
)@@G@@KED   @D@@@'         DFU   A8,2,X1 .      GET CONSTANT UNPACKED   @F@'@9ZM
)@@G@@         IF    A10,GE,02017,I THEN,GTEVC5 . -> CONSTANT TOO BIG   @F@@@'ZN
)@@G@@         IF    A8,GE,02017,I THEN,GTEVC5 . -> CONSTANT TOO BIG    @H@'@9ZO
)@@G@@         IF    A10,GE,02000,I THEN,GTEVC9 . -> CONSTANT NOT SMALL FRACTIZP
)@@G@@ON    @H@@@'         IF    A8,GE,02000,I THEN,GTEVC9 . -> CONSTANT NOT SZQ
)@@G@@MALL FRACTION     @E@'@9         MOVE  A9,0,I .      CONVERT SMALL FRACTZR
)@@G@@ION TO ZERO @E@@@'         LOAD  A9,0,I .      CONVERT SMALL FRACTION TOZS
)@@G@@ ZERO @^@@@9         GOTO  GTEVC4 . @#@@@9GTEVC9   LABEL .  @B@'@9      ZT
)@@G@@   STOREN A10,A3 .     SET TO SHIFT @B@@@'         STOREN A8,A3 .      SZU
)@@G@@ET TO SHIFT @D@'@9         SSA   A8,02074,A3 . RIGHT JUSTIFY CONSTANT   ZV
)@@G@@@D@@@'         SSA   A9,02074,A3 . RIGHT JUSTIFY CONSTANT   @E@@@'      ZW
)@@G@@   LOAD    A9,A10 .          GET INTO CORRECT REG     @^@@@9         GOTZX
)@@G@@O  GTEVC4 . @#@@@9GTEVC3   LABEL .  @C@'@9         LOAD  A9,W1,X1 .    GZY
)@@G@@ET FIXED VALUE    @C@@@'         LOAD  A9,W1+1,X1 .  GET FIXED VALUE    ZZ
)@@G@@@G@@@9         LOAD  A3,SGDSCL,X7 .          GET SCALE NOT LESS THEN ZERAA
)@@G@@O     @D@@@9         SSA   A9,0,A3 .     SCALE FIXED BINARY NUMBER@#@@@9AB
)@@G@@GTEVC4   LABEL .  @E@'@9         IF    A9,GE,32767 THEN,GTEVC5 . -> CONSAC
)@@G@@TANT TOO BIG@F@@@'         IF    A9,GE,32767,I THEN,GTEVC5 . -> CONSTANTAD
)@@G@@ TOO BIG    @F@@@9         IF    SGDSGN,OFF,SGDCLS THEN,GTEVC7 . -> SIGNAE
)@@G@@ IS POSITIVE@^@@@9         LOADN A9,A9 .  @#@@@9GTEVC7   LABEL .  @#@@@9AF
)@@G@@         GENM  .  @B@@@9         GFREE AGRL1 .       FREE TEMPS   @B@@@9AG
)@@G@@         GFIN  'POP' .        EXIT AND POP@A@@@9         JMP   .        AH
)@@G@@     RETURN @I@@@9 . ---------------------------------------------------AI
)@@G@@--------------------------    @C@@@9 . *** PERFORM TYPE CONVERSIONS IF NAJ
)@@G@@EEDED ***   @I@@@9 . ---------------------------------------------------AK
)@@G@@--------------------------    @H@@@9GMDSCV   LOCAL .             ENTRY FAL
)@@G@@ROM 'MULTIPLY' AND 'DIVIDE' BIF STAGING   @ @@@9         LOAD  A8,DGGSCPAM
)@@G@@ .    @F@'@9         MOVE  DGGSCP,0,I .  SET FOR INPLIED SCALE AND PRECIAN
)@@G@@SION  @F@@@'.        MOVE  DGGSCP,0,I .  SET FOR INPLIED SCALE AND PRECIAO
)@@G@@SION  @C@@@9         LOADA X2,DGGSTK .    USE TARGET CLASS  @D@@@9      AP
)@@G@@   LOADA X3,SGDAID .     CHANGE TOP STACK ITEM  @D@@@9         CGCONV R,AQ
)@@G@@X2 R,X3 .  PERFORM TYPE CONVERSION  @G@'@9         MOVE  DGGSCP,0,I    .AR
)@@G@@ RESET FOR IMPLIED SCALE AND PRECISION    @G@@@'.        MOVE  DGGSCP,0,AS
)@@G@@I    . RESET FOR IMPLIED SCALE AND PRECISION    @F@@@9         LOADA X3,AT
)@@G@@SGDAID+DCGSLT .       POINT TO SECOND STACK ITEM@D@@@9         CGCONV R,AU
)@@G@@X2 R,X3 .  PERFORM TYPE CONVERSION  @E@@@9         STORE X4,DCGSV2+9 . SAV
)@@G@@AVE X4 TYPE POINTER FOR RETURN@C@@@9         JMP   .             -> RETUAW
)@@G@@RN TO CALLER@ @@@9/.           NOOP TARGETTING  @#@@@9GGTNOP* LLOC .    AX
)@@G@@@B@@@9       LOAD  X4,0,I     . RETURN CODE=0   @B@@@9       MOVE  DGFLGAY
)@@G@@Z,0,I . IGEN FLGS=0     @]@@@9       LJMP @[@@@9.     @A@@@9.           AZ
)@@G@@ UNARY MINUS TARGETING  @#@@@9GGTNEG   LLOC .   @ @@@9         LOAD  A3,BA
)@@G@@SGDCLS .    @E@@@9         XOR,U A3,SGDSGN .                        ****BB
)@@G@@**    @ @@@9         STORE A4,SGDCLS .    @D@@@9         GOTO    GGTNOP BC
)@@G@@.          RETURN TO XGEN     @B@@@9/.     ------ STAGING ROUTINES -----BD
)@@G@@--    @B@@@9.            STAGING FOR + , -   (BINARY) @C@@@9 . ON ENTRY:BE
)@@G@@ DGGSCL, DGGPRE HOLD LEFT (P,Q)     @A@@@9 . RESULT (P,Q) DERIVED FROM SBF
)@@G@@TACK  @C@@@9 . ARGS SCALED ACCORDING TO DGGSCL AND SGDSCL   @D@@@9 . ORRBG
)@@G@@ED CLASS OF TARGET IS IN F-REGISTER ON ENTRY    @D@'@9 . USES REGISTERS BH
)@@G@@A7 [R0], A9 [R1], A10 [R2], A2 [R15]@A@@@' . USES REGISTERS A7 , A9 , A1BI
)@@G@@0 , A2@#@@@9GGSADS* LABEL .   @#@@@9       GNTR  2    @#@@@9GGSAD5*  LABBJ
)@@G@@EL .  @I@@@9       IF  SDFXFL,ON  THEN,GGSFLT . ->OPERATION IS FLOAT  (OBK
)@@G@@R'D CLASS IS IN FREG    @^@@@9       LOAD  A9,SGDSCL .@H@@@9       IF   BL
)@@G@@   A9,NE,DGGSCL  THEN,GGSAD4    . IF DIFFERENT, SCALE SMALLER ARG @C@@@9BM
)@@G@@       LOAD  A9,SGDPRE+DCGSLT .        PT <- PR @F@@@9       IF  A9,GE,SBN
)@@G@@GDPRE  THEN,GGSAD3 . -> PL < PR, THUS LEAVE PL  @D@@@9         LOAD  A9,BO
)@@G@@SGDPRE .   USE PR AS THE LARGER     @A@@@9         STORE A9,DGGPRE .   SBP
)@@G@@AVE PT@ @@@9GGSAD3   LABEL               .@D@@@9         ADD   A9,1,I . BQ
)@@G@@     ADD 1 TO RESULT PRECISION@D@@@9       LINK  GGSPMX     . FIND MAX PBR
)@@G@@REC FOR TYPE IN A7@D@@@9       IF  A7,GE,A9  THEN,GGSAD2  . ->OUR PREC IBS
)@@G@@S OKAY@#@@@9GGSAD0   LABEL .  @ @@@9       LOAD  A9,A7 . USE MAX  @#@@@9BT
)@@G@@GGSAD2 LABEL .    @E@@@9       STORE A9,SGDPRE+DCGSLT     . STORE RESULTBU
)@@G@@ANT PREC    @A@@@9       GOTO  GGSRET     . RETURN    @]@@@9GGSFLT LABELBV
)@@G@@@^@@@9       LOAD  A9,SGDPRE .@F@@@9       IF  A9,LT,SGDPRE+DCGSLT  THENBW
)@@G@@,GGSRET . -> PT ALREADY FOUND @F@@@9       STORE A9,SGDPRE+DCGSLT     . BX
)@@G@@I.E. PT <- MAX(PL,PR) = PR    @A@@@9       GOTO  GGSRET     . RETURN    BY
)@@G@@@#@@@9GGSAD4 LABEL .    @B@@@9         LOAD  A9,SGDPRE .   LOAD  P1     BZ
)@@G@@@B@@@9         LOAD  A2,SGDSCP .   COMPUTE Q1   @H@@@9         SSA   A2,CA
)@@G@@9 .        RIGHT JUSTIFY R-SCALE WITH SIGN EXTENSION *******@C@@@9      CB
)@@G@@   SUB   A9,A2         . COMPUTE P1 - Q1  @C@@@9         LOAD  A10,SGDPRCC
)@@G@@E+DCGSLT .     LOAD P2  @C@@@9         LOAD  A2,SGDSCP+DCGSLT . COMPUTE CD
)@@G@@Q2    @H@@@9         SSA   A2,9 .        RIGHT JUSTIFY L-SCALE WITH SIGNCE
)@@G@@ EXTENSION *******@C@@@9         SUB   A10,A2        . COMPUTE P2 - Q2  CF
)@@G@@@F@'@9         IF    A10,GE,A9 THEN,GGSAD6 . COMPUTE MAX (P1-Q1,P2-Q2)  CG
)@@G@@@F@@@'         IF    A10,LT,A9 THEN,GGSAD6 . COMPUTE MAX (P1-Q1,P2-Q2)  CH
)@@G@@@E@@@9         LOAD  A9,A10 .      MAX (P1-Q1,P2-Q2) = P2 - Q2    @G@@@9CI
)@@G@@GGSAD6 LABEL .               MERGE POINT WHEN MAX (P - Q) LOADED IN A9  CJ
)@@G@@@D@@@9       LINK  GGSSCL     . SCALE SMALL Q UP TO LARGE   @A@@@9      CK
)@@G@@  LOAD   A10,DGGSCP .  LOAD QT@D@@@9         STORE A10,SGDSCP+DCGSLT . SCL
)@@G@@ET QT IN STACK    @E@@@9         SSA   A10,9 .       COMPUTE QT         CM
)@@G@@********    @B@@@9       ADD   A9,A10 . MAX(PL-QL,PR-QR)+QT @C@@@9      CN
)@@G@@   GOTO  GGSAD3 .      -> SET PR,RETURN   @C@'@9 . ROUTINE SETS A7 [R0] CO
)@@G@@<- QR AND A10 [R2] <- QL@B@@@' . ROUTINE SETS A7  <- QR AND A10  <- QL  CP
)@@G@@@#@@@9GGSGQS   LLOC .   @A@@@9         LOAD  A7,SGDSCP .   QR     @G@@@9CQ
)@@G@@         SSA   A7,9 .        SHIFT RIGHT WITH SIGN EXTENSION    ******* CR
)@@G@@@B@@@9         LOAD  A10,SGDSCP+DCGSLT .     QL @H@@@9         SSA   A10CS
)@@G@@,9         . SHIFT RIGHT WITH SIGN EXTENSION     *******    @C@@@9      CT
)@@G@@   LJMP .              RETURN TO CALLER   @G@@@9 .           SCALING, OPCU
)@@G@@. WITH SMALLER Q TIMES BASE(2/10)**ABS(QL-QR)   @C@'@9 . USES REGISTERS CV
)@@G@@A7 [R0], A8 [R5], X3 [R3]     @B@@@' . USES REGISTERS A7 , A8 [R5], X3 [CW
)@@G@@R3]   @#@@@9GGSSCL* LOCAL .   @B@@@9       LOAD  A8,SGDSCP .    COMPUTE CX
)@@G@@QR    @E@@@9         SSA   A8,9 .                             ******    CY
)@@G@@@B@@@9         LOAD  A7,DGGSCP .   COMPUTE QL   @F@@@9         SSA   A7,CZ
)@@G@@9 .                                 *******     @G@@@9       IF  A7,GE,ADA
)@@G@@8  THEN,GGSSC1  . QL>QR, SCALE OP ALREADY IN DGGSCT   @C@@@9         STODB
)@@G@@RE A7,SGDSCL+DCGSLT . RESTORE Q2    @[@@@'.     @C@'@9         STORE A8,DC
)@@G@@DGGSCL .   SET Q-TARGET TO Q1 @C@@@'.        STORE A8,DGGSCL .   SET Q-TDD
)@@G@@ARGET TO Q1 @[@@@'.     @F@@@'         MOVE    DGGSCP,SGDSCP .   CONVERTDE
)@@G@@ LEFT TO LOOK LIKE RIGHT@F@@@9         LOADA X3,DCGSLT+SGDAID .      POIDF
)@@G@@NT TO LEFT STACK ITEM   @^@@@9         GOTO  GGSSC2 . @]@@@9GGSSC1 LABELDG
)@@G@@@D@@@9         LOAD  X3,W1U,X7 .   POINT TO RIGHT STACK ITEM@#@@@9GGSSC2DH
)@@G@@   LABEL .  @C@@@9       CGCONV  DGGSTK R,X3     . DO CONVERSION  @]@@@9DI
)@@G@@       JMP .@F@@@9.            PUT MAX PRECISION FOR TYPE (BX/DX --> 35/DJ
)@@G@@18) IN A7   @]@@@9GGSPMX* LLOC@B@@@9       LOAD  A7,KBXMXP,I  . ASSUME BDK
)@@G@@IN FIX@C@@@9       IF  SDDCBN,ON  THEN,LJMP   . GOOD ASSUMPT@B@@@9      DL
)@@G@@ LOAD  A7,KDXMXP,I     . ITS DEC FIX@A@@@9.            DOES NOTHING BUT DM
)@@G@@RETURN@#@@@9GGSNOP* LABEL .   @]@@@9       LJMP @D@'@9 . SET VALUE OF Q DN
)@@G@@TO MAX (VALUE IN A10[R2],MAX Q)     @C@@@' . SET VALUE OF Q TO MAX (VALUDO
)@@G@@E IN A10,MAX Q)   @H@@@9.            STORE QT, FIRST ASSURING ITS WITHINDP
)@@G@@ BOUNDS X1=WHERE TO STORE QT  @]@@@9GGSSTQ LLOC @ @@@9         STORE A10DQ
)@@G@@,SGDSCL,X1 .@E@@@9         IF    A10,LT,KINMXQ,I THEN,GGSSQ1 . -> QT < MDR
)@@G@@AX Q  @E@@@9         SUB   A10,KINMXQ,I .          BRING INTO RANGE     DS
)@@G@@@G@@@9         GOTO  GGSSQ2 .      -> PRINT ERROR MESSAGE FOR SCALE TO LDT
)@@G@@ARGE  @#@@@9GGSSQ1 LABEL .    @E@@@9         IF    A10,GE,1-KINMXQ,I THEDU
)@@G@@N,LJMP  . -> QT>MINQ    @F@@@9         ADD   A10,KINMXQ,I .          BRIDV
)@@G@@NG SCALE UP TO RANGE    @#@@@9GGSSQ2   LOCAL .  @G@@@9       EXERR EXERGDW
)@@G@@G12 LEVEL,1 .     'RESULT SCAL FACTOR EXCEEDS 35...'  @B@@@9         STODX
)@@G@@RE A10,SGDSCL,X1 . STORE QT   @]@@@9       JMP  @A@@@9/.           STAGIDY
)@@G@@NG FOR MULTIPLY   @#@@@9GGSMU  LABEL .    @E@'@9 . USES REGISTERS A7[R0]DZ
)@@G@@, A9[R1], A10[R2], A2[R15], A8[R5]  @B@@@' . USES REGISTERS A7, A9, A10,EA
)@@G@@ A2, A8[R5] @ @'@9 . X3[R3], X1[R1], X4[R4]     @^@@@' . X3[R3], X1, X4[EB
)@@G@@R4]   @#@@@9       GNTR  2    @G@@@9         SET IGZERO++IGPLUS++IGBNFX+EC
)@@G@@+IGRLCX++IGDCFX,OFF,DGFLGZ . CLEAR  @^@@@9       USING SGDSCT,X7 .@H@@@9ED
)@@G@@       IF  SDFXFL,ON  THEN,GGSMDM . ->RESULT IS FLOAT (CLASS IS IN F-REGEE
)@@G@@)     @A@@@9 . PT = PL + PR + 1  ,  QT = QL + QR@C@@@9         LINK  GGSEF
)@@G@@GQS .      A7 <- QR, A10 <- QL@C@@@9         ADD   A10,A7 .      A10 <- EG
)@@G@@QR + QL     @D@@@9       LOADA X1,SGDAID+DCGSLT     . WHERE TO STORE A10EH
)@@G@@@F@@@9       LINK  GGSSTQ     . STORE QT AND CHECK FOR SCALE OVERFLOW   EI
)@@G@@@^@@@9       LOAD  A9,SGDPRE .@ @@@9       ADD   A9,SGDPRE+DCGSLT @B@@@9EJ
)@@G@@       ADD   A9,1,I     . PT = PR+PL+1    @C@@@9       LINK  GGSPMX     EK
)@@G@@. A7 <- MAXPRE FOR TYPE @C@@@9       IF  A7,GE,A9  THEN,GGSMU1  . -> PT EL
)@@G@@IS OK @A@@@9       LOAD  A9,A7 . PT <- PMAX     @]@@@9GGSMU1 LABEL@E@@@9EM
)@@G@@       STORE A9,SGDPRE+DCGSLT     . SET PT INTO STACK ITEM  @B@@@9      EN
)@@G@@   MOVE  A10,0,I .     SHIFT <- 0   @]@@@9GGSMU3 LABEL@F@@@9       IF  SEO
)@@G@@DDCBN,OFF  THEN,GGSMU2     . ->ITS DECIMAL (FIXED)    @D@@@9       LOADAEP
)@@G@@ X3,RCFXBM  . MAY NEED THIS FOR COMPLEX   @D@@@9         SET     IGBNFX,EQ
)@@G@@ON,DGFLGZ . SAY BIN FIXED     @D@'@9         LOADN A10,A10 .     A10[R2]ER
)@@G@@ <- Q - QL - QR   @C@@@'         LOADN A10,A10 .     A10 <- Q - QL - QR ES
)@@G@@@]@@@9GGSMU4 LABEL@C@@@9         LOAD  A9,KBXMXS,I . MAX ALLOWED SHIFT  ET
)@@G@@@D@@@9       LINK  GGSFLM     . LIMIT A10 AND SAVE ITS SIGN @C@@@9GGSMU9EU
)@@G@@   LABEL . MERGE POINT FOR DIV BIN FIXED  @E@@@9       STORE A10,AGX0OF EV
)@@G@@ . SET UP BINARY SCALING (SHIFTING) @C@@@9       GOTO  GGSMDS     . DECIEW
)@@G@@DE REAL/COMPLEX   @]@@@9GGSMU2 LABEL@D@@@9       LOADA X3,RCFXDM  . MAY EX
)@@G@@NEED THIS FOR COMPLEX   @C@@@9       LINK  GGSTBS     . SET UP DECIMAL SEY
)@@G@@CALING@C@@@9       GOTO  GGSMDS     . DECIDE REAL/COMPLEX   @I@@@9 . ---EZ
)@@G@@------------------------------------------------------------------------FA
)@@G@@--    @B@@@9 . *** STAGING FOR 'MULTIPLY' BIF ***     @I@@@9 . ---------FB
)@@G@@--------------------------------------------------------------------    FC
)@@G@@@F@@@9 . I DIFFER FROM IBM CODE BY MAKING TYPE CONVERSIONS IF NECESSARY FD
)@@G@@@#@@@9GGSMUL   LABEL .  @F@@@9         GNTR  2 .           F-REGISTER ALFE
)@@G@@READY CONTAINS CLASS    @G@@@9         SET IGZERO++IGPLUS++IGBNFX++IGRLCFF
)@@G@@X++IGDCFX,OFF,DGFLGZ . CLEAR  @F@@@9         LINK  GMDSCV .      PERFORMFG
)@@G@@ TYPE CONVERSIONS IF NEEDED   @E@@@9         IF    SDFXFL,ON THEN,GGMDFCFH
)@@G@@ . -> CLASS IS FLOAT    @E@'@9         LINK  GGSGQS .       A7[R0] <- QRFI
)@@G@@, A10 [R2] <- QL  @D@@@'         LINK  GGSGQS .       A7 <- QR, A10  <- FJ
)@@G@@QL    @C@'@9         ADD   A10,A7 .      A10[R2] <- QL + QR @C@@@'      FK
)@@G@@   ADD   A10,A7 .      A10 <- QL + QR     @G@@@9         SSA   A8,9 .   FL
)@@G@@     A8 CONTAINS Q FROM GMDSCV          ******  @D@'@9         SUB   A10FM
)@@G@@,A8 .      A10 [R2] <- (QL + QR) - Q@D@@@'         SUB   A10,A8 .      AFN
)@@G@@10  <- (QL + QR) - Q    @E@@@9         MOVE  SGDSCP,DGGSCP .         (QLFO
)@@G@@,PL) <- (Q,P)     @D@@@9         GOTO  GGSMU3 . -> MERGE WITH '*' STAGINFP
)@@G@@G     @I@@@9 . ---------------------------------------------------------FQ
)@@G@@--------------------    @E@@@9 . ** COMPUTE DECIMAL FIXED SCALING CONSTAFR
)@@G@@NT ADDRESS **     @I@@@9 . ---------------------------------------------FS
)@@G@@--------------------------------    @]@@@9GGSTBS LOCAL@E@@@9       LOAD FT
)@@G@@ A9,KFLTSZ,I     . SIZE OF POWERS OF 10 TABLE   @C@'@9         LOADN A10FU
)@@G@@,A10 .     A10 [R2] <- -A10   @B@@@'         LOADN A10,A10 .     A10  <-FV
)@@G@@ -A10 @D@@@9       LINK  GGSFLM     . LIMIT A10 AND SAVE ITS SIGN @C@@@9FW
)@@G@@       SLB    A10,1 . TABLE IS IN DOUBLE WORDS  @H@@@9       ADD   A10,KFX
)@@G@@KPW10-2,I     . DISPL IN TABLE + STARTING ADDR OF TABLE     @A@@@9      FY
)@@G@@ STORE A10,AGX0OF  . INTO AW  @]@@@9       JMP  @#@@@9GGSFLM LLOC .     FZ
)@@G@@@F@'@9 . SAVE FLAGS IN DGFLGZ AS TO WHETHER THE SHIFT IN A10[R2] WAS    GA
)@@G@@@E@@@' . SAVE FLAGS IN DGFLGZ AS TO WHETHER THE SHIFT IN A10 WAS  @E@@@9GB
)@@G@@ . ZERO, POSITIVE, OR NEGATIVE.  SET A10 TO ABSOLUTE VALUE  @A@'@9 . USEGC
)@@G@@ A9[R1] TO LIMIT SHIFT SIZE.  @ @@@' . USE A9 TO LIMIT SHIFT SIZE.@F@@@9GD
)@@G@@ . THIS ROUTINE TAKES THE PLACE OF STORING THE CC OF IBM CODE     @C@@@9GE
)@@G@@ . FOR USE IN A COMPUTED GOTO IN THE ICODE.     @H@@@9         STORE A10GF
)@@G@@,DGGSCP .  SAVE SHIFT FOR SCALING IN COMPLEX SUBROUTINES    @B@@@9      GG
)@@G@@   SET   IGPLUS++IGZERO,ON,DGFLGZ . @E@@@9         IF    A10,NZERO THEN,GH
)@@G@@GGSFL1 . -> NON-ZERO SHIFT    @F@@@9         LOAD  A10,0,I .     -> INSUGI
)@@G@@RE SHIFT IS A POSITIVE ZERO   @B@@@9         LJMP .              -> RETUGJ
)@@G@@RN    @C@@@9GGSFL1   LABEL .             NON-ZERO SHIFT     @A@@@9      GK
)@@G@@   SET   IGZERO,OFF,DGFLGZ .  @E@@@9         IF    A10,GE,0,I THEN,GGSFLGL
)@@G@@2 . -> POSITIVE SHIFT   @E@'@9         SET   IGPLUS,OFF,DGFLGZ .     A10GM
)@@G@@[R2] WAS NEGATIVE @E@@@'         SET   IGPLUS,OFF,DGFLGZ .     A10 WAS NGN
)@@G@@EGATIVE     @D@@@9         LOADM A10,A10 .     SET A10 TO ABSOLUTE VALUEGO
)@@G@@@#@@@9GGSFL2   LABEL .  @E@@@9         IF    A9,GE,A10 THEN,LJMP . -> SHGP
)@@G@@IFT SIZE IS OK    @E@@@9         LOAD  A10,A9 .      USE MAXIMUM POSSIBLGQ
)@@G@@E VALUE     @B@@@9         LJMP .              -> RETURN    @I@@@9/ . --GR
)@@G@@------------------------------------------------------------------------GS
)@@G@@--    @A@@@9 . *** STAGING FOR 'DIVIDE' BIF *** @I@@@9 . ---------------GT
)@@G@@--------------------------------------------------------------    @#@@@9GU
)@@G@@GGSDIV   LABEL .  @D@@@9         GNTR  2 .        F-REGISTER CONTAINS CLGV
)@@G@@ASS   @G@@@9         SET IGZERO++IGPLUS++IGBNFX++IGRLCX++IGDCFX,OFF,DGFLGW
)@@G@@GZ . CLEAR  @F@@@9         LINK  GMDSCV .      PERFORM TYPE CONVERSIONS GX
)@@G@@IF NEEDED   @E@@@9         IF    SDFXFL,ON THEN,GGMDFC . -> CLASS IS FLOGY
)@@G@@AT    @G@'@9         LINK  GGSDVS .      A10[R2] <- QL - QR + PMAX, QL <GZ
)@@G@@- QL - QR   @F@@@'         LINK  GGSDVS .      A10 <- QL - QR + PMAX, QLHA
)@@G@@ <- QL - QR @C@@@9         STORE A8,DGGSCP .   (QL,PL) <- (Q,P)   @D@@@9HB
)@@G@@         SSA   A8,9 .        A8 [R4] <- Q FROM GMDSCV @^@@@9         SUBHC
)@@G@@   A10,A8 . @B@@@9         STORE A10,DGGPRE .  P <- FAKE P  @D@@@9      HD
)@@G@@   GOTO  GGSDV2 .      -> MERGE WITH '/' STAGING@I@@@9 . ---------------HE
)@@G@@--------------------------------------------------------------    @A@@@9HF
)@@G@@ . *** STAGING FOR DIVISION ***     @I@@@9 . ---------------------------HG
)@@G@@--------------------------------------------------    @#@@@9GGSDV  LABELHH
)@@G@@ .    @#@@@9       GNTR  2    @G@@@9         SET IGZERO++IGPLUS++IGBNFX+HI
)@@G@@+IGRLCX++IGDCFX,OFF,DGFLGZ . CLEAR  @H@@@9       IF  SDFXFL,ON  THEN,GGSHJ
)@@G@@MDM . ->RESULT IS FLOAT (CLASS IS IN F-REG)     @]@@@9GGSDV1 LABEL@E@@@9HK
)@@G@@       LINK  GGSDVS     . A7<-PMAX+QL-QR ,  QL <- QL-QR     @E@'@9      HL
)@@G@@ STORE A7,SGDPRE+DCGSLT     . PT <- PMAX = A7[R0]     @D@@@'       STOREHM
)@@G@@ A7,SGDPRE+DCGSLT     . PT <- PMAX = A7   @E@@@9       LOAD  X4,DGGPRE  HN
)@@G@@. PL (COMPUTED DURING TARGETTING)   @B@@@9       SUB   A10,X4      . MAXHO
)@@G@@P+QL-QR-PL  @D@@@9       LOADA X1,SGDAID+DCGSLT     . WHERE TO STORE    HP
)@@G@@@G@@@'         IF      A10,GE,0,I  THEN,GGSDV1A . POSITIVE SCALE FOR RESHQ
)@@G@@ULT   @G@@@'         EXERR   ERGG55  LEVEL,0 . WARN.  RIGHTMOST DIGITS MHR
)@@G@@AY BE LOST  @#@@@'GGSDV1A  LABEL .  @F@@@9       LINK  GGSSTQ     . STORHS
)@@G@@E QT AND CHECK FOR SCALE OVERFLOW   @C@'@9       LOAD  A10,X4          .HT
)@@G@@ A10[R2] <- P     @B@@@'       LOAD  A10,X4          . A10 <- P   @#@@@9HU
)@@G@@GGSDV2 LABEL   .  @E@@@9       IF  SDDCBN,ON  THEN,GGSDV3     . ->ITS BIHV
)@@G@@NARY (FIXED)@D@@@9       LOADA X3,RCFXDD  . MAY NEED THIS FOR COMPLEX   HW
)@@G@@@E@'@9         SUB   A10,A7 .      A10[R2] <- -(P-PL) (= -SHIFT)  @D@@@'HX
)@@G@@         SUB   A10,A7 .      A10 <- -(P-PL) (= -SHIFT)@C@@@9       LINK HY
)@@G@@ GGSTBS     . SET UP DECIMAL SCALING@E@@@9.            DETERMINE WHICH DHZ
)@@G@@IRECTION TO SCALE AND DOIT    @E@@@9         IF    IGZERO,ON,DGFLGZ THENIA
)@@G@@,GGSMDS . NOTHING TO GEN@B@@@9         LOADA X1,GGSHFT .   ASSUME REAL  IB
)@@G@@@F@@@9         ADD   X1,DCGSV2+9 . ADD IN REAL/COMPLEX FACTOR (0 OR 1)  IC
)@@G@@@^@@@9         USING WORD,X1 .@E@@@9         LOAD  X2,W1H1,X1 .  ASSUME ID
)@@G@@LEFT (+) SHIFT (MULT)   @F@@@9         IF    IGPLUS,ON,DGFLGZ THEN,GGSDVIE
)@@G@@6 . -> GOOD ASSUMPTION  @F@@@9         LOAD  X2,W1H2,X1 .  ACTUALLY RIGHIF
)@@G@@T (-) SHIFT (DIVIDE)    @#@@@9GGSDV6 LABEL .    @^@@@9       GENMR R,X2 IG
)@@G@@ .    @H@@@9         SET   IGPLUS++IGZERO,ON,DGFLGZ . SET FOR TRUNCATIONIH
)@@G@@ AFTER DIVISION   @C@@@9       GOTO  GGSMDS     . CHECK COMPLEX/REAL    II
)@@G@@@^@@@9         GMODE 'M' .    @]@@@9GGSHPC GLBL @G@@@9         GIFR  GGSIJ
)@@G@@PCA,AGIM2 .          SEE IF IMAG PART IS IN REGISTER  @E@@@9         GLOIK
)@@G@@AD AGIM2,2 .     IF NOT, PUT IT IN REGISTER     @C@@@9GGSPCA   GLBL . MEIL
)@@G@@RGE POINT WHEN IN REGISTER    @G@@@9       GFLOAT OPDFM,AGIM2,AGXR0 . LEIM
)@@G@@FT (+) DECIMAL FIXED SHIFT IMAG PART@]@@@9GGSHPR GLBL @F@@@9         GIFIN
)@@G@@R  GGSPRA,AGRL2 . SEE IF REAL PART IS IN REGISTER     @E@@@9         GLOIO
)@@G@@AD AGRL2,2 .     IF NOT, PUT IT IN REGISTER     @#@@@9GGSPRA   GLBL .   IP
)@@G@@@G@@@9       GFLOAT OPDFM,AGRL2,AGXR0 . LEFT (+) DECIMAL FIXED SHIFT REAIQ
)@@G@@L PART@F@@@9         GFIN  . -> SCALING DONE, READY TO DIVIDE FIXED DECIIR
)@@G@@MAL   @]@@@9GGSHMC GLBL @F@@@9         GIFR  GGSMCA,AGIM2 . SEE IF IMAG IS
)@@G@@PART IS IN REGISTER     @D@@@9         GLOAD AGIM2,2 . IF NOT, PUT IT INIT
)@@G@@ REGISTER   @D@@@9GGSMCA   GLBL . MERGE POINT WHEN IMAG PART IN REGISTERIU
)@@G@@@H@@@9       GFLOAT OPDFD,AGIM2,AGXR0 . RIGHT (-) DECIMAL FIXED SHIFT IMIV
)@@G@@AG PART     @]@@@9GGSHMR GLBL @G@@@9         GIFR  GGSMRA,AGRL2 .       IW
)@@G@@    SEE IF REAL PART IS IN REGISTER @E@@@9         GLOAD AGRL2,2 .      IX
)@@G@@IF NOT, PUT IT IN REGISTER    @G@@@9GGSMRA   GLBL .               MERGE IY
)@@G@@POINT WHEN REAL PART IS IN REGISTER @H@@@9       GFLOAT OPDFD,AGRL2,AGXRIZ
)@@G@@0 . RIGHT (-) DECIMAL FIXED SHIFT REAL PART     @F@@@9         GFIN  . -JA
)@@G@@> SCALING DONE,READY TO DIVIDE FIXED DECIMAL    @]@@@9GGSDV3 LABEL@D@@@9JB
)@@G@@       LOADA X3,RCFXBD  . MAY NEED THIS FOR COMPLEX   @D@@@9         SETJC
)@@G@@     IGBNFX,ON,DGFLGZ . SAY BIN FIXED     @G@@@9         STORE A10,DGGSCJD
)@@G@@P .  SAVE PRECISION FOR USE IN COMPLEX CASE     @E@@@9         SUB   A10JE
)@@G@@,A7 .      A10 = -(PMAX - PL) = -SHIFT    @F@@@9         SET   IGPLUS++IJF
)@@G@@GZERO,OFF,DGFLGZ . SIGNAL RIGHT (-) SHIFT @ @@@9         JN    A10,GGSDVJG
)@@G@@5 .   @E@@@9         IF A10,NZERO THEN,GGSDV4 . ->NOT ZERO,SET TO SCALE JH
)@@G@@@F@@@9         SET     IGPLUS++IGZERO,ON,DGFLGZ . TELL ICODE NO SCALEINGJI
)@@G@@@D@@@9         GOTO    GGSMU9 .          ->MERGE WITH MULT  @#@@@9GGSDV4JJ
)@@G@@   LABEL .  @I@@@9         ADD   A10,36,I . COMPUTE RIGHT JUSTIFICATION JK
)@@G@@AMOUNT FOR DIVISION WITH S    @E@@@9         GOTO  GGSDV7 .      -> CHECJL
)@@G@@K FOR SHIFT OVERFLOW    @#@@@9GGSDV5   LABEL .  @A@@@9         SET   IGPJM
)@@G@@LUS,ON,DGFLGZ .   @^@@@9         LOADM A10,A10 .@F@@@9GGSDV7   LABEL .  JN
)@@G@@           MERGE TO CHECK FOR MAXIMUM SHIFT     @B@@@9         IF    A10JO
)@@G@@,LT,72,I THEN,GGSMU9 .  @ @@@9         LOAD  A10,72,I .     @D@@@9      JP
)@@G@@   GOTO  GGSMU9 . -> MERGE WITH MULT PROCESSING @]@@@9GGSDVS LOCAL@E@'@9JQ
)@@G@@         LINK  GGSGQS .      A7[R0] <- QR  ,  A10[R2] <- QL @D@@@'      JR
)@@G@@   LINK  GGSGQS .      A7 <- QR  ,  A10 <- QL   @A@@@9         SUB   A10JS
)@@G@@,A7 .      QL - QR@C@@@9         STORE A10,SGDSCL+DCGSLT .      SET QL  JT
)@@G@@@C@@@9       LINK  GGSPMX     . A7 <- MAXPRE FOR TYPE @C@@@9       ADD  JU
)@@G@@ A10,A7      . A10 <- PMAX+QL-QR    @#@@@9       JMP     .  @G@@@9GGMDFCJV
)@@G@@   LABEL .             OP IS FLOAT 'MULTIPLY' OR 'DIVIDE' BIF     @E@@@9JW
)@@G@@         GOTO  GGSMDE .      -> CONTINUE FLOATING STAGING   @E@@@9.     JX
)@@G@@       MULT/DIV...COME HERE TO SEE IF YOU QUIT YET    @]@@@9GGSMDM LABELJY
)@@G@@@^@@@9       LOAD  A7,SGDPRE .@C@@@9       IF  A7,LT,SGDPRE+DCGSLT  THENJZ
)@@G@@,GGSMDE .   @E@@@9       STORE A7,SGDPRE+DCGSLT     . I.E. PT <- MAX(PL,KA
)@@G@@PR)   @#@@@9GGSMDE LABEL   .  @C@@@9       LOAD  X3,DXGARG  . FLOAT ROUTKB
)@@G@@INE OFFSET  @F@@@9         SET   IGZERO,ON,DGFLGZ .      SIGNAL FLOAT TOKC
)@@G@@ ICODE BY   @I@@@9         SET   IGPLUS,OFF,DGFLGZ . SETTING AN OVERFLOWKD
)@@G@@ SHIFT INDICATOR (CC*2=6)     @#@@@9GGSMDS LABEL .    @G@@@9       IF  SKE
)@@G@@DRLCX,OFF  THEN,GGSRET     . -> REAL, YOU'RE DONE  ELSE     @C@@@9.     KF
)@@G@@ DROP THROUGH TO HANDLE COMPLEX-ITIES     @H@@@9/.           ICODE TO GEKG
)@@G@@NERATE CALLING SEQUENC FOR OPERATORS IMPLEMENTED AS   @F@@@9.           KH
)@@G@@ SUBROUTINES.  THESE ARE COMPLEX * AND /, AND ALL **  @[@@@9.     @G@@@9KI
)@@G@@IGEXPN   EQU     040 .             FLAG TO SAY EXPONENTATION      ***** KJ
)@@G@@@[@@@9.     @[@@@9.     @#@@@9GGSCB1 LABEL .    @A@@@9       STORE X3,DXKK
)@@G@@GARG  . A(SUBR)   @G@@@9       GASGN  'TEMP'  R,X7  'ATTR',R,X7  'COND',KL
)@@G@@'IFREG' . ARGL IN TEMP  @D@@@9       LOADA X2,SGDAID+DCGSLT . POINT TO LKM
)@@G@@EDT ARG     @G@@@9       GASGN  'TEMP'  R,X2  'ATTR',R,X2  'COND','IFREGKN
)@@G@@' . ARGR IN TEMP  @C@@@9       SET   IGRLCX,ON,DGFLGZ     . ITS COMPLEX KO
)@@G@@@E@@@9       SET   IGEPNI++IGEXPN,OFF,DGFLGZ . NOT EXPONENTIATION @^@@@9KP
)@@G@@       GOTO  GGSCB4 .   @#@@@9GGSCB3 LABEL .    @E@@@9       STORE X3,DXKQ
)@@G@@GARG  . ADDR OF PARTICULAR RUNTIME CODE   @D@@@9         SET     IGEXPN,KR
)@@G@@ON,DGFLGZ . SAY IT IS EXPON   @ @@@9         USING SGDSCT,X7 .    @#@@@9KS
)@@G@@GGSCB4 LABEL .    @D@@@9         LOAD  A7,SGDSCP+DCGSLT .  GET SCALE ANDKT
)@@G@@ PRE  @F@@@9         STORE   A7,AGX0OF .       PUT IT WHERE IT CAN BE REKU
)@@G@@ACHED @#@@@9       GENM .     @C@@@9       GINST OPLA,AGRA1,AGRL2,U    .KV
)@@G@@ A(ARGL)    @B@@@9       GBOFF GGSCB2,IGRLCX   . -> ITS REAL@G@@@9      KW
)@@G@@ GFREE  AGIM2 .        FREE ANY TEMPS ASSOCIATE WITH IMAG PART    @E@@@9KX
)@@G@@GGSCB2 GLBL .                OBTAIN SPACE FOR THE RESULT    @C@@@9      KY
)@@G@@ GINST OPLA,AGRA2,AGRL1,U    . A(ARGR)    @C@@@9       GBOFF GGSCB7,IGRLKZ
)@@G@@CX   . -> ITS REAL, OR  @D@@@9       GBON  GGSCB7,IGEPNI   . -> ITS COMPLA
)@@G@@LEX**INT    @^@@@9       GFREE  AGIM1 .   @#@@@9GGSCB7 GLBL .     @E@@@9LB
)@@G@@         GBON    GGSCB6,IGEXPN .   IS THIS COMPLEX * OR / ? @E@@@9      LC
)@@G@@   GINST   OPLA,AGRA3,AGXR0,U . GET SCALE AND PRE     @#@@@9GGSCB6   GLBLD
)@@G@@L .   @^@@@9       GSUB  'BILTN' .  @D@@@9         GBON    GGSCB5,IGBNFXLE
)@@G@@ .   IS THIS BIN FIXED? @E@@@9         GGETGR  AGRL2,2 .         GET A RLF
)@@G@@EG FOR RESULT     @D@@@9         GDBLE   OPDL,AGRL2,AGRA3 . GET REAL PARLG
)@@G@@T     @C@@@9         GBOFF   GGSCB8,IGRLCX .   IS IT REAL?  @E@@@9      LH
)@@G@@   GGETGR  AGIM2,2 .         GET REGS FOR IMAG PART   @D@@@9         GDBLI
)@@G@@LE   OPDL,AGIM2,AGRA1 . GET IMAG PART     @E@@@9         GGOTO   GGSCB8 LJ
)@@G@@.                   GO FINISH UP    @D@@@9GGSCB5   GLBL .               LK
)@@G@@     IT IS BIN FIXED    @E@@@9         GGETGR  AGRL2,1 .         GET A RLL
)@@G@@EG FOR RESULT     @D@@@9         GINST   OPLA,AGRL2,AGRA3 . GET REAL PARLM
)@@G@@T     @D@@@9         GBOFF   GGSCB8,IGRLCX .   IS IT COMPLEX?     @E@@@9LN
)@@G@@         GGETGR  AGIM2,1 .         GET REG FOR IMAG PART    @D@@@9      LO
)@@G@@   GINST   OPLA,AGIM2,AGRA1 . GET IMAG PART     @C@@@9GGSCB8   GLBL .   LP
)@@G@@                 MERGE HERE   @C@@@9         GFIN .                    ELQ
)@@G@@ND OF ICODE @B@@@9         GOTO    GGSRET .          RETURN @B@@@9/.    LR
)@@G@@       STAGING FOR EXPONENTIATION   @[@@@9.     @[@@@9.     @#@@@9GGSEPNLS
)@@G@@ LABEL .    @D@@@9         GNTR    2 .               SAVE REGISTERS     LT
)@@G@@@G@@@9       SET   IGRLCX+IGEPNI,OFF,DGFLGZ  . ASSUME REAL A ND EXP NOT LU
)@@G@@INT   @D@@@9         MOVE    DGGSTK,0,I .      CLEAR THE WORKSPACE@E@@@9LV
)@@G@@         MOVE    DGGID,SD0ART,I .  SET TO BE TYPE ARITH.    @^@@@9      LW
)@@G@@ LOAD  F,SGDCLS   @G@@@9       IF  SDRLCX+SDFXFL,ON  THEN,GGSEX1    . ->LX
)@@G@@ ITS FLOAT OR COMPLEX   @F@@@9       IF  SGDSCL,ZERO    THEN,GGSEX3  . -LY
)@@G@@>QR=0, AGR IS REAL FIX  @[@@@9.     @D@@@9.        CONVERT TO FLOAT HERELZ
)@@G@@... AND DO FLT**FLT     @[@@@9.     @E@@@9GGSEX1 LABEL .                MA
)@@G@@     EXPONENT NOT INTEGER     @ @@@9       LOR   F,SGDCLS+DCGSLT .@C@@@9MB
)@@G@@       SET   SDFXFL,ON  . TYPER+TYPEL+FLOAT     @E@@@9         STORE   FMC
)@@G@@,DGGCLS .        SET THE CLASSIN WORKSPACE@D@@@9       LOADA X2,DGGSTK .MD
)@@G@@           POINT TO WORKSPACE @G@@@9       GASGN  'TEMP'  R,X7  'ATTR',RME
)@@G@@,X2  'COND','IFREG' . ARGR IN TEMP  @I@@@9       GASGN  'TEMP'  SGDAID+DMF
)@@G@@CGSLT  'ATTR',R,X2  'COND','IFREG'   . ARG IN TEMP    @B@@@9       LOADAMG
)@@G@@ X3,REXG    . REALFLT**REALFLT@D@@@9       IF  SDRLCX,OFF,SGDCLS  THEN,GMH
)@@G@@GSEX2   . ->REAL  @ @@@9       SET   IGRLCX,ON,DGFLGZ @B@@@9       LOADAMI
)@@G@@ X3,RECXG   . COMPFLT**COMPFLT@#@@@9GGSEX2 LABEL .    @^@@@9       LOAD MJ
)@@G@@ A7,SGDPRE .@C@@@9       IF  A7,LT,SGDPRE+DCGSLT  THEN,GGSCB3 .   @E@@@9MK
)@@G@@       STORE A7,SGDPRE+DCGSLT          . PL <- MAX(PL,PR)   @^@@@9      ML
)@@G@@ GOTO  GGSCB3 .   @D@@@9GGSEX3 LABEL .     . HERE, ARGR IS (QR=0 , REAL MM
)@@G@@, FIX)@E@@@9       SET   IGEPNI,ON,DGFLGZ      EXPONENT IS AN INTEGER   MN
)@@G@@@F@@@9       IF  SDFXFL,ON,SGDCLS+DCGSLT  THEN,GGSEX8  . ->LEFT FLOAT   MO
)@@G@@@F@@@9       IF  SDVRCN,OFF  THEN,GGSEX5     . ->RIGHT NOT CONSTANT     MP
)@@G@@@F@@@9       IF  SGDEXP,ON,SGDID  THEN,GGSEX5     . ->RIGHT IS SIGNED   MQ
)@@G@@@C@@@9       LSDP  X2,SGDRDS  . LOC OF DF CONSTANT    @E@@@9         SUBMR
)@@G@@     X2,2,I .          POINT TO DX CONSTANT     @F@@@9       IF  SDDCBN,MS
)@@G@@ON  THEN,GGSEX4 . CONST IS BX   (C(F)=SGDCLS)   @^@@@9       USING WORD,MT
)@@G@@X2 .  @F@@@9         IF  W1,NZERO THEN,GGSEX5 . CONSTANT IS NOT BIN FIXEMU
)@@G@@D     @F@@@9         SET  SDDCBN,ON .           SET FIXED BINARY CONSTANMV
)@@G@@T     @#@@@9GGSEX4 LABEL .    @D@@@9       ADD   X2,1,I     . POINT PASTMW
)@@G@@ DX TO BX VALUE   @E@@@9       IF  W1,ZERO  THEN,GGSEX5  . -> IT IS A COMX
)@@G@@NST ZERO    @B@@@9       LOAD  A8,SGDPRE+DCGSLT     . PL    @F@@@9      MY
)@@G@@   IF    SDDCBN,ON,SGDCLS+DCGSLT THEN,GGSEX99 . -> BIN BASE @G@@@9      MZ
)@@G@@   MPYS  A8,DCVDTB .         DEC PREC TO BIN PREC (MPY BY 3.32)   @D@@@9NA
)@@G@@         SRB   A8,14 .             (3.32*16384)/16384 @#@@@9GGSEX99  LABNB
)@@G@@EL .  @ @@@9       ADD   A8,1,I     . PL+1@C@@@9       MPY   A8,W1,X2   NC
)@@G@@ . A8,A9 <- ARGR*(PL+1) @F@@@9       SLBD  A8,1  . SHIFT SIGN BIT TO OTHND
)@@G@@ER REG (FOR OVFLW CHECK)@D@@@9       IF  A8,NE,0,I  THEN,GGSEX5 . P OVFLNE
)@@G@@WS ONE WORD @^@@@9       SRB   A9,1  .    @C@@@9       SUB   A9,1,I     NF
)@@G@@. PT = ARGR*(PL+1)-1    @A@@@'         LOAD  A3,F .    SAVE FLAGS @F@@@'NG
)@@G@@         LOAD  F,SGDCLS+DCGSLT .  GET DATA TYPE OF LEFT ARGUMENT  @C@@@9NH
)@@G@@       LINK  GGSPMX     . A7<-MAX PREC FOR TYPE @C@@@'         LOAD  F,ANI
)@@G@@3 .      RESET RIGHT DATA TYPE@C@@@9       IF  A7,GE,A9  THEN,GGSX11  . NJ
)@@G@@->PT IS OKAY@[@@@9.     @F@@@9GGSEX5 LABEL .     . NOW COVVERT ARGL TO FNK
)@@G@@LOAT, PT = MAX(PR,PL)   @ @@@9       LOR   F,SGDCLS+DCGSLT .@C@@@9      NL
)@@G@@ SET   SDFXFL,ON  . TYPER+TYPEL+FLOAT     @A@@@9       STORE F,DGGCLS . NM
)@@G@@RESULT CLASS@D@@@9         LOADA   X2,DGGSTK .       POINT TO WORKSPACE NN
)@@G@@@H@@@9       GASGN  'TEMP'  SGDAID+DCGSLT  'ATTR',R,X2 'COND','IFREG'   NO
)@@G@@. AR IN TEMP@E@@@9       IF  SDDCBN,ON,SGDCLS  THEN,GGSEX7    . -> ARGR NP
)@@G@@IS BIN@E@@@9       MOVE  DGGSCL,0,I . IF HERE, ARGL IS BIN, ARGR IS DEC NQ
)@@G@@@C@@@9       SET   SDDCBN,ON,DGGCLS     . TYPE=REAL BX@C@@@9       CGCONNR
)@@G@@V R,X2 R,X7     . CONV ARGR: DX->BX @#@@@9GGSEX7 LABEL .    @^@@@9      NS
)@@G@@ LOAD  A7,SGDPRE .@C@@@9       IF  A7,LT,SGDPRE+DCGSLT  THEN,GGSEX6 .   NT
)@@G@@@E@@@9       STORE A7,SGDPRE+DCGSLT          . PL <- MAX(PL,PR)   @^@@@9NU
)@@G@@       GOTO  GGSEX6 .   @#@@@9GGSEX8 LABEL .    @I@@@9       GASGN  'TEMNV
)@@G@@P'  SGDAID+DCGSLT  'ATTR',SGDAID+DCGSLT  'COND','IFREG' . ARGL    @#@@@9NW
)@@G@@GGSEX6 LABEL .    @^@@@9       LOADA X2,SFK170 .@G@@@9       GASGN  'TEMNX
)@@G@@P'  R,X7  'ATTR',R,X2  'COND','IFREG' . ARGR IN TEMP  @A@@@9       SET  NY
)@@G@@IGBNFX,OFF,DGFLGZ .     @#@@@9GGSEX9 LABEL .    @B@@@9       LOADA X3,RENZ
)@@G@@XFLT  . REALFLT**INT    @H@@@9       IF  SDRLCX,OFF,SGDCLS+DCGSLT  THEN,OA
)@@G@@GGSCB3 . -> ARGL IS REALLY REAL     @E@@@9       SET  IGRLCX,ON,DGFLGZ  OB
)@@G@@   . TELL ICODE TIS COMPLEX   @B@@@9       LOADA X3,RCXFLT  . COMPFLT**IOC
)@@G@@NT    @^@@@9       GOTO  GGSCB3 .   @#@@@9GGSX11 LABEL .    @D@@@9      OD
)@@G@@ LOAD  A7,SGDSCP+DCGSLT .    PICK UP SCALE,PRE  @D@@@9       SSA   A7,9 OE
)@@G@@.                RIGHT JUSTIFY SCALE@B@@@9       MPY   A7,0,X2    . QT =OF
)@@G@@ ARGR*QL    @F@@@9       SLBD  A7,1  . SHIFT SIGN BIT TO OTHER REG (FOR OG
)@@G@@OVFLW CHECK)@D@@@9       IF  A7,NE,0,I  THEN,GGSEX5 . QT OVFLWED WORD   OH
)@@G@@@E@@@9         SRBD    A7,1 .            RESTORE A8 TO BE SCA     @E@'@9OI
)@@G@@       IF  A8,GE,KINMXQ+1,I  THEN,GGSEX5    . ->QT TOO LARGE@E@@@'.     OJ
)@@G@@ IF  A8,GE,KINMXQ+1,I  THEN,GGSEX5    . ->QT TOO LARGE@E@'@9       IF  AOK
)@@G@@8,LE,-KINMXQ-1,I  THEN,GGSEX5   . ->QT TOO SMALL@E@@@'.      IF  A8,LE,-OL
)@@G@@KINMXQ-1,I  THEN,GGSEX5   . ->QT TOO SMALL@E@@@'         IF    A8,NE,0,IOM
)@@G@@ THEN,GGSEX5 . -> NON STANDARD PL/1 @B@@@'.        IF Q ^=0 THEN ASSUME ON
)@@G@@FLOAT RESULT@[@@@'.     @A@'@9       STORE A8,SGDSCL+DCGSLT .     @D@'@9OO
)@@G@@       STORE A9,SGDPRE+DCGSLT .     SAVED FROM ABOVE  @^@@@9       LOADAOP
)@@G@@ X2,SFK170 .@G@@@9       GASGN  'TEMP'  R,X7  'ATTR',R,X2  'COND','IFREGOQ
)@@G@@' . ARGR IN TEMP  @I@@@9       GASGN  'TEMP'  SGDAID+DCGSLT  'ATTR',SGDAOR
)@@G@@ID+DCGSLT  'COND','IFREG' . ARGL    @C@@@'         STORE A9,SGDPRE+DCGSLOS
)@@G@@T .   SET RESULT P@E@@@'.                                   RESULTING Q OT
)@@G@@ALREADY 0   @I@@@9       IF  SDDCBN,OFF,SGDCLS+DCGSLT  THEN,GGSEX9X . ->OU
)@@G@@ITS DX, USE FLOAT ROUTINE     @F@'@9         SET   SDDCBN,ON,SGDCLS+DCGSOV
)@@G@@LT . SET FIXED BINARY RESULT  @B@@@9       LOADA X3,REXFXB  . REALBIN**IOW
)@@G@@NT    @F@@@9       IF  SDRLCX,OFF,SGDCLS+DCGSLT  THEN,GGSCB3 . RESULT ISOX
)@@G@@ REAL @D@@@9       SET  IGRLCX,ON,DGFLGZ . TELL ICODE ITS REAL    @B@@@9OY
)@@G@@       LOADA X3,RCXFXB  . COMPBIN**INT    @^@@@9       GOTO  GGSCB3 .   OZ
)@@G@@@#@@@9GGSEX9X LABEL .   @F@@@9         SET   IGDCFX,ON,DGFLGZ .     SET PA
)@@G@@FIXED DECIMAL (SCALE)   @D@@@9         LOAD  A10,SGDSCP+DCGSLT .  GET REPB
)@@G@@SULTING Q   @^@@@9         SSA   A10,9 .  @D@@@9         LINK  GGSTBS . PC
)@@G@@              SET SCALING     @E@'@9         IF    SGDSCL+DCGSLT,ZERO THPD
)@@G@@EN,GGSEX9 . -> CALL FCN @E@@@'.        IF    SGDSCL+DCGSLT,ZERO THEN,GGSPE
)@@G@@EX9 . -> CALL FCN @C@@@'         GOTO GGSEX9 .    -> QL ^=0 FROM BEFORE PF
)@@G@@@A@@@'.        NOTE - NON STANDARD PL/1   @[@@@9.     @#@@@9.        NOTPG
)@@G@@E     @#@@@9.        NOTE     @E@@@9.              THE FOLLOWING IS NOT PH
)@@G@@ANSI STANDARD FOR NOW   @E@@@9.              ANY FIXED DECIMAL**POWER WHPI
)@@G@@ERE SCALE FACTOR  @D@@@9.              IS NOT ZERO WILL BE A FLOAT RESULPJ
)@@G@@T     @[@@@9.     @[@@@9.     @A@'@9        SET  IGDCFX,OFF,DGFLGZ .    PK
)@@G@@@B@'@9        SET  SDFXFL,ON,SGDCLS+DCGSLT .    @A@'@9         MOVE SGDSPL
)@@G@@CL+DCGSLT,0,I .   @D@'@9         GOTO  GGSEX9 .               -> CALL FCPM
)@@G@@N.    @B@@@9/.           ICODE FOR FLOAT OPERATIONS   @A@@@9.           PN
)@@G@@ ADDITION -- COMPLEX    @C@@@9       GMODE 'M'   . SET BIT FOR PACKING IPO
)@@G@@CODE  @[@@@9.     @[@@@9.     @#@@@9GGADFC GLBL .     @C@@@9       GIFR PP
)@@G@@ GGADF1,AGIM2    . -> IM2     IN REG@F@@@9         GIFR  GGADF4,AGIM1 . PQ
)@@G@@SEE IF IMAG PART IS IN REGISTER     @D@@@9         GLOAD AGIM1,2 .     IPR
)@@G@@F NOT, PUT IT THERE     @F@@@9GGADF4   GLBL .              MERGE POINT WPS
)@@G@@HEN AGIM1 IS IN REGISTER@F@@@9         GFLOAT OPDFA,AGIM1,AGIM2 . ADD LEPT
)@@G@@FT TO RIGHT IMAG PART   @E@@@9         GSET  AGIM2,AGIM1 . CHANGE RIGHT PU
)@@G@@TO LEFT AS RESULT @^@@@9         GGOTO GGADF5 . @F@@@9GGADF1 GLBL    . MPV
)@@G@@ERGE POINT WHEN LEFT IMAG PART IN IN REGISTER   @F@@@9       GFLOAT OPDFPW
)@@G@@A,AGIM2,AGIM1 . ADD RIGHT TO LEFT IMAG PART     @F@@@9GGADF5   GLBL .  MPX
)@@G@@ERGE POINT AFTER IMAG PART ADDITIONS GENERATED  @G@@@9       GBOFF GGADFPY
)@@G@@R,IGDCFX   . IF DEC X, FALL THROUGH FOR OVFLW CHECK   @D@@@9         GBAPZ
)@@G@@L  GOVIM2 . DEC FIXED OVERFLOW CHECKING   @[@@@9.     @ @@@9.           QA
)@@G@@ ADDITION -- REAL @[@@@9.     @#@@@9GGADFR GLBL .     @F@@@9       GIFR QB
)@@G@@ GGADF2,AGRL2    . -> LEFT REAL PART IS IN REGISTER   @E@@@9         GIFQC
)@@G@@R  GGADF6,AGRL1 . RIGHT REAL PART IS IN REGISTER@F@@@9       GLOAD AGRL1QD
)@@G@@,2       . OTHERWISE PUT RIGHT PART IN REGISTER @F@@@9GGADF6   GLBL .   QE
)@@G@@           MERGE POINT WHEN AGRL2 IS IN REGISTER@F@@@9         GFLOAT OPQF
)@@G@@DFA,AGRL1,AGRL2 . ADD LEFT TO RIGHT REAL PART   @E@@@9         GSET  AGRQG
)@@G@@L2,AGRL1 . CHANGE RIGHT TO LEFT REAL PART @^@@@9         GGOTO GGADF7 . QH
)@@G@@@F@@@9GGADF2 GLBL .    MERGE POINT WHEN LEFT REAL PART IS IN REGISTER   QI
)@@G@@@F@@@9       GFLOAT OPDFA,AGRL2,AGRL1 . ADD RIGHT TO LEFT REAL PART     QJ
)@@G@@@E@@@9GGADF7   GLBL .  MERGE WHEN REAL PART ADDITION IN GENERATED @G@@@9QK
)@@G@@       GBOFF GGADF3,IGDCFX   . IF DEC X, FALL THROUGH FOR OVFLW CH+CK   QL
)@@G@@@D@@@9         GBAL  GOVRL2 . DEC FIXED REAL OVERFLOW CHECK @#@@@9GGADF3QM
)@@G@@ GLBL .     @C@@@9.       GAPPN GGLPCL     . RESTORE REGS IF BIF  @#@@@9QN
)@@G@@       GFIN  'POP'@[@@@9.     @A@@@9.            SUBTRACTION -- COMPLEX QO
)@@G@@@[@@@9.     @#@@@9GGSUFC GLBL .     @C@@@9       GIFR  GGSUF1,AGIM2    .QP
)@@G@@ -> IM2 IN REG    @^@@@9       GLOAD AGIM2,2    @#@@@9GGSUF1 GLBL    .  QQ
)@@G@@@G@@@9       GFLOAT OPDFAN,AGIM2,AGIM1  . SUBTRACT RIGHT FROM LEFT IMAG QR
)@@G@@PART  @G@@@9       GBOFF GGSUFR,IGDCFX . FALL THROUGH FOR DEC FIX OVERFLQS
)@@G@@OW CHECK    @F@@@9         GBAL  GOVIM2 .      IMAG FUNNY FLOAT OVERFLOWQT
)@@G@@ CHECKING   @[@@@9.     @A@@@9.            SUBTRACTION -- REAL    @[@@@9QU
)@@G@@.     @#@@@9GGSUFR GLBL .     @C@@@9       GIFR  GGSUF4,AGRL2    . -> REQV
)@@G@@AL2   IN REG@D@@@9       GLOAD AGRL2,2 .     OTHERWISE PUT REAL2 IN REG QW
)@@G@@@#@@@9GGSUF4 GLBL .     @G@@@9       GFLOAT OPDFAN,AGRL2,AGRL1  . SUBTRAQX
)@@G@@CT RIGHT FROM LEFT REAL PART  @G@@@9       GBOFF GGSUF7,IGDCFX . FALL THQY
)@@G@@ROUGH FOR DEC FIX OVERFLOW CHECK    @E@@@9         GBAL  GOVRL2 .       QZ
)@@G@@DECIMAL FIXED OVERFLOW CHECKER@]@@@9GGSUF7 GLBL @#@@@9       GFIN  'POP'RA
)@@G@@@G@@@9GOVRL2   GLBL . DECIMAL FIXED REAL OVERFLOW CHECKING ROUTINE GENERRB
)@@G@@ATION @E@@@9         GSUB  RTOVCH .      REAL DEC FIX OVERFLOW CHECKER  RC
)@@G@@@G@@@9         GINST 00,AGRA3,AGRL2 'NO' . LOAD RESULT FOR OVERFLOW CHECRD
)@@G@@KING  @^@@@9         GGOTO GGOVER . @F@@@9GOVIM2   GLBL . DECIMAL FIXED RE
)@@G@@IMAGINARY PART OVERFLOW CHECKING    @E@@@9         GSUB  RTOVCH .       RF
)@@G@@IMAG DEC FIX OVERFLOW CHECKER @A@@@9         GINST 00,AGRA3,AGIM2 'NO' .RG
)@@G@@@#@@@9GGOVER   GLBL .   @^@@@9         GAPPN GGOVR2 . @C@@@9         GRTRH
)@@G@@RN .             -> RETURN TO CALLER@E@@@9GGOVR2   LLOC .              SRI
)@@G@@EE IF OVERFLOW CHECKING NEEDED@G@'@9         IF    OOPTD,ON,DGOPT3 THEN,RJ
)@@G@@GGOVR3 . -> CHECK NEEDED     *****  @F@@@'         IF      DCONFO,ON,DCGRK
)@@G@@ONF  THEN,GGOVR3 . =>FOFL ENABLED   @F@@@9         SUB   X10,2,I .     ERL
)@@G@@RASE CODE WHEN CHECK NOT NEEDED     @C@@@9         LJMP .              -RM
)@@G@@> END SUBROUTINE  @C@@@9GGOVR3   LABEL .             CHECK IS NEEDED    RN
)@@G@@@^@@@9         SUB   X10,1,I .@E@@@9         LOAD  A6,SGDPRE+DCGSLT,X7 .RO
)@@G@@   PRECISION OF RESULT  @B@@@9         SLB   A6,1 .        PRECISION * 2RP
)@@G@@@H@@@9         STORE A6,W1Q1,*X10 .          SET INTO Q1 OF WORD FOLLOWIRQ
)@@G@@NG CALL     @B@@@9         LJMP .              -> RETURN    @B@@@9/.    RR
)@@G@@       ICODE FOR FIXED OPERATORE    @A@@@9.            ADDITION -- COMPLRS
)@@G@@EX    @[@@@9.     @#@@@9GGADBC GLBL .     @C@@@9       GIFR  GGADB1,AGIMRT
)@@G@@2    . -> IM2     IN REG@ @@@9         GIFR  GGADB3,AGIM1 . @^@@@9      RU
)@@G@@   GLOAD AGIM1 .  @#@@@9GGADB3   GLBL .   @A@@@9         GINST OPAA,AGIMRV
)@@G@@1,AGIM2 .   @D@@@'         GAPPN   GGFOFL .          CHECK FOFL ENABLED RW
)@@G@@@C@@@'         GBOFF   GGADB5,IGFOFL .   FOFL ENABLED?@E@@@'         GINRX
)@@G@@ST   OPSA,AGRA3,AGIM1 . STORE RESULT FROM RTFOFB@#@@@'GGADB5   GLBL .   RY
)@@G@@@ @@@9         GSET  AGIM2,AGIM1 .  @^@@@9         GGOTO GGADBR . @#@@@9RZ
)@@G@@GGADB1 GLBL .     @A@@@9       GINST OPAA,AGIM2,AGIM1 .     @ @@@'      SA
)@@G@@   GAPPN   GGFOFL .     @A@@@'         GBOFF   GGADB6,IGFOFL .    @A@@@'SB
)@@G@@         GINST   OPSA,AGRA3,AGIM2 . @#@@@'GGADB6   GLBL .   @[@@@9.     SC
)@@G@@@ @@@9.            ADDITION -- REAL @[@@@9.     @#@@@9GGADBR GLBL .     SD
)@@G@@@ @@@9       GIFR  GGADB2,AGRL2     @ @@@9         GIFR  GGADB4,AGRL1 . SE
)@@G@@@^@@@9         GLOAD AGRL1 .  @#@@@9GGADB4   GLBL  .  @A@@@9         GINSF
)@@G@@ST OPAA,AGRL1,AGRL2 .   @ @@@'         GAPPN   GGFOFL .     @A@@@'      SG
)@@G@@   GBOFF   GGADB7,IGFOFL .    @A@@@'         GINST   OPSA,AGRA3,AGRL1 . SH
)@@G@@@#@@@'GGADB7   GLBL .   @ @@@9         GSET  AGRL2,AGRL1 .  @^@@@9      SI
)@@G@@   GGOTO GGSUF7 . @#@@@9GGADB2 GLBL .     @ @@@9       GINST OPAA,AGRL2,SJ
)@@G@@AGRL1 @ @@@'         GAPPN   GGFOFL .     @A@@@'         GBOFF   GGADB8,SK
)@@G@@IGFOFL .    @A@@@'         GINST   OPSA,AGRA3,AGRL2 . @#@@@'GGADB8   GLBSL
)@@G@@L .   @#@@@9       GFIN  'POP'@[@@@9.     @A@@@9.            SUBTRACTIONSM
)@@G@@ -- COMPLEX @[@@@9.     @#@@@9GGSUBC GLBL .     @C@@@9       GIFR  GGSUBSN
)@@G@@1,AGIM2    . -> IM2 IN REG    @F@@@9       GLOAD AGIM2         . IF NOT,SO
)@@G@@PUT IMAG PART IN REGISTER     @E@@@9GGSUB1 GLBL .    MERGE WHEN LEFT IMASP
)@@G@@G PART IS IN REGISTER   @G@@@9       GINST OPANA,AGIM2,AGIM1 . SUBTRACT SQ
)@@G@@RIGHT FROM LEFT IMAG PART     @ @@@'         GAPPN   GGFOFL .     @A@@@'SR
)@@G@@         GBOFF   GGSUB5,IGFOFL .    @A@.@'         GINST   OPSA,AGRA3,AGSS
)@@G@@IM1 . @A@@@.         GINST   OPSA,AGRA3,AGIM2 . @#@@@'GGSUB5   GLBL .   ST
)@@G@@@[@@@9.     @A@@@9.            SUBTRACTION -- REAL    @[@@@9.     @#@@@9SU
)@@G@@GGSUBR GLBL .     @C@@@9       GIFR  GGSUB3,AGRL2    . -> REAL2   IN REGSV
)@@G@@@F@@@9         GLOAD AGRL2 .       IF NOT,PUT REAL LEFT PART IN REGISTERSW
)@@G@@@E@@@9GGSUB3 GLBL .    MERGE POINT WHEN REAL LEFT PART IN REGISTER@G@@@9SX
)@@G@@       GINST OPANA,AGRL2,AGRL1 . SUBTRACT RIGHT FROM LEFT REAL PART     SY
)@@G@@@ @@@'         GAPPN   GGFOFL .     @A@@@'         GBOFF   GGSUB6,IGFOFLSZ
)@@G@@ .    @A@@@'         GINST   OPSA,AGRA3,AGRL2 . @#@@@'GGSUB6   GLBL .   TA
)@@G@@@^@@@9       GFIN  'POP'  .   @[@@@9.     @A@@@9.            UNARY PLUS TB
)@@G@@ I-CODE     @[@@@9.     @#@@@9GGUPLS GLBL .     @F@@@9         GAPPN   GTC
)@@G@@GUPL1 .          SET TO RETURN TO CORRECT PLACE @#@@@9         GFIN .   TD
)@@G@@@F@@@9GGUPL1   GLBL .                    HERE TO FUDGE RETURN STACK     TE
)@@G@@@G@@@9         LOAD    A3,A0 .           GET STACK ADDR                 TF
)@@G@@***** @F@'@9         SUB     A3,2,I .          POINT TO PROPER PLACE IN TG
)@@G@@STACK @F@@@'         SUB     A3,1,I .          POINT TO PROPER PLACE IN TH
)@@G@@STACK @G@@@9         LOADA   A6,XGCNRT .       DON'T TURN OFF CONST. FLATI
)@@G@@G ON RETURN @E@@@9         STORE   A6,W1H2,A3 .      SET NEW RETURN ADDRTJ
)@@G@@ESS   @#@@@9         LJMP .   @B@@@'GGFOFL   GLBL .  ROUTINE TO FIX UP FTK
)@@G@@OFL   @D@@@'         SET     IGFOFL,OFF,DGFLGZ . TURN FOFL OFF    @H@@@'TL
)@@G@@         IF      DCONFO,OFF,DCGONF  THEN,LJMP . FOFL DISABLED=>NO CHECK TM
)@@G@@CODE  @C@@@'         SET     IGFOFL,ON,DGFLGZ . FOFL ENABLED@E@@@'      TN
)@@G@@   LOAD    A3,0,I .          CLEAR REG TO BUILD INSTR @E@@@'         LOATO
)@@G@@DXM  A3,X10 .          GET NEXT WORD FOR CODE   @E@;@'         ADD     ATP
)@@G@@3,GGJNOI,I .     CREATE JNO  $+3  INSTR   @E@@@;         ADD     A3,GGJNTQ
)@@G@@OI   .     CREATE JNO  $+3  INSTR   @D@@@'         STORE   A3,0,*X10 .  TR
)@@G@@     STORE USER INSTR   @D@@@'         LOAD    A3,GGSBFB .       GET RTFTS
)@@G@@OFB SUB CALL@ @@@'         STORE   A3,0,*X10 .  @#@@@'         LJMP .   TT
)@@G@@@I@@@9/.           EXPONENTIATION I-CODE CLEANUP.  MOST WORK DONE IN RUNTU
)@@G@@TIME ROUTINES     @[@@@9.     @[@@@9.     @#@@@9GGEXPN GLBL .     @C@@@9TV
)@@G@@       GBOFF  GGMUBC,IGDCFX  . ->NOT DEC FIX    @H@@@9       GBOFF  GGMUTW
)@@G@@F2,IGRLCX  . -> ITS REAL.   ELSE, FALL THRU FOR COMPLEX     @[@@@9.     TX
)@@G@@@I@@@9.            I-CODE FOR MULT/DIV.  SOME DIVS USE SAME CODE AS MULTTY
)@@G@@S (SEE ACTION     @I@@@9.            TABLE.  THE FLAGS IN DCGSV4+1 (A7) TZ
)@@G@@WERE SET IN SUBR GGSFLM IN STAGN    @A@@@9.        ALL FLOAT COMPLEX MULUA
)@@G@@T/DIV @#@@@9GGMUFC GLBL .     @[@@@9.     @D@@@9         GBOFF GGMUF3,IGUB
)@@G@@ZERO . -> SOME SHIFT IS NEEDED@B@@@9         GBOFF GGMUF8,IGPLUS . -> DOUC
)@@G@@NE    @F@@@9         GIFR  GGMFCZ,AGIM2 .  SEE IF IMAG PART IS IN REGISTUD
)@@G@@ER    @D@@@9         GLOAD AGIM2,2 .     IF NOT, PUT IT THERE     @D@@@9UE
)@@G@@         GGOTO GGMFCZ .      -> NORMALIZE IMAG PART   @#@@@9GGMUF3   GLBUF
)@@G@@L .   @F@@@9         GIFR  GGMUF4,AGIM2 . SEE IF IMAG PART IS IN REGISTEUG
)@@G@@R     @C@@@9         GLOAD AGIM2,2 .     IF NOT,PUT IT THERE@G@@@9GGMUF4UH
)@@G@@   GLBL .  MERGE POINT FOR SHIFTING WHEN IMAG PART IS IN REGISTER @E@@@9UI
)@@G@@         GBON  GGMFCP,IGPLUS . -> POSITIVE SHIFT NEEDED     @H@@@9      UJ
)@@G@@ GFLOAT OPDFD,AGIM2,AGXR0 . PERFORM (-) (DIVIDE) SHIFT OF IMAG PART     UK
)@@G@@@^@@@9       GGOTO GGMFCZ .   @#@@@9GGMFCP GLBL .     @G@@@9       GFLOAUL
)@@G@@T OPDFM,AGIM2,AGXR0 . PERFORM (+) (MULT) SHIFT OF IMAG PART @#@@@9GGMFCZUM
)@@G@@ GLBL .     @I@@@9       GFLOAT OPDFA,AGIM2,AGXUNZ  . NORMALIZE RESULT BUN
)@@G@@Y ADDING UNNORMALIZED ZERO    @E@@@9         GBAL  GOVIM2 .      CHECK FUO
)@@G@@OR DEC FIX IMAG OVERFLOW@D@@@9         GGOTO GGMUF2 .       DO SAME TO RUP
)@@G@@EAL PART    @[@@@9.     @C@@@9.            FLOATING REAL MULTIPLICATION UQ
)@@G@@ICODE @[@@@9.     @#@@@9GGMUFR GLBL .     @E@@@9       GIFR  GGMUF1,AGRLUR
)@@G@@2 .  -> LEFT SIDE IS IN REGISTER    @E@@@9         GIFR  GGMUF5,AGRL1 . US
)@@G@@-> RIGHT SIDE IS IN REGISTER  @F@@@9         GLOAD AGRL1,2 .     OTHERWIUT
)@@G@@SE PUT RIGHT SIDE IN REGISTER @D@@@9GGMUF5   GLBL .  MERGE WHEN RIGHT SIUU
)@@G@@DE IS IN REGISTER @I@@@9         GFLOAT OPDFM,AGRL1,AGRL2 . PERFORM THE UV
)@@G@@MULTIPLICATION ON THE RIGHT OPER    @F@@@9         GSET  AGRL2,AGRL1 . PUW
)@@G@@UT THE AW IN THE LEFT STACK ITEM    @^@@@9         GGOTO GGMUF2 . @#@@@9UX
)@@G@@GGMUF1 GLBL .     @G@@@9       GFLOAT OPDFM,AGRL2,AGRL1   . MULTIPLY THEUY
)@@G@@ LEFT TIMES THE RIGHT   @[@@@9.     @C@@@9. FLOATING REAL MULTIPLICATIONUZ
)@@G@@ AND DIVISION     @[@@@9.     @#@@@9GGMUF2 GLBL .     @F@@@9         GBOVA
)@@G@@FF GGMUF6,IGZERO . -> SOME NORMALIZING SHIFT IS NEEDED@E@@@9         GBOVB
)@@G@@FF GGMUF8,IGPLUS . -> NOT DEC FIXED SO FINISH UP@E@@@9         GIFR  GGMVC
)@@G@@FRZ,AGRL2 . MAKE SURE OPND IS IN REGISTER @^@@@9         GLOAD AGRL2,2 .VD
)@@G@@@B@@@9         GGOTO GGMFRZ .      -> NORMALIZE @F@@@9GGMUF6   GLBL .   VE
)@@G@@           PERFORM A DECIMAL SHIFT ON RESULT    @E@@@9         GIFR  GGMVF
)@@G@@UF7,AGRL2 . INSURE OPERAND IS IN REGISTER @^@@@9         GLOAD AGRL2,2 .VG
)@@G@@@#@@@9GGMUF7   GLBL .   @G@@@9         GBON  GGMFCP,IGPLUS . -> SHIFT REVH
)@@G@@SULT (+) (MULT) TO THE LEFT   @G@@@9       GFLOAT OPDFD,AGRL2,AGXR0 . SHVI
)@@G@@IFT RESULT (-) (DIV) TO THE RIGHT   @^@@@9       GGOTO GGMFRZ .   @#@@@9VJ
)@@G@@GGMFRP GLBL .     @A@@@9       GFLOAT OPDFM,AGRL2,AGXR0 .   @F@@@9GGMFRZVK
)@@G@@ GLBL .    MERGE AFTER ANY SHIFTING AND OPND IS IN REGISTER @I@@@9      VL
)@@G@@ GFLOAT OPDFA,AGRL2,AGXUNZ  . NORMALIZE DEC FIXED BY ADDING UNNORMALIZEDVM
)@@G@@ Z    @E@@@9         GBAL  GOVRL2 .      REAL DEC FIX OVERFLOW CHECKING VN
)@@G@@@H@@@9GGMUBC GLBL . MULTIPLY/DIVIDE BIN FIX COMPLEX SHIFT HANDLED BY SUBVO
)@@G@@ROUTINE     @#@@@9GGMUF8 GLBL .     @^@@@9.       GAPPN GGLPCL .  @^@@@9VP
)@@G@@       GFIN 'POP' .     @[@@@9.     @A@@@9.  FIXED BINARY REAL MULTIPLICVQ
)@@G@@ATION @[@@@9.     @#@@@9GGMUBR GLBL .     @D@@@9       GIFR  GGMUB2,AGRLVR
)@@G@@2 . -> LEFT IS IN REGISTER    @E@@@9         GSET  AGIM1,AGRL2 . SWITCH VS
)@@G@@LEFT AND RIGHT OPERAND  @ @@@9         GSET  AGRL2,AGRL1 .  @ @@@9      VT
)@@G@@   GSET  AGRL1,AGIM1 .  @G@@@9         GIFR  GGMUB2,AGRL2 . MAKE SURE NEVU
)@@G@@W LEFT SIDE IS IN REGISTER    @^@@@9         GLOAD AGRL2,1 .@F@@@9GGMUB2VV
)@@G@@   GLBL .              MERGE WHEN LEFT SIDE IS IN REGISTER  @G@@@9      VW
)@@G@@   GBON  GGMUB3,IGZERO . -> WHEN NOT SHIFTING MSI MAY BE USED     @G@@@9VX
)@@G@@         GIFO  GGMUB1,AGRL2 .MAKE SURE RESULT GOES TO ODD-EVEN PAIR     VY
)@@G@@@E@@@9         GSHIFT AGRL2 .      IF NOT PUT IT IN ODD-EVEN PAIR @A@@@9VZ
)@@G@@         GSHIN OPLDSL,AGRL2,36,I .  @#@@@9GGMUB1 GLBL .     @D@/@'      WA
)@@G@@   GSET    AGIM1,AGRL2 .     SAVE ODD REG A.W.  @F@@@9       GINST OPMI,WB
)@@G@@AGRL2,AGRL1 . MULTIPLY THE LEFT BY THE RIGHT    @E@@@9         GBON GGMBWC
)@@G@@RP,IGPLUS . -> A RIGHT (+) SHIFT IS NEEDED@B@@@9       GSHIN OPDSA,AGRL2WD
)@@G@@,AGXR0    . MINUS @^@@@9       GGOTO GGMUB4 .   @#@@@9GGMBRP GLBL .     WE
)@@G@@@B@@@9       GSHIN OPLDSC,AGRL2,AGXR0   . PLUS  @D@@@9GGMUB4   GLBL .   WF
)@@G@@           MERGE AFTER SHIFTING     @E@/@9         GSHIFT AGRL2 .      RWG
)@@G@@ESULT IS IN EVEN REGISTER     @ @@@'         GAPPN   GGFOF1 .     @A@@@'WH
)@@G@@         GBOFF   GGMUB9,IGFOFL .    @F@/@'         GCJMP   OPJNZ,AGIM1,AWI
)@@G@@GTMP1 . ODD REG NOT=0 =>OVERFLOW    @F@@@/         GCJMP   OPJZ,AGRL2,AGWJ
)@@G@@TMP1 . ODD REG NOT=0 =>OVERFLOW     @ @@@'         GSUB    RTFOFB .     WK
)@@G@@@A@@@'         GINST   OPSA,AGRA3,AGRL2 . @C@@@'         GLABEL  AGTMP1 WL
)@@G@@.          FILL IN JUMP @#@@@'GGMUB9   GLBL .   @E@@@/         GSHIFT AGWM
)@@G@@RL2 .      RESULT IS IN EVEN REGISTER     @#@@@9GGMBRZ GLBL .     @^@@@9WN
)@@G@@       GFIN 'POP' .     @#@@@9GGMUB3   GLBL .   @G@@@9         GINST OPMWO
)@@G@@SI,AGRL2,AGRL1 . NO SHIFT NEEDED AFTER MULTIPLICATION @E@@@.         GAPWP
)@@G@@PN   GGFOFL .          CHECK FOR FIXEDOVFLOW    @A@@@.         GBOFF   GWQ
)@@G@@GMUB8,IGFOFL .    @D@@@.         GINST   OPSA,AGRA3,AGRL2 . STORE DEFAULWR
)@@G@@T     @#@@@.GGMUB8   GLBL .   @^@@@9         GGOTO GGMBRZ . @[@@@9.     WS
)@@G@@@ @@@9.            FLOAT REAL DIV   @[@@@9.     @#@@@9GGDVFR GLBL .     WT
)@@G@@@D@@@9       GIFR  GGDVF1,AGRL2    . -> LEFT IS IN REGISTER @E@@@9      WU
)@@G@@ GLOAD AGRL2,2 .       OTHERWISE, PUT IT IN A REGISTER@E@@@9GGDVF1 GLBL WV
)@@G@@.                MERGE WHEN LEFT IS IN REGISTER @D@@@9       GFLOAT OPDFWW
)@@G@@D,AGRL2,AGRL1 . DIVIDE LEFT BY RIGHT@F@@@9       GGOTO GGMUF2 .        -WX
)@@G@@> MERGE WITH MULTIPLICATION CLEANUP @[@@@9.     @ @@@9.   FIXED BINARY RWY
)@@G@@EAL DIVISION@[@@@9.     @#@@@9GGDVBR GLBL .     @E@@@9       GIFR  GGDVBWZ
)@@G@@1,AGRL2    . INSURE LEFT OP IS IN REGISTER@^@@@9       GLOAD AGRL2,1 .  XA
)@@G@@@ @@@9         GGOTO   GGDVB2 .     @#@@@9GGDVB1 GLBL .     @G@@@9      XB
)@@G@@   GIFO  GGDVB2,AGRL2 .  INSURE LEFT OP IS FIRST IN ODD REGISTER  @^@@@9XC
)@@G@@         GSHIFT AGRL2 . @A@@@9         GSHIN OPLDSL,AGRL2,36,I .  @H@@@9XD
)@@G@@GGDVB2   GLBL .              SHIFT RIGHT WITH SIGN EXTENSION BEFORE DIVIXE
)@@G@@SION  @D@@@9         GBOFF GGDVB3,IGPLUS . -> SHIFT RIGHT > 36    @C@@@9XF
)@@G@@         GSHIN OPDSA,AGRL2,36,I .  EXTEND SIGN  @F@@@9         GBON  GGDXG
)@@G@@VB4,IGZERO . -> NO LEFT SHIFT NEEDED FOR SCALING@G@@@9         GSHIN OPLXH
)@@G@@DSC,AGRL2,AGXR0 . SHIFT LEFT (+) TO GET SIGN BITS     @^@@@9         GGOXI
)@@G@@TO GGDVB4 . @#@@@9GGDVB3   GLBL .   @G@@@9         GSHIN OPDSA,AGRL2,AGXXJ
)@@G@@R0 . SHIFT RIGHT > 36  WITH SIGN EXTENSION@#@@@9GGDVB4   GLBL .   @C@@@'XK
)@@G@@         GAPPN   GGZDIV .          FIX ZDIV FLAG@D@@@'         GBOFF   GXL
)@@G@@GDVB7,IGZDIV .   SEE IF ZDIV ENABLED@E@@@/         GIFR    GGDVB6,AGRL1 XM
)@@G@@.    SEE IF DIVISOR IN REG    @C@@@/         GLOAD   AGRL1,1 .         GXN
)@@G@@ET IT IN ONE@#@@@/GGDVB6   GLBL .   @D@@@'         GSUB    RTZDIV .     XO
)@@G@@     CHECK DIVISOR=0    @B@@@'         GINST   00,AGRA3,AGRL1  'NO' .   XP
)@@G@@@G@@@.         GAPPN   GGZDV1 .          PUT IN SCALE FOR ZDIVCHECK ROUTXQ
)@@G@@INE   @#@@@'GGDVB7   GLBL .   @D@@@9       GINST OPDI,AGRL2,AGRL1 . DIVIXR
)@@G@@DE LEFT BY RIGHT  @^@@@9       GFIN 'POP' .     @#@@@9GGLPCL LLOC .     XS
)@@G@@@[@@@9.     @[@@@9.     @D@@@9.        I DON'T THINK THIS IS NECESSARY .XT
)@@G@@ PRM 3/21/74@[@@@9.     @G@@@9.       IF  IGITER,OFF,DGFLGZ  THEN,LJMP  XU
)@@G@@   . -> NO ITERATION, QUIT    @[@@@9.     @[@@@9.     @B@@@9.           XV
)@@G@@ MORE TO BE INSERTED HERE     @[@@@9.     @#@@@9       LJMP .     @B@@@'XW
)@@G@@GGZDIV   GLBL .  HERE TO FIX ZDIV FLAG    @C@@@'         SET     IGZDIV,XX
)@@G@@OFF,DGFLGZ . CLEAR FLAG @F@@@'         IF      DCONZD,OFF,DCGONF  THEN,LXY
)@@G@@JMP . ZDIV IS DISABLED  @C@@@'         SET     IGZDIV,ON,DGFLGZ . ZDIV EXZ
)@@G@@NABLED@#@@@'         LJMP .   @F@@@.GGZDV1   GLBL .                    HYA
)@@G@@ERE TO PUT IN SCALE FOR ZDIV  @D@@@.         SUB     X10,1,I .         GYB
)@@G@@ET INSTR TO CHANGE@D@@@.         LOAD    A6,SGDSCP,X7 .    GET SIGNED SCYC
)@@G@@ALE   @^@@@.         SSA     A6,9 . @C@@@.         STORE   A6,W1Q1,*X10 YD
)@@G@@.    STORE SCALE  @B@@@.         LJMP .                    RETURN @B@@@'YE
)@@G@@GGFOF1   GLBL .  HERE TO FIX FOFL FLAG    @C@@@'         SET     IGFOFL,YF
)@@G@@OFF,DGFLGZ . CLEAR FLAG @F@@@'         IF      DCONFO,OFF,DCGONF  THEN,LYG
)@@G@@JMP . FOFL DISABLED     @C@@@'         SET     IGFOFL,ON,DGFLGZ . FOFL EYH
)@@G@@NABLED@#@@@'         LJMP .   @A@@@'GGRPTR   LABEL . STAGING FOR POINTERYI
)@@G@@@D@@@'         SET SGDPTR,ON,SGDID . INDICATE PTR IS PRESENT@#@@@'      YJ
)@@G@@   LJMP .   @#@@@'PTRNOP   LABEL    @#@@@'         GFIN .   @]@@@9    ENYK
)@@G@@D .   ___DE BIN FIX COMPLEX SHIFT HANDLED BY SUBROUTINE     @#@@@9GGMUF8YL
)@@G@@ GLBL .     @^@@@9.       GAPPN GGLPCL .  @^@@@9       GFIN 'POP' .     YM
)@@G@@*[S@@@*SDFF*@C@@@Y.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@YYN
)@@G@@.     @D@@@Y.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@YYO
)@@G@@.     @ @@@Y.        MARVIN V. ZELKOWITZ  @B@@@Y.        DEPARTMENT OF CYP
)@@G@@OMPUTER SCIENCE   @A@@@Y.        UNIVERSITY OF MARYLAND     @B@@@Y.     YQ
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@Y.     @G@@@Y.        PERMISSIOYR
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@Y.   REPRESENYS
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@Y.     @G@@@Y.     YT
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@YYU
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDYV
)@@G@@@E@@@Y.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@YYW
)@@G@@.     @F@@@Y.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDYX
)@@G@@ED:   @[@@@Y.     @G@@@Y.        (A) ANY RESULTING PROGRAM, OR REPORT, PYY
)@@G@@APER OR DOCUMENTATION   @G@@@Y.        DESCRIBING SUCH PROGRAM WILL CLEAYZ
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@Y.        IS A DIALECT OF PLUM OR IS ZA
)@@G@@DERIVED FROM PLUM, AND  @[@@@Y.     @G@@@Y.        (B) ALL SUCH MODIFICAZB
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@Y.        OF ERRORS IN THZC
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@Y.        A BRIEF DESCRIPZD
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@Y.        TO THE UNZE
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@Y.     @F@@@Y.        (C) NO PROGRAMSZF
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@Y.        WITHOUT WRITTENZG
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@Y.     @F@@@Y.     ZH
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@Y.     ZI
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@YZJ
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     ZK
)@@G@@@E@@@Y.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@YZL
)@@G@@.     @G@@@Y.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILERZM
)@@G@@ ITSELF,    @F@@@Y.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN ZN
)@@G@@USING PLUM. @E@@@Y.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USZO
)@@G@@ER TO @F@@@Y.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PRZP
)@@G@@ODUCT @G@@@Y.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT ZQ
)@@G@@DEVELOPED   @#@@@Y.   FROM PLUM.    @[@@@Y.     @[@@@Y.     @[@@@Y.     ZR
)@@G@@@[@@@Y.     @[@@@Y.     @[@@@Y/.    @#@@@Y         AXR$  .  @#@@@Y      ZS
)@@G@@   DCLRG  . @^@@@YGPATCH*  PROC *1,1 .    @D@@@Y         STORE GPATCH(1,ZT
)@@G@@1),GPATCH(1,2),GPATCH(1,3) .  @]@@@Y         END@[@@@Y .    @^@@@Y .    ZU
)@@G@@   SETUP DSECTS   @B@@@Y .       ADD PLTVDS,PLCGST,PLDSAW,PLCSAW  @#@@@YZV
)@@G@@         UNLIST . @]@@@Y@ADD PLTVDS @#@@@Y         LIST .   @]@@@Y@ADD PZW
)@@G@@LCGST @#@@@Y@ADD PLDSAW .     @#@@@Y         PLAC  .  @#@@@Y       PLAR ZX
)@@G@@.     @#@@@Y         PLSD  .  @#@@@Y         PLCGD  . @#@@@Y         PLWZY
)@@G@@ORD  .@#@@@Y         PLIG .   @#@@@Y         CEND  .  @^@@@Y/CGDRVR   CSZZ
)@@G@@ECT 3 .     @ @@@Y . <<< PREAMBLE FLAGS >>>     @#@@@Y . <<< END >>>    AA
)@@G@@@^@@@Y . <<< RETURN FLAG >>>  @F@@@YICRTEX EQU   0001 .    EXPRESSION FOAB
)@@G@@LLOWS (IN 'RETURN' M-CODE)    @D@@@YONEONE         +1,-1 .           CONAC
)@@G@@STANT NEEDED IN DO@D@@@YSGDCS   EQU    0400 .              CASE STACK TYAD
)@@G@@PE    @E@@@YSGDFST   EQU   SDVRCN .            NOT FIRST \N\ PREFIX     AE
)@@G@@@E@@@YSGDELF   EQU   SDFXFL .            ELSE PRESENT IN CASE     @D@@@YAF
)@@G@@AGPTA7   EQU   1 .                 PTR TO AW IN A7    @[@@@Y .    @#@@@YAG
)@@G@@. =============== @E@@@Y        LIT .      SUBSEQUENT LITERALS ARE UNDERAH
)@@G@@ L.C. 3     @ @@@Y         USING SGDSCT,X7 .    @^@@@Y . ---------------AI
)@@G@@----  @ @@@Y .  SET ADDRESS WORD DISPLAY  @^@@@Y . -------------------  AJ
)@@G@@@ @@@Y         USING   WORD,X4 .    @#@@@YBGDSPY*  LOCAL .  @D@@@Y      AK
)@@G@@   LOAD    X6,X9 .           X6->CURRENT BLOCK  @H@@@Y         LOAD    AAL
)@@G@@8,3,I .          DO 4 LEVELS OF ADDRESSING IN REGS X10-X7   @H@@@Z      AM
)@@G@@   LOAD    R1,4,I .          MAKE SURE WE SET 5 BLOCKS IF THAT MANY     AN
)@@G@@@E@@@Y         LOAD    X4,SDBKAW,X9 .    PTR TO CURRENT A.R. BASE @E@@@YAO
)@@G@@         MOVE    W1,AGRX10 .       CURRENT LEVEL USES X10   @D@@@Y      AP
)@@G@@   LOAD    X11,DCGBPT .       OUTER BLOCK SD    @D@@@Y         LOADA   AAQ
)@@G@@2,AGRX9 .        SET INDEX THRU AW'S@ @@@Y         USING   SDSECT,X6 .  AR
)@@G@@@#@@@YBGDSP1   LABEL .  @C@@@Z         LOOP    R1,BGDSP5 .       DECREMEAS
)@@G@@NT R1 @#@@@ZBGDSP5   LABEL .  @G@@@Y         LOOP    A8,BGDSP2 .       LAT
)@@G@@OOP THRU 3 LEVELS OF ADDRESSING     @#@@@ZBGDSP0   LABEL .  @A@@@Y      AU
)@@G@@   LOAD    X4,SDBKAW,X11 .    @E@@@Y         MOVE    W1H1,AGRX10,I .   CAV
)@@G@@REATE CORE ADDRESS WORD @D@Z@Y         LOAD    X11,SDBSLD,X11 .    GET SAW
)@@G@@TATIC DEPTH @D@@@Z         LOAD    A8,SDBSLD,X11 .    GET STATIC DEPTH  AX
)@@G@@@F@Z@Y         SUB     X11,1,I .          ZELK SAYS IT'S ONE TOO MANY   AY
)@@G@@@F@@@Z         SUB     A8,1,I .          ZELK SAYS IT'S ONE TOO MANY    AZ
)@@G@@@E@Z@Y         STORE   X11,W1H2,X4 .      SAVEAWAY IN CORE AW     @D@@@ZBA
)@@G@@         STORE   A8,W1H2,X4 .      SAVEAWAY IN CORE AW@ @@@Z         LOOBB
)@@G@@P    R1,BGDSP6 .  @#@@@Z         JMP .    @#@@@ZBGDSP6   LABEL .  @D@@@ZBC
)@@G@@         LOAD    X11,SDBKLK,X11 .  GO OUT 1 LEVEL     @D@@@Z         IF BD
)@@G@@     X11,ZERO  THEN,JMP  ELSE,BGDSP0 .    @#@Z@Y         JMP  .   @#@@@YBE
)@@G@@BGDSP2   LABEL .  @I@Z@Y         IF      SD3OBK,ON,SDCLS3  THEN,BGDSP3 .BF
)@@G@@ ON UNIT BLOCK. SKIP THIS LEVEL     @H@@@Z         IF      SD3OBK,OFF,SDBG
)@@G@@CLS3  THEN,BGDSP4 . NOT UNIT BLOCK. DON'T SKIP  @D@@@Z         SUB     ABH
)@@G@@2,1,I .          SKIP THIS A.W.     @ @@@Z         LOOP    A8,BGDSP4 .  BI
)@@G@@@C@@@Z         GOTO    BGDSP0 .          FINISH UP    @#@@@ZBGDSP4   LABBJ
)@@G@@EL .  @A@@@Y         LOAD    X4,SDBKAW,X11 .    @E@@@Y         LOAD    ABK
)@@G@@6,W1,A2 .        MOVE AW FOR THIS LEVEL   @ @@@Y         STORE   A6,W1,XBL
)@@G@@4 .   @#@@@YBGDSP3   LABEL .  @ @@@Y         LOAD    X6,X11 .     @C@@@YBM
)@@G@@         SUB     A2,1,I .          GET NEXT AW  @D@@@Y         LOAD    XBN
)@@G@@11,SDBKLK,X11 .    GO OUT ONE LEVEL @F@@@Y. IF ZERO THEN LEVEL 0 REACHEDBO
)@@G@@ AND WE'RE DONE, OTHERWISE CONTINUE @#@@@Y. WITH NEXT LEVEL.@D@@@Y      BP
)@@G@@   IF      X11,ZERO  THEN,JMP   ELSE,BGDSP1 .   @ @@@Y . ---------------BQ
)@@G@@---------   @A@@@Y . GENERATE BRANCH WORD AROUND BLOCK@ @@@Y . ---------BR
)@@G@@----------------  @#@@@YDGBRCH* LLOC  .   @ @@@Y         LOADA X4,DCGLBLBS
)@@G@@ .    @D@@@Y. N.B:  PUT SOMETHING INTO X4 BEFORE LINKING TO HERE  @H@@@YBT
)@@G@@       IF CGFRMT+CGRCHB,OFF,DCGFL2  THEN,LJMP . -> BOTH OFF, NO BRANCH NBU
)@@G@@EEDED @#@@@Y         LOCAL .  @^@@@Y       GFIX  DBGWC1 .   @G@@@Y      BV
)@@G@@ GEN .                 GENERATE BRANCH AROUND PROC/BLOCK/FORMAT   @A@@@YBW
)@@G@@       GJUMP AGPTX4 .   UNCOND JUMP @F@@@Y       SET   CGFRMT,OFF,DCGFL2BX
)@@G@@ . NOTE ONE BRANCH HAS BEEN GENNED  @]@@@Y       JMP .@#@@@Y. ==========BY
)@@G@@===   @A@@@YDGNTRY* LLOC .   DEFINE ENTRY POINTS@E@@@Y       LOAD  X3,DCBZ
)@@G@@GELB .     START OF ENTRY LABEL CHAIN     @ @@@Y       MOVE  DCGELB,0,I CA
)@@G@@.     @#@@@YDGNTR1 LABEL .    @C@@@Y       IF  X3,ZERO  THEN,LJMP . -> ECB
)@@G@@ND OF CHAIN @G@@@Y       LOAD  A3,SDENAD,X3 .  NOT YET TO END, GET ADDR CC
)@@G@@OF NEXT ENTRY SD  @H@@@Y         STORE X10,SDENAD,X3 .         STORE CODCD
)@@G@@E ADDR IN CURRENT PROC SD     @D@@@Y         LOAD  X3,A3 .       POINT TCE
)@@G@@O NEXT PROC SD    @D@@@Y       GOTO  DGNTR1 .     CONTINUE TO END OF CHACF
)@@G@@IN    @^@@@Y/ .   PREFIX PROCESSOR  @#@@@YPGNCDE LABEL .    @G@@@Y      CG
)@@G@@ IF  DCGCDE,ON,DCGFLG  THEN,PGNXTS .  -> USEABLE CODE WAS GENED   @D@@@YCH
)@@G@@       GFIX  DBGWC1 .      BACKUP TO LAST USEABLE CODE@^@@@Y       GOTO CI
)@@G@@PGNXT0 .    @[@@@Y .    @ @@@Y .   WHICH STMT TO PROCESS    @[@@@Y .    CJ
)@@G@@@#@@@YPGSPLT LABEL .    @B@@@Y.         STATIC LANGUAGE ANALYSIS FIRST .CK
)@@G@@@D@@@Y         LOAD   A3,A8 .            STATEMENT TYPE     @D@@@Y      CL
)@@G@@   SRB    A3,9 .             UPPER 9 BITS ONLY  @B@@@Y         L,H2 A6,DCM
)@@G@@SRCGL-(ACBGIN/IC),A3 .  @^@@@Y         ADD   A6,1,I . @B@@@Y         S,HCN
)@@G@@2 A6,DSRCGL-(ACBGIN/IC),A3 .  @E@@@Y         LOAD  F,A8 .        SAVE FLCO
)@@G@@AGS FROM STATEMENT TYPE @B@@@Y       SRBD  A8,10 .        IN HALFWORDS  CP
)@@G@@@^@@@Y         LOAD  X2,A8 .  @C@@@Y       LOAD  X3,PGSTBL-(ACBGIN/IC)/2CQ
)@@G@@+FH1,X2 .   @E@@@Y       IF  A9,GE,0,I  THEN,PGSPL1 .   -> KEEP FIRST HACR
)@@G@@LFWORD@E@@@Y       LOAD  X3,PGSTBL-(ACBGIN/IC)/2+FH2,X2 .     GET HALF2 CS
)@@G@@@#@@@YPGSPL1 LABEL .    @C@@@Y       LINK  0,X3 .           PROCESS THISCT
)@@G@@ STMT @#@@@YPGNXTS LABEL .    @E@@@Y         LOAD  R11,DCGSNO . REMEMBERCU
)@@G@@ LAST STATEMENT CODED   @ @@@Y         STORE R11,DCGLST .   @F@@@YPGNXT0CV
)@@G@@*  LABEL .             ENTRY POINT FROM BLOCK INITIALIZATION@E@@@Y      CW
)@@G@@   LINK  BCKPGC . PREPARE TO LOOK AT B-CODE AGAIN     @F@@@Y       IF  0CX
)@@G@@400,OFF,LIMALX  THEN,PGSTRT . ->SUPRESS DEBUG LIST    @E@@@Y       LOAD CY
)@@G@@ X4,DPGSLC .     START LOCATION FOR DISASSEMBLY @C@@@Y         LOAD  X5,CZ
)@@G@@W1U,X10 . END OF CODE TO LIST @F@@@Y         SUB   X5,1,I .      MOVE ENDA
)@@G@@D POINTER BACK FROM FREE WORD @D@@@Y       LINK  LSTBGN .        -> CALLDB
)@@G@@ DISASSEMBLER     @#@@@YPGSTRT   LABEL  . @C@@@Y         GETC  . SKIP TODC
)@@G@@ NEXT START STATEMENT   @#@@@YPGNXT1   LABEL  . @E@@@Y         IF    A8,DD
)@@G@@LT,ACSTMT,I THEN,PGSTRT . -> NOT FOUND YET@D@@@Y       GMARK DPGSLC .  PDE
)@@G@@ROTECT BETACODE FOR THIS STMT @E@@@Y         LOAD  A3,X1 .       ESTABLIDF
)@@G@@SH BUFFER AREA FOR CODER@C@@@Y       SUB   A3,10,I . BOUND ON CODE TO GEDG
)@@G@@N     @^@@@Y       STORE A3,DCGGNB .@E@@@Y         MOVE  DCGINT,RGCORS,ADH
)@@G@@RGSIZ .  FREE ALL REGISTERS   @E@@@Y         MOVE   DCGFLG,0,I  .      NDI
)@@G@@O CODE GENERATED YET    @D@@@Y         LOAD  F,A8 .        SAVE FLAGS FODJ
)@@G@@R STATEMENT @F@@@Y         GETC .                        ADVANCE TO STATDK
)@@G@@EMENT NUMBER@E@@@Y         IF    ICTSSF,ON THEN,PGXX1 . STATEMENT WAS SUDL
)@@G@@PPLIED@D@@@Y         STORE A8,DCGSNO .   SET NEW STATEMENT NUMBER @^@@@YDM
)@@G@@         STORE A8,R11 . @#@@@YPGXX1    LABEL .  @G@@@Y         IF    ICTDN
)@@G@@ELF+ICTCNF,OFF THEN,PGCN99 . NO ELSE PREFIX OR CONT   @F@@@Y         MOVDO
)@@G@@E  DCGLST,0177777,I . THIS IS POSSIBLE ENTRY POINT    @D@@@Y         LOADP
)@@G@@D    A10,DCGGNB .      GET ADDR OF STMT-10@G@@@Y         ADD     A10,10,DQ
)@@G@@I .        THEY SUBTRACTED 10 BEFORE STORING    @G@@@Y         SUB     ADR
)@@G@@10,ADPBCM-FH2+FXH2 . REMOVE OFSET FOR MOVING BCODE .  @E@@@Y         SLBDS
)@@G@@     A10,1 .           MAKE A BCODE PTR IN A10  @E@@@Y         IF    ICTDT
)@@G@@CNF,ON THEN,PGCNT1 . A CONT STATEMENT     @^@@@Y . PROCESS ELSE PREFIX  DU
)@@G@@@E@@@Y         IF    SGDCS,OFF,SGDID THEN,PGXX4 . ->NOT CASE ELSE @D@@@YDV
)@@G@@         LINK  PGCSEL .            SET JUMP TO EXIT   @D@@@Y         GMADW
)@@G@@RK X10 .               GET PTR TO ELSE    @ @@@Y         LOAD  A3,SGDEOLDX
)@@G@@ .    @ @@@Y         STORE X10,W1H2,A3 .  @D@@@Y         SET   SGDELF,ONDY
)@@G@@,SGDCLS .  ELSE PRESENT FLAG  @B@@@Y         GOTO  PGCN99 .            -DZ
)@@G@@>MERGE@[@@@Y.     @[@@@Y.     @#@@@YPGCSEL   LOCAL .  @E@@@Y         SETEA
)@@G@@   DCGCDE,ON,DCGFLG .  SET VALID CODE GENNED    @F@@@Y         IF    SGDEB
)@@G@@FST,OFF,SGDCLS THEN,PGCSEX . ->FIRST PREFIX     @]@@@Y         GEN@^@@@YEC
)@@G@@         GJUMP SGDDOL . @#@@@YPGCSEX   LABEL .  @A@@@Y         SET   SGDED
)@@G@@FST,ON,SGDCLS .   @#@@@Y         JMP .    @#@@@YPGXX4    LABEL .  @D@@@YEE
)@@G@@         LOAD  A11,X7 . SAVE CURRENT TOP OF STACK     @#@@@YPGXX2    LABEF
)@@G@@EL .  @F@@@Y         IF    A10,EQ,SGDEPT THEN,PGXX3 . LOOP TO FIND STACKEG
)@@G@@ ENTRY@G@@@Y         ADD   X7,DCGSLT,I . NEXT STACK ENTRY, FOR THIS ELSEEH
)@@G@@ CLAUSE     @C@@@Y         GOTO  PGXX2 . -> TRY NEXT STACK ENTRY  @B@@@YEI
)@@G@@PGXX3    LABEL .     FOUND ELSE CLAUSE    @D@@@Y         MOVE  SGDIFD,0,EJ
)@@G@@I . CLEAR REACHABLE FLAGS     @G@@@Y         IF    CGRCHB,OFF,DCGFL2 THEEK
)@@G@@N,PGELS1 . CAN'T FALL THRU FROM THEN@#@@@Y         GEN .    @D@@@Y      EL
)@@G@@   GJUMP SGDELS . GEN BRANCH AROUND ELSE CLAUSE @A@@@Y         MOVE SGDIEM
)@@G@@FD,CGRCHB,I .     @C@@@Y         SET   DCGCDE,ON . CODE IS NOW GENERATEDEN
)@@G@@@#@@@YPGELS1   LABEL    @F@@@Y         SET   CGRCHB,ON,DCGFL2 . ELSE CLAEO
)@@G@@USE IS ALWAYS REACHABLE @#@@@Y         GEN .    @D@@@Y         GLABEL SGEP
)@@G@@DCNT . MARK TARGET OF IF BRANCH     @F@@@Y         MOVE  SGDCNT,SGDELS .EQ
)@@G@@ MOVE LABEL AW TO CORRECT FIELD     @D@@@Y         STORE A11,X7 . RESTORER
)@@G@@E TOP OF STACK POINTER  @[@@@Y.     @B@@@Y.        I THINK THAT THIS IS ES
)@@G@@WRONG...    @[@@@Y.     @C@@@Y.         STORE F,DCGFLG . RESTORE CODEGENET
)@@G@@ FLAGS@[@@@Y.     @E@@@Y         GOTO  PGCN99 . -> TEST FOR LABELS ON STEU
)@@G@@ATEMENT     @[@@@Y .    @C@@@Y . PROCESS CONTINUING STATEMENT (FOLLOWS IEV
)@@G@@F)    @[@@@Y .    @#@@@YPGCNT1   LABEL    @ @@@Y         LOAD  A13,SGDIDEW
)@@G@@ .    @G@@@Y         IF    A13,NE,SGDIF,I THEN,PGCN99 . NOT AN IF STACK EX
)@@G@@ELEMENT     @G@@@Y         IF    A10,NE,SGDCPT THEN,PGCN99 . -> CONTINUEEY
)@@G@@ PTRS DON'T MATCH @#@@@YPGCNT3   LABEL .  @G@@@Y         LOAD  A3,DCGFL2EZ
)@@G@@ . FOLLOWING IF IS REACHABLE IS ELSE,    *******@F@@@Y         OR,Q2    FA
)@@G@@A3,SGDIFD-(IN 9,Q2,0,0),X7 . OR THEN CLAUSE WILL@G@@@Y         STORE A4,FB
)@@G@@DCGFL2 . FALL THROUGH                          *******@[@@@Y .    @#@@@YFC
)@@G@@         GEN .    @E@@@Y         GLABEL SGDCNT . DEFINE LOCATION OF CONTFD
)@@G@@INUE BRANCH @D@@@Y       XGPOP 'SIZE',DCGSLT .      ERASE STACK ELEMENT FE
)@@G@@@[@@@Y .    @^@@@Y         GOTO  PGCNT1 . @[@@@Y .    @#@@@YPGCN99   LABFF
)@@G@@EL .  @F@@@Y         GMARK DBGWC1 .      MARK LOCATION OF STATEMENT STARFG
)@@G@@T     @E@@@Y         LOADXM X1,DCGGNB .  RELOAD ADDRESS OF ACSTMT - 10  FH
)@@G@@@E@@@Y         ADD   X1,10,I .     COMPUTE ADDRESS OF ACSTMT + 1  @ @@@YFI
)@@G@@         LOAD  A1,KLCH2W .    @#@@@Y         GETC .   @B@@@Y         LOAFJ
)@@G@@D  F,A8 .        SAVE FLAGS   @^@@@Y         USING WORD,X1 .@F@@@Y      FK
)@@G@@   SET   CGFRMT,ON,DCGFL2 . FORMAT LABEL NOT ENCOUNTERED    @F@@@Y      FL
)@@G@@   IF    ICTLBF,OFF THEN,PGSKLB . -> SKIP STATEMENT NUMBER  @ @@@Y . LOOFM
)@@G@@P FOR LABEL PREFIXES    @#@@@YPGLABL   LABEL .  @B@@@Y         GETC . NEFN
)@@G@@XT META-CODE SYLLABLE   @E@@@Y         IF    A8,LT,ACBSLH,I THEN,PGLABL FO
)@@G@@. SCAN NEXT M-CODE@C@@@Y         AND,U A8,0777000 .  GET RID OF FLAGS   FP
)@@G@@@G@@@Y         IF    A9,EQ,ACLABS,I THEN,PGLBLC . SUBSCRIPTED LABEL FOUNFQ
)@@G@@D     @F@@@Y         IF    A9,EQ,ACLABC,I THEN,PGLBLC . LABEL CONSTANT FFR
)@@G@@OUND  @E@@@Y         IF    A9,EQ,ACBSLH,I THEN,PGCAPF . -> \N\ PREFIX   FS
)@@G@@@G@@@Y         IF    A9,LT,(ACBGIN/IC)*IC,I THEN,PGLABL . -> SCAN NEXT MFT
)@@G@@-CODE @D@@@Y         GOTO  PGSTYP . -> PROCESS STATEMENT TYPE     @^@+@YFU
)@@G@@/.       CASE PREFIX \N\@#@@@+/.        \N\     @#@@@YPGCAPF   LABEL.   FV
)@@G@@@E@+@Y         LINK  PGCSEL .            SET BRANCH TO END OF CASE@^@@@+FW
)@@G@@         EXERR 0 LEVEL,3@#@@@YPGCAPF2  LABEL .  @E@+@Y         LOAD  X4,FX
)@@G@@SGDLOP .         NEXT PTR IN ARG LIST     @D@+@Y         LOAD  A9,SGDLULFY
)@@G@@ .         NUM. ARGS SEEN     @C@+@Y         LOAD  X3,SGDEOL .         EFZ
)@@G@@LSE PTR     @D@+@Y         LOAD  A7,1,I .             ASSUME + SIGN     GA
)@@G@@@C@+@Y         GETC .                    GET BCD PTR  @C@+@Y         IF GB
)@@G@@ A8,EQ,ACBPL,I THEN,PGCAQ1 . ->+    @E@+@Y         IF    A8,NE,ACBMN,I TGC
)@@G@@HEN,PGCAQ2 . ->NOT -, BCD PTR @C@+@Y         LOADN  A7,A7 .        MULTIGD
)@@G@@PLIER OF -1 @#@+@YPGCAQ1   LABEL .  @#@+@Y         GETC .   @#@+@YPGCAQ2GE
)@@G@@   LABEL .  @^@+@Y         LOAD  X11,A8 . @E@+@Y         IF    A7,EQ,1,IGF
)@@G@@ THEN,PGCAQ3 . ->POSITIVE PREFIX    @^@+@Y         LOADN A8,A8 .  @D@+@YGG
)@@G@@         SLB   A8,18 .         SET UPPER PART TO 0    @^@+@Y         SRBGH
)@@G@@   A8,18 .  @#@+@YPGCAQ3   LABEL .  @D@+@Y         LOAD  X5,SDBDLK,X11. GI
)@@G@@     SD PTR OF CONSTANT @ @+@Y         USING SDSECT,X5 .    @F@+@Y      GJ
)@@G@@   IF    SDARST,ON,SDCLS1 THEN,PGCAP1 . ->STRING PREFIX     @D@+@Y      GK
)@@G@@   LOAD  A10,SDFXPT+1,X5 .   GET VALUE OF \N\   @D@+@Y         MPYS  A10GL
)@@G@@,A7 .            SCALE TO + OR -1   @F@+@YPGCAP3   LABEL .              GM
)@@G@@     COMMON POINT FOR STRING PREFIX @D@+@Y         GMARK A7 .           GN
)@@G@@     CURRENT ADDRESS    @B@+@Y         SLB   A7,18 .             ADDR,0 GO
)@@G@@@B@+@Y         LOAD  A6,A8 .             BCD PTR@C@+@Y         SRBD  A6,GP
)@@G@@18 .             A7=BCD,ADDR  @ @+@Y         STORE A10,0,X4 .     @D@+@YGQ
)@@G@@         STORE A7,1,X4 .           SET VALUE, BCD-ADDR@^@+@Y         ADDGR
)@@G@@   X4,2,I . @C@+@Y         STORE X4,SGDLOP .         SAVE NEW ADDR@C@+@YGS
)@@G@@         LOAD  R1,A9 .             SAVE COUNT   @^@+@Y         ADD   A9,GT
)@@G@@1,I . @ @+@Y         STORE A9,SGDLUL .    @^@+@Y         LOADXI X3,2,I .GU
)@@G@@@D@+@Y         SE,H1 A8,2,*X3 .          SEE IF BCD IN LIST @A@+@Y      GV
)@@G@@   GOTO  PGCAP2 . ->OK SO FAR @A@+@Y         EXERR ERDUPL LEVEL,2 .     GW
)@@G@@@#@+@YPGCAP2   LABEL .  @#@+@Y         GETC .   @E@+@Y         IF      AGX
)@@G@@8,EQ,ACCOMA,I  THEN,PGCAPF2 .  DO NEXT ONE@E@+@Y         IF    SDARST,OFGY
)@@G@@F,SDCLS1 THEN,PGLABL . ->ARITH \N\  @G@+@Y         LOAD  A9,SDBCNT,X11 .GZ
)@@G@@     IF STRING OF LENGTH 1. OK ALREADY    @A@+@Y         IF    A9,LT,2,IHA
)@@G@@ THEN,PGLABL@#@+@Y         GEN .    @#@+@Y         GLIT 1   @ @+@Y      HB
)@@G@@   LMJ   A1,EXCASESC .  @ @+@Y         GOTO    PGLABL .     @ @+@Y      HC
)@@G@@   USING SDSECT,X5 .    @C@+@YPGCAP1   LABEL .                   STRING HD
)@@G@@PREFIX@D@+@Y         LOAD  A10,SDSTML .         LENGTH F STRING   @^@+@YHE
)@@G@@         SLB   A10,18 . @C@+@Y         ADD   A10,W1Q1+2,X11 .       FIRSHF
)@@G@@T CHAR@B@+@Y         GOTO  PGCAP3 .            MERGE .@^@@@Y/ .      LABHG
)@@G@@EL PREFIX   @D@@@Y .   COME HERE FOR SIMPLE OR SUBSCRIPTED LABEL PREFIX HH
)@@G@@@#@@@YPGLBLC   LABEL .  @C@@@Y         GETC .              READ THE LABEHI
)@@G@@L'S SD@A@@@Y         LSDP  X5,A8 . LABEL'S SD   @ @@@Y       LOAD  F,SDCHJ
)@@G@@LS4,X5 .    @E@@@Y         IF    SD4FLB,ON  THEN,PGFLAB . -> FORMAT LABEHK
)@@G@@L     @F@@@Y         SET   CGRCHB,ON,DCGFL2 . LABELED STATEMENTS ARE REAHL
)@@G@@CHABLE@D@@@Y         IF    SD4ENT,ON  THEN,PGNTRY . -> ENTRY LABEL@G@@@YHM
)@@G@@         MOVE DCGLST,0177777,I . WITH TARGET OF GOTOS, FORCE STMT NO.   HN
)@@G@@@ @@@Y         USING SDSECT,X5 .    @#@@@YPGLAB1   LABEL .  @D@@@Y      HO
)@@G@@ MOVE  SDLCHN,ADPCLC . ADD LABEL TO LABEL CHAIN @E@@@Y        STORE A8,AHP
)@@G@@DPCLC .    CURRENT SD BECOMES CHAIN HEAD  @E@@@Y       GMARK SDADD .    HQ
)@@G@@ DEFINE LABEL AS CURRENT LOCATION   @F@@@Y       IF  SDCHCK,OFF,SDCLS3  HR
)@@G@@THEN,PGLAB3 . -> LABEL NOT CHACKED  @#@@@Y       GENM .     @E@Z@Y      HS
)@@G@@ GSUB  EXCHK .         GENERATE CALL TO CHECK ROUTINE @E@@@Z       GSUB HT
)@@G@@ ONCHK .         GENERATE CALL TO CHECK ROUTINE @B@@@Y       GLITRG A8 .HU
)@@G@@      SD PTR INTO CODE  @#@@@Y       GFIN .     @E@@@Y       SET   DCGCDHV
)@@G@@E,ON,DCGFLG .     CODE HAS BEEN GENERATED @#@@@YPGLAB3   LABEL .  @F@@@YHW
)@@G@@       MOVE  SDLLIM-FH1,DCGLLL-FH1,2 .    INITIALIZE LIMITS, ETC  @F@@@YHX
)@@G@@         STORE R11,SDDCNM,X5 .         SET SOURCE STATEMENT NUMBER@D@@@YHY
)@@G@@       GOTO  PGLABL .        -> SCAN FOR MORE LABELS  @#@@@YPGFLAB   LABHZ
)@@G@@EL .  @A@@@Y       LOADA X4,DAGFMT-AGRX0+AGAW . @C@@@Y       LINK  DGBRCIA
)@@G@@H+1 .       GEN BR AROUND FMT @D@@@Y       GMARK DBGWC1 .       MARK LOCIB
)@@G@@ OF LAST FMT LABEL@^@@@Y       GOTO  PGLAB1 .   @ @@@Y         USING SDSIC
)@@G@@ECT,X5 .    @C@@@YPGNTRY LABEL .               PROCESS ENTRY LABEL@E@@@YID
)@@G@@       MOVE  SDENAD,DCGELB .       LIFO CHAIN OF ENTRY SD'S @ @@@Y      IE
)@@G@@   STORE X5,DCGELB .    @^@@@Y       GOTO  PGLABL .   @[@@@Y .    @#@@@YIF
)@@G@@PGSKLB LABEL .    @]@@@Y       GETC @#@@@YPGSKLP LABEL .    @]@@@Y      IG
)@@G@@ GETC @G@@@Y       IF  A8,LT,(ACBGIN/IC)*IC,I  THEN,PGSKLP .  -> SCAN NEIH
)@@G@@XT META-CODE@#@@@YPGSTYP LABEL .    @C@@@Y         STORE A8,DCGSRS .    II
)@@G@@  SAVE STMT TYPE  @E@@@Y       LOADA X11,PGSPLT .          USE THIS BELOIJ
)@@G@@W TO RETURN @G@@@YPGMVIS*   LLOC  .      GENERATE CODE TO IDENTIFY STMT IK
)@@G@@DURING EXECUTION  @^@@@Y       LOAD  A2,R11 .   @F@@@Y       IF  A2,EQ,DIL
)@@G@@CGLST  THEN,LJMP .   ->NO CHANGE ->NO NEW CODE  @C@@@YPGMVBT   LOCAL .  IM
)@@G@@           CALLED FROM DGDOSP @H@@@Y         LOAD  A3,DGOPT3 .          IN
)@@G@@   PUT OPTIONS WHERE IGEN CAN GET THEM    @B@@@Y         OR,Q3 A3,DGOXRFIO
)@@G@@-(IN 63,Q3,1,0)   @ @@@Y         STORE A4,DGFLGZ .    @E@@@Y         IF IP
)@@G@@ A2,LT,DHNUM,I  THEN,PGMV2 . ROOM IN HISTOGRAM? @B@@@Y         SET     0IQ
)@@G@@200,OFF,DGFLGZ . NOPE   @ @@@YPGMV2    LABEL . ->MERGE HERE @F@@@Y      IR
)@@G@@   STORE R11,AGX0OF .   SET STATEMENT NUMBER FOR GENERATION @F@@@Y      IS
)@@G@@   GENM .                        FIX THE STATEMENT NUMBER   @G@@@Y      IT
)@@G@@   GINST OPLR,AGRX11,AGXR0,U 'NO' . FAKE LR R11 WITH STMT NUMBER  @B@@@YIU
)@@G@@         GBOFF PGMV3,0001 . -> NO TRACE   @D@@@Y         GSUB  EXTRAC   IV
)@@G@@       CALL TRACE ROUTINE     @#@@@YPGMV3    GLBL .   @D@@@Y         GBOIW
)@@G@@FF PGMV1,0200 . -> NO HISTOGRAM REQUIRED  @E@@@Y         GBOFF PGMV4,002IX
)@@G@@0 . -> NO STAT LANG ANAL. HIST ONLY @C@@@Y          GAPPN PGSTLA .    GEIY
)@@G@@T LMJ INST SET UP @^@@@Y         GLITRG A7 .    @C@@@Y          GGOTO PGIZ
)@@G@@MV1 .      -> FINISH ICODES   @#@@@YPGMV4    GLBL .   @G@@@Y         GSUJA
)@@G@@B  EXHIST .      ADD TO HISTORIOGRAM COUNT FOR STATEMENT    @C@@@YPGMV1 JB
)@@G@@   GLBL .              MERGE TO FINISH    @#@@@Y         GFIN .   @A@@@YJC
)@@G@@         JMP . -> RETURN TO CALLER  @E@@@YPGSTLA   GLBL .               JD
)@@G@@GET STATIC LANG ANAL ADDR.    @C@@@Y         LOAD  A3,DCGSRS .   STATEMEJE
)@@G@@NT TYPE     @C@@@Y         SRB   A3,9 .        LOWER 9 BITS ONLY  @B@@@YJF
)@@G@@         SUB   A3,ACBGIN/IC,I .   0-30    @B@@@Y         SLB   A3,1 .   JG
)@@G@@         0-60     @C@@@Y         AA    A3,DSRLMJ .       SET LMJ INST   JH
)@@G@@@E@@@Y         STORE A3,DCGSV4+1 .     SET AS A7 IN SAVE AREA     @#@@@YJI
)@@G@@         LJMP .   @D@@@YDSRLMJ   LMJ   X11,EXMETR .      CALL METRIC ROUJJ
)@@G@@TINE .@A@@@-/.        UNIMPLEMENTED FEATURES    @#@@@-DGLEAV*   LABEL   JK
)@@G@@@#@@@-DGWRIT*   LABEL   @#@@@-DGREAD*   LABEL   @^@@@-         EXERR 0 LJL
)@@G@@EVEL,3@ @@@Y/ .       ALLOCATE AND FREE   @[@@@Y.     @[@@@Y.     @#@@@YJM
)@@G@@DGALLC     LLOC . @ @@@Y         USING   WORD,X5 .    @#@@@YDGALNX   LABJN
)@@G@@EL .  @F@@@Y         LOAD    X5,X1 .           SAVE PTR TO BEGIN OF B COJO
)@@G@@DE    @E@@@Z         LOAD    A3,W1H2+2 .       GET SD OF THING TO ALLOC JP
)@@G@@@D@@@Z         USING   SDSECT,A3 .       SEE IF IT HAS A DV @B@@@Z      JQ
)@@G@@   IF SDDVA,NZERO THEN,DGALLC1 .    @E@@@Z         LOAD    F,SDCLS4 .   JR
)@@G@@     SET TO SEE IF STRUCT     @D@@@Z         IF SDSTRU,OFF THEN,DGALL0 .JS
)@@G@@ -> IF NOT STRUCT @#@@@ZDGALLC1  LABEL .  @ @@@Z         STORE   A3,AGX0JT
)@@G@@OF .  @#@@@Z         GENM .   @D@@@Z         GINST   OPLA,AGRA1,AGXR0,U JU
)@@G@@. LOAD SD OF THING@B@@@Z         GSUB    EXADVF . GO FILLIN DV    @#@@@ZJV
)@@G@@         GFIN .   @#@@@YDGALL0   LABEL .  @E@@@Y         IF      W1H2+1,JW
)@@G@@ZERO  THEN,DGALL1 . NO SET PHRASE   @E@@@Y         LMCP  R,W1H2+1 .     JX
)@@G@@     GET PTR TO SET PHRASE    @D@@@Y         XGEN  R,2 .               EJY
)@@G@@VALUATE SET PHRASE@ @@@Y         GOTO    DGALL2 .     @#@@@YDGALL1   LABJZ
)@@G@@EL .  @B@@@Y         LOAD    A3,W1H2+2 .       SD ADDR@D@@@Y         LOAKA
)@@G@@D    A8,SDBPTR,A3 .    GET IMPLIED PTR    @ @@@Y         XGEN I 'SINGLE'KB
)@@G@@ .    @#@@@YDGALL2   LABEL .  @#@@@Y         GENM .   @B@@@Y         GINKC
)@@G@@ST   OPLA,AGRA3,AGRL1,U 'NO' .@ @@@Y         GSUB    PTRUNL .     @#@@@YKD
)@@G@@         GFIN .   @B@@@Y         LOAD    A7,W1H2+2 .       SD ADDR@D@@@YKE
)@@G@@         OR      A7,LAFUDG .       LA,U A1,SD ADDR    @#@@@Y         GENKF
)@@G@@ .    @^@@@Y         GLITRG  A8 .   @E@@@Y         IF      W1H1+1,ZERO  KG
)@@G@@THEN,DGALL3 . NO IN PHRASE    @E@@@Y         LMCP  R,W1H1+1 .          GKH
)@@G@@ET PTR TO IN PHRASE     @D@@@Y         XGEN  R,2 .               EVALUATKI
)@@G@@E IN PHRASE @#@@@Y         GEN .    @D@@@Y         GINST  OPLA,AGRA3,AGRKJ
)@@G@@L1,U . LA,U A3,AREA ADDR@A@@@Y         XGPOP . POP LATEST ENTRY   @ @@@YKK
)@@G@@         GOTO    DGALL4 .     @#@@@YDGALL3   LABEL .  @#@@@Y         GENKL
)@@G@@ .    @^@@@Y         GLIT    1 .    @D@@@Y         LOAD    A3,SYSARE,I .KM
)@@G@@     USE SYSTEM AREA    @#@@@YDGALL4   LABEL .  @#@@@Y         GENM .   KN
)@@G@@@D@@@Y         GINST   OPLA,AGRA2,AGRL1,U . LA,U A2,PTR ADDR@ @@@Y      KO
)@@G@@   GSUB    EXALLC .     @[@@@Y.     @^@@@Y.        INITIALIZE?    @[@@@YKP
)@@G@@.     @#@@@Y         GFIN .   @C@@@Y         XGPOP                  .  CKQ
)@@G@@LEAR STACK  @F@@@Y         IF      W1H2,ZERO  THEN,PGNXTS . NOTHING MOREKR
)@@G@@ TO ALLOCATE@^@@@Y         LMCP  W1H2 .   @E@@@Y         GOTO    DGALNX KS
)@@G@@.          PROCESS NEXT VARIABLE    @]@@@Z/. FREE STMT@[@@@Z.     @^@@@YKT
)@@G@@DGFREE      LABEL .     @ @Z@Y             EXERR  0  LEVEL,3@F@@@Z      KU
)@@G@@   LOAD    X5,X1 .           SAVE PTR TO BEGIN OF BCODE     @E@@@Z      KV
)@@G@@   LOAD    X6,W1H1+2 . GET SD AT START OF FREE EXPR   @D@@@Z         LOAKW
)@@G@@D    F,SDCLS0,X6 .     SEE IF BSD OR PTR  @F@@@Z         IF SD0BSD++SD0CKX
)@@G@@NT,OFF THEN,DGFRE3 . -> IF IT IS A PTR    @D@@@Z         LOAD    A8,SDBPKY
)@@G@@TR,X6 .    GET IMPLIED PTR    @ @@@Z         GOTO    DGFRE9 .     @E@@@ZKZ
)@@G@@DGFRE3   LABEL .                   SEE IF SCALER PTR USED   @ @@@Z      LA
)@@G@@   LOAD    F,SDCLS2,X6 .@E@@@Z         IF SDARRY,ON THEN,DGFRE4 . -> IF LB
)@@G@@ARRAY REFRENCE    @E@@@Z         LOAD    A8,X6 .           SET THE PTR FLC
)@@G@@OR XGEN     @G@@@Z         LOAD    X6,W1H2+2,X5 .    GET THE SD OF THE VLD
)@@G@@AR FOR RESOLVING  @ @@@Z         GOTO    DGFRE9 .     @G@@@ZDGFRE4   LABLE
)@@G@@EL . PTR ARRAY REFERENCE, FIND END BY COUNTING LFT & RGT    @E@@@Z.     LF
)@@G@@   PARENS AND INSERT -!  SO IT CAN BE PASSED TO XGEN  @[@@@Z.     @G@@@ZLG
)@@G@@         LOAD    A3,1,I .          START COUNT AT ONE FOR LFT PAREN     LH
)@@G@@@D@@@Z         SETGC   2,W1+3,X5 .         START AFTER '('  @#@@@ZDGFRE5LI
)@@G@@  LABEL .   @#@@@Z         GETC .   @D@@@Z         IF A8,NE,ACLBRK,I THELJ
)@@G@@N,DGFRE6 . -> IF NOT '('@D@@@Z         ADD     A3,1,I .          POP ONELK
)@@G@@ FOR '('    @ @@@Z         GOTO    DGFRE5 .     @^@@@ZDGFRE6   LABEL . NLL
)@@G@@OT '('@D@@@Z         IF A8,NE,ACRBRK,I THEN,DGFRE5 . -> NOT ')'   @ @@@ZLM
)@@G@@         SUB     A3,1,I .     @G@@@Z         IF A3,NE,0,I THEN,DGFRE5 . LN
)@@G@@-> IF COUNT HASNT GONE TO 0 YET     @[@@@Z.     @F@@@Z         GETC .  GLO
)@@G@@ET THE SD AFTER THE ARRAY EXP END FOR RESOLVE   @^@@@Z         STORE   ALP
)@@G@@8,X6 .@H@@@Z         LOAD    A3,ACENEX,I .     GET AN -! FOR STORING OVELQ
)@@G@@R SPOT JUST READ  @F@@@Z         TE      A1,KLCH2W .       IF = THEN GETLR
)@@G@@C IS SET FOR H1   @ @@@Z         GOTO    DGFRE7 .     @G@@@Z         SUBLS
)@@G@@     X1,1,I .          BCODE IS  ) SD  WITH X1 -> NEXT WORD @ @@@Z      LT
)@@G@@   STORE   A3,W1H2,X1 . @ @@@Z         GOTO    DGFRE8 .     @#@@@ZDGFRE7LU
)@@G@@   LABEL .  @I@@@Z         STORE   A3,W1H1,X1 .      BCDE IS   * ) SD ->LV
)@@G@@  WITH X1 -> TO WD WITH SD    @#@@@ZDGFRE8   LABEL    @G@@@Z         SETLW
)@@G@@GC   2,W1+1,X5 .        SET TO READ ARRAY REFERNCE FOR XGEN @^@@@Z      LX
)@@G@@   XGEN    R,2 .  @ @@@Z         GOTO    DGFR10 .     @[@@@Z.     @[@@@ZLY
)@@G@@.     @C@@@ZDGFRE9   LABEL . MERGE FROM SIMPLE PTR CASE     @C@@@Z      LZ
)@@G@@   XGEN    I 'SINGLE' . PUT PTR ON STK    @#@@@ZDGFR10   LABEL .  @E@@@ZMA
)@@G@@         STORE   X6,AGX0OF .       STORE SD FOR RESOLVE     @#@@@Z      MB
)@@G@@   GENM .   @D@@@Z         GINST   OPLA,AGRA3,AGRL1,U . LA,U A3,PTRADDR MC
)@@G@@@D@@@Z         GINST   OPLA,AGRA2,AGXR0,U . LA,U A2,SDADDR  @D@@@Z      MD
)@@G@@   GSUB    PTRVER .          LMJ X11,RESOLVE    @#@@@Z         GFIN .   ME
)@@G@@@D@@@Z         IF W1H1+1,NZERO THEN,DGFRE2 . -> IF IN PHRASE@A@@@Z      MF
)@@G@@   GEN .   USE SYSTEM AREA    @#@@@Z         GLIT 1 . @ @@@Z         LOAMG
)@@G@@D    A1,SYSARE,I .@ @@@Z         GOTO    DGFR11 .     @A@@@ZDGFRE2   LABMH
)@@G@@EL . AREA SPECIFIED     @E@@@Z         LMCP    R,W1H1+1 .        GET PTRMI
)@@G@@ TO IN PHRASE     @F@@@Z         XGEN    R,2 .             PUT AREA PHRAMJ
)@@G@@SE ON TOP OF STK  @#@@@Z         GEN .    @F@@@Z         GINST   OPLA,AGMK
)@@G@@RA1,AGRL1,U . LA,U A1,AREA TO FREE IN     @#@@@Z         XGPOP .  @#@@@ZML
)@@G@@DGFR11   LABEL .  @#@@@Z         GENM .   @H@@@Z         GINST   OPLA,AGMM
)@@G@@RA3,AGRL1,U . LA,U A3,VERIFIED PTR (PTRADDR IS ON STK)@C@@@Z         GSUMN
)@@G@@B    EXFREE .          LMJ X11,FREE @^@@@Z         GFIN 'POP' .   @G@@@ZMO
)@@G@@         IF W1H2,ZERO THEN,PGNXTS . -> IF NO OTHER VAR ON FREE STMT     MP
)@@G@@@F@@@Z         LMCP    R,W1H2 .          START ALL OVER WITH NEXT PHRASEMQ
)@@G@@@ @@@Z         GOTO    DGFREE .     @A@@@Y/.       ON AND REVERT STATEMEMR
)@@G@@NTS   @B@@@YDGRVRT   LLOC .  REVERT STMT ENTRY PT     @F@@@Y         LOAMS
)@@G@@D    X5,X1 .           SAVE PTR TO BEGIN OF B CODE    @D@Z@Y         MOVMT
)@@G@@E    DCGSV7,0,I .      CLEAR FLAG AREA    @D@@@Z         MOVE    DCGSVF1MU
)@@G@@,1,I .      SET REVERT FLAG   @F@Z@Y         SET     01,ON,DCGSVF1 .   SMV
)@@G@@ET FLAG INDICATING REVERT     @D@@@Z         LOAD    A9,W1Q2 .         GMW
)@@G@@ET FLAGS+# IN LIST@F@@@Z         SRBD    A9,7  .           SEPARATE FLAGMX
)@@G@@S FROM # IN LIST  @^@@@Y         GOTO    DGON1 .@A@@@YDGON     LLOC .  OMY
)@@G@@N STMT ENTRY PT   @D@@@Y         LOAD    X5,X1 .           SAVE PTR TO BMZ
)@@G@@ CODE @D@@@Y         MOVE    DCGSV7,0,I .      CLEAR FLAG AREA    @E@@@ZNA
)@@G@@         LOAD    A9,W1Q2 .         GET FLAGS +  # IN LIST   @F@@@Z      NB
)@@G@@   SRBD    A9,7  .           SEPARATE FLAGS FROM # IN LIST  @G@@@Z      NC
)@@G@@   LOAD    A7,ADBK0S .       USE BLOCK 0 SD AS DUMMY IF  SYSTEM   @F@@@ZND
)@@G@@         IF      ONSYST,ON,A9  THEN,DGON0 . SYSTEM=>NO BLOCK SD   @D@Z@YNE
)@@G@@         LOAD A7,W1H1+1 .          GET SD OF BLOCK    @D@@@Z         LOANF
)@@G@@D A7,W1H2   .          GET SD OF BLOCK    @#@@@ZDGON0    LABEL .  @C@@@ZNG
)@@G@@         LOAD    X5,A7 .           SAVE BLOCK SD@ @@@Z         GETC .  SNH
)@@G@@KIP BLOCK SD@F@@@Y         OR      A7,LXFUDG .       CREATE LX,U X5,BLOCNI
)@@G@@K SD ADDR   @#@@@Y         GEN .    @C@@@Y         GLITRG  A8 .         NJ
)@@G@@     GEN INSTR    @^@@@YDGON1    LABEL . MERGE  @E@Z@Y         LOAD    ANK
)@@G@@3,W1H2 .         GET FLAGS +  # IN LIST   @F@Z@Y         SRBD    A3,16 .NL
)@@G@@           SEPARATE FLAGS FROM # IN LIST  @C@Z@Y         STORE   A3,DCGSNM
)@@G@@VF2 .      SAVE FLAGS   @C@@@Z         STORE   A9,DCGSVF2 .      SAVE FLNN
)@@G@@AGS   @C@Z@Y         SRB     A4,20 .           GET # IN LIST@D@@@Z      NO
)@@G@@   SRB     A10,29 .           GET # IN LIST     @E@Z@Y         LOAD    ANP
)@@G@@10,A4 .          SAVE # FOR LOOP COUNT    @^@Z@Y         LOAD    A7,A4 .NQ
)@@G@@@ @@@Z         LOAD    A7,A10 .     @F@Z@Y         OR      A7,LACOND .  NR
)@@G@@     CREATE LA,U A15,# OF CONDITIONS@F@@@Z         OR      A7,LAFUDG .  NS
)@@G@@     CREATE LA,U A1,# OF CONDITIONS @#@@@Y         GEN .    @^@@@Y      NT
)@@G@@   GLITRG  A8 .   @C@@@Y         IF      01,ON,DCGSVF1  THEN,DGON2 .    NU
)@@G@@@#@@@Y         GEN .    @D@@@Y         GSUB    ONSTMT .          LMJ X11NV
)@@G@@,ON STMT    @C@Z@Y         GETC .  ALIGN GETC REGS TO SD OF BLOCK @ @@@YNW
)@@G@@         GOTO    DGONLP .     @#@@@YDGON2    LABEL .  @#@@@Y         GENNX
)@@G@@ .    @D@@@Y         GSUB    REVRT .           LMJ X11,REVERT     @C@@@YNY
)@@G@@DGONLP   LABEL . LOOP THROUGH LIST OF CONDITIONS@ @@@Y         LOOP    ANZ
)@@G@@10,DGON3 .  @E@@@Z         LINK    BCKPGC .          BACKUP GETC ONE TOKOA
)@@G@@EN    @F@@@Z         IF      01,ON,DCGSVF1  THEN,PGNXTS . REVERT=>NO BLOOB
)@@G@@CK SD @ @@@Z         LOAD    A3,ADBK0S .  @G@@@Z         IF      A3,EQ,XOC
)@@G@@5  THEN,PGNXTS . WAS SYSTEM=>NO ON UNIT BLOCK   @D@@@Z         LOADA   XOD
)@@G@@5,SDONAW,X5 .    GET ADDRESS OF AW  @F@@@Z         GEN .                OE
)@@G@@     GEN JUMP AROUND ON UNIT BLOCK  @ @@@Z         GJUMP   AGPTX5 .     OF
)@@G@@@C@@@Y         GOTO    PGNXTS .          FINISHED     @B@@@YDGON3    LABOG
)@@G@@EL . PROCESS NEXT CONDITION   @H@Z@Y         GETC .  ALIGN GETC REGS TO OH
)@@G@@CONDITION(SKIP , OR BLOCK SD OR # IN LIST)@B@@@Y         GETC .  GET AC OI
)@@G@@CONDITION CODE    @^@Z@Y         SLBD    A8,27 .@^@@@Z         SRBD    AOJ
)@@G@@8,9  .@G@@@Z         SRB     A9,27 .           GET HAVE COND. # IN A9 IFOK
)@@G@@ NOT CHECK  @C@Z@Y         LOAD    A9,025,I .        ASSUME CHECK @F@Z@YOL
)@@G@@         IF      A7,GE,0332,I  THEN,DGON5 . IT'S CHECK ALRIGHT    @D@@@ZOM
)@@G@@         IF      A8,LE,0331,I  THEN,DGON5 . NOT CHECK @C@@@Z         LOAON
)@@G@@D    A9,025,I .        SET CHECK    @E@Z@Y         SRB     A8,27 .      OO
)@@G@@     JUST HAVE COND. # IN A8  @H@Z@Y         LOAD    A9,A8 .           AOP
)@@G@@9 WILL COONTAIN LITERAL IN CALLING LIST   @#@@@YDGON5    LABEL .  @^@@@ZOQ
)@@G@@         LOAD    A7,A9 .@C@@@Y         SLB     A9,9 .            0,CODE OR
)@@G@@#,0   @D@@@Y         ADD     A9,DCGSVF2 .       0,CODE #,FLAGS    @D@@@YOS
)@@G@@         SLB     A9,18 .           CODE #,FLAGS,0     @E@Z@Y         IF OT
)@@G@@     A8,LT,015,I  THEN,DGON4 . NOT COND(REF)    @E@@@Z         IF      AOU
)@@G@@7,LT,015,I  THEN,DGON4 . NOT COND(REF)    @E@Z@Y         XGEN    R,2 .  OV
)@@G@@           EVALUATE NAME IN EXPR    @F@@@Z         ADD     X1,1,I .     OW
)@@G@@     GET TO SD OF NAME OF VARIABLE  @B@@@Z         GETC .               OX
)@@G@@     GET SD @E@Z@Y         ADD     A9,SGDRSD .       CODE #,FLAGS,SD ADDOY
)@@G@@R     @D@@@Z         ADD     A9,A8 .       CODE #,FLAGS,SD ADDR   @A@Z@YOZ
)@@G@@         XGPOP . POP ENTRY OFF STACK@F@@@Z         ADD     X1,1,I .     PA
)@@G@@     SKIP TO COMMA IF LIST OF CONDS @#@@@YDGON4    LABEL .  @A@@@Y      PB
)@@G@@   GEN .   PUT LITERAL IN CODE@^@@@Y         GLITRG  A9 .   @D@@@Z      PC
)@@G@@   GETC .                    SKIP COMMA IF ANY  @B@@@Y         GOTO    DPD
)@@G@@GONLP .          NEXT?  @ @@@Y/.       SIGNAL STATEMENT     @[@@@Y.     PE
)@@G@@@A@@@YDGSIGN   LABEL . ENTRY FOR SIGNAL   @E@@@Y         GETC .         PF
)@@G@@           GET ACODE OF CONDITION   @C@Z@Y         LOAD    A7,A8 .      PG
)@@G@@     SAVE ACODE   @C@@@Z         STORE   A8,DCGSV7 .       SAVE ACODE   PH
)@@G@@@F@Z@Y         SLBD    A7,27 .           SHIFT OUT FIRST HALF OF CODE   PI
)@@G@@@E@@@Z         SRBD    A8,9  .           SHIFT OUT CONDITION #    @D@Z@YPJ
)@@G@@         SRB     A7,27 .           GET CONDITION #    @D@@@Z         SRBPK
)@@G@@     A9,27 .           GET CONDITION #    @D@@@Z         IF      A8,LT,0PL
)@@G@@332,I  THEN,DGSGN0 . NOT CHECK@E@@@Z         LOAD    A9,025,I .        SPM
)@@G@@ET CHECK COND NUMBER    @#@@@ZDGSGN0   LABEL .  @E@Z@Y         IF      APN
)@@G@@7,LT,015,I  THEN,DGSGN1 . NO SD NEEDED    @E@@@Z         IF      A9,LT,0PO
)@@G@@15,I  THEN,DGSGN1 . NO SD NEEDED    @G@Z@Y         IF      A6,GE,0332,I PP
)@@G@@ THEN,DGSGN1 . CHECK - ALSO NO SD NEEDED  @E@Z@Y         XGEN    R,2 .  PQ
)@@G@@           EVALUATE EXPR FOR SD     @D@@@Z         ADD     X1,1,I .     PR
)@@G@@     GET TO SD OF NAME  @B@@@Z         GETC .                    GET SD PS
)@@G@@@D@Z@Y         LOAD    A9,SGDRSD .       GET SD OF NAME     @C@@@Z      PT
)@@G@@   LOAD    A9,A8 .       GET SD OF NAME   @ @Z@Y         OR      A9,LA9FPU
)@@G@@DG .  @ @@@Z         OR      A9,LXFUDG .  @#@@@Y         GEN .    @D@Z@YPV
)@@G@@         GLITRG  A10 .             GEN  LA,U A9,SD    @D@@@Z         GLIPW
)@@G@@TRG  A10 .             GEN  LA,U X5,SD    @#@Z@Y         XGPOP .  @#@@@YPX
)@@G@@DGSGN1   LABEL .  @#@@@Y         GEN .    @D@@@Y         GSUB    ONMNGR PY
)@@G@@.          CALL ON UNIT MNGR  @C@@@Z         LOAD    A9,86,I .         SPZ
)@@G@@IGNAL MSG # @C@@@Z         SLB     A9,9 .            0,MSG #,0    @D@Z@YQA
)@@G@@         LOAD    A9,2,I .          MSG # = 0,LEVEL=2  @B@@@Z         ADDQB
)@@G@@     A9,2,I .          LEVEL=2@C@@@Y         SLB     A9,18 .           MQC
)@@G@@SG #,LEVEL,0@D@Z@Y         ADD     A9,A8 .           MSG #,LEVEL,ACODE  QD
)@@G@@@D@@@Z         ADD     A9,DCGSV7 .       MSG #,LEVEL,ACODE  @#@@@Y      QE
)@@G@@   GENM .   @^@@@Y         GLITRG  A9 .   @^@@@Y         GLIT    2 .    QF
)@@G@@@#@@@Y         +0,0 .   @#@@@Y         +0,0 .   @#@@@Y         GFIN .   QG
)@@G@@@E@@@Y         LOAD    A9,5,I .          SET SIGNAL+RETURN FLAGS  @^@@@YQH
)@@G@@         SLB     A9,27 .@F@@@Y         LOADXM  X5,X10 .          GET CURQI
)@@G@@RENT ADDR IN GEN CODE   @ @@@Z         LOADXI  X5,0,I .     @F@Z@Y      QJ
)@@G@@   A,H2    A9,X5  .          PUT IN CURRENT POS. IN CODE    @F@@@Z      QK
)@@G@@   ADD     A9,X5  .          PUT IN CURRENT POS. IN CODE    @E@@@Y      QL
)@@G@@   ADD     A9,3,I .          RETURN ADDR FROM ONUNIT  @#@@@Y         GENQM
)@@G@@M .   @E@@@Y         GLITRG  A9 .              GEN. FLAGS,0,RETURN ADDR QN
)@@G@@@B@@@Y         GLITRG  A9 .              DITTO  @B@@@Y         GLITRG  AQO
)@@G@@9 .              DITTO  @#@@@Y         GFIN .   @B@@@Y         GOTO    PQP
)@@G@@GNXTS .          DONE   @[@@@Z.     @C@@@Z.       FUDGE FOR IGNORING SYSQQ
)@@G@@TEM STATEMENT     @[@@@Z.     @E@@@ZDGSYST   LABEL .                   HQR
)@@G@@ERE TO SKIP SYSTEM STMT @G@@@Z         GETC .                    HAVE TOQS
)@@G@@ GET A TOKEN TO AVOID LOOP    @B@@@Z         GOTO    PGNXTS .          DQT
)@@G@@ONE   @ @@@Y/ .     PROC STATEMENT DRIVER @#@@@YDGPROC LABEL .    @B@@@YQU
)@@G@@       GETC .           BLOCK SD PTR.     @D@@@Y       LOAD  X4,X9 .    QV
)@@G@@     ENCLOSING BLOCK'S SD     @E@@@Y       GFIX  DBGWC1 .        BACKUP QW
)@@G@@TO ERASE STMT IDENT     @^@@@Y       USING SDSECT,X4. @#@@@YDGPRCL LABELQX
)@@G@@ .    @A@@@Y                                   .@F@@@Y. IF THE CODE IS CQY
)@@G@@HANGED TO NOT REQUIRE A LABEL ON EVERY PROC     @D@@@Y. THIS IS ONE OF TQZ
)@@G@@HE PLACES THAT A CHANGE MUST BE MADE@A@@@Y                              RA
)@@G@@     .@F@@@Y       LSDP  X4,SDNXDC,X4 .    FOLLOW CHAIN OF VBLES IN BLOCRB
)@@G@@K     @F@@@Y       IF  SD4ENT,OFF,SDCLS4  THEN,DGPRCL .    -> NOT AN ENTRC
)@@G@@RY    @G@@@Y       IF  A8,NE,SDENBK  THEN,DGPRCL .     -> NOT AN ENTRY TRD
)@@G@@O THIS PROC.@D@@@Y       MOVE  SDENUM,0,I .    FIRST ENTRY GETS NUMBER 0RE
)@@G@@@E@@@Y         LOAD  A7,1,I .      SECOND OFFSET (ENTRY NUMBER)   @^@@@YRF
)@@G@@       MOVE SDENCH,0,I .@#@@@YDGPRC0 LABEL .    @D@@@Y       LOAD  X2,X4RG
)@@G@@ .       X2=STARTOF ENTRIES CHAIN   @#@@@YDGPRC1 LABEL .    @E@@@Y      RH
)@@G@@ LSDP  X4,SDNXDC,X4 .    CONTINUE FOLLOWING CHAIN     @G@@@Y       IF  XRI
)@@G@@4,ZERO  THEN,DGBLCK . -> END OF CHAIN, ALLOCATE STORAGE     @E@@@Y      RJ
)@@G@@ IF  SD4ENT,OFF,SDCLS4  THEN,DGPRC1 .  -> NOT AN ENTRY@G@@@Y       IF  ARK
)@@G@@8,NE,SDENBK  THEN,DGPRC1 .     -> NOT AN ENTRY TO THIS BLOCK@C@@@Y      RL
)@@G@@LOAD  X3,X2 .          SEARCH ENTRY LIST  @#@@@YDGPRC4 LABEL .    @G@@@YRM
)@@G@@       LOAD  A3,SD2SP,X3 .  COMPARE 1 1/2 WORDS AT SDSCAL       ******* RN
)@@G@@@ @@@Y         USING SDSECT,X4 .    @E@@@Y       IF  A3,NE,SD2SP  THEN,DRO
)@@G@@GPRC3 .   -> NOT RIGHT ONE    @A@@@Y         LOAD  A3,SDCLS1-FQ1,X3 .   RP
)@@G@@@G@@@Y         IF    A3,NE,SDCLS1-FQ1 THEN,DGPRC3 . -> NOT THIS ONE TRY RQ
)@@G@@NEXT  @ @@@Y       LOAD  A3,SDENUM,X3 .   @E@@@Y       STORE A3,SDENUM,XRR
)@@G@@4 .  RETURNS SAME TYPE AS ANOTHER   @D@@@Y       GOTO DGPRC1 .         -RS
)@@G@@> LOOK FOR MORE ENTRIES @#@@@YDGPRC3 LABEL .    @E@@@Y       LSDP  X3,SDRT
)@@G@@ENCH,X3 .  CONTINUE ALONG ENTRY CHAIN     @F@@@Y       IF  X3,NZERO  THERU
)@@G@@N,DGPRC4 . COMPARE TYPE RETURNED WITH REST@C@@@Y       STORE A7,SDENUM .RV
)@@G@@     SET ENTRY NUMBER   @D@@@Y         ADD   A7,1,I .      ADVANCE ENTRYRW
)@@G@@ COUNTER    @D@@@Y       STORE X2,SDENCH,X4 .  LINK ENTRY NAME TO CHAIN RX
)@@G@@@E@@@Y       GOTO DGPRC0 .         -> LOOK FOR MORE ENTRY NAMES   @A@@@YRY
)@@G@@ . [R2] X2 = HEAD OF ENTRY CHAIN    @ @@@Y . [R1] A7 = NUMBER OF ENTRIESRZ
)@@G@@@^@@@Y       USING SDSECT,X9 .@]@@@Y . NOTE:    @B@@@Y .       X2 [R2] =SA
)@@G@@ HEAD OF ENTRY CHAIN    @A@@@Y .       X3 [R1] = NUMBER OF ENTRIES@ @@@YSB
)@@G@@/ .   END STATEMENT DRIVER    @^@@@Y         USING WORD,X1 .@#@@@YDGEND SC
)@@G@@LABEL .     @G@@@Y       IF  ICENBF+ICENPF,OFF THEN,DGNDD1  .   -> NOT ASD
)@@G@@ BEGIN OR PROC    @[@@@Y .    @B@@@Y .   END FOR PROCEDURE OR BEGIN BLOCSE
)@@G@@K     @F@Z@Y       IF  CGRCHB,OFF,DCGFL2  THEN,DGEND1 .  -> NOT REACHABLSF
)@@G@@E     @E@@@Z       IF  CGRCHB,ON,DCGFL2  THEN,DGEND1X .  ->  REACHABLE  SG
)@@G@@@E@@@Z         GFIX    DBGWC1 .          BACKUP TO ERASE MOVES    @ @@@ZSH
)@@G@@         GOTO    DGEND1 .     @#@@@ZDGEND1X  LABEL .  @#@@@Y       GENM SI
)@@G@@.     @^@@@Y       GSUB EXEXIT .    @#@@@Y       GLIT 1 .   @F@@@Y      SJ
)@@G@@   +     0 .           FLAGS INDICATE THIS IS A BLOCK EXIT  @#@@@Y      SK
)@@G@@ GFIN .     @A@@@Y       SET   CGRCHB,OFF,DCGFL2 .    @#@@@ZDGEND1   LABSL
)@@G@@EL .  @G@@@Z         IF      SD3OBK,OFF,SDCLS3  THEN,DGEND3 . NOT ON UNISM
)@@G@@T BLOCK     @E@@@Z         LOADA   X3,SDONAW,X9 .    GET ADDR OF AW IN SSN
)@@G@@D     @#@@@Z         GEN .    @F@@@Z         GLABEL  AGPTX3 .          FSO
)@@G@@ILL IN JUMP AROUND ON UNIT    @A@Z@Y       GOTO  DGEND3 .    SKIP BACKUPSP
)@@G@@@#@Z@YDGEND1 LABEL .    @C@Z@Y       GFIX  DBGWC1 .    BACKUP TO ERASE MSQ
)@@G@@OVES. @#@@@YDGEND3 LABEL .    @^@@@Y         LOAD  X8,DCGTSK@C@@@Y      SR
)@@G@@   STORE X8,DCGTLV .     POP TEMP STACK   @C@@@Y      LOAD  A6,DTGMAX . SS
)@@G@@   MAXIMUM TEMP LOC.    @D@@@Y       STORE A6,SDFXLN,X9 .  SET IT INTO BST
)@@G@@LOCK SD     @F@@@Y       LSDP  A7,SDCHLD,X9 .   GET 1ST VBLE OF CHECK/NOSU
)@@G@@CHECK LIST  @D@@@Y         LOAD  X9,DCGBPT .     RESTORE BLOCK POINTER  SV
)@@G@@@E@@@Z         MOVE    DCGONF,SDSTON .   RESTORE CONDITION FLAGS  @D@@@YSW
)@@G@@         LOAD  X7,DCGSTL .         RESET STACK POINTER@^@@@Y       USINGSX
)@@G@@ WORD,X7 .  @A@@@Y       MOVE  DCGBPT-FH1,W1,DCGBSZ . @ @@@Y       XGPOPSY
)@@G@@ 'SIZE',DCGBSZ .  @A@@@Y         MOVE  AGDOST+FH2,DCGLOF .  @E@@@Y      SZ
)@@G@@ IF  DCGLBL,ZERO  THEN,DGEND2 .   -> NOT GENERATED    @C@@@Y       SET  TA
)@@G@@ CGRCHB,ON,DCGFL2 .   ITS REACHABLE @B@@@Y       LOADA X3,DCGLBL .   LABTB
)@@G@@EL A.W.     @]@@@Y       GEN  @^@@@Y       GLABEL AGPTX3 .  @E@@@Y      TC
)@@G@@   MOVE  DCGLBL,0,I . CLEAR LABEL A.W. FOR NEXT PROC  @#@@@YDGEND2 LABELTD
)@@G@@ .    @^@@@Y       LINK  BGDSPY .   @D@@@Y       LOAD  A9,SDFXLN,X9 .   TE
)@@G@@STACK LEVEL OF OUTER BLK@G@)@Z         IF      SDBKDP,ZER0  THEN,DGEND6 TF
)@@G@@. BLOCK 0 => NO CHECK LIST    @G@@@)         IF      SDBKDP,ZERO  THEN,DTG
)@@G@@GEND6 . BLOCK 0 => NO CHECK LIST    @F@@@Y       LSDP  A10,SDCHLD,X9 .  TH
)@@G@@    A10 = 1SR SD ON CHK/NOCHK LIST  @#@@@YDGEND4 LABEL .    @D@@@Y      TI
)@@G@@ IF  A7,EQ,0,I  THEN,DGEND6 .  END OF CHECK LIST@D@@@Y         STOREM A7TJ
)@@G@@,X5 .     SOME POINTERS ARE < 0     @^@@@Y         USING WORD,X5 .@^@@@YTK
)@@G@@       USING SDSECT,X5 .@E@@@Y       IF  A10,NE,W1U  THEN,DGEND5 .  -> RTL
)@@G@@ESET CHECK BIT    @^@@@Y         USING WORD,X7 .@G@@@Y       IF  A9,EQ,WTM
)@@G@@1U  THEN,DGEND6 . ->CHECK STATUS OF ENCLOSING BLOCK   @G@@@Y       LOAD TN
)@@G@@ A3,SDCLS3,X5 .   FLIP CHECK BIT                   *******  @F@@@Y      TO
)@@G@@ XOR,U A3,SDCHCK .                                  ********@ @@@Y      TP
)@@G@@ STORE A4,SDCLS3,X5 .   @#@@@YDGEND5 LABEL .    @ @@@Y       LSDP  A7,SDTQ
)@@G@@CHLT,X5 .   @A@@@Y       IF  A7,LT,0,I  THEN,DGEND7 . @E@@@Y       SET  TR
)@@G@@ SDCHK2,OFF,SDCLS3 .     VBLE NOT ON CHECKLIST  @^@@@Y       GOTO  DGENDTS
)@@G@@4 .   @[@@@Y .    @#@@@YDGEND7 LABEL .    @^@Z@Y       SUB   X7,1,I .   TT
)@@G@@@^@@@Z       ADD   X7,1,I .   @E@@@Y         LOAD  A6,W1,X7 .       MOVETU
)@@G@@ SD TO PREV LIST ENTRY  @ @@@Y         STORE A6,SDCHLT,X5 . @^@@@Y      TV
)@@G@@ GOTO  DGEND4 .   @[@@@Y .    @[@@@Y .    @^@@@Y       USING SDSECT,X9 .TW
)@@G@@@#@@@YDGNDD1 LABEL .    @E@@@Y       IF  ICENDF,ON  THEN,PGNCDE .    IS TX
)@@G@@THIS A SIMPLE DO ?@D@@@Y         IF    ICENCF,OFF THEN,DGEND8 . ->NOT CATY
)@@G@@SE    @E@@@Y         IF    SGDELF,ON,SGDCLS THEN,DGEN50 . ->ELSE PRESENTTZ
)@@G@@@^@@@Y         GMARK X10 .    @C@@@Y         LOAD  A3,SGDEOL .         PUA
)@@G@@TR TO ELSE  @ @@@Y         STORE X10,W1H2,A3 .  @#@@@YDGEN50   LABEL .  UB
)@@G@@@]@@@Y         GEN@E@@@Y         GLABEL SGDDOL .           LINK UP FORWAUC
)@@G@@RD BRANCHES @#@@@Y         XGPOP .  @A@@@Y         GOTO  PGNXT0 . ->NEXTUD
)@@G@@ STMT @D@@@YDGEND8   LABEL .                   END ITERATIVE DO   @^@@@YUE
)@@G@@         LINK  DGNDDO . @#@@@YDGEND6 LABEL .    @D@@@Y       MOVE  DCGLSUF
)@@G@@T,0177777,I .     FORCE NEW LINE #  @^@@@Y       GOTO  PGNXT0 .   @[@@@YUG
)@@G@@ .    @[@@@Y .    @A@@@YDGENDO*  LLOC .    ENTRY FROM CGIO  @#@@@YDGNDDOUH
)@@G@@ LOCAL .    @E@@@Y       LOAD  X5,DCGTLV .           GET POINTER TO TEMPUI
)@@G@@ STACK@^@@@Y       USING WORD,X5 .  @E@@@Y       MOVE  W1H2,SGDTFS .    UJ
)@@G@@     FREE 'TO' AND 'BY' TEMPS @E@@@Y       MOVE  DCGLLL-FH1,SGDLLL .    UK
)@@G@@     RESET TEMP LEVEL . @F@@@Y         MOVE    AGDOST+FH2,DCGLOF .  SET UL
)@@G@@PROPER DISPLACEMENT     @#@@@Y       GENM .     @F@@@Y       GINST  OPLXUM
)@@G@@,AGRX11,AGDOST,H1 . RETURN THROUGH DO STACK     @#@@@Y       GLIT 1 .   UN
)@@G@@@A@@@Y        J    TVEXST-(IN 63,0,1,0) . @^@@@Y       GLABEL SGDEOL .  UO
)@@G@@@G@@@Y       GINST OPSZ,AGRX0,AGDOST .  ZERO DO STACK WORD => INACTIVE DUP
)@@G@@O     @H@@@Y.                                  THE AGRX0 IS TO HOLD THE UQ
)@@G@@PLACE FOR CGIG    @^@@@Y       GFIN 'POP' .     @ @@@Y       LOAD  A7,DCUR
)@@G@@GLOF-FH1 .  @E@@@Y       ANH   A7,ONEONE .   SUB 1 FROM W1H1, ADD 1 TO WUS
)@@G@@1H2   @ @@@Y       STORE A7,DCGLOF-FH1 .  @ @@@Y       SET   CGRCHB,ON,DUT
)@@G@@CGFL2 @]@@@Y       JMP .@ @@@Y/ .    GOTO STATEMENT DRIVER  @#@@@YDGGOTOUU
)@@G@@   LABEL .  @ @@@Y         USING SDSECT,X9 .    @B@@@Y         XGEN  R,1UV
)@@G@@ . EVALUATE THE LABEL   @G@@@Y         SET   CGRCHB,OFF,DCGFL2 . STATEMEUW
)@@G@@NT AFTER THE GOTO IS NOT REABL@G@@@Y         IF    SDVRCN,ON,SGDCLS THENUX
)@@G@@,DGGCON . GOTO A LABEL CONSTANT     @ @@@Y . GO TO A LABEL VARIABLE     UY
)@@G@@@#@@@Y         GENM .   @F@@@Y         GDBLE OPDL,AGRA1,AGRL1 . LOAD FIEUZ
)@@G@@LDS OF LABEL VARIABLE   @#@@@YDGGLCN GLBL .     @C@@@Y         GSUB  EXGVA
)@@G@@OTO . CALL SERVICE ROUTINE    @^@@@Y         GFIN  'POP' .  @F@@@Y      VB
)@@G@@   GOTO  PGNXTS . -> PROCESS NEXT META-CODE INSTRUCTION     @ @@@Y . GO VC
)@@G@@TO A LABEL CONSTANT     @#@@@YDGGCON   LABEL .  @#@@@Y         GENM .   VD
)@@G@@@F@@@Y         GINST OPLA,AGRA1,AGRL1 . LOAD INV CNT FROM LABEL'S AR    VE
)@@G@@@F@@@Y         GINST OPLA,AGRA2,AGIM1,U . LOAD ADDRESS OF LABEL'A SD    VF
)@@G@@@G@@@Y         GMODE 'S' .         ENSURE LAST BYTES OF IGEN CODE ARE PUVG
)@@G@@T OUT @^@@@Y       GGOTO DGGLCN .   @^@@@Y. -------------------   @ @@@YVH
)@@G@@ .   DO WHILE STMT DRIVER     @^@@@Y. -------------------   @#@@@YDGDOWLVI
)@@G@@ LABEL .    @F@@@Y         GMARK   A3 .              WHERE ARE GENNING CVJ
)@@G@@ODE NOW?    @E@@@Y         ADD     A3,2,I .          SKIP STMTS NOW GENEVK
)@@G@@RATING@D@@@Y         STORE   A3,AGX0OF .       PUT WHERE REACHABLE@#@@@YVL
)@@G@@       GENM .     @F@@@Y         GINST   OPLA,AGRA3,AGXR0,U . POINT TO TVM
)@@G@@OP OF DO LOOP     @A@@@Y       GINST OPSA,AGRA3,AGDOST,H1 . @#@@@Y      VN
)@@G@@ GFIN .     @E@@@Y         GMARK   DCGLLL .          SET LABEL UPPER LIMVO
)@@G@@ITS   @E@@@Y         GMARK   DCGLUL .         SET LABEL UPPER LIMITS    VP
)@@G@@@F@@@Y         LINK    PGMVBT .          GENERATE HISTOGRAM & STMT #    VQ
)@@G@@@#@@@YDGDOW1 LABEL .    @E@@@Y        LOAD  X5,DCGTLV .     CURRENT TEMPVR
)@@G@@ STACK LEVEL.     @^@@@Y       USING WORD,X5 .  @E@@@Y       MOVE  SGDTFVS
)@@G@@S,W1H2 .         SAVE TEMP STACK POINTER  @F@@@Y       ADD   X1,1,I .   VT
)@@G@@           IGNORE ACWHIL AND ( TOKENS.    @D@@@Y.                       VU
)@@G@@           NEXT GETC IS !-    @^@@@Y       GOTO DGIF0 .     @^@@@Y/ .  IVV
)@@G@@F STMT DRIVER     @#@@@YDGIF   LOCAL .    @#@@@Y       XGPUSH .   @ @@@YVW
)@@G@@       MOVE  SGDID,SGDIF,I .  @F@@@Y       MOVE  SGDIFD,CGRCHB,I .  IF NVX
)@@G@@O ELSE, STMT IS REACHABLE     @#@@@Y       GETC .     @D@@@Y       STOREVY
)@@G@@ A8,SGDCPT .           SAVE CONTINUE PTR  @#@@@Y       GETC .     @D@@@YVZ
)@@G@@       STORE A8,SGDEPT .     SAVE ELSE METACODE PTR   @#@@@YDGIF0  LABELWA
)@@G@@ .    @#@@@Y       GETC .     @C@@@Y       XGEN  A8 .      EVALUATE RELAWB
)@@G@@TIONAL EXPR.@D@@@Y         LOAD    A3,SGDID .        PICK UP ID BITS    WC
)@@G@@@G@@@Y         XOR,U   A3,SGDCC .        SEE IF THE ID BITS SAY COND CODWD
)@@G@@E     @F@@@Y         IF  A4,EQ,0,I  THEN,DGIF1 . MAKE SURE PROPER BITS AWE
)@@G@@RE ON @[@@@Y.     @B@@@Y.        NOT COND CODE, MUST BE BIT STRING@[@@@YWF
)@@G@@.     @#@@@Y       GENM .     @F@@@Y       GINST OPLA,AGRA3,AGRL1,U .  LWG
)@@G@@OAD THE DOPE VETCOR ADDRESS   @^@@@Y       GSUB IFTEST .    @E@@@Y      WH
)@@G@@ GJUMP   SGDCNT+DCGSLT .     RETURN 'HERE' IF FALSE   @^@@@Y       GFIN WI
)@@G@@'POP' .     @E@@@Y         JMP .                     RETURN TO MAIN DRIVWJ
)@@G@@ER    @#@@@YDGIF1 LABEL .     @E@@@Y       LOAD  A7,SGDAID+FQ4 . GET TESWK
)@@G@@T OPCODE SET IN STAGING @E@@@Y       SLB   A7,26 .               PUT IN WL
)@@G@@PLACE FOR J FIELD @#@@@YDGIF3   LABEL .   @#@@@YDGIF5  LABEL .    @]@@@YWM
)@@G@@      GENM .@#@@@YDGIF2  GLBL .     @F@@@Y       GCJMP  OPJZ,AGRL1,SGDCNWN
)@@G@@T+DCGSLT . DO A JUMP & 'FAKE' IT    @G@@@Y       GAPPN   KLUGIT .       WO
)@@G@@     GET CORRECT J FIELD FOR THE JUMP     @^@@@Y       GFIN 'POP' .     WP
)@@G@@@]@@@Y       JMP .@D@@@YKLUGIT   GLBL .  FIX OPCODE-J FIELD FOR 'TEST' JWQ
)@@G@@UMP   @F@@@Y       LOAD  A3,X10 .              GET ADDR OF LAST INSTRUCTWR
)@@G@@ION   @E@@@Y       SUB   A3,1,I .              POINT TO RIGHT PLACE     WS
)@@G@@@E@@@Y       LOAD  A7,DCGSV4+1 .         PICK UP WHAT WAS IN A7   @E@@@YWT
)@@G@@       OR    A7,0,A3 .             CORRECT J FIELD PROBLEM  @F@@@Y      WU
)@@G@@ STORE A8,0,A3 .             PUT AWAY 'FIXED' INSTRUCTION   @A@@@Y      WV
)@@G@@ LJMP .    GO ON BACK TO GFIN @[@@@Y .    @^@@@Y . -------------------- WW
)@@G@@@ @@@Y .  DO SPECIFICATION DRIVER   @^@@@Y . -------------------- @A@@@YWX
)@@G@@DGDOS*   LLOC .     ENTRY FROM CGIO @C@@@Y         MOVE  DCGDST,1,I .   WY
)@@G@@  SET CGIO ENTRY  @A@@@Y         GOTO  DGDOPX .   ->MERGE   @D@@@YDGDOCSWZ
)@@G@@   LLOC .                    ENTRY FOR CASE DO  @#@@@YDGDOSP LLOC .     XA
)@@G@@@D@@@Y         MOVE  DCGDST,0,I .    .NEED ENTRY FOR I/0    @C@@@YDGDOPXXB
)@@G@@   LOCAL .                 APPARENT ENTRY @#@@@Y       XGPUSH .   @E@@@YXC
)@@G@@         LOAD    A3,A5 .           GET STMT TYPE FROM A5    @D@@@Y      XD
)@@G@@   SRB     A3,9 .            GET RID OF FLAGS   @H@@@Y         IF      AXE
)@@G@@3,EQ,ACDOCS*/-9,I THEN,DGDOC1 . IS THIS A DO CASE STMT?     @D@@@Y      XF
)@@G@@ MOVE  SGDLLL,DCGLLL-FH1 .    SAVE LABEL LIMITS @D@@@Y       SET   DCGLLXG
)@@G@@S,OFF,DCGFLG .  LABEL LIMITS NOT SET@ @@@Y       LOAD  A11,DCGLOF-FH1  .XH
)@@G@@@D@@@Y         AH      A11,ONEONE .      ADD 1 H1, SUB 1 H2 @F@@@Y      XI
)@@G@@ STORE A11,DCGLOF-FH1  .     GET OFFSET OF DO WRD IN AREC   @^@@@Y      XJ
)@@G@@   SRB   A11,18 . @E@@@Y         STORE   A11,AGDOST+FH2 .  STORE OFFSET XK
)@@G@@INTO AW     @E@@@Y       IF  A8,EQ,ACDOW*/-10,I  THEN,DGDOWL .  -> DO-WHXL
)@@G@@ILE   @#@@@Y . ------------   @#@@@Y . DO SPECIAL     @[@@@Y .    @F@@@YXM
)@@G@@ . DSPEC =  ACDSPC;->NEXT DOSPEC ! ->ACTO;->ACBY ! ->ACWHIL;0 !   @[@@@YXN
)@@G@@ .    @F@@@Y . (POINTERS(->) MAY ALSO BE =0, ACDSPC IS ALIGNED AT FULLWOXO
)@@G@@RD!!  @#@@@Y . ------------   @D@@@Y       XGEN  R,3          .        EXP
)@@G@@VALUATE INDEX     @D@@@Y       LOADA A11,SGDRAB-FH1 . TWO LEVEL ADDRESSIXQ
)@@G@@NG????@B@@@Y       IF  A11,NE,SGDRBS  THEN,DGDO20 .   @#@@@YDGDOS1 LABELXR
)@@G@@ .    @#@@@Y       GENM .     @^@@@Y       GGETT AGXTMP .   @ @@@Y      XS
)@@G@@ GINST OPLA,AGRA1,AGRR1 @A@@@Y         GINST   OPSA,AGRA1,AGXTMP .@^@@@YXT
)@@G@@       GFREE AGRR1 .    @ @@@Y       GSET AGRR1,AGXTMP .    @#@@@Y      XU
)@@G@@ GFIN .     @#@@@Y       GOTO DGDO21@#@@@YDGDO20 LABEL .    @B@@@Y      XV
)@@G@@ MOVE SGDRAB-FH1,AGRX5-AGRX0+AGAW . @#@@@YDGDO21 LABEL .    @F@@@Y      XW
)@@G@@   IF      SDRLCX,OFF,SGDID  THEN,DGDO23 . ->NOT COMPLEX    @ @@@Y      XX
)@@G@@ LOADA A11,SGDIAB .     @E@@@Y       IF  A11,NE,SGDIBS  THEN,DGDO22 . ->XY
)@@G@@NO AUX BASE .     @#@@@Y       GENM .     @#@@@YDGDOS2 GLBL .     @^@@@YXZ
)@@G@@       GGETT AGXTMP .   @A@@@Y       GINST OPLA,AGRA1,AGRI1 .     @A@@@YYA
)@@G@@         GINST   OPSA,AGRA1,AGXTMP .@^@@@Y       GFREE AGRI1 .    @ @@@YYB
)@@G@@       GSET AGRI1,AGXTMP .    @#@@@Y       GFIN .     @ @@@Y       GOTO YC
)@@G@@DGDO23 . MERGE    @#@@@YDGDO22 LABEL .    @B@@@Y       MOVE SGDIAB,AGRX5YD
)@@G@@-AGRX0+AGAW .     @#@@@YDGDO23 LABEL .    @^@@@Y       LOAD  A8,0,I .   YE
)@@G@@@^@@@Y       GTMP  R,A8 .     @E@@@Y       STORE A8,SGDTBT+DCGSLT. ORIGIYF
)@@G@@NAL TEMP STACK LEVEL    @^@@@Y       STORE A8,DTGMDO .@F@@@Y       LOAD YG
)@@G@@  F,DCGFLG . HOLD IT, ITS USED A LOT. RESTORED AT RET @G@@@Y       IF  AYH
)@@G@@8,GE,DCGMED  THEN,DGDO14X . ->CURRENT LAVEL USED IN FORMATS @^@@@Y      YI
)@@G@@ FTMP  R,A8 .     @^@@@Y       STORE A8,DCGMED .@^@@@Y       GTMP  R,A8 YJ
)@@G@@.     @E@@@YDGDO14X  LABEL .                    FIND DO SPEC  FIRST TIMEYK
)@@G@@@#@@@Y         GETC .   @E@@@Y         IF A8,NE,ACDSPC,I THEN,DGDO14X . YL
)@@G@@LOOK FOR DO SPEC  @E@@@Y         LOAD  X5,W1U,X1 .         GET ADDRESS OYM
)@@G@@F DOSPEC    @^@@@Y       GOTO  DGDO14 .   @#@@@YDGDO13 LABEL .    @F@@@YYN
)@@G@@       LOAD  A8,SGDTFS+DCGSLT . FREE NULL TEMP ABOVE 'TO' AND 'BY'@^@@@YYO
)@@G@@       FTMP  R,A8 .     @E@@@Y         SRB     A10,1 .           CHANGE YP
)@@G@@MCPTR TO REAL PTR @E@@@Y         ADD     A10,ADPBCM-FH2+FXH2 . ADD IN DIYQ
)@@G@@SPLACEMENT  @F@@@Y         LOAD    X5,A10 .          GET PTR TO ACDSPEC YR
)@@G@@INTO X5     @^@@@Y         USING   WORD,X5@[@@@Y.     @B@@@Y.        THIYS
)@@G@@S LINE DOESN'T MAKE ANY SENCE @[@@@Y.     @C@@@Y.       MOVE  DLXDOP,DCGYT
)@@G@@DOP . RESET OPTION FLAGS@[@@@Y.     @E@@@YDGDO14 LABEL .                YU
)@@G@@     START PROCESSING SPECS   @D@@@Y       SET DCGDTO+DCGDBY+DCGDBX+DCGDYV
)@@G@@BN,OFF .  RESET   @E@@@Y         SETGC   2,W1H2+2 .        SETUP TO READYW
)@@G@@ 'FROM' EXPR@[@@@Y.     @D@@@Y.        NOTE: SETGC ALWAYS ALIGNS ON WORDYX
)@@G@@ BOUNDRY    @[@@@Y.     @#@@@Y         XGEN R,2 @E@@@Y       IF  W1H1+1,YY
)@@G@@ZERO  THEN,DGDOS3 .  -> NO 'TO' CLAUSE    @C@@@Y         LMCP    R,W1H1+YZ
)@@G@@1 .        PTR TO ACTO .@^@@@Y       SET DCGDTO,ON .  @E@@@Y       XGEN ZA
)@@G@@ R,2 .                 GEN CODE FOR 'TO' EXPR   @F@@@Y       IF  SDVRCN,ZB
)@@G@@OFF,SGDCLS  THEN,DGDO15 . ->ITS NOT A CONSTANT .@G@@@Y       IF  SGDSGN,ZC
)@@G@@OFF,SGDCLS  THEN,DGDOS4 . ->ITS A POSITIVE CONSTANT   @#@@@YDGDO15 LABELZD
)@@G@@ .    @[@@@Y.     @F@@@Y.                MATCH 'TO' EXPR TO INDEX, AND FZE
)@@G@@ORCE INTO TEMP    @[@@@Y.     @F@@@Y         SET   SGDEXP,ON,SGDID .   FZF
)@@G@@ORCE THE 'TO' EXPR INTO TEMP  @D@@@Y       GASGN 'TEMP'  R,X7  'ATTR',SGZG
)@@G@@DAID+2*DCGSLT .   @B@@@Y       GOTO  DGDOS4 . -> TEST FOR 'BY'    @#@@@YZH
)@@G@@DGDOS3 LABEL .    @G@@@Y       XGPUSH .                    FAKE ACTO STAZI
)@@G@@CK IF NONE SUPPLIED     @G@@@YDGDOS4 LABEL .                     'TO' ISZJ
)@@G@@ EVALUATED NOW AND IS IN TEMP @D@@@Y       IF  W1H2+1,ZERO  THEN,DGDOS5 ZK
)@@G@@. ->NO 'BY' CLAUSE@C@@@Y       LMCP      R,W1H2+1 .        POINT TO ACBYZL
)@@G@@@A@@@Y       GMARK  A12 .  SAVE LOC CTR   @D@@@Y       XGEN  R,2 .      ZM
)@@G@@           EVALUATE 'BY' EXPR @F@@@Y       IF  SDVRCN,ON,SGDCLS  THEN,DGZN
)@@G@@DO16 . ->BY CLAUSE IS CONSTANT@ @@@Y       GASGN  'TEMP'  R,X7 .  @ @@@YZO
)@@G@@       SET DCGDBY+DCGDBX,ON   @ @@@Y       GOTO DGDOS6 .  MERGE   @#@@@YZP
)@@G@@DGDOS5 LABEL .    @H@@@Y       XGPUSH .                    FAKE 'BY' STAZQ
)@@G@@CK ELEMENT IF NONE SUPPLIED   @E@@@Y       IF  DCGDTO,OFF  THEN,DGDOS6 .ZR
)@@G@@ NO 'TO' OR 'BY' CLAUSE @G@@@Y         ADD     X7,6,I .          POP OFFZS
)@@G@@ THAT WHICH WAS JUST PUSHED   @F@@@Y         LOADA   A8,SDA1 .         UZT
)@@G@@SE THE SUPPLIED  CONSTANT 1   @E@@@Y         XGEN    I  'SINGLE'       .ZU
)@@G@@ CREATE THE SGD THINGY  @^@@@Y       GOTO  DGDO17 .   @#@@@YDGDO16 LABELZV
)@@G@@ .    @C@@@Y       GFIX A12 . ERASE ANY CODE JUST GENED     @F@@@Y      ZW
)@@G@@ IF  SGDSGN,OFF,SGDCLS  THEN,DGDO17 . ->POSITIVE BY CONSTANT@D@@@Y      ZX
)@@G@@ SET   DCGDBN,ON .     MARK NEGATIVE 'BY' CON   @F@@@YDGDO17 LABEL .    ZY
)@@G@@                 'BY' EXPR IS REALLY A CONSTANT @^@@@Y       SET   DCGDBZZ
)@@G@@Y,ON .@#@@@YDGDOS6 LABEL .    @F@@@Y       LINK  DGDOSI .    COPY INDEX AA
)@@G@@TO TOP OF STACK FOR REFERENCE @F@@@Y       GASGN  R,X2  SGDAID+2*DCGSLT AB
)@@G@@. ASSIGN 'FROM' TO 'INDEX'    @[@@@Y.     @B@@@Y.        THIS LINE DOESNAC
)@@G@@'T MAKE ANY SENCE @[@@@Y.     @F@@@Y.       SET   010,ON,DLXDOP . TURN OAD
)@@G@@FF TEST FOR UNDEFINED VBLE    @[@@@Y.     @[@@@Y.     @B@@@Y.        KEEAE
)@@G@@P TRACK OF THE TEMP STACK...  @E@@@Y.        THE 'TO' AND THE 'BY' TEMPSAF
)@@G@@ WILL BE FREED BY CGIG. @[@@@Y.     @^@@@Y       LOAD  A8,0,I .   @^@@@YAG
)@@G@@       GTMP  R,A8 .     @C@@@Y       STORE A8,SGDTFS+4*DCGSLT . SAVE OFFAH
)@@G@@SET   @B@@@Y       IF  A8,LE,DTGMDO  THEN,DGDO18 .    @C@@@Y       STOREAI
)@@G@@  A8,DTGMDO . SAVE MAX(DTGMDO,A8)   @#@@@YDGDO18 LABEL .    @A@@@Y      AJ
)@@G@@   AND,U F,DCGDTO+DCGDBX .    @F@@@Y         IF    F+1,NE,DCGDTO+DCGDBX,AK
)@@G@@I THEN,DGDOS8 .  CONSTANT 'BY'@#@@@Y         GENM .   @#@@@Y         GLIAL
)@@G@@T 1 . @C@@@Y         LA,U    A3,1 .            POSITIVE SIGN@E@@@Y      AM
)@@G@@   GINST   OPTP,AGRX0,AGRL1 'NO' . SEE IF 'BY' IS POS @E@@@Y       GINSTAN
)@@G@@ OPLNA,AGRA3,AGRA3 .  A3=-1 FOR NEGATIVE BY     @D@@@Y       GINST OPSA,AO
)@@G@@AGRA3,AGDOST,H2 . SAVE IN DOSTK     @#@@@Y       GFIN .     @B@@@Y      AP
)@@G@@   GOTO    DGDOS7 .          ->MERGE@C@@@YDGDOS8   LABEL . NOT 'TO',AND AQ
)@@G@@'EXPR' FOR 'BY'   @G@@@Y         IF  DCGDTO,OFF THEN,DGDOS7 . IF NO 'TO'AR
)@@G@@,'BY' SIGN TEST NOT NECC@E@@@Y         IF  DCGDBN,ON  THEN,DGDOS0 . CONSAS
)@@G@@TANT POS OR NEG?  @[@@@Y.     @A@@@Y.                POS CONSTANT HERE  AT
)@@G@@@[@@@Y.     @#@@@Y         GEN .    @F@@@Y         GINST   OPSR,AGRR12,AAU
)@@G@@GDOST,H2 . SET A + SIGN IN DOSTACK  @ @@@Y         GOTO    DGDOS7 .     AV
)@@G@@@A@@@YDGDOS0   LABEL . NEG CONSTANT HERE  @#@@@Y         GENM .   @#@@@YAW
)@@G@@         GLIT 1 . @D@@@Y         LA,XU A3,-1 .             GET A 'NEG' SAX
)@@G@@IGN   @E@@@Y         GINST   OPSA,AGRA3,AGDOST,H2 . NEG 'BY' CONSTANT   AY
)@@G@@@#@@@Y         GFIN .   @#@@@YDGDOS7 LABEL .    @C@@@Y         IF DCGDTOAZ
)@@G@@+DCGDBY,OFF THEN,DGDOS9 .     @G@@@Y         MOVE    AGTMP2,0,I .      JBA
)@@G@@UMP AROUND INCREMENT FIRST TIME***  @F@@@Y         GMARK   A3 .         BB
)@@G@@     WHERE ARE WE GENNING CODE?     @F@@@Y         ADD     A3,3,I .     BC
)@@G@@     POINT PAST INST WE WILL GEN    @E@@@Y         STORE   A3,AGX0OF .  BD
)@@G@@     SAVE WHERE WE CAN GET IT @#@@@Y         GENM .   @#@@@YDGDOSA   GLBBE
)@@G@@L .   @E@@@Y         GINST   OPLA,AGRA3,AGXR0,U . POINT TO TOP OF LOOP  BF
)@@G@@@B@@@Y         GINST OPSA,AGRA3,AGDOST,H1 .     @G@@@Y         GJUMP   ABG
)@@G@@GTMP2 .          JUMP AROUND CODE TO INCREMENT***     @#@@@Y         GFIBH
)@@G@@N .   @^@@@Y       LINK DGDOSL .    @D@@@Y         IF    DCGDST,NZERO THBI
)@@G@@EN,DGDO19 . -> I/O LIST @^@@@Y         LOAD  A2,R11 . @^@@@Y       LINK BJ
)@@G@@ PGMVBT .   @#@@@YDGDO19 LABEL .    @ @@@Y         SUB   X7,DCGSLT,I .  BK
)@@G@@@^@@@Y       LOAD  A8,ACBPL,I @D@@@Y       XGEN I 'SINGLE' .           ABL
)@@G@@DD 'BY' TO INDEX  @^@@@Y       LINK  DGDOSI .   @C@@@Y       GASGN  R,X2BM
)@@G@@  R,X7 .  ASSIGN TO INDEX     @ @@@Y       XGPOP 'SIZE',3*DCGSLT .@#@@@YBN
)@@G@@         GEN .    @G@@@Y         GLABEL  AGTMP2 .          FILL IN JUMP BO
)@@G@@AROUND INCREMENT CODE   @C@Z@Y       IF  DCGDTO,OFF  THEN,DGDO25 . ->NO BP
)@@G@@'TO'  @E@@@Z       IF  DCGDTO,OFF  THEN,DGDO26 . ->NO 'TO', 'BY' ONLY   BQ
)@@G@@@D@@@Y       SUB   X7,3*DCGSLT,I . RECOVER TO EXPR ENTRY    @E@@@Y      BR
)@@G@@ MOVE  SGDAID,SGDAID+3*DCGSLT,DCGSLT .  COPY INDEX    @]@@@Y . -------  BS
)@@G@@@G@@@Y . WARNING: THESE LINES ARE AN ATTEMPT TO GENERATE OPTIMAL CODE,ANBT
)@@G@@D AS  @A@@@Y . SUCH MAY BE IN(CORRECT/COMPLETE) @]@@@Y . -------  @E@@@YBU
)@@G@@         LOAD    A8,ACBMN,I . LOAD A BINARY MINUS  ON STACK @C@@@Y      BV
)@@G@@   XGEN    I 'SINGLE' .  GEN TO - INDEX   @#@@@Y         GENM .   @G@@@YBW
)@@G@@       GINST OPMSI,AGRL1,AGDOST,XH2 . TIMES (+-)1 FOR (POS/NEG) 'BY'    BX
)@@G@@@^@@@Y         GFREE   AGRL1 .@#@@@Y         GFIN .   @[@@@Y.     @G@@@YBY
)@@G@@.                                  NOW DECIDE ON THE TYPE OF JUMP TO USEBZ
)@@G@@@[@@@Y.     @E@@@Y         IF  W1H1+2,NZERO  THEN,DGDO32 . IS THERE A WHCA
)@@G@@ILE?  @[@@@Y.     @F@@@Y.        NO WHILE WITH THIS DO, JUMP TO START OFCB
)@@G@@ USER'S DO GROUP  @G@@@Y.        IF THE 'TO' IN NOT REACHED,ELSE FALL THCC
)@@G@@ROUGH TO NEXT DOSPEC    @[@@@Y.     @#@@@Y         GEN .    @G@@@Y      CD
)@@G@@ GCJMP OPJP,AGRL1,SGDLOP+3*DCGSLT 'NO' . JUMP TO USER'S DO GROUP  @G@@@YCE
)@@G@@         IF DCGDBX++DCGDBN,OFF THEN,DGDO11 . TEST FOR POS. BY CONST     CF
)@@G@@@#@@@Y         GEN .    @G@@@Y         GCJMP  OPJZ,AGRL1,SGDLOP+3*DCGSLTCG
)@@G@@ . INSURE TEST OF +/- ZERO    @#@@@YDGDO11   LABEL .  @E@@@Y         XGPCH
)@@G@@OP   'SIZE',2*DCGSLT . POP OFF 'TO' AND 'INDEX' @E@@@Y         GOTO    DCI
)@@G@@GDO10 .          -> NO WHILE TO PROCESS   @F@@@YDGDO32   LABEL .        CJ
)@@G@@           REVERSE JUMPS WITH WHILE HERE  @[@@@Y.     @F@@@Y.        IF CK
)@@G@@THE 'TO' LIMIT IS REACHED,JUMP AROUND 'WHILE',ELSE    @C@@@Y.        FALCL
)@@G@@L THROUGH AND TEST THE WHILE CLAUSE @[@@@Y.     @E@@@Y         MOVE    SCM
)@@G@@GDDOL+3*DCGSLT,0,I . CLEAR AW FOR JUMP    @G@@@Y         IF DCGDBX++DCGDCN
)@@G@@BN,OFF THEN,DGDO12 . TEST FOR POS. BY CONST     @G@@@Y         GEN .    CO
)@@G@@                 NOT A KNOWN POSITIVE CONST FOR THE BY@E@@@Y         GINCP
)@@G@@ST  OPTZ,AGRX0,AGRL1  'NO' . TEST FOR +/- ZERO  @#@@@YDGDO12   LABEL .  CQ
)@@G@@@#@@@Y         GEN   .  @C@@@Y         GCJMP   OPJN,AGRL1,SGDDOL+3*DCGSLCR
)@@G@@T .   @G@@@Y         XGPOP   'SIZE',2*DCGSLT . POP OFF 'TO' AND COPY OF CS
)@@G@@'INDEX'     @D@@@Y         GOTO    DGDO33 .          ->PROCESS WHILE    CT
)@@G@@@B@@@ZDGDO26   LABEL .            NO TO, BY ONLY@^@@@Z         USING WORCU
)@@G@@D,X5  @E@@@Z         IF    W1H1+2,NZERO THEN,DGDO33 . -> WHILE PHRASE   CV
)@@G@@@D@@@Z         GEN .              NO TO, NO WHILE, BUT BY   @C@@@Z      CW
)@@G@@   GJUMP SGDLOP+DCGSLT . JUMP TO CODE     @B@@@Z         GOTO  DGDO10 . CX
)@@G@@       NEXT OPTION@#@@@YDGDOS9 LABEL .    @F@@@Y            XGPOP   'SIZCY
)@@G@@E',3*DCGSLT . CLEAR 'TO' AND 'BY' ENTRIES @^@@@Y         USING WORD,X5 .CZ
)@@G@@@H@@@Y         IF    W1H1+2,NZERO  THEN,DGDO35       . THERE IS A WHILE DA
)@@G@@PRESENT     @[@@@Y.     @^@@@Y.        NO WHILE HERE  @[@@@Y.     @E@@@YDB
)@@G@@         GMARK   A3 .              POINT TO WHERE WE ARE    @F@@@Y      DC
)@@G@@   ADD     A3,3,I .          POINT PAST INST TO BE GENNED   @F@@@Y      DD
)@@G@@   STORE   A3,AGX0OF .       PUT WHERE IT CAN BE GOTTEN     @#@@@Y      DE
)@@G@@   GENM .   @E@@@Y         GINST   OPLA,AGRA3,AGXR0,U . POINT PAST TOP ODF
)@@G@@F LOOP@B@@@Y         GINST OPSA,AGRA3,AGDOST,H1 .     @D@@@Y         GJUDG
)@@G@@MP SGDLOP+DCGSLT . JUMP TO USERS DO GROUP @#@@@Y         GFIN .   @G@@@YDH
)@@G@@         IF    W1H2,ZERO  THEN,DGDEND . NO FURTHER DO SPECS -> THEN EXITDI
)@@G@@@ @@@Y         LOAD  A10,W1H2 .     @ @@@Y         LOADA X11,DGDO13 .   DJ
)@@G@@@B@@@Y         IF    DCGDST,NZERO THEN,DGDO13 . @^@@@Y         LOAD  A2,DK
)@@G@@R11 . @^@@@Y         GOTO  PGMVBT . @#@@@YDGDO35   LABEL .  @D@@@Y      DL
)@@G@@   MOVE    AGTMP2,0,I .      CLEAR FOR LABEL    @E@@@Y         GMARK   ADM
)@@G@@3 .              POINT TO WHERE WE ARE    @E@Z@Y         ADD     A3,3,I DN
)@@G@@.          POINT PAST TOP OF LOOP   @E@@@Z         ADD     A3,2,I .     DO
)@@G@@     POINT PAST TOP OF LOOP   @D@@@Y         STORE   A3,AGX0OF .       SDP
)@@G@@AVE WHERE EXPECTED@^@Z@Y         GENMR DGDOSA . @#@@@Z         GENM     DQ
)@@G@@@A@@@Z         GINST OPLA,AGRA3,AGXR0,U . @E@@@Z         GINST OPSA,AGRADR
)@@G@@3,AGDOST,H1 . NO TO, NO BY, WHILE   @#@@@Z         GFIN     @D@@@Y      DS
)@@G@@   MOVE  SGDDOL+DCGSLT,0,I .  CLEAR FOR JUMP    @#@Z@Y         GENM .   DT
)@@G@@@D@Z@Y         GJUMP SGDDOL+DCGSLT .  JUMP AROUND THE WHILE @^@Z@Y      DU
)@@G@@   GLABEL AGTMP2 .@#@Z@Y         GFIN .   @]@@@Y . -------  @ @@@Y . PRODV
)@@G@@CESS 'WHILE' CLAUSE     @]@@@Y . -------  @#@@@YDGDO25 LABEL .    @^@@@YDW
)@@G@@       USING WORD,X5 .  @E@@@Y        IF  W1H1+2,ZERO  THEN,DGDO10 . ->NDX
)@@G@@O WHILE CLAUSE    @D@@@YDGDO33   LABEL .                   PROCESS WHILEDY
)@@G@@ HERE @[@@@Y.     @B@@@Y.        THIS LINE DOESN'T MAKE ANY SENCE @[@@@YDZ
)@@G@@.     @ @@@Y.       MOVE  DLXDOP,DCGDOP . @[@@@Y.     @E@@@Y         LMCEA
)@@G@@P W1H1+2 .             POINT TO 'WHILE' EXPR    @E@@@Y       XGEN R,2 . EB
)@@G@@                 PROCESS RELATIONAL EXPR  @F@@@Y         LOAD    A3,SGDIEC
)@@G@@D .        PICK UP ID BITS FORM STACK     @E@@@Y         XOR,U   A3,SGDCED
)@@G@@C .        SEE IF TYPE COND CODE    @E@@@Y         IF  A4,EQ,0,I  THEN,DEE
)@@G@@GDO34 . -> IT IS COND CODE    @[@@@Y.     @A@@@Y.        BIT STRING TESTEF
)@@G@@ NEEDED .   @[@@@Y.     @#@@@Y         GENM .   @F@@@Y         GINST   OEG
)@@G@@PLA,AGRA3,AGRL1,U . LOAD THE ADDR OF THE DV     @D@@@Y         GSUB    DEH
)@@G@@OTEST .          CALL DOTESTER .    @F@@@Y         GJUMP   SGDLOP+2*DCGSEI
)@@G@@LT . RETURN TRUE HERE,GOTO DO GROUP @E@@@Y         GLABEL  SGDDOL+2*DCGSEJ
)@@G@@LT . FILL IN JUMP AROUND WHILE@^@@@Y         GFIN    'POP' .@E@@@Y      EK
)@@G@@   GOTO    DGDO10 .          -> PROCESS NEXT DOSPEC   @A@@@YDGDO34 LABELEL
)@@G@@ .   TYPE COND CODE HERE@F@@@Y         LOAD    A7,SGDAID+FQ3 .   GET 'DOEM
)@@G@@' J-FIELD SET IN STAGING@E@@@Y         SLB     A7,26 .           PUT IN EN
)@@G@@J-FIELD POSITION  @#@@@Y         GENM .   @G@@@Y         GCJMP   OPJZ,AGEO
)@@G@@RL1,SGDLOP+2*DCGSLT . IF TRUE JUMP TO DO GROUP  @F@@@Y         GAPPN   KEP
)@@G@@LUGIT .          PUT IN PROPER J-FIELD FOR JUMP @F@@@Y         GLABEL SGEQ
)@@G@@DDOL+2*DCGSLT .  FILL IN JUMP AROUND 'WHILE'    @^@@@Y         GFIN    'ER
)@@G@@POP' .@B@@@YDGDO10   LABEL . LOOK FOR MORE DOSPECS    @^@@@Y         USIES
)@@G@@NG WORD,X5 .@E@@@Y         IF  W1H2,ZERO  THEN,DGDEND . -> NO MORE DO SPET
)@@G@@ECS   @E@@@Y         LOAD    A10,W1H2 .        LOAD THE META CODE PTR   EU
)@@G@@@E@@@Y         GOTO    DGDO13 .          -> PROCESS NEXT DO SPEC .@#@@@YEV
)@@G@@DGDEND LABEL .    @[@@@Y.     @B@@@Y.        THIS LINE DOESN'T MAKE ANY EW
)@@G@@SENCE @[@@@Y.     @ @@@Y.       MOVE  DLXDOP,DCGDOP . @[@@@Y.     @#@@@YEX
)@@G@@       GENM .     @G@@@Y         GJUMP   SGDEOL+DCGSLT .   ALL DOSPECS DEY
)@@G@@ONE,JUMP TO END OF LOOP @D@@@Y       GLABEL SGDLOP+DCGSLT .  START OF USEZ
)@@G@@ERS CODE    @[@@@Y.     @G@@@Y.                           I DON'T THINK FA
)@@G@@THAT THIS GOES HERE CORRECTLY @^@@@Y.        GFREE AGRI1 .  @^@@@Y.     FB
)@@G@@   GFREE AGRR1 .  @[@@@Y.     @[@@@Y.     @^@@@Y       GFIN 'POP' .     FC
)@@G@@@D@@@Y       LOAD  A8,SGDTFS . RELEASE 'TO' AND 'BY' TEMPS  @^@@@Y      FD
)@@G@@ FTMP  R,A8 .     @D@@@Y       LOAD  A8,SGDTBT .   ''    INDEX          FE
)@@G@@ ''   @^@@@Y       FTMP  R,A8 .     @C@@@Y       LOAD  X5,DCGTLV .  CURRFF
)@@G@@ENT STACK LEVEL . @^@@@Y       USING WORD,X5 .  @E@@@Y       MOVE  SGDTFFG
)@@G@@S,W1H2 . SAVE CURRENT OFFSET (H2=TGFSET)  @G@@@Y       MOVE  W1H2,DTGMDOFH
)@@G@@ .     FAKE TEMP STACK BY CHANGING LAST OFFSET  @C@@@Y       STORE F,DCGFI
)@@G@@FLG .  RESTORE, AFTER LONG USE@]@@@Y       JMP .@^@@@Y . ---------------FJ
)@@G@@-     @#@@@Y . DO SUBRUOTINES @^@@@Y . ----------------     @#@@@YDGDOSIFK
)@@G@@ LOCAL .    @E@@@Y       LOAD  X2,X7 .               ADD ONE STACK ELEMEFL
)@@G@@NT    @ @@@Y       SUB   X2,DCGSLT,I .    @^@@@Y       USING WORD,X2 .  FM
)@@G@@@D@@@Y       MOVE  W1,SGDAID+3*DCGSLT,DCGSLT .  COPY INDEX  @]@@@Y      FN
)@@G@@ JMP .@[@@@Y .    @#@@@YDGDOSL LLOC .     @^@@@Y       GMARK DCGLUL .   FO
)@@G@@@E@@@Y       IF  DCGLLS,ON  THEN,LJMP . ->LOWER LIMIT ALREADY SET @ @@@YFP
)@@G@@       GMARK DCGLLL .  SET IT @A@@@Y       SET   DCGLLS,ON .   SET FLAG FQ
)@@G@@@#@@@Y       LJMP .     @[@@@Y.     @^@@@Y. --------------------- @]@-@YFR
)@@G@@. DO CASE   @^@@@Y. --------------------- @#@@@YDGDOC1   LABEL .  @^@@@-FS
)@@G@@         EXERR 0 LEVEL,3@C@-@Y         SET   SGDCS,ON,SGDID .    SET CASFT
)@@G@@E     @B@-@Y         NONPL1 XGCASF,DDGNCS,DGDOC99     @#@-@YDGDOC99  LABFU
)@@G@@EL .  @D@-@Y         GETC .                    POINT TO ACCASE    @^@-@YFV
)@@G@@         LOAD  A9,0,I . @C@-@Y         SRBD  A8,9 .              CASENUMFW
)@@G@@BERS,0@ @-@Y         STORE A9,SGDLLL .    @A@-@Y         GETC .         FX
)@@G@@           (@B@-@Y         GETC .                    !-     @B@-@Y      FY
)@@G@@   XGEN I .                  EXPR   @E@-@Y         IF    SDARST,ON,SGDCLFZ
)@@G@@S THEN,DGDOC2 . ->STRING CASE @F@-@Y         CGCONV SFK170 R,X7 .      SGA
)@@G@@ET FIXED BINARY CAE NUMBER    @#@-@Y         GENM .   @A@-@Y         GINGB
)@@G@@ST OPLA,AGRA3,AGRL1 .   @^@-@Y         GSUB EXCASEAR .@^@-@Y         GFIGC
)@@G@@N 'POP' .   @#@-@YDGDOC3   LABEL .  @E@-@Y         GMARK SGDEOL .       GD
)@@G@@     SET PTR TO ELSE WORD     @ @-@Y         LOAD  A9,SGDLLL .    @#@-@YGE
)@@G@@         GEN .    @^@-@Y         GLITRG A9 .    @E@-@Y         GMARK SGDGF
)@@G@@LOP .            PTR TO NEXT ARG IN LLIST @D@-@Y         LOAD  A3,SGDLLLGG
)@@G@@ .         GET NUMBER OF CASES@D@-@Y         SRB   A3,26 .             2GH
)@@G@@*NUMBER OF CASS   @E@-@Y         ADD   X10,A3 .            SET NEW CODE GI
)@@G@@ADDRESS .   @F@-@Y.              CHECK FOR SPACE -----------------------GJ
)@@G@@------------@^@-@Y         JMP . RETURN . @C@-@YDGDOC2   LABEL .        GK
)@@G@@           STRING CAS   @A@-@Y         SET   SDARST,ON,SGDCLS .   @#@-@YGL
)@@G@@         GENM .   @A@-@Y         GINST OPLA,AGRA2,AGRL1,U . @ @-@Y      GM
)@@G@@   GSUB  EXCASEST .     @^@-@Y         GFIN  'POP'    @^@-@Y         GOTGN
)@@G@@O  DGDOC3 . @^@-@Y/ . LEAVE STATEMENT     @#@-@YDGLEAV   LABEL .  @A@-@YGO
)@@G@@         NONPL1 XGLEAF,DDGNLV,DGLV99@#@-@YDGLV99   LABEL .  @E@-@Y      GP
)@@G@@   SET   CGRCHB,OFF,DCGFL2 . NEXT STMT NOT REACHABLE  @E@-@Y         LOAGQ
)@@G@@D  A9,F  .             SAVE COUNT OF BLOCKS     @C@-@Y         GETC .   GR
)@@G@@                 GET SD OR 0  @D@-@Y         LOAD  X4,X7 .             SGS
)@@G@@AVE STACK TOP     @E@-@Y         IF    A8,NE,ACNULL,I THEN,DGLV01 . ->NOGT
)@@G@@NLOCAL LEAVE@G@-@Y         LINK  DGLVBK .            GET NEXT ITERATIVE GU
)@@G@@DO BLOCK TO LEAVE @F@-@Y         LOADA A7,SGDEOL,X4 .      POINT TO EXITGV
)@@G@@ LOC IN STACK     @#@-@Y         GEN .    @^@-@Y         GJUMP AGPTA7 . GW
)@@G@@@B@-@Y         GOTO  PGNXTS . ->NEXT STATEMENT  @#@-@YDGLV01   LABEL .  GX
)@@G@@@^@-@Y         SLB   A9,27 .  @H@-@Y         SRB   A9,27 .             NGY
)@@G@@UMBER OF ITERATIVE DO BLOCKS TO LEAVE     @D@-@Y         LOAD  A10,DCGLOGZ
)@@G@@F .        CURRENT DOSTACK    @#@-@YDGLV02   LABEL .  @E@-@Y         LOOHA
)@@G@@P  A9,DGLV04 .         NEXT ITERATIVE DO BLOCK  @D@-@Y         LINK  DGLHB
)@@G@@VBK .            GET LAST BLOCK     @ @-@Y         LOADA A7,SGDEOL,X4 . HC
)@@G@@@#@-@Y         GEN .    @^@-@Y         GJUMP AGPTA7 . @^@-@Y         GOTHD
)@@G@@O  PGNXTS . @#@-@YDGLV04   LABEL .  @D@-@Y         LINK  DGLVBK .       HE
)@@G@@     GO OUT ONE LEVEL   @A@-@Y         STORE A10,AGDOST+FH2 .     @^@-@YHF
)@@G@@         SUB   A10,1,I .@#@-@Y         GEN .    @E@-@Y         GINST OPSHG
)@@G@@Z,AGRX0,AGDOST . CLEAR THIS DO STACK ELT  @D@-@Y         ADD   X4,DCGSLTHH
)@@G@@,I .       GO OUT 1 LEVEL     @D@-@Y         GOTO  DGLV02 .            OHI
)@@G@@UT ONE MORE LEVEL @[@-@Y.     @E@-@YDGLVBK   LLOC .                    LHJ
)@@G@@OOK FOR ITERATIVE DO    @^@-@Y         USING WORD,X4 .@#@-@YDGLVB2   LABHK
)@@G@@EL .  @D@-@Y         IF    SGDIF,ON,W1Q1 THEN,DGLVB1 . ->IF BLOCK @G@-@YHL
)@@G@@         IF    SGDCS,OFF,W1Q1 THEN,LJMP . ->NOT CASE, SO ITERATIVE DO   HM
)@@G@@@#@-@YDGLVB1   LABEL .  @ @-@Y         ADD   X4,DCGSLT,I .  @^@-@Y      HN
)@@G@@   GOTO  DGLVB2 . @#@@@Y/ . ------------- @A@@@Y .  ASSIGNMENT STATEMENTHO
)@@G@@ DRIVER     @#@@@Y .  ------------- @#@@@YDGASGN LABEL .    @^@@@Y      HP
)@@G@@ LOAD  A7,DCGTLV .@C@@@Y         MOVE DXGLHS,0,I .         LHS COUNT=0  HQ
)@@G@@@#@@@Y       GETC .     @#@@@Y       XGEN  A8 . @^@@@Y       STORE A7,DCHR
)@@G@@GTLV .@^@@@Y       GOTO PGNXTS .    @#@@@Y . ----------     @ @@@Y . BEGHS
)@@G@@IN STATEMENT DRIVER     @#@@@Y . ----------     @#@@@YDGBGN1 LABEL .    HT
)@@G@@@#@@@Y       GETC .     @#@@@Y       GENM .     @C@@@Y       GSUB EXNTRYHU
)@@G@@ .  BLK ENTRY SERVICE ROUTINE @#@@@Y       GLITRG A8 .@#@@@Y       GFIN HV
)@@G@@.     @B@@@Y       GMARK DBGWC1 . SAVE BLOCK CALL     @D@@@Y         LOAHW
)@@G@@D  X2,0,I .      SET TO NO PARAMETER LIST @A@@@Y       GOTO DGBLCK .  ALHX
)@@G@@LOCATE VBLES@#@@@Y . ----------     @^@@@Y . STOP, EXIT DRIVER    @#@@@YHY
)@@G@@ . ----------     @#@@@YDGSTOP LABEL .    @]@@@Y       GEN .@B@@@Y      HZ
)@@G@@ GSUB  EXSTOP .   DO WORK AT RUNTIME@F@@@Y       SET   CGRCHB,OFF,DCGFL2IA
)@@G@@ .  STMTS AFTER THIS NOT REACHABLE  @^@@@Y       GOTO PGNXTS .    @^@@@YIB
)@@G@@ . ------------------   @^@@@Y .   CALL STMT DRIVER   @^@@@Y . ---------IC
)@@G@@---------   @#@@@YDGCALL*   LOCAL . @D@@@Y       LOAD  A7,DCGTLV .   TEMID
)@@G@@P LEV MIGHT GET CHANGED @#@@@Y       GETC .     @#@@@Y       XGEN  A8 . IE
)@@G@@@^@@@Y       STORE A7,DCGTLV .@D@@@Y       LOAD  X2,SGDRAB-FH1 .   POINTIF
)@@G@@R TO CALL FLG BYTE@^@@@Y       USING WORD,X2 .  @E@@@Y       SET ARFNRN,IG
)@@G@@OFF,W1Q2 . INDICATE CALL TYPE PROCEDURE   @#@@@Y       XGPOP .    @]@@@YIH
)@@G@@       JMP .@[@@@Y.     @#@@@Y. ----------------@^@@@Y. DEBUGGING DRIVERII
)@@G@@S     @#@@@Y. ----------------@D@@@YDGFLOW   LABEL .                   FIJ
)@@G@@LOW STATEMENT     @^@@@Y         LOAD  A7,1,I . @D@@@Y         IF    F,NIK
)@@G@@ZERO THEN,DGFLO1 .   -> FLOW STMT   @^@@@Y         LOAD  A7,2,I . @E@@@YIL
)@@G@@DGFLO1   LABEL .                   FLOW STMT MERGES HERE    @A@@@Y      IM
)@@G@@   NONPL1 XGFFLW,DDGFLW,DGFCMN@#@@@YDGFCMN   LABEL .  @H@@@Y         GETIN
)@@G@@C .                    IF SIGNAL,IGNORE ERROR,IF FLOW SEE IF PROC @D@@@YIO
)@@G@@         IF A8,NE,ACFPRC,I THEN,DGSIG2 . IF NOT PROC  @E@@@Y         ADDIP
)@@G@@     A7,3,I .          SAY FLOW OR NOFLOW PROC  @D@@@YDGSIG2   LABEL .  IQ
)@@G@@                 MERGE TO SET CALL  @D@@@Y         GENM .               IR
)@@G@@     GENERATE SUB CALL  @^@@@Y         GSUB  EXFLOW . @^@@@Y         GLIIS
)@@G@@TRG A7 .    @#@@@Y         GFIN .   @D@@@Y         GOTO  PGNXTS .       IT
)@@G@@     ->NEXT STATEMENT   @^@@@Y . ------------------   @ @@@Y .    DRIVERIU
)@@G@@S FOR I/O STMTS   @A@@@Y .    GET, PUT, OPEN, CLOSE, FORMAT @^@@@Y . ---IV
)@@G@@---------------   @#@-@YDGREAD   LABEL .  @^@-@Y         LINK  RGREAD   IW
)@@G@@@^@-@Y         GOTO  PGNXTS   @[@-@Y.     @#@-@YDGWRIT   LABEL .  @^@-@YIX
)@@G@@         LINK  RGWRIT   @^@-@Y         GOTO  PGNXTS   @#@@@YDGGET  LABELIY
)@@G@@ .    @^@@@Y       LINK  PLGIOG .   @#@@@Y       GOTO PGNXTS@#@@@YDGPUT IZ
)@@G@@ LABEL .    @^@@@Y       LINK  PLGIOP .   @^@@@Y       GOTO PGNXTS .    JA
)@@G@@@#@@@YDGOPEN LABEL .    @#@@@Y       LINK PLGIOO@^@@@Y       GOTO PGNXTSJB
)@@G@@ .    @#@@@YDGCLSE LABEL .    @^@@@Y       LINK  PLGIOC .   @^@@@Y      JC
)@@G@@ GOTO PGNXTS .    @#@@@YDGFRMT LABEL .    @^@@@Y       GFIX  DBGWC1 .   JD
)@@G@@@^@@@Y       LINK  PLGIOF .   @]@@@Y       GEN .@^@@@Y       GLABEL DAGFJE
)@@G@@MT .  @^@@@Y       GOTO PGNXTS .    @^@@@Y/ . RETURN STMT DRIVER  @#@@@YJF
)@@G@@DGRTRN LABEL .    @^@@@Y         USING WORD,X1 .@F@@@Y       SET   CGRCHJG
)@@G@@B,OFF,DCGFL2 .   FOLLOWING STMTS NOT RCHBLE     @D@@@Y       IF ICRTEX,OJH
)@@G@@FF  THEN,DGRTNO . NO VALUE TO RETURN@^@@@Y         LOAD X5,X9 .   @[@@@YJI
)@@G@@ .    @A@@@Y .    IF HERE, MUST RETURN A VALUE  @#@@@YDGRTN1 LABEL .    JJ
)@@G@@@^@@@Y       USING SDSECT,X5 .@E@@@Y       IF  SDBGPR,ON,SDCLS1  THEN,DGJK
)@@G@@RTN2 .  -> ITS A PROC   @E@@@Y       LSDP  X5,SDBKLK,X5 .   FOLLOW LINK JL
)@@G@@TO OUTER BLOCK    @B@@@Y       GOTO  DGRTN1 .      LOOK AT IT     @[@@@YJM
)@@G@@ .    @#@@@YDGRTN2 LABEL .    @#@@@Y       XGPUSH .   @C@@@Y         XGEJN
)@@G@@N  R,1 .         EVALUATE EXPRESSION@D@@@Y       LOAD X2,SDBKAW,X5 .   BJO
)@@G@@LOCK'S AR BASE AW OFFSET@F@@@Y         STORE X2,AGARTN+FH1 .         ATTJP
)@@G@@RIBUTE CODE BASE POINTER@G@@@Y       ADD   X2,1,I .         OFSET OF RETJQ
)@@G@@URNED VALUE     MCMP01/74     @A@@@Y       STORE X2,SGDRBS+DCGSLT,X7 .  JR
)@@G@@@A@@@Y       STORE X2,SGDIBS+DCGSLT,X7 .  @F@@@Y       LSDP  X4,SDECHN,XJS
)@@G@@5 .        GET ENTRY CHAIN FROM BLOCK SD  @^@@@Y       LOAD  A10,1,I .  JT
)@@G@@@G@@@Y       IF  A10,EQ,SDNMEN  THEN,DGRTN3 . -> NORMAL CASE, ONLY ONE EJU
)@@G@@NTRY  @#@@@Y       GENM .     @^@@@Y       GKEEP AGRL1 .    @^@@@Y      JV
)@@G@@ GKEEP AGIM1 .    @F@@@Y         GINST OPLA,AGRA1,AGARTN,H1 'NO' . GET EJW
)@@G@@NTRY NUMBER CODE  @#@@@Y         GLIT 1 . @G@@@Y         GOTO  *0,A1 .  JX
)@@G@@     WHERE TO BRANCH IN COMPUTED GOTO TABLE     @#@@@Y       GFIN .     JY
)@@G@@@A@@@Y       MOVE  DDGDOS,SGDAID,DCGSLT . @ @@@Y       LOAD  A8,SDNMEN,XJZ
)@@G@@5 .   @F@@@Y         LOAD  X5,X10 .      GET CURRENT LOCATION AND INCREMKA
)@@G@@ENTOR @E@@@Y         SUB   X5,1,I .      POINT TO JUMP JUST GENERATED   KB
)@@G@@@E@@@Y         LOAD  A10,W1,X5 .   FETCH THE JUMP INSTRUCTION     @C@@@YKC
)@@G@@         AU,U  A10,0,X10 .   COMPUTE U-FIELD    @D@@@Y         STORE A11KD
)@@G@@,W1,*X5 .  RESTORE JUMP INSTRUCTION @C@@@Y         ANA,U A10,0200000 . RKE
)@@G@@EMOVE INDIRECT BIT@^@@@Y       GCORE R,A8 .     @^@@@Y       USING SDSECKF
)@@G@@T,X4  @#@@@YDGRTN8 LABEL .    @D@@@Y         AU,U  A10,0,X10 .   CREATE KG
)@@G@@A GOTO FOR TABLE  @E@@@Y         LOAD  A3,SDENUM,X4 .          COMPUTE TKH
)@@G@@ABLE ADDRESS@ @@@Y         ADD   A3,W1U,X5 .    @C@@@Y         STORE A11KI
)@@G@@,W1,A3 .   SET GOTO INTO TABLE@F@@@Y         MOVE  SGDAID,DDGDOS,DCGSLT KJ
)@@G@@. SET INITIAL STATE OF VALUE  @F@@@YDGRTN3 LABEL .               ENTER HKK
)@@G@@ERE IF ONLY ONE ENTRY POINT   @B@@@Y       LOAD  F,SDCLS1 . SAVE AN INSTKL
)@@G@@R.    @F@@@Y       STORE F,SGDCLS+DCGSLT .    FORM STACK EL FROM ENTRY NKM
)@@G@@AME SD@D@@@Y       MOVE  SGDSCP+DCGSLT,SD2SP . CONTINUE ''     '  @E@@@YKN
)@@G@@       IF SDARST,OFF  THEN,DGRTN4 .  -> RETURNS ARITH. VALUE@F@@@Y      KO
)@@G@@ MOVE  SGDID+DCGSLT,SD0STR,I .     ENTRY HAS STRING ATTR.   @I@@@Y      KP
)@@G@@ IF SDARST,ON,SGDCLS  THEN,DGRTN5 . OK MATCH BETWEEN EXPECTED AND ARRIVIKQ
)@@G@@NG    @[@@@Y .    @G@@@Y .     HERE, THERES A MISMATCH BETWEEN VALUE RETKR
)@@G@@URNED AND VALUE EXPECTED@C@@@Y .     COMPILE WARNING, MAYBE ERROR AT RUNKS
)@@G@@TIME  @#@@@YDGRTN6 LABEL .    @#@@@Y       GENM .     @^@@@Y       GSUB KT
)@@G@@EXRTRN .    @#@@@Y       GLIT 1 .   @E@@@Y       +     ARFNRN+ARNOCV,0 .KU
)@@G@@      FLAGS, DATA FOR ROUTINE @#@@@Y       GFIN .     @H@@@Y       EXERRKV
)@@G@@ ERCGRT LEVEL,0 . ' ATTRS OF VALUE RETURNED IMCOMPATIBLE WITH     @D@@@YKW
)@@G@@ . 'VALUE IN RETURN HAS ATTRIBUTES INCOMPATIBLE WITH' @ @@@Y . 'ONE OR MKX
)@@G@@ORE ENTRY POINTS.'@^@@@Y       GOTO  DGRTN7 .   @[@@@Y .    @[@@@Y .    KY
)@@G@@@#@@@YDGRTN4 LABEL .    @F@@@Y       IF SDARST,ON,SGDCLS  THEN,DGRTN6 . KZ
)@@G@@ -> ERROR, GIVE WARNING @F@@@Y       MOVE  SGDID+DCGSLT,SD0ART,I .    ENLA
)@@G@@TRY HAS ARITH ATTR.     @D@@@Y       LOAD  A7,SDRTC .      WORDS NEEDED LB
)@@G@@FOR RETURN  @^@@@Y         SRB   A7,1 .   @E@@@Y       STORE A7,SGDIDS+DLC
)@@G@@CGSLT .    IMAGINARY PART DISPL.    @#@@@YDGRTN5 LABEL .    @C@@@Y      LD
)@@G@@ GASGN SGDAID+DCGSLT  R,X7 .   !!!SYNTAX  @#@@@Y       GENM .     @^@@@YLE
)@@G@@       GSUB EXRTRN .    @#@@@Y       GLIT 1 .   @D@@@Y       +ARFNRN,0 .LF
)@@G@@    FLAG FOR VALUE BEING RETURNED   @#@@@Y       GFIN .     @#@@@YDGRTN7LG
)@@G@@ LABEL .    @G@@@Y         LSDP  X4,SDENCH,X4 .          FOLLOW CHAIN OFLH
)@@G@@ PROC'S IN BLOCK  @G@@@Y       IF X4,NZERO  THEN,DGRTN8 . -> NOT TO OUTELI
)@@G@@RMOST, KEEP CONVERTING  @C@@@Y       XGPOP 'SIZE',DCGSLT*2 .   POP STACKLJ
)@@G@@ TWICE@^@@@Y       GOTO  PGNXTS .   @#@@@YDGRTNO LABEL .    @F@@@Y      LK
)@@G@@   GENM .                    TURN ON THE CODE GENERATOR     @^@@@Y      LL
)@@G@@ GSUB EXRTRN .    @#@@@Y       GLIT 1 .   @F@@@Y       +0 .     NO FLAGSLM
)@@G@@ FOR SERVICE ROUTINE => NO VALUE RETURNED @#@@@Y       GFIN .     @^@@@YLN
)@@G@@       GOTO  PGNXTS .   @A@@@Y/ .      DELETED STATEMENT DRIVER   @#@@@YLO
)@@G@@DGDLET LOCAL .    @]@@@Y       GEN .@^@@@Y       GLIT  DGDL2-$-1 .@F@Z@YLP
)@@G@@       EXERR  ERCGDL LEVEL,1 . ' DELETED STATEMENT ENCOUNTERED'   @F@@@ZLQ
)@@G@@         EXERR   ERCGDL  LEVEL,2 . 'DELETED STATEMENT ENCOUNTERED'@#@@@YLR
)@@G@@DGDL2  LABEL .    @]@@@Y       JMP .@ @@@Y . -------------------------- LS
)@@G@@@ @@@Y .   END OF GAMMA CODE DRIVER @ @@@Y . -------------------------- LT
)@@G@@@#@@@YDGEAC  LLOC  .    @^@@@Y       USING SDSECT,X9 .@D@@@Y         STOLU
)@@G@@RE   R11,DHSTMT .      SAVE MAX # OF STMTS@F@@@Y         MOVE  SDBDLK,DPLV
)@@G@@GSLC .     PUT END OF CODE INTO BLOCK ZERO@F@@@Y         MOVE  SDFXLN,DTLW
)@@G@@GMAX .         SET AR SIZE FOR BLOCK 1    @G@@@Y       IF  CGABRT,OFF,DCLX
)@@G@@GFL2  THEN,DGEAC1 . -> COMPLIATION SUCESSFUL    @E@@@Y       EXERR  ERCGLY
)@@G@@ABORT LEVEL,3 . ' COMPLIATION ABORTED'    @#@@@YDGEAC1 LABEL .    @E@@@YLZ
)@@G@@         SZ,H2 DSRCGL+ACEAC/IC-ACBGIN/IC . CLEAR EAC COUNT  @E@@@Y      MA
)@@G@@   SUB   X10,2,I .          GO TO LAST INST GENERATED @B@@@Y         STOMB
)@@G@@RE  X10,DCGLCG .       SAVE IT@H@@@Y         MOVE    ADPEND,ADPCND .   SMC
)@@G@@ET REAL END OF CORE FOR EXECUTION TIME    @G@@@Y       IF  04,OFF,LIMALXMD
)@@G@@  THEN,PLCGND .  ->NO LIST REQUESTED, RETURN    @C@@@Y       MOVE  DGOLCME
)@@G@@T,DZZPZ .  FORCE PAGE EJECT   @^@@@Y       LOAD  X4,ADPCSE .@#@@@Y      MF
)@@G@@ GMARK X5 . @G@@@Y       LOADA X11,PLCGND . SO LISTER RETURNS TO EXIT   MG
)@@G@@       *********  @B@@@Y       GOTO  LSTBGN .  GIVE ASSEM. LISTING@[@@@YMH
)@@G@@.     @[@@@Y.     @^@@@Y/ .   FLAGS AND DATA    @^@@@Y.        ERROR NUMMI
)@@G@@BERS  @ @@@YERCGRT EQU   45 . RETURN ERROR@F@@@YERDUPL   EQU   40 .     MJ
)@@G@@ DUPLICATE CASE PREFIX. SECOND ONE IGNORED@A@@@YERCGDL EQU   48 . DELETEMK
)@@G@@D STATEMENT @B@@@YERCGABORT EQU 46 . COMPILATION ABORTED    @E@@@YERXGRNML
)@@G@@   EQU   52 .               NON-STANDARD PL/1 USED    @#@@@Y . =========MM
)@@G@@======@D@@@YDGDODT CSECT 3 .    DATA AREA (MAINLY FOR DO-DRIVER)  @[@@@YMN
)@@G@@ .    @F@@@YDDGDOS   EQU   DCVSV .       SAVE AREA FILLED IN RETURN DRIVMO
)@@G@@ER    @B@@@YAGRR1  EQU  SGDRAB-( IN 0,H1,0,0) . AW FOR@C@@@YAGRI1  EQU  MP
)@@G@@SGDIAB-( IN 0,H1,0,0) .       "     @C@@@YDGMSK1 SFW 0 .      FAKE A STAMQ
)@@G@@CK ENTRY FOR '1'  @^@@@YFILL(1) SQ  SD0ART .    @^@@@YFILL(1) SQ  SDVRCNMR
)@@G@@ .    @#@@@YFILL(1) SH  01 .  @D@@@YFILL(1) SAC  AGRX0-AGRX0+AGAW,KKF1-(MS
)@@G@@IN 63,0,1,0) .    @^@@@YLAFUDG   LA,U    A1,0 . @^@@@YLXFUDG   LX,U    XMT
)@@G@@5,0 . @^@Z@YLACOND   LA,U    A15,0 .@C@@@YDGLR11   SF    0237260000000 .MU
)@@G@@    LR,U R11,0    @B@@@YDGLTZ    SF    0507000000001 .    TZ,U 1  @]@@@YMV
)@@G@@ . ----     @C@@@YDGTLE  SH  0557400 .    H1 OF A ' TLE,U ' INSTR.@[@@@YMW
)@@G@@ .    @#@@@Y       CEND .     @^@@@Y/CGDRVR   CSECT 3 .     @A@@@YDDGFLWMX
)@@G@@   INSERT  4,'FLO','W   ' .   @ @@@YDDGNCS   INSERT 4,'CAS','E   '@ @@@YMY
)@@G@@DDGNLV   INSERT 5,'LEA','VE  '@A@@@YDDGSGN   INSERT  6,'SIG','NAL ' .   MZ
)@@G@@@#@@@YPGSTBL SFW 0 .    @G@@@YFILL(1) SAC   DGBGN1,DGCALL . FIRST BEGIN NA
)@@G@@STATEMENT, CALL STATEMENT     @D@@@YFILL(1) SAC   DGCLSE,PGNCDE . CLOSE,NB
)@@G@@ DECLARE (IGNORE) @B@@@YFILL(1) SAC   DGEND,DGNTRY . END, ENTRY   @B@@@YNC
)@@G@@FILL(1) SAC   DGFRMT,DGGET . FORMAT, GET  @A@@@YFILL(1) SAC   DGGOTO,DGIND
)@@G@@F . GOTO, IF@B@@@YFILL(1) SAC   DGOPEN,DGPROC . OPEN, PROC  @B@@@YFILL(1NE
)@@G@@) SAC   DGPUT,DGRTRN  . PUT, RETURN @C@@@YFILL(1) SAC   DGSTOP,PGNCDE . NF
)@@G@@STOP, NULL STMT   @H@@@YFILL(1) SAC   PGNCDE,DGDOSP . DO, DO WHILE PHRASNG
)@@G@@E (SAME AS FOR SO SPECIAL)    @D@@@YFILL(1) SAC   DGDOSP,DGDOCS . SPECIANH
)@@G@@L DO, DO CASE     @B@@@YFILL(1) SAC   DGASGN,DGASGN . ASSIGNMENT, @D@@@YNI
)@@G@@FILL(1) SAC   DGASGN,DGEAC       . END ALPHA CODE     @F@@@YFILL(1) SAC NJ
)@@G@@  DGFLOW,DGSTOP      . EXIT (SAME CODE AS FOR STOP)   @B@@@YFILL(1) SAC NK
)@@G@@  DGON,DGRVRT . ON , REVERT   @C@@@YFILL(1) SAC   DGSIGN,DGDLET .      SNL
)@@G@@IGNAL, 0    @D@@@YFILL(1)  SAC  DGALLC,DGFREE .      ALLOCATE, FREE     NM
)@@G@@@C@@@YFILL(1)  SAC  DGLEAV,DGREAD .      LEAVE,READ   @B@@@YFILL(1)  SACNN
)@@G@@   DGWRIT,0 .          WRITE, @C@Z@YFILL(1)  SAC   PGNCDE,0 .          SNO
)@@G@@YSTEM ,     @C@@@ZFILL(1)  SAC   DGSYST,0 .          SYSTEM ,     @#@@@YNP
)@@G@@         CEND .   @]@@@Y       END .___    GSUB EXRTRN .    @#@@@Y      NQ
)@@G@@ GLIT 1 .   @E@@@Y       +     ARFNRN+ARNOCV,0 .      FLAGS, DATA FOR RONR
)@@G@@*[S@@@*SDFF*@C@@@@.   COPYRIGHT 1975 BY UNIVERSITY OF MARYLAND    @[@@@@NS
)@@G@@.     @D@@@@.   QUESTIONS CONCERNING THIS SHOULD BE DIRECTED TO:  @[@@@@NT
)@@G@@.     @ @@@@.        MARVIN V. ZELKOWITZ  @B@@@@.        DEPARTMENT OF CNU
)@@G@@OMPUTER SCIENCE   @A@@@@.        UNIVERSITY OF MARYLAND     @B@@@@.     NV
)@@G@@   COLLEGE PARK, MARYLAND 20742     @[@@@@.     @G@@@@.        PERMISSIONW
)@@G@@N TO USE THESE LISTINGS AND THE COMPUTER PROGRAMS THEY@E@@@@.   REPRESENNX
)@@G@@T IS GRANTED UNDER THE FOLLOWING CONDITIONS:    @[@@@@.     @G@@@@.     NY
)@@G@@   1. UNLIMITED USE MAY BE MADE OF THE PROGRAMS REPRESENTED BY    @G@@@@NZ
)@@G@@.   THESE LISTINGS PROVIDED THAT THE NAME PLUM OR UNIVERSITY OF MARYLANDOA
)@@G@@@E@@@@.   PL/1 COMPILER REMAINS ASSOCIATED WITH THESE PROGRAMS.   @[@@@@OB
)@@G@@.     @F@@@@.        2. MODIFICATIONS MAY BE MADE TO THE LISTINGS PROVIDOC
)@@G@@ED:   @[@@@@.     @G@@@@.        (A) ANY RESULTING PROGRAM, OR REPORT, POD
)@@G@@APER OR DOCUMENTATION   @G@@@@.        DESCRIBING SUCH PROGRAM WILL CLEAOE
)@@G@@RLY INDICATE THAT THE PROGRAM @E@@@@.        IS A DIALECT OF PLUM OR IS OF
)@@G@@DERIVED FROM PLUM, AND  @[@@@@.     @G@@@@.        (B) ALL SUCH MODIFICAOG
)@@G@@TIONS, OTHER THAN TRIVIAL CORRECTIONS     @F@@@@.        OF ERRORS IN THOH
)@@G@@E SOURCE PROGRAMS, SHALL BE REPORTED AND  @G@@@@.        A BRIEF DESCRIPOI
)@@G@@TION OF THE FEATURE ADDED SHALL BE SUBMITTED    @C@@@@.        TO THE UNOJ
)@@G@@IVERSITY OF MARYLAND, AND     @[@@@@.     @F@@@@.        (C) NO PROGRAMSOK
)@@G@@ DERIVED FROM THESE LISTINGS SHALL BE SOLD@G@@@@.        WITHOUT WRITTENOL
)@@G@@ APPROVAL FROM THE UNIVERSITY OF MARYLAND, AND  @[@@@@.     @F@@@@.     OM
)@@G@@   (D) COPIES OF THESE PROGRAMS MAY BE TRANSMITTED TO OTHER @G@@@@.     ON
)@@G@@   LOCATIONS PROVIDED THAT SUCH TRANSMITTALS CLEARLY INDICATE     @G@@@@OO
)@@G@@.        WHETHER THE PROGRAMS ARE EXACT COPIES OF THE UNIVERSITY OF     OP
)@@G@@@E@@@@.        MARYLAND PLUM COMPILER OR ARE MODIFICATIONS TO IT. @[@@@@OQ
)@@G@@.     @G@@@@.        3. THESE CONDITIONS ONLY APPLY TO THE PLUM COMPILEROR
)@@G@@ ITSELF,    @F@@@@.   AND ARE NOT MEANT TO APPLY TO ANY PROGRAM WRITTEN OS
)@@G@@USING PLUM. @E@@@@.   THE PURPOSE OF THESE CONDITIONS IS TO ALLOW ANY USOT
)@@G@@ER TO @F@@@@.   EXPERIMENT WITH THE COMPILER AS LONG AS THE RESULTING PROU
)@@G@@ODUCT @G@@@@.   IS NOT SOLD AND AS LONG AS IT IS KNOWN THAT THE PRODUCT OV
)@@G@@DEVELOPED   @#@@@@.   FROM PLUM.    @[@@@@.     @[@@@@.     @[@@@@.     OW
)@@G@@@[@@@@.     @[@@@@.     @[@@@@/.    @B@@@@/.       PLUM CODE GENERATOR -OX
)@@G@@ I/O DRIVER @^@@@@.        ENTRY POINTS   @D@@@@.        PLGIOC         OY
)@@G@@           CLOSE STATEMENT    @D@@@@.        PLGIOF                    FOZ
)@@G@@ORMAT STATEMENT   @C@@@@.        PLGIOG                    GET STATEMENTPA
)@@G@@@D@@@@.        PLGIOL                    XGEN COROUTINE     @C@@@@.     PB
)@@G@@   PLGIOP                    PUT STATEMENT@D@@@@.        PLGIOO         PC
)@@G@@           OPEN STATEMENT     @#@@@@.        ON ENTRY @^@@@@.        X9=PD
)@@G@@BLOCK SD    @^@@@@.        X7=TOP OF STACK@A@@@@.        A8=STATEMENT TYPE
)@@G@@PE B CODE   @B@@@@.        X5 WILL CONTAIN LOC OF 'GET'     @E@@@@.     PF
)@@G@@   X8 WILL CONTAIN STMT TYPE (0=GET, 1=PUT 2=FORMAT)  @#@@@@         AXRPG
)@@G@@$ .   @#@@@@         DCLRG .  @#@@@@         UNLIST . @]@@@@@ADD PLTVDS PH
)@@G@@@#@@@@@ADD PLCGST .     @]@@@@@ADD PLDSAW @#@@@@         LIST .   @#@@@@PI
)@@G@@         PLWORD . @#@@@@         PLSD .   @#@@@@         PLAR .   @ @@@@PJ
)@@G@@         USING   AREC,X10 .   @#@@@@         PLAC .   @#@@@@         PLIPK
)@@G@@G .   @#@@@@         PLCGD .  @F@@@@GBRLA*   PROC .                    CPL
)@@G@@HANGE JUMP TO LX,U X11 INST   @^@@@@         LOAD  A3,X10 . @^@@@@      PM
)@@G@@   SUB   A3,1,I . @^@@@@         USING WORD,A3 .@A@@@@         MOVE  W1HPN
)@@G@@1,EGFJMP+FH1 .    @#@@@@         END .    @C@@@@BACKUP*   PROC  *0,2 .  PO
)@@G@@   BACKUP ONE GETC.     @^@@@@         SUB   X1,1,I . @#@@@@         GETPP
)@@G@@C .   @#@@@@         END .    @^@@@@CGFIX*   PROC  *1 .     @F@@@@      PQ
)@@G@@   CGCONV  EGF17  R,X7 .     CONVERT TO FIXED BIN(17,0)     @#@@@@      PR
)@@G@@   END .    @#@@@@CGIO     CSECT 3 .@G@@@@/. ...........................PS
)@@G@@..........................................@G@@@@.        ENTRY POINTS FOPT
)@@G@@R GET AND PUT STATEMENTS                       .@G@@@@. ................PU
)@@G@@......................................................@C@@@@PLGIOG*  LABPV
)@@G@@EL .                   GET ENTRY    @C@@@@         LOAD    X8,0,I .     PW
)@@G@@     SET GET STMT @D@@@@         GOTO  EGGTCT .            -> MERGE WITHPX
)@@G@@ PUT  @C@@@@PLGIOP*  LABEL .                   PUT ENTRY    @C@@@@      PY
)@@G@@   LOAD    X8,1,I .          SET PUT STMT @D@@@@EGGTCT   LOCAL .        PZ
)@@G@@           APPARENT ENTRY     @C@@@@         STORE   X8,DGIOTS .       SQA
)@@G@@AVE I/O TYPE@D@@@@         LOAD  X5,X1 .             SAVE PTR TO 'GET'  QB
)@@G@@@G@@@@. ................................................................QC
)@@G@@......@G@@@@.        PROCESS SKIP(EXPR) OR (LINE(EXPR))                 QD
)@@G@@           .@G@@@@. ....................................................QE
)@@G@@..................@^@@@@         USING WORD,X5 .@D@@@@         IF    W1HQF
)@@G@@2+1,ZERO THEN,EGGT0A . -> DEFAULT   @C@@@@         LMCP  R,W1H2+1 .     QG
)@@G@@     SET XGENENTRY@C@@@@         XGEN  R,2 .               SKIP SKIP(   QH
)@@G@@@E@@@@         CGFIX .                   CONVERT TO FIXED (17)    @#@@@@QI
)@@G@@         GEN .    @C@@@@         GINST OPLX,AGRX1,AGRL1 .  X1=NO LINES  QJ
)@@G@@@D@@@@         XGPOP .                   POP STACK OF ENTRY @D@@@@      QK
)@@G@@   GOTO  EGGT01 .            -> DO FILE NAME    @E@@@@EGGT0A   LABEL .  QL
)@@G@@                 NO LINE, USE DEFAULT     @^@@@@         USING WORD,X5 .QM
)@@G@@@E@@@@         IF    ICGTSF,OFF,W1Q2 THEN,EGGT01 . -> NO SKIP     @C@@@@QN
)@@G@@         GEN .                     SET SKIP OF 1@#@@@@         GLIT 1 . QO
)@@G@@@^@@@@         LX,U  X1,1 .   @G@@@@. ..................................QP
)@@G@@....................................@G@@@@.        GET SD OR DOPE VECTORQQ
)@@G@@ INTO X2                                 .@G@@@@. ......................QR
)@@G@@................................................@#@@@@EGGT01   LABEL .  QS
)@@G@@@^@@@@         USING WORD,X5 .@D@@@@         IF    W1H2,ZERO THEN,EGGT54QT
)@@G@@ . -> NO FILE     @D@@@@         LMCP  R,W1H2 .            POINT TO FILEQU
)@@G@@(SD)  @C@@@@         XGEN  R,2 .               POINT TO EXPR@#@@@@EGGT04QV
)@@G@@   LABEL .  @#@@@@         GEN .    @F@@@@         GINST OPLX,AGRX2,AGRLQW
)@@G@@1,U 'NO' . SD POINTER GOES INTO X2  @D@@@@         IF ICGTFF,OFF,W1Q2 THQX
)@@G@@EN,EGGT03 . ->STRING I/O@G@@@@         XGPOP .                   POP OFFQY
)@@G@@ THE STACK ELT FOR THE FILE   @C@@@@         GOTO  EGGT03 .            -QZ
)@@G@@> IGNORE MSG@E@@@@EGGT54   LABEL .                   PRINT WARNING OF NORA
)@@G@@ FILE @F@@@@         IF    EGSYSP,ON,DCGFL2 THEN,EGGT03 . -> PRINTED WARRB
)@@G@@NING  @E@@@@         SET   EGSYSP,ON,DCGFL2 .  SET WARNING PRTED FLAG   RC
)@@G@@@F@@@@         EXERR ERIOWR LEVEL,0 'NONUM' . 'SYSIN/SYSPRINT' ASSUMED  RD
)@@G@@@G@@@@. ................................................................RE
)@@G@@......@G@@@@.        OPEN I/O STATEMENT                                 RF
)@@G@@           .@G@@@@. ....................................................RG
)@@G@@..................@#@@@@EGGT03   LABEL .  @D@@@@         LOAD  A7,EGLMJ RH
)@@G@@.          SET LINK TO I/O    @A@@@@         ADD   A7,EGRTAD+FH2,X8 .   RI
)@@G@@@D@@@@         LOAD  A8,W1Q2,X5 .        GET OPEN FLAGS     @#@@@@      RJ
)@@G@@   GENM .   @C@@@@         GLITRG A7 .               LINK TO OPEN @B@@@@RK
)@@G@@         GLITRG A8 .               'FLAGS'@#@@@@         GFIN .   @C@@@@RL
)@@G@@         LOAD  A7,W1Q2,X5 .        GET FLAGS    @F@@@@         AND,U A7,RM
)@@G@@ICGTLF .         SEE IF DATA EDIT OR LIST I/O   @G@@@@         IF    A8,RN
)@@G@@NE,0,I THEN,EGGT3A .                -> CONTROL ONLY, N@G@@@@         IF RO
)@@G@@     DGIOTS,ZERO  THEN,EGGTCL  ELSE,JMP . CLOSE CONTROL GET @#@@@@EGGT3ARP
)@@G@@   LABEL .  @F@@@@         IF    A8,EQ,2,I THEN,EGIODT .                RQ
)@@G@@-> DATA     @F@@@@         IF    A8,EQ,4,I THEN,EGIOED .                RR
)@@G@@-> EDIT     @G@@@@/. ...................................................RS
)@@G@@..................@G@@@@.        LIST I/O                               RT
)@@G@@                       .@G@@@@. ........................................RU
)@@G@@..............................@D@@@@         MOVE  DGIOTP,ICGTLF,I .   SRV
)@@G@@ET LIST I/O FLAG  @F@@@@         LOAD  A7,EGRTAD+FH1,X8 .           GET RW
)@@G@@ROUTINE TO CALL   @D@@@@         STORE A7,DGIOCR .         SAVE THIS ADDRX
)@@G@@RESS  @^@@@@         USING WORD,X5 .@E@@@@         LMCP  R,W1H1+1 .     RY
)@@G@@     POINT TO 'LIST(EXPR)'    @C@@@@         ADD   X1,1,I .            SRZ
)@@G@@KIP 'LIST(' @D@@@@         GOTO  EGGTLP .            -> MAIN EXPRIO LOOPSA
)@@G@@@G@@@@. ................................................................SB
)@@G@@......@G@@@@.        EDIT I/O                                           SC
)@@G@@           .@G@@@@. ....................................................SD
)@@G@@..................@#@@@@EGIOED   LABEL .  @E@@@@         LMCP  R,W1H1+1 SE
)@@G@@.          POINT TO 'EDIT(LIST)'    @D@@@@         ADD   X1,1,I .       SF
)@@G@@     IGNORE 'EDIT('     @#@@@@EDIOE2   LABEL .  @E@@@@         MOVE  DAGSG
)@@G@@FMT,0,I .        CLEAR AW PTRS FOR JUMPS  @]@@@@         GEN@E@@@@      SH
)@@G@@   GJUMP DAGFMT .            BRANCH AROUND FORMAT     @E@@@@         GBRSI
)@@G@@LA .                   CHANGE TO LA,U X11-STMT  @#@@@@         GEN .    SJ
)@@G@@@#@@@@         GLIT  1 .@A@@@@         STORE X11,AREXFT+FH2 .     @C@@@@SK
)@@G@@         LOAD  A8,ICGTEF,I .       SET EDIT I/O @^@@@@         USING WORSL
)@@G@@D,X5 .@F@@@@         IF    ICGTRF,OFF,W1Q2 THEN,EDIOE3 . -> NO REMOTE FOSM
)@@G@@RMAT  @ @@@@         ADD   A8,010,I .     @#@@@@EDIOE3   LABEL .  @D@@@@SN
)@@G@@         STORE A8,DGIOTP .            SET 'EDIT' TYPE @A@@@@         MOVSO
)@@G@@E  DGIOCR,EGEDLK+FH2 .  @F@@@@         LOADA X11,EGGTLP .        SET RETSP
)@@G@@URN TO BE MAIN LOOP     @D@@@@EGMXTP   LLOC .                    FUDGE TSQ
)@@G@@EMP STACK   @D@@@@.        SET TEMP STACK = MAX(CURRENTV ALUE,DCGMED)   SR
)@@G@@@D@@@@         MOVE  DCGIOK,DTGMAX .     SAVE CURRENT MAX   @ @@@@      SS
)@@G@@   USING   WORD,A3 .    @D@@@@         LOAD  A3,DCGTLV .         GET ENDST
)@@G@@ OF TEMPS   @ @@@@         LOAD  A6,W1H1,A3 .   @D@@@@         ADD   A6,SU
)@@G@@W1H2,A3 .        GET MAX TEMP VALUE @ @@@@         STORE A6,DTGMAX .    SV
)@@G@@@G@@@@         IF    CGFMTF,OFF,DCGFL2 THEN,LJMP . -> NO REMOTE FMAT, RESW
)@@G@@TURN  @D@@@@         IF    A6,GE,DCGMED THEN,LJMP . -> CURRENT OK @D@@@@SX
)@@G@@         SET   EGTMPF,ON,DCGFL2 .  RELEASE TEMPS LATER@ @@@@         LOASY
)@@G@@D  A7,DCGMED .    @ @@@@         STORE A7,DTGMAX .    @D@@@@         LOASZ
)@@G@@D    A3,DCGTLV .       GET LEVEL AGAIN    @ @@@@         SUB   A7,W1H2,ATA
)@@G@@3 .   @ @@@@         MOVE  DCGMED,W1H1 .  @^@@@@         STORE A7,W1H1 .TB
)@@G@@@#@@@@         LJMP .   @G@@@@/. .......................................TC
)@@G@@..............................@G@@@@.        PROCESS EXPRESSIONS IN LISTTD
)@@G@@                                   .@G@@@@. ............................TE
)@@G@@..........................................@#@@@@EGGTLP   LABEL .  @D@@@@TF
)@@G@@         GETC .                    GET NEXT TOKEN .   @#@@@@EGGTLB   LABTG
)@@G@@EL .  @^@@@@         LOAD  A9,A8 .  @F@@@@         SRB   A9,9 .         TH
)@@G@@     GET LOW ORDER 9 BITS OF TOKEN  @D@@@@         IF    A9,EQ,ACLDOP/ICTI
)@@G@@,I THEN,EGGTDO . -> DO  @D@@@@         IF    A9,EQ,ACRPAR/IC,I THEN,EGGTTJ
)@@G@@LA . -> DONE@F@@@@         IF    A9,EQ,ACDOS/IC,I THEN,EGGTDD . -> CLOSETK
)@@G@@ DO SPEC    @G@@@@         IF    A9,NE,ACSTXI/IC,I THEN,EGGTLP . -> IGNOTL
)@@G@@RE IF NOT EXPR STA@G@@@@         XGEN  I .                 GENERATE CODETM
)@@G@@. RETURN VIA PLGIOL FOR @E@@@@.                                  CALL TOTN
)@@G@@ I/O ROUTINES     @E@@@@         GOTO  EGGTLP .            -> NEXT EXPR TO
)@@G@@IN LIST     @B@@@@EGGTDO   LABEL .                   DO SPEC@D@@@@      TP
)@@G@@   LINK  EGDOCL .            CALL DO DRIVER     @E@@@@         GOTO  EGGTQ
)@@G@@TLB .            -> NEXT EXPR IN LIST     @#@@@@EGDOCL   LOCAL .  @D@@@@TR
)@@G@@         GETC .                    POINT TO DO SPEC   @D@@@@         LINTS
)@@G@@K  SXGBC .             SAVE CURRENT B CODE@D@@@@         STORE A3,DCGIOTTT
)@@G@@ .         SAVE CURRENT LOC.  @D@@@@         LMCP I .                  PTU
)@@G@@OINT TO DO SPEC   @F@@@@         XGPUSH  'SIZE',1 .        CREATE A TEMPTV
)@@G@@ PLACE FOR X5     @B@@@@         STORE   X5,SGDAID .       SAVE X5@^@@@@TW
)@@G@@         LINK  DGDOS .  @F@@@@         LOAD    X5,SGDAID+DCGSLT . GET BATX
)@@G@@CK X5:SKIP DO STACK ELT.@C@@@@         LOAD  A8,DCGIOT .         RESET PTY
)@@G@@TR    @#@@@@         LMCP  I .@#@@@@         JMP .    @C@@@@EGGTDD   LABTZ
)@@G@@EL .                   END DO SPEC  @C@@@@         LINK  EGENDO .       UA
)@@G@@     -> END DO    @B@@@@         GOTO  EGGTLB .            -> NEXT@#@@@@UB
)@@G@@EGENDO   LOCAL .  @D@@@@         LINK  SXGBC .             GET CURRENT PUC
)@@G@@TR    @B@@@@         STORE A3,DCGIOT .         SAVE IT@E@@@@         STOUD
)@@G@@RE   X5,SGDAID+DCGSLT . SAVE X5 THROUGH CGDR    @D@@@@         LINK  DGEUE
)@@G@@NDO .            CALL DO DRIVER     @C@@@@         LOAD    X5,SGDAID .  UF
)@@G@@     GET X5 BACK  @E@@@@         XGPOP   'SIZE',1 .        TAKE OFF TEMPUG
)@@G@@ STORAGE    @ @@@@         LOAD  A8,DCGIOT .    @#@@@@         LMCP  I .UH
)@@G@@@D@@@@.         GETC .                    PTR AROUND DO SPEC@#@@@@      UI
)@@G@@   LMCP I . @C@@@@         JMP .                     -> RETURN    @#@@@@UJ
)@@G@@EGGTLA   LABEL .  @F@@@@         IF    ICGTDF,ON,DGIOTP THEN,EGGTCL . ->UK
)@@G@@ LIST, NOT EDIT   @G@@@@/. .............................................UL
)@@G@@........................@G@@@@.        PROCESS FORMAT LIST              UM
)@@G@@                             .@G@@@@. ..................................UN
)@@G@@....................................@B@@@@.        GETC POINTS TO ')' OFUO
)@@G@@ I/O LIST   @F@@@@         LOADA X11,EGGTE4 .        FUDGE TEMP STACK TOUP
)@@G@@ BE MAX     @#@@@@EGTPSK   LLOC .   @D@@@@         LOAD  A3,DCGTLV .    UQ
)@@G@@     GET TEMP STACK PTR @C@@@@         MOVE  DCGIOF,W1 .         SAVE ENUR
)@@G@@TRY   @ @@@@         LOAD  A4,DTGMAX .    @C@@@@         SUB   A4,1,I . US
)@@G@@           GET MAXZIE -1@D@@@@         STORE A4,W1H1 .           SET NEWUT
)@@G@@ TEMP LEVEL @C@@@@         MOVE  W1H2,1,I .          SET SIZE =1  @C@@@@UU
)@@G@@         GETC .                    IGNORE TOKEN @C@@@@         LJMP .   UV
)@@G@@                 -> RETURN    @#@@@@EGGTE4   LABEL .  @D@@@@         XGPUW
)@@G@@USH 'SIZE',3 .         SET I/O STACK ENTRY@C@@@@         MOVE  DAGFM2,0,UX
)@@G@@I .        CLEAR AW     @#@@@@         GENM .   @E@@@@         GJUMP DAGUY
)@@G@@FM2 .            BRANCH AROUND FORMAT     @E@@@@         GLABEL DAGFMT .UZ
)@@G@@           SET PTR FROM LIST TO FMAT@#@@@@         GLIT  1 .@F@@@@      VA
)@@G@@   STORE   X11,ARDED .       SAVE RETURN ADDR TO I/O LIST   @#@@@@      VB
)@@G@@   GFIN .   @#@@@@EGFRM1   LABEL .  @D@@@@         MOVE  SGDID,SGDIOF,I VC
)@@G@@.    SET FORMAT ENTRY   @F@@@@         MOVE  SGDITP,SGDILS+SGDIFM,I . SEVD
)@@G@@T MAIN I/O STACK ELEMENT@E@@@@         SET   EGEDTF,OFF,DCGFL2 . SET VALVE
)@@G@@ID EDIT FLAG OFF  @#@@@@EGFT01   LABEL .  @C@@@@         GETC .         VF
)@@G@@           NEXT TOKEN   @#@@@@EGFT04   LABEL .  @#@@@@EGFT11   LABEL .  VG
)@@G@@@E@@@@         MOVE  DGIOFT,0,I .        CLEAR COMPLEX FORMAT FLAG@E@@@@VH
)@@G@@         XGPUSH 'SIZE',3 .         STACK SPACE FOR NEXT ITEM@A@@@@      VI
)@@G@@   MOVE  SGDID,SGDIOF,I .     @E@@@@         LOAD  A9,A8 .             SVJ
)@@G@@EE WHAT TYPE OF ITM     @^@@@@         SRB   A9,9 .   @E@@@@         IF VK
)@@G@@   A9,EQ,ACFTA/IC,I THEN,EGFT02 . -> FORMAT ITEM@G@@@@         IF    A9,VL
)@@G@@EQ,ACLLST/IC,I THEN,EGFT01 . -> NEXT LEVEL OF (-)     @B@@@@.        MUSVM
)@@G@@T BE ITERATION EXPRESSION     @C@@@@         SET   SGDIOR,ON,SGDITP .  SVN
)@@G@@ET LOOP FLAG@E@@@@         LOAD    A7,A8 .           SAVE TOKEN PAST GTMVO
)@@G@@P     @E@@@@         GTMP  1 .                 TEMP FOR CURRENT VALUE   VP
)@@G@@@D@@@@         STORE A8,SGDITM .         SAVE ADDR OF TEMP  @C@@@@      VQ
)@@G@@   LOAD    A8,A7 .           RECLAIM TOKEN@D@@@@         IF    A9,NE,ACLVR
)@@G@@PAR/IC,I THEN,EGGT05 . ->N    @B@@@@         GETC .                    (VS
)@@G@@N)    @#@@@@EGGT05   LABEL .  @#@@@@         XGEN  I .@E@@@@         CGFVT
)@@G@@IX .                   CONVERT TO FIXED(17)     @#@@@@         GEN .    VU
)@@G@@@D@@@@         GINST   OPLA,AGRA3,AGRL1 . LA  A3,ITERATION  @F@@@@      VV
)@@G@@   XGPOP .                   DONE WITH ITERATION FACTOR NOW @G@@@@      VW
)@@G@@   GMARK X10 .               GET CURRENT LOC COUNTER FOR LOOP     @D@@@@VX
)@@G@@         LOADA A7,2,X10 .          POINT PAST JGD     @D@@@@         STOVY
)@@G@@RE A7,SGDIOT .         SET RETURN ADDRESS @D@@@@         ADD   A7,EGJGD VZ
)@@G@@.          SET JGD REG,$+2    @C@@@@         MOVE  AGR10D,SGDITM .     SWA
)@@G@@ET TEMP LOC @D@@@@         MOVE    AGRL1,0,I .       CLEAR WORD FOR JUMPWB
)@@G@@@#@@@@         GENM .   @C@@@@         GLITRG A7 .               JGD   AWC
)@@G@@3,$+2 @D@@@@         GJUMP AGRL1 .             J <=0,END ITERATION@C@@@@WD
)@@G@@         GINST OPSA,AGRA3,AGXR10 . SA    A3,TEMP@#@@@@         GFIN   . WE
)@@G@@@E@@@@         GETC .                    LOOK FOR FIRST FMAT ITEM @G@@@@WF
)@@G@@         IF A8,NE,ACRPAR,I THEN,EGGT06 . ) THERE FROM ITERATION FACTOR? WG
)@@G@@@C@@@@         GETC .                    YES,SKIP IT  @#@@@@EGGT06   LABWH
)@@G@@EL .  @C@@@@         IF    A8,EQ,ACLLST,I THEN,EGFT01 .     @D@@@@EGFT02WI
)@@G@@   LABEL .                   PROCESS FORMAT ITEM@C@@@@         SET   SGDWJ
)@@G@@IFM,ON,SGDITP .  A8=ACFITM    @C@@@@         STORE A8,DGIOFM .         SWK
)@@G@@ET FMAT TYPE@ @@@@         LOAD  F,DGIOFM .     @D@@@@         IF    F,LWL
)@@G@@T,5,I THEN,EGFTFX . -> DATUM FORMAT @E@@@@         IF    F,LT,012,I THENWM
)@@G@@,EGFTIT . -> CONTROL FORMAT   @#@@@@EGFTFX   LABEL .  @E@@@@         SETWN
)@@G@@   EGEDTF,ON,DCGFL2 .  SET VALID FORMAT FLAG    @E@@@@         IF    F,EWO
)@@G@@Q,012,I THEN,EGFTCX . -> COMPLEX FORMAT   @C@@@@         IF    F,LT,012,WP
)@@G@@I THEN,EGFTIT . -> DATUM@G@@@@/. .......................................WQ
)@@G@@..............................@G@@@@.        REMOTE (R) FORMAT ITEM     WR
)@@G@@                                   .@G@@@@.  ...........................WS
)@@G@@..........................................@C@@@@         XGEN  R,2 .    WT
)@@G@@           SKIP TO !-   @C@@@@         LOAD    A7,DGIOTS .       GET STMWU
)@@G@@T TYPE@E@@@@         IF A7,EQ,2,I THEN,EGFTRX . ->IS THIS A FORMAT STMT?WV
)@@G@@@E@@@@         ADD  A7,EGLA6 .          GENERATE LA,U A6,(GET!PUT)@#@@@@WW
)@@G@@         GEN .    @^@@@@         GLITRG A7 .    @#@@@@EGFTRX   LABEL .  WX
)@@G@@@F@@@@         IF    SDVRCN,ON,SGDCLS THEN,EGFTRC . -> CONSTANT LABEL   WY
)@@G@@@#@@@@         GENM .   @C@@@@         GINST OPLA,AGRA1,AGIM1 .  SD ADDRWZ
)@@G@@ESS   @C@@@@         GGOTO EGFTR3 .            -> MERGE     @#@@@@EGFTRCXA
)@@G@@   GLBL .   @#@@@@         GENM .   @A@@@@         GINST OPLA,AGRA1,AGIMXB
)@@G@@1,U . @#@@@@EGFTR3   GLBL .   @C@@@@         GINST OPLA,AGRA2,AGRL1 .  IXC
)@@G@@NV COUNT    @C@@@@         GSUB  EXFTGO .            CALL FORMAT  @^@@@@XD
)@@G@@         GFIN  'POP' .  @#@@@@EGFTR2   LABEL .  @C@@@@         GETC .   XE
)@@G@@                 GOTO ')'     @D@@@@         GOTO  EGFTC3 .            CXF
)@@G@@HECK NEXT ITEM    @G@@@@/. .............................................XG
)@@G@@........................@G@@@@.        NORMAL FORMAT ITEM (NOT R OR C)  XH
)@@G@@                             .@G@@@@. ..................................XI
)@@G@@....................................@#@@@@EGFTIT   LABEL .  @B@@@@      XJ
)@@G@@   GETC .                    GET (. @D@@@@         IF    A8,EQ,ACLPAR,I XK
)@@G@@THEN,EGFTF1 . -> (EXPR) @D@@@@         SUB   X1,1,I .             BACK TXL
)@@G@@O FMAT ITEM @#@@@@         GETC .   @E@@@@         MOVE  DGIOF2,3,I .   XM
)@@G@@     ALL 3 OPERANDS MISSING   @F@@@@         GOTO  EGFTCD .            CXN
)@@G@@ODE CALL TO FORMAT ROUTINES   @#@@@@EGFTF1   LABEL .  @D@@@@         XGEXO
)@@G@@N  R,1 .               CODE OPERAND 1     @D@@@@         CGFIX .        XP
)@@G@@           CONVERT TO FIXED   @D@@@@         IF 0400,OFF THEN,EGFCZ1 . AXQ
)@@G@@F NOT COMPLEX     @E@@@@         IF 0200,ON THEN,EGFCZ1 .  IF REAL PART XR
)@@G@@OF COMPLEX  @#@@@@         GEN .    @C@@@@         GINST OPLXI,AGRX1,AGRXS
)@@G@@L1 .  LXI X1,REAL1@D@@@@         GOTO    EGFCX1 .          MERGE WITH LXXT
)@@G@@M INST@D@@@@EGFCZ1   LABEL .                   HERE TO DO LXM     @]@@@@XU
)@@G@@         GEN@D@@@@         GINST   OPLXM,AGRX1,AGRL1 . LXM X1,OPERAND1  XV
)@@G@@@#@@@@EGFCX1   LABEL .  @E@@@@         XGPOP .                   GET RIDXW
)@@G@@ OF OPERAND 1     @#@@@@EGFT0B   LABEL .  @#@@@@         GETC .   @F@@@@XX
)@@G@@         IF    A8,EQ,ACCOMA,I THEN,EGFTF2 . -> OPERAND 2 PRESENT  @F@@@@XY
)@@G@@         IF    A8,NE,ACRPAR,I THEN,EGFT0B . -> NOT END OF ITEM    @E@@@@XZ
)@@G@@         MOVE  DGIOF2,2,I .        SET 2 OPERANDS MISSING   @E@@@@      YA
)@@G@@   GOTO  EGFTCD .            -> CALL FORMAT ROUTINES  @D@@@@EGFTF2   LABYB
)@@G@@EL .                   EXPR 2 PRESENT     @C@@@@         XGEN  R,1 .    YC
)@@G@@           POINT TO !-  @E@@@@         CGFIX .                   CONVERTYD
)@@G@@ TO FIXED(17)     @D@@@@         IF 0400,OFF THEN,EGFCZ2 . IF NOT COMPLEYE
)@@G@@X     @E@@@@         IF 0200,ON THEN,EGFCZ2 .  IF SECOND TIME AROUND    YF
)@@G@@@#@@@@         GEN .    @D@@@@         GINST OPLXI,AGRX2,AGRL1 .  LXI X2YG
)@@G@@,OPERAND    @D@@@@         GOTO    EGFCX2 .          MERGE WITH LXM     YH
)@@G@@@#@@@@EGFCZ2   LABEL .  @#@@@@         GEN .    @D@@@@         GINST   OYI
)@@G@@PLXM,AGRX2,AGRL1 . LXM X2,OPERAND2  @#@@@@EGFCX2   LABEL .  @C@@@@      YJ
)@@G@@   XGPOP .                   POP THE STACK@E@@@@         MOVE  DGIOF2,1,YK
)@@G@@I .        SET OPERAND 3 MISSING    @#@@@@EGFT05   LABEL .  @E@@@@      YL
)@@G@@   GETC .                    SEE IF OPERAND 3 PRESENT @E@@@@         IF YM
)@@G@@   A8,EQ,ACCOMA,I THEN,EGFT03 . -> THIRD OPERND @E@@@@         IF    A8,YN
)@@G@@EQ,ACRPAR,I THEN,EGFTCD . -> NO OPERAND 3 @C@@@@         GOTO  EGFT05 . YO
)@@G@@           -> SKIP TOKEN@#@@@@EGFT03   LABEL .  @C@@@@         XGEN R,1 YP
)@@G@@.                CODE EXPR 3  @C@@@@         CGFIX .                   FYQ
)@@G@@IXED(17)    @D@@@@         IF 0400,OFF THEN,EGFCZ3 . IF NOT COMPLEX     YR
)@@G@@@E@@@@         IF 0200,ON THEN,EGFCZ3 .  IF SECOND TIME AROUND    @#@@@@YS
)@@G@@         GEN .    @D@@@@         GINST OPLXI,AGRX3,AGRL1 .  LXI X3,OPERAYT
)@@G@@ND 3  @D@@@@         GOTO    EGFCX3 .          GO MERGE WITH LXM  @#@@@@YU
)@@G@@EGFCZ3   LABEL .  @#@@@@         GEN .    @D@@@@         GINST   OPLXM,AYV
)@@G@@GRX3,AGRL1 . LXM X3,OPERAND3  @#@@@@EGFCX3   LABEL .  @#@@@@         XGPYW
)@@G@@OP .  @E@@@@         MOVE  DGIOF2,0,I .        ALL THREE OPANDS PRESENT YX
)@@G@@@C@@@@         GOTO  EGFT05 .            SCAN TO )    @G@@@@/. .........YY
)@@G@@............................................................@G@@@@.     YZ
)@@G@@   COMPLEX FORMAT ITEM (C)                                       .@G@@@@ZA
)@@G@@. ......................................................................ZB
)@@G@@@#@@@@EGFTCX   LABEL .  @D@@@@         ADD   F,0400,I .          SET COMZC
)@@G@@PLEX ITEM   @C@@@@         GETC .                    IGNOTE C(    @#@@@@ZD
)@@G@@         GETC .   @G@@@@         GOTO  EGFT02 .            GENERATE CODEZE
)@@G@@ TO PUT OPS IN X1-X3    @#@@@@EGCM01   LABEL .  @F@@@@         IF    020ZF
)@@G@@0,ON THEN,EGCM11 . ->DID SECOND CALL ALREADY    @E@@@@         MOVE  DGIZG
)@@G@@OF3,DGIOF2 .     SAVE OPERND PRES FLAGS   @D@@@@         MOVE  DGIOFT-FHZH
)@@G@@2+FQ3,DGIOFM . SAVE 1 TYPE    @D@@@@         SET   0200,ON .           NZI
)@@G@@EXT TIME IS LAST  @G@@@@         GETC .                    SEE IF OPERANZJ
)@@G@@D 2 IS REALLY PRESENT   @F@@@@         IF    A8,NE,ACCOMA,I THEN,EGCM11 ZK
)@@G@@. -> NO SECOND ITEM     @C@@@@         GETC .                    POINT TZL
)@@G@@O FITM@D@@@@         GOTO  EGFT02 .            PROCESS FORMAT ITEM@#@@@@ZM
)@@G@@EGCM11   LABEL .  @E@@@@         SET   0600,OFF .          TURN COMPLEX ZN
)@@G@@FLAGS OFF   @D@@@@         LOAD  A7,DGIOF3 .         GET OPS PRESENT    ZO
)@@G@@@D@@@@         SLB   A7,3 .              3 BITS FOR EACH    @ @@@@      ZP
)@@G@@   ADD   A7,DGIOF2 .    @ @@@@         STORE A7,DGIOF2 .    @B@@@@      ZQ
)@@G@@   MOVE  DGIOFT-FH2+FQ4,DGIOFM .    @E@@@@         MOVE  DGIOFM,ACFTC-ACZR
)@@G@@FTA,I . SET COMPLEX FORMAT    @C@@@@         GOTO  EGFTGO .            CZS
)@@G@@ALL I/O     @G@@@@/. ...................................................ZT
)@@G@@..................@G@@@@.        CALL EDIT I/O                          ZU
)@@G@@                       .@G@@@@. ........................................ZV
)@@G@@..............................@#@@@@EGFTCD   LABEL .  @A@@@@         IF ZW
)@@G@@   0400,ON THEN,EGCM01 .@D@@@@.                                  -> COMPZX
)@@G@@LEX ITEM    @#@@@@EGFTGO   LABEL .  @F@@@@.        GENERATED            ZY
)@@G@@     LX    X1,OPERAND 1(IFPRESENT)  @F@@@@.                             ZZ
)@@G@@     LX    X2,OPERAND2 (IF PRESENT) @F@@@@.                             AA
)@@G@@     LX    X3,OPERAND 3(IF PRESENT) @D@@@@.        MUST GENERATE        AB
)@@G@@     LMJ   X11,EDIT/IO  @G@@@@.                                        +AC
)@@G@@FITM,OPFLAGS,COMPLEX1,COMPLEX2@C@@@@         LOAD  X3,DGIOTS .         GAD
)@@G@@ET I/O TYPE @C@@@@         LOAD  A7,EGLMJ .          GET LINK INST@E@@@@AE
)@@G@@         ADD   A7,EGRTAD+FH1+2,X3 . GET ROUTINE ADDRESS     @C@@@@      AF
)@@G@@   LOAD  A9,DGIOFM .         FORMAT TYPE  @D@@@@         SLB   A9,9 .   AG
)@@G@@           ROOM FOR OP FLAGS  @ @@@@         ADD   A9,DGIOF2 .    @E@@@@AH
)@@G@@         SLB   A9,18 .             COMPLEX FLAGS (IF C)     @ @@@@      AI
)@@G@@   ADD   A9,DGIOFT .    @#@@@@         GENM .   @^@@@@         GLITRG  AAJ
)@@G@@7 .   @^@@@@         GLITRG A9 .    @#@@@@         GLIT  1 .@F@@@@FMTFDGAK
)@@G@@   LABEL .                   A LABEL FOR THE SAVE OF X11    @F@@@@      AL
)@@G@@   STORE   X11,ARDED .       SAVE RETURN ADDR TO I/O LIST   @#@@@@      AM
)@@G@@   GFIN .   @#@@@@EGFTC3   LABEL .  @E@@@@         IF    A8,EQ,ACRPAR,I AN
)@@G@@THEN,EGFTND . -> END LEVEL    @E@@@@         IF    A8,EQ,ACCOMA,I THEN,EAO
)@@G@@GFTND . -> END ITEM     @C@@@@         IF    A8,EQ,ACRLST,I THEN,EGFTND AP
)@@G@@.     @D@@@@         SRB   A8,12 .             LEAVE 026 OF ACCODE@E@@@@AQ
)@@G@@         IF    A8,EQ,026,I THEN,EGFTND . -> END OF ITEM     @C@@@@      AR
)@@G@@   GETC .                    SKIP TOKEN   @D@@@@         GOTO  EGFTC3 . AS
)@@G@@           SKIP TO END OF ITEM@C@@@@EGFTND   LABEL .                   EAT
)@@G@@ND OF ITEM  @F@@@@         IF    SGDIOR,OFF,SGDITP THEN,EGFTN2 . -> NO LAU
)@@G@@OOP ON ITEM @G@@@@. ....................................................AV
)@@G@@..................@G@@@@.        END OF LOOP                            AW
)@@G@@                       .@G@@@@. ........................................AX
)@@G@@..............................@F@@@@         MOVE  AGR10D,SGDITM .     GAY
)@@G@@ET ITERATION FACTOR ADDRESS   @D@@@@         LOAD  A7,EGJGD .          SAZ
)@@G@@ETUP JGD A3,LOOP  @D@@@@         ADD   A7,SGDIOT .         GET LOOP ADDRBA
)@@G@@ESS   @#@@@@         GENM .   @C@@@@         GINST OPLA,AGRA3,AGXR10 . LBB
)@@G@@A A3,COUNT .@D@@@@         GLITRG A7 .               JGD   A3,LOOP .    BC
)@@G@@@D@@@@         GLABEL AGRL1 .            SET FORWARD BRANCH @#@@@@      BD
)@@G@@   GFIN .   @C@@@@         LOAD  A8,SGDITM .         FREE TEMP    @^@@@@BE
)@@G@@         FTMP R,A8 .    @#@@@@EGFTN2   LABEL .  @D@@@@         GETC .   BF
)@@G@@                 GO PAST DELIMETER  @G@@@@         IF    SGDILS+SGDIFM,SBG
)@@G@@AME,SGDITP THEN,EGFTN9 . -> END FORMAT    @#@@@@EGFTN3   LABEL .  @D@@@@BH
)@@G@@         XGPOP 'SIZE',3.           POP FORMAT ITEM    @D@@@@EGFTN4   LABBI
)@@G@@EL .                   SEE WH_T TO DO NEXT@E@@@@         IF    A8,EQ,ACCBJ
)@@G@@OMA,I THEN,EGFT01 . -> NEXT ITEM    @F@@@@         IF    A8,EQ,ACRLST,I BK
)@@G@@THEN,EGFTND . -> POP NEXT LEVEL     @C@@@@         GETC .               BL
)@@G@@     SKIP TOKEN   @E@@@@         GOTO  EGFTN4 .            -> SEE WHAT TBM
)@@G@@O DO NOW    @#@@@@EGFTN9   LABEL .  @C@@@@         LOAD  F,DGIOTS .     BN
)@@G@@     GET I/O TYPE @E@@@@         IF    EGEDTF,ON,DCGFL2 THEN,EGFTF3 . ->BO
)@@G@@ EDIT ITEM  @G@@@@         EXERR EREGNE LEVEL,0 .    NO DATA ITEM IN FORBP
)@@G@@MAT STATEMENT     @D@@@@         IF    02,ON THEN,EGFTNC . -> FORMAT STABQ
)@@G@@TEMENT@F@@@@         EXERR EREGNL LEVEL,1 .    FORMAT WILL BE EXECUTED OBR
)@@G@@NCE   @D@@@@         GOTO  EGFTF4 .            -> END EDIT FORMAT @#@@@@BS
)@@G@@EGFTF3   LABEL .  @E@@@@         IF    02,ON THEN,EGFTNC . -> END FORM?TBT
)@@G@@ STATEMENT  @F@@@@         LOAD    A3,FMTFDG .       CHECK LAST INSTRUCTBU
)@@G@@ION GENNED  @G@@@@         SUB     X10,1,I .         POINT TO LAST INSTRBV
)@@G@@UCTION GENNED     @ @@@@         USING   WORD,X10 .   @F@@@@         IF BW
)@@G@@A3,EQ,W1 THEN,EGFTF9 . WAS LAST INST STORE X11,ARDED? @D@@@@         ADDBX
)@@G@@   X10,1,I .           NOPE->PRESERVE IT  @C@@@@EGFTF9   LABEL .        BY
)@@G@@           MERGE HERE   @#@@@@         GEN .    @E@@@@         GJUMP   DBZ
)@@G@@AGFMT .          JUMP TO TOP OF FORMAT    @#@@@@EGFTF4   LABEL .  @#@@@@CA
)@@G@@         GEN .    @G@@@@         GLABEL DAGFM2 .           FORWARD BRANCCB
)@@G@@H AROUND FORMAT FROM LST@#@@@@EGFTDD   LABEL .  @E@@@@         XGPOP 'SICC
)@@G@@ZE',3 .          FREE FORMAT STACK ELEMENT@^@@@@         USING WORD,X5 .CD
)@@G@@@E@@@@         IF    ICGTRF,OFF,W1Q2 THEN,EGFTDM . -> NO R FORMATS@C@@@@CE
)@@G@@         LOAD  A7,DTGMAX .         GET MAX TEMPS@E@@@@         IF    A7,CF
)@@G@@LT,DCGMFR THEN,EGFTDM . OLD MAX>NEW MAX   @D@@@@         STORE A7,DCGMFRCG
)@@G@@ .         SET NEW BASE LEVEL @#@@@@EGFTDM   LABEL .  @D@@@@         LOACH
)@@G@@D  X3,DCGTLV .         RESET TEMP LEVEL   @^@@@@         USING WORD,X3 .CI
)@@G@@@ @@@@         MOVE  W1,DCGIOF .    @F@@@@         IF    EGTMPF,OFF,DCGFCJ
)@@G@@L2 THEN,EGFTDF . -> NO TEMPS TO FREE@A@@@@         SET EGTMPF,OFF,DCGFL2CK
)@@G@@ .    @^@@@@         USING WORD,X3 .@^@@@@         LOAD  A7,W1H1 .@ @@@@CL
)@@G@@         MOVE  W1H1,DCGMED .  @^@@@@         ADD   A7,W1H2 .@ @@@@      CM
)@@G@@   STORE A7,DCGMED .    @#@@@@EGFTDF   LABEL .  @D@@@@         LOAD  A7,CN
)@@G@@DCGIOK .         GET OLD MAX TEMP   @E@@@@         IF    A7,LT,DTGMAX THCO
)@@G@@EN,EGFTNF . -> NEW MAX VALUE  @ @@@@         STORE A7,DTGMAX .    @#@@@@CP
)@@G@@EGFTNF   LABEL .  @E@@@@         IF    A8,EQ,ACLPAR,I THEN,EDIOE2 . -> NCQ
)@@G@@EXT PAIR    @E@@@@         IF    A8,NE,ACNIL,I THEN,EGGTCL . -> END STATCR
)@@G@@EMENT @#@@@@         GETC .   @D@@@@         GOTO  EGFTNF .            CCS
)@@G@@HECK NEXT TOKEN   @G@@@@/. .............................................CT
)@@G@@........................@G@@@@.        FORMAT STATEMENT                 CU
)@@G@@                             .@G@@@@. ..................................CV
)@@G@@....................................@D@@@@PLGIOF*  LOCAL .              CW
)@@G@@     ENTRY FROM CGDR    @F@@@@         LOAD  X5,X1 .             SAVE ADCX
)@@G@@DRESS OF 'FORMAT' ACODE @D@@@@         LOAD  X8,2,I .            ST FORMCY
)@@G@@AT TYPE     @C@@@@         STORE X8,DGIOTS .         SAVE TYPE    @D@@@@CZ
)@@G@@         SET     CGFMTF,ON,DCGFL2 . SAW FORMAT STMT   @E@@@@         XGPDA
)@@G@@USH 'SIZE',3 .         SET FORMAT STACK ELEMENT @F@@@@         MOVE  DCGDB
)@@G@@MED,DCGMFR .     SET NEW FLOOR ON TEMP STACK    @D@@@@         LINK  EGMDC
)@@G@@XTP .            FUDGE TEMP STACK   @^@@@@         LINK  EGTPSK . @D@@@@DD
)@@G@@         GTMP 1 .                  TEMPORSTRY LOC     @ @@@@         STODE
)@@G@@RE A8,SGDITM .    @ @@@@         STORE A8,AGR10D .    @F@@@@         GENDF
)@@G@@M .                    POINT TO TEMP FOR THIS FORMAT  @D@@@@         GINDG
)@@G@@ST  OPLX,AGRX5,AGXR10,U . LX,U X5,PTR     @#@@@@         GLIT  1 .@B@@@@DH
)@@G@@         LMJ   X11,0,X11 .         RETURN @#@@@@         GFIN .   @D@@@@DI
)@@G@@         GOTO  EGFRM1 .            -> PROCESS FORMAT  @[@@@@.     @[@@@@DJ
)@@G@@.     @E@@@@EGFTNC   LABEL .                   END FORMAT STATEMENT     DK
)@@G@@@D@@@@         LOAD  A7,DTGMAX .         SET NEW MAX BASE   @B@@@@      DL
)@@G@@   STORE A7,DCGMFR .         BASE   @ @@@@         STORE A7,DCGMED .    DM
)@@G@@@#@@@@         GEN .    @E@@@@         GSUB  EXFTRT .            -> RETUDN
)@@G@@RN FROM FORMAT    @E@@@@         GOTO  EGFTDD .            -> RETURN TO DO
)@@G@@STMT DRIVER @G@@@@/. ...................................................DP
)@@G@@..................@G@@@@.        GET/PUT DATA STATEMENT                 DQ
)@@G@@                       .@G@@@@. ........................................DR
)@@G@@..............................@#@@@@EGIODT   LABEL .  @D@@@@         STODS
)@@G@@RE A8,DGIOTP .        SAVE DATA FLAGS     @D@@@@         LOAD  A9,EGLMJ DT
)@@G@@.          SETUP CALL TO I/O  @A@@@@         ADD   A9,EGRTAD+FH2+4,X8 . DU
)@@G@@@D@@@@         LOAD  A7,EGFUDG .         SETUP NULL LIST    @^@@@@      DV
)@@G@@   USING WORD,X5 .@D@@@@         LOAD  A8,W1H1+1 .         GET MC POINTEDW
)@@G@@R     @E@@@@         IF    A8,NE,0,I THEN,EGGTD1 . -> NOT NULL LIST     DX
)@@G@@@#@@@@         GENM .   @^@@@@         GLITRG A7 .    @^@@@@         GLIDY
)@@G@@TRG A9 .    @#@@@@         GFIN .   @C@@@@         GOTO  EGGTCL .       DZ
)@@G@@     CLOSE I/O    @C@@@@EGGTD1   LABEL .                   NOT NULL LISTEA
)@@G@@@D@@@@         LMCP I .                  POINT TO DATA LIST @C@@@@      EB
)@@G@@   ADD   A7,1,I .            SET NOT NULL @#@@@@         GEN .    @^@@@@EC
)@@G@@         GLITRG A7 .    @E@@@@         STORE A9,DGIOCR .         SAVE ROED
)@@G@@UTINE ADDRESS     @E@@@@         LOAD  A9,0,I .            SET CALL NOT EE
)@@G@@STARTED YET @#@@@@         GETC .   @#@@@@EGGTD2   LABEL .  @C@@@@      EF
)@@G@@   GETC .                    GET TOKEN    @#@@@@EGGTD5   LABEL .  @F@@@@EG
)@@G@@         IF    A8,EQ,ACLDOP,I THEN,EGGTDA . -> SETUP DO SPEC FIRST@E@@@@EH
)@@G@@         IF    A8,EQ,ACRPAR,I THEN,EGGTGA . -> END OF LIST  @C@@@@      EI
)@@G@@   LOAD  A11,A8 .            SEE IF !-    @^@@@@         SRB   A11,9 .  EJ
)@@G@@@F@@@@         IF    A11,EQ,ACDOS/IC,I THEN,EGGTGD . -> CLOSE DO SPEC   EK
)@@G@@@E@@@@         IF    A11,NE,ACSTXI/IC,I THEN,EGGTD2 . -> IGNORE   @C@@@@EL
)@@G@@         GETC .                    0    OR 0    @C@@@@         GETC .   EM
)@@G@@                 SD   OR SD   @B@@@@         LOAD  A11,A8 .            SEN
)@@G@@AVE SD@C@@@@         GETC .                    [    OR -!   @F@@@@      EO
)@@G@@   IF    A8,NE,ACLBRK,I THEN,EGGTGC . -> PUT SD IN CODE     @D@@@@      EP
)@@G@@   IF    A9,EQ,0,I THEN,EGGTGE . -> LIST CLOSED @C@@@@         LOAD  A8,EQ
)@@G@@0,I .            CLOSE LIST   @F@@@@         LINK  EGGTPK .            PER
)@@G@@UT TERMINATOR (0) IN LIST     @C@@@@         LINK  EGGTPC .            CES
)@@G@@LOSE LIST   @#@@@@EGGTGE   LABEL .  @C@@@@         SUB   X1,2,I .       ET
)@@G@@      REREAD EXPR @#@@@@         GETC .   @E@@@@         LOAD  A11,DGIOCEU
)@@G@@R .         SAVE ROUTINE ADDRESS    @E@@@@         LOADA A3,EXPTDA .    EV
)@@G@@      SET PUT DATA ROUTINE    @ @@@@         STORE A3,DGIOCR .    @C@@@@EW
)@@G@@         XGEN  I .                 CODE XGEN    @E@@@@         STORE A11EX
)@@G@@,DGIOCR .        RESET PREVIOUS ROUTINE   @B@@@@         GOTO  EGGTD2 . EY
)@@G@@           -> NEXT@#@@@@EGGTGC   LABEL .  @B@@@@         LOAD  X4,A8 .  EZ
)@@G@@           SAVE -!@C@@@@         IF    X8,ZERO THEN,EGGTGZ . -> GET STMTFA
)@@G@@@^@@@@         LOAD  A8,A11 . @E@@@@         LINK  EGGTPK .            PFB
)@@G@@UT STMT, PUT SD IN CODE @B@@@@         GOTO  EGGTGG .            -> NEXTFC
)@@G@@@#@@@@EGGTGZ   LABEL .  @G@@@@         LSDP  X3,A11 .            SD IN XFD
)@@G@@3. SEE IF STRUCTURE FOR PUT ST@#@@@@EGGTGW   LABEL .  @ @@@@         USIFE
)@@G@@NG SDSECT,X3 .    @F@@@@         IF    SDSTRU,OFF,SDCLS4 THEN,EGGTGY . -FF
)@@G@@> REACHED LEAF    @D@@@@         LSDP  X3,SDSON .          GO TO SON FORFG
)@@G@@ LEAF @^@@@@         GOTO  EGGTGW . @#@@@@EGGTGY   LABEL .  @^@@@@      FH
)@@G@@   LOAD  A8,X3 .  @E@@@@         IF    SDCHCK,OFF,SDCLS3 THEN,EGGTGU . -FI
)@@G@@> NO CHECK  @D@@@@         ADD   A8,0200000,I .      SET CHECK FLAG     FJ
)@@G@@@D@@@@EGGTGU   LABEL .                   PUT SE IN CODE     @^@@@@      FK
)@@G@@   LINK  EGGTPK . @#@@@@EGGTGX   LABEL .  @C@@@@         IF    A8,EQ,X3 FL
)@@G@@THEN,EGGTGG . -> DONE   @B@@@@         LSDP  A8,SDBROT . GET BROTHER    FM
)@@G@@@D@@@@         IF    A8,NE,0,I THEN,EGGTGN . -> DO BROTHER  @D@@@@      FN
)@@G@@   LSDP  X3,SDDAD .          GO UP ONE LEVEL    @^@@@@         GOTO  EGGFO
)@@G@@TGX . @#@@@@EGGTGN   LABEL .  @^@@@@         LOAD  X3,A8 .  @F@@@@      FP
)@@G@@   GOTO  EGGTGW .            TRY BROTHER PART OF STRUCTURE  @#@@@@EGGTGGFQ
)@@G@@   LABEL .  @^@@@@         LOAD  A8,X4 .  @#@@@@EGGTGH   LABEL .  @D@@@@FR
)@@G@@         IF    A8,EQ,ACENEX+1,I THEN,EGGTD2 . -> END  @#@@@@         GETFS
)@@G@@C .   @E@@@@         GOTO  EGGTGH .            -> SCAN TO END OF EXPR   FT
)@@G@@@B@@@@EGGTGA   LABEL .                   DO     @ @@@@         LOADA X11FU
)@@G@@,EGGTCL .   @#@@@@EGGTDC   LLOC .   @F@@@@         IF    A9,EQ,0,I THEN,FV
)@@G@@LJMP . -> NO NEED TO CLOSE LIST     @#@@@@         LOCAL .  @^@@@@      FW
)@@G@@   LOAD  A8,0,I . @D@@@@         LINK  EGGTPK .            ADD LIST TERMFX
)@@G@@INATOR@C@@@@         LINK  EGGTPC .            CLOSE IT     @C@@@@      FY
)@@G@@   JMP .                     -> RETURN    @#@@@@EGGTDA   LABEL .  @C@@@@FZ
)@@G@@         LINK  EGGTDC .            CLOSE I/O    @E@@@@         LINK  EGDGA
)@@G@@OCL .            CALL DO PROCESSOR IN CGIO@D@@@@         GOTO  EGGTD5 . GB
)@@G@@           PROCESS DO LIST    @#@@@@EGGTGD   LABEL .  @E@@@@         LINGC
)@@G@@K    EGGTDC .          CLOSE I/O LIST FIRST     @D@@@@         LINK  EGEGD
)@@G@@NDO .            END DO (IN CGDR)   @B@@@@         GOTO  EGGTD5 .       GE
)@@G@@     -> NEXT@[@@@@.     @[@@@@.     @D@@@@EGGTPK   LOCAL .              GF
)@@G@@     PACK HALFWORD SD'S @D@@@@         IF    A9,NE,0,I THEN,EGGTP1 . -> GG
)@@G@@LIST STARTED@C@@@@         LOAD  A7,EGLMJ .          SET LINK     @C@@@@GH
)@@G@@         ADD   A7,DGIOCR .         GET ADDRESS  @#@@@@         GEN .    GI
)@@G@@@^@@@@         GLITRG A7 .    @#@@@@EGGTP1   LABEL .  @E@@@@         SLBGJ
)@@G@@   A10,18 .            LEAVE SPACE FOR ITEM     @^@@@@         ADD   A10GK
)@@G@@,A8 . @^@@@@         ADD   A9,1,I . @A@@@@         IF    A9,ODD THEN,JMPGL
)@@G@@ .    @#@@@@EGGTPD   LABEL .  @#@@@@         GEN .    @B@@@@         GLIGM
)@@G@@TRG A10 .              SD1,SD2@#@@@@         JMP .    @D@@@@EGGTPC   LLOGN
)@@G@@C .                    CLOSE I/O LIST     @E@@@@         SLBD    A8,36 .GO
)@@G@@           CLEAR A9,SAVE IT FOR TEST@G@@@@         IF    A8,EVEN THEN,LJGP
)@@G@@MP . '0' ON AN EVEN END OF WORD BOUNDRY?  @E@@@@         LOCAL .        GQ
)@@G@@           NOPE, FILL OUT THE WORD  @C@@@@         SLB   A10,18 .       GR
)@@G@@     LEAVE SD,0   @D@@@@         LOAD  A9,0,I .            SET LIST EMPTGS
)@@G@@Y     @^@@@@         GOTO  EGGTPD . @G@@@@/. ...........................GT
)@@G@@..........................................@G@@@@.        I/O COROUTINE TGU
)@@G@@O XGEN FOR EDIT AND LIST EXPR'S                .@G@@@@. ................GV
)@@G@@......................................................@D@@@@PLGIOL*  LOCGW
)@@G@@AL .                   ENTRY FROM XGEN    @C@@@@         STORE F,DCGSV6 GX
)@@G@@.          SAVE REGS    @ @@@@         STORE X2,DCGSV6+1 .  @ @@@@      GY
)@@G@@   STORE X3,DCGSV6+2 .  @ @@@@         STORE X4,DCGSV6+3 .  @C@@@@      GZ
)@@G@@   STORED                    A7,DCGSV6+4 .@ @@@@         LOAD  F,DGIOTP HA
)@@G@@.     @ @@@@         USING SGDSCT,X7 .    @E@@@@         IF    SDARST,ONHB
)@@G@@,SGDCLS THEN,EGAP06 . -> STRING DATA@E@@@@         GASGN 'TEMP' R,X7 'COHC
)@@G@@ND','IFEXPR' . DATA IN CODE   @#@@@@EGAP06   LABEL .  @E@@@@         MOVHD
)@@G@@E  DGFLGZ,SGDCLS .     SET FLAGS FOR ICODER     @#@@@@         GENM .   HE
)@@G@@@C@@@@         GINST OPLA,AGRA5,AGRL1,U . LA,U A5,DATA@C@@@@         GBOHF
)@@G@@FF EGAP07,SDRLCX .     -> IF REAL   @^@@@@         GFREE AGIM1 .  @#@@@@HG
)@@G@@EGAP07   GLBL .   @^@@@@         GFREE AGRL1 .  @#@@@@         GFIN .   HH
)@@G@@@C@@@@         LOAD  X4,SGDRSD .         SAVE SD .    @D@@@@         LOAHI
)@@G@@D  A8,SGDAID .         SET SGDID WORD     @E@@@@         IF    ICGTDF,ONHJ
)@@G@@ THEN,EGAP17 . -> 'LIST' OR 'DATA'  @ @@@@         LOAD  A7,EGEDLK .    HK
)@@G@@@C@@@@         GOTO  EGAP01 .            -> MERGE     @#@@@@EGAP17   LABHL
)@@G@@EL .  @ @@@@         LOAD  A7,EGLMJ .     @ @@@@         ADD   A7,DGIOCRHM
)@@G@@ .    @C@@@@         IF    ICGTEF,ON THEN,EGAP01 . -> 'LIST'@C@@@@      HN
)@@G@@   LOAD  A8,SGDRSD .         SAVE SD PTR  @#@@@@EGAP01   LABEL .  @#@@@@HO
)@@G@@         GENM .   @^@@@@         GLITRG A7 .    @^@@@@         GLITRG A8HP
)@@G@@ .    @#@@@@         GFIN .   @E@@@@         IF    ICGTEF,OFF THEN,EGAP0HQ
)@@G@@8 . -> DATA, RETURN     @ @@@@         LOAD  A8,DGIOTS .    @D@@@@      HR
)@@G@@   IF    A8,ODD THEN,EGAP08 . -> PUT STATEMENT  @ @@@@         USING SDSHS
)@@G@@ECT,X4 .    @E@@@@         IF    SDCHCK,OFF,SDCLS3 THEN,EGAP08 . -> NO CHT
)@@G@@HECK  @E@@@@         IF    SDARRY,OFF,SDCLS2 THEN,EGAP09 . -> NOT ARRAY HU
)@@G@@@C@@@@         GENM .                    CALL CHECK   @A@@@@         GINHV
)@@G@@ST OPLA,AGRA3,AGRL1,U . @^@@@@         GSUB ONCHKA .  @^@@@@         GLIHW
)@@G@@TRG X4 .    @#@@@@         GFIN .   @B@@@@         GOTO  EGAP08 .       HX
)@@G@@     -> DONE@#@@@@EGAP09   LABEL .  @C@@@@         GENM .               HY
)@@G@@     ARRAY CHECK  @^@@@@         GSUB ONCHK .   @^@@@@         GLITRG X4HZ
)@@G@@ .    @#@@@@         GFIN .   @#@@@@EGAP08   LABEL .  @ @@@@         LOAIA
)@@G@@DD A7,DCGSV6+4 .  @ @@@@         LOAD  F,DCGSV6 .     @ @@@@         LOAIB
)@@G@@D  X2,DCGSV6+1 .  @ @@@@         LOAD  X3,DCGSV6+2 .  @ @@@@         LOAIC
)@@G@@D  X4,DCGSV6+3 .  @#@@@@         JMP .    @G@@@@/. .....................ID
)@@G@@................................................@ @@@@.        CLOSE I/OIE
)@@G@@ AND RETURN @G@@@@. ....................................................IF
)@@G@@..................@#@@@@EGGTCL   LABEL .  @C@@@@         LOAD  X8,DGIOTSIG
)@@G@@ .      SET STMT TYPE   @D@@@@         GOTO  $+1,X8 .            TEST STIH
)@@G@@MT TYPE     @B@@@@         GOTO  EGGTCX .            GET    @B@@@@      II
)@@G@@   GOTO  EGGTCP .            PUT    @C@@@@         GOTO  EGFMF .        IJ
)@@G@@     -> FORMAT    @F@@@@EGGTCP   LABEL .                   CLOSE PUT (DAIK
)@@G@@TA OR STRING)     @^@@@@         USING WORD,X5 .@C@@@@         LOAD  A7,IL
)@@G@@W1Q2 .           GET FLAGS    @C@@@@         AND,U A7,ICGTLF .         SIM
)@@G@@EE IF DATA  @E@@@@         IF    A8,EQ,2,I THEN,EGGTC1 . -> DATA STATEMEIN
)@@G@@NT    @D@@@@         IF    1,ON,DGOPT4 THEN,EGGTC1 . -> R OPTION  @D@@@@IO
)@@G@@EGGTCG   LABEL .                   CLOSE GET (STRING) @G@@@@         IF IP
)@@G@@   ICGTKF,OFF,W1Q2 THEN,JMP . ->NOT STRING, NO CALL CLOSE   @#@@@@EGGTC1IQ
)@@G@@   LABEL .  @D@@@@         LOAD  A7,EGLMJ .          SETUP LMJ X11,CLOSEIR
)@@G@@@D@@@@         ADD   A7,EGRTAD+FH2+2,X8 . SET CLOSE ADDRESS @#@@@@      IS
)@@G@@   GEN .    @^@@@@         GLITRG A7 .    @^@@@@         USING WORD,X5 .IT
)@@G@@@D@@@@         IF ICGTKF,OFF,W1Q2 THEN,EGFMF . -> NO STRING @#@@@@      IU
)@@G@@   GEN .    @D@@@@         GFREE AGRL1 .             FREE STRING IF TEMPIV
)@@G@@@#@@@@         XGPOP .  @#@@@@EGFMF    LABEL .  @D@@@@         JMP .    IW
)@@G@@                 RETURN TO CGDR     @#@@@@EGGTCX   LABEL .  @E@@@@      IX
)@@G@@   IF    ICGTKF,ON,W1Q2 THEN,EGGTC1 . -> CLOSE STRING @E@@@@         GENIY
)@@G@@ .                     PRODUCE FUDGE FOR ENDFILE@B@@@@         GSUB EXGCIZ
)@@G@@LS .          CLOSE I/O @#@@@@         JMP .    @G@@@@/. ...............JA
)@@G@@......................................................@G@@@@.        CLOJB
)@@G@@SE STATEMENT                                               .@G@@@@. ....JC
)@@G@@..................................................................@#@@@@JD
)@@G@@PLGIOC*  LOCAL .  @D@@@@         AND,U   F,0777 .          COUNT IN LOW JE
)@@G@@9 BITS@C@@@@         LOAD    A7,F+1 .          GET COUNT    @C@@@@      JF
)@@G@@   GETC .                     CLOSE FLAGS @C@@@@         LOAD  A10,A8 . JG
)@@G@@            SAVE THEM   @#@@@@EGCLLP   LABEL .  @C@@@@         GETC .   JH
)@@G@@                 SEARCH FOR !-@^@@@@         SRBD  A8,9 .   @F@@@@      JI
)@@G@@   IF    A8,NE,ACCOMA/IC,I THEN,EGCL94 . ->NOT NEXT FILE    @C@@@@      JJ
)@@G@@   GETC .                       FLAGS     @^@@@@         LOAD  A10,A8 . JK
)@@G@@@^@@@@         GOTO  EGCLLP . @#@@@@EGCL94   LABEL .  @F@@@@         IF JL
)@@G@@   A8,NE,ACSTEX/IC,I THEN,EGCLLP . -> GET NEXT TOKEN  @^@@@@         SLBJM
)@@G@@D  A8,9 .   @^@@@@         XGEN   I .     @#@@@@         GENM .   @D@@@@JN
)@@G@@         GINST OPLA,AGRA3,AGRL1,U .  LA  A3,SD-FILE   @^@@@@         GFRJO
)@@G@@EE AGRL1 .  @#@@@@         GLIT 1 . @C@@@@         LMJ   X11,EXIOCL .   JP
)@@G@@     CLOSE I/O    @B@@@@         GLITRG A10 .              FLAGS  @^@@@@JQ
)@@G@@         GFIN 'POP' .   @ @@@@         LOOP  A7,EGCLLP .    @A@@@@      JR
)@@G@@   JMP . RETURN TO CGDR .     @G@@@@. ..................................JS
)@@G@@....................................@G@@@@.        OPEN STATEMENT       JT
)@@G@@                                         .@G@@@@. ......................JU
)@@G@@................................................@#@@@@PLGIOO*  LOCAL .  JV
)@@G@@@^@@@@         USING WORD,X5 .@#@@@@EGOPNX   LABEL .  @E@@@@         LOAJW
)@@G@@D  X5,X1 .             SAVE PTR TO 'OPEN' ACODE @D@@@@         IF    W1HJX
)@@G@@2,ZERO THEN,EGOP01 . -> NO TITLE    @B@@@@         LMCP R,W1H2 . POINT TJY
)@@G@@O TITLE     @^@@@@         XGEN  R,2 .    @#@@@@         GENM .   @C@@@@JZ
)@@G@@         GINST OPLX,AGRX1,AGRL1,U . DV IN X1    @^@@@@         GFREE AGRKA
)@@G@@L1 .  @^@@@@         GFIN  'POP' .  @^@@@@         USING WORD,X5 .@#@@@@KB
)@@G@@EGOP01   LABEL .  @E@@@@         IF    W1H1+1,ZERO THEN,EGOP02 . -> NO LKC
)@@G@@INESIZE     @ @@@@         LMCP  R,W1H1+1 .     @^@@@@         XGEN  R,2KD
)@@G@@ .    @#@@@@         CGFIX .  @#@@@@         GEN .    @D@@@@         GINKE
)@@G@@ST OPLX,AGRX2,AGRL1 .  LINESIZE INTO X2   @#@@@@         XGPOP .  @#@@@@KF
)@@G@@EGOP02   LABEL .  @E@@@@         IF    W1H2+1,ZERO THEN,EGOP03 . -> NO PKG
)@@G@@AGESIZE     @ @@@@         LMCP  R,W1H2+1 .     @^@@@@         XGEN  R,2KH
)@@G@@ .    @#@@@@         CGFIX .  @#@@@@         GEN .    @D@@@@         GINKI
)@@G@@ST OPLA,AGRA5,AGRL1 .  PAGESIZE IN A5     @#@@@@         XGPOP .  @#@@@@KJ
)@@G@@EGOP03   LABEL .  @C@@@@         LMCP  R,W1H1+2 .            GET FILE   KK
)@@G@@@^@@@@         XGEN  R,2 .    @^@@@@         LOAD  A7,W1Q2 .@#@@@@      KL
)@@G@@   GENM .   @C@@@@         GINST OPLA,AGRA3,AGRL1,U . SD IN A3    @#@@@@KM
)@@G@@         GLIT  1 .@C@@@@         LMJ   X11,EXOPEN .        CALL I/O     KN
)@@G@@@B@@@@         GLITRG                    A7 .   @^@@@@         GFIN  'POKO
)@@G@@P' .  @D@@@@         IF    W1H2+2,ZERO THEN,JMP . -> NO MORE FILES@E@@@@KP
)@@G@@         LMCP  W1H2+2 .            GET NEXT FILE TO OPEN    @E@@@@      KQ
)@@G@@   GOTO  EGOPNX .            -> PROCESS NEXT FILE     @G@@@@/. .........KR
)@@G@@........................................................    @G@@@@/. ...KS
)@@G@@..................................................................@G@@@@KT
)@@G@@.        DATA STORAGE FOR CGIO                                         .KU
)@@G@@@G@@@@. ................................................................KV
)@@G@@......@#@@@@CGIO     CSECT 3 .@#@@@@EGRTAD   LABEL .  @D@@@@FILL(1)  SACKW
)@@G@@   EXGTLT,EXGTOP .     GET LIST,OPEN GET  @D@@@@FILL(1)  SAC   EXPTLT,EXKX
)@@G@@PTOP .     PUT LIST,OPEN PUT  @D@@@@FILL(1)  SAC   EXGTED,EXGTCL .     GKY
)@@G@@ET EDIT,CLOSE GET @D@@@@FILL(1)  SAC   EXPTED,EXPTCL .     PUT EDIT,CLOSKZ
)@@G@@E PUT @D@@@@FILL(1)  SAC   EXFMAT,EXGTDT .     CALL FMT,GET DATA  @D@@@@LA
)@@G@@FILL(1)  SAC   0,EXPTDT .          0,       PUT DATA  @#@@@@EGLMJ    SFWLB
)@@G@@   0 .@C@@@@         LMJ   X11,0 .             LINK ROUTINE @#@@@@EGFJMPLC
)@@G@@   SFW   0 .@^@@@@         LX,U X11,0     @#@@@@EGFUDG   SFW   0 .@G@@@@LD
)@@G@@         LX,U X1,0 .               LIST/NOLIST FLAG FOR GET/PUT DATA    LE
)@@G@@@#@@@@EGEDLK   SFW   0 .@G@@@@         LMJ     X11,*AREXFT-(IN 5,0,0,0),LF
)@@G@@X10 . SET LINK INSTRUCTION    @#@@@@EGJGD    SFW   0 .@^@@@@         JGDLG
)@@G@@   A3,0 .   @#@@@@EGLA6    SFW   0 .@^@@@@         LA,U  A6,0 .   @#@@@@LH
)@@G@@EGJMP    SFW   0 .@#@@@@         J     0 .@E@@@@EGF17    SFW   0 .      LI
)@@G@@           FIXED (17,0) STACK ENTRY @^@@@@FILL(1)  SQ    SD0ART . @C@@@@LJ
)@@G@@FILL(1)  SQ    SDDCBN .            FIXED BINARY @B@@@@FILL(1)  SQ    0 .LK
)@@G@@                 Q=0    @B@@@@FILL(1)  SQ    17 .                P=17   LL
)@@G@@@#@@@@         CEND .   @G@@@@ERIOWR   EQU   24 .                SYSIN/SLM
)@@G@@YSPRINT ASSUMED IN I/O STATEME@F@@@@EREGNE   EQU   25 .                NLN
)@@G@@O DATA FORMAT IN FORMAT FIELD @F@@@@EREGNL   EQU   26                  FLO
)@@G@@ORMAT WILL BE EXECUTED ONCE   @#@@@@         END .    ___   @^@@@@      LP
)@@G@@   GLITRG A7 .    @^@@@@         USING WORD,X5 .@D@@@@         IF ICGTKFLQ
)@@G@@@]DCZ#[@@CY!"^@CY?C@)CY!"@)CY?"C@@@I[@@CZA/,0[]#@@@CZA@]ECZ#[@@CY,C@@CYXLR
)@@G@@"^@CY,*@@@@G1@@@@G/K@ J(C@@CY?"C@CZ@[@@CY?C@@CY."G@CY?R@KCZC[@[EXTN8LEXRLS
)@@G@@^^K J0/,0^)?@@@ J0@@@CY;@]JCZ#N@0 J5/K@ J6@]KCZ#R]0CZ^R@KCZDR@)CZE*4@SZ[LT
)@@G@@/K@SZ[/K@[-9AA0CZ^A@KCZDA@)CZEC8FK@@[^@ J#[^@ IB[^@ I^[^@ G-[^@ H3[^@ H0LU
)@@G@@[^@ GVC@VK@[[@KCZB/K@ GVR@VK@@C@@C(![@[EX3C@@DPB"^@C(,*@@@@G1@@@@G/K@ KPLV
)@@G@@N@0 KO/K@ Q*@[HC('C@[EX>[@@C*0C@-EX?[@)C*1[@@C*2*@@C*0/K@ KYC@@C*1[@@C*2LW
)@@G@@C@@C*2[@[EX3C@)C(\"^)C*2*@@@@I/K@ K?(@[EX=/K@ K*C@[EX=[@[EX2(@[EX:/K@ K?LX
)@@G@@C@[EX:[@[EX2C/@@@[C@)C(0"^)C*2(@@@@IC8@@@@C/)@@[(@@C*2C8)@@@+@@@@I/)K K9LY
)@@G@@N@0 K8/K@ Q*@[VC('C@[EXP[@@CZFC@-EXO[@)CZGC/@@@[*@@CZGC8@@@@C/)@@[*@@CZFLZ
)@@G@@C8)@@@+@@@@I/)K LCN@0 LB/K@ Q*@[ZC('C/@@@[*@@CZGC8@@@@C/)@@[*@@CZFC8)@@@MA
)@@G@@)@@@@I/=K QVR/)@@[R/0@[=N.@@@[A@)C*3C@]CZE[@@C*4 @@C*5(@@C*4/K@ L:C/@@@[MB
)@@G@@G@@C*5[@@C*5R[@C*4G/@_"V/G@ L-*@@@@G/K@ QYC@@C*3T/@@[=G@@C*5C@)C*4[@?C)0MC
)@@G@@E[^EXW[[GCX*C@^EXQ[@@C*4/K@ LRC@@C*5[@]C*=C/)@@[[@<C<9G/@__./C@ L3*@@@@GMD
)@@G@@/K@ L_N8NC<9^^K L9N8NCX(^^K L8/,0^S#@@@ L8@@@ L9@@@C*5@@@C(1@@@C(2@@@C(2ME
)@@G@@@[4C('O/)@@[O/0@[=8L@ LN @@C*6 @@C*7C@@C*>[@@C*8C@)C*&[@)C*9 @@C*'G/@__"MF
)@@G@@R.@@@[[@@@[^A[@C*3C/@@@[G@@C*'[@@C*;H@@C*9/G@ MO*@@@@G/K@ QFC@^C>W[@@C*/MG
)@@G@@R@)C*/D@)C*;G@)C*9C[]C+O[[@C*.R@0C*.C[<EXW[[)C*"R@)C*;[@)@[ A@)C*5C@]C$@MH
)@@G@@[@@C*_R[KC*_C@>C<8[@)C(@R[KC(@C[ EXW[[@C([/,0 3%@@@C*"@@@C([@@@C(3@@@C(3MI
)@@G@@@@@C(]@@@C(#@@@C(^@]FC('(@@C(^/K@ M9C/@@@]H@@C(^/@@ QD/G@ Q /K@ QBC@#EXNMJ
)@@G@@[@@C( R[KEXZR[)C( R[0C(@C@$EXN[@)C(AR]@C(AC[#EXO[[@C(BR]KC(BC[$EXO[[)C(CMK
)@@G@@R[0C(CC]AEXV[]@C(DC]&EXW[])C(EC#AEXT"BDEXT[#@C(FC#(EXU"B&EXU]#)C(GC@CEXVML
)@@G@@[@@C(HC@*EXW[@)C(IC[CEXT" BEXT[[@C(JC[$EXU" *EXU][)C(KC]CEXX[]@C(LC]*EXYMM
)@@G@@[])C(MC#CEXS"#@C(4"N@@@S[#@@@F;<V@@D[#KC(NC_)@@[G_K__B*@@@@T0@@@@TC;)@@@MN
)@@G@@C_@@@[C@@C(NG/@__G*@@@@G1@@@@GC;@@@@)#)@@S/$0 ODC@ EXP[@@C(OR]KC(OC#DEXSMO
)@@G@@"#@C(5"#@C(4"N@@@S[#@@@F;<V@@D[#KC(PC_)@@[G_K_83*@@@@TC;)@@@C_@@@[C/)@@5MP
)@@G@@H@)C(N*@@@@I1@@@@IC;@@@@+#)@@S/$0 OD][@C(JC@@C(D"C@C(DC@)C(E"C)C(EC[@C(HMQ
)@@G@@"D@C(HC[)C(I"D)C(IC]@C(F"E@C(FC])C(J"E)C(JC#@C(G"F@C(GC#)C(K"F)C(K[#)C(.MR
)@@G@@C#)C(L"F)C(D"F)C(H[#)C("C#)C(M"F)C(E"F)C(I[#)C(_C#)C(""F)C("[#)C("C#)C(_MS
)@@G@@"F)C(_[#)C(_C#)C(L"F)C(,"F)C(F"F)C(J"F)C(D"F)C(H[#)C%@C#)C(M"F)C(,"F)C(GMT
)@@G@@"F)C(K"F)C(E"F)C(IR.)@@[N.)@@][@@C%[[@)C%][[@C%#[[)C%^[]@C% [])C%A[#@C%BMU
)@@G@@[#)C%CA[)C(QC@@C%["@AC*&[@@C(RC@)C%]"@&C*&[@)C(SC[@C%#"[AC*([[@C(TC[)C%^MV
)@@G@@"[&C*([[)C(U"C@C(T"D@C% " @C%@"^@C("C]@C%A"E@C(R"]@@@K"I@@@G[]@C(V"C)C(UMW
)@@G@@"D)C%B" )C%CC@@C(."C@C(S"@@@@M"^)C(_"G@@@I[@@C(W"]@C(W[]@C(XC/@@@[H@@C(QMX
)@@G@@*@@@@G/K@ P&C@@C(X[@@C(Y/,0^Q!@@@C(X@@@C(6@]4C('[@AC*?O.)@@[8L) O_C@)C*,MY
)@@G@@"@)C*\"C)DPIC[@DPI"D@C(," @C(!"D@C*!"^)@@K[@)C(Z"^)C*6/C) P'*@@@@I/K@ QBMZ
)@@G@@C@)C(Z[@)C*6C[@C(Y[[@C()C[)C*.[[)C*7C]@C(@[]@C(-C])C(][])C(+/K@ QBC@@C*5NA
)@@G@@[@@C*'O/)@@[8LK M)O.@@@[8L@ MG*@@C*7/K@ QKN@0 QJ/K@ Q*@# C('C@@C*6[@[EX4NB
)@@G@@C@)C(+[@-EX8C@@C*7[@[EX#C@)C(-[@-EX]N@0 QU/K@ Q*@#EC('N@0 QX/K@ Q*@#FC('NC
)@@G@@/,0[B%@@[C(<@#GC(''^@[&6/,0[H+@@@C(7@#JC('N@0 Q$/K@ Q*@#JC('R]0C(;9!)C%DND
)@@G@@9,@C%F9,)C%H9\@C%J9\)C%LR@KC%NR@)C%OR@0C%PR[@C%QR[KC%RR[)C%SR[0C%TR]@C%UNE
)@@G@@R]KC%VN[@C%WN[KC%XN[)C%Y*4@S(8/K@S(8/K@[-9AA0C(;9()C%D9%@C%F9%)C%H9:@C%JNF
)@@G@@9:)C%LA@KC%NA@)C%OA@0C%PA[@C%QA[KC%RA[)C%SA[0C%TA]@C%UA]KC%V^[@C%W^[KC%XNG
)@@G@@^[)C%Y/K@ KEC/@@@[[@@C%<R@K@@@R@)EXZ @@C%=C@:K@@[@)C%>C[]EXM[[@C%&C[)C:#NH
)@@G@@[[-EX>C@@C:#[@[EX?*@@C%&/K@ R+N@0 R-/K@ X]@[MC:QC@@C:#[@@C3]R@)C%&N8MEXRNI
)@@G@@^^K R*/,0^S5@@@ R*@@@C:^@@@C: @[OC:Q[@@C%$A@)C:TC@@C%$G/@__//C@ R3*@@@@GNJ
)@@G@@/K@ R6R@KC:TC@[EX>[@@C3]R@)C%<R@K@@@O@KC%=C@@C:A[@@C%* @@C%( @@C%%D@)C:#NK
)@@G@@[@)C%:C[@C:B[[[EX>(@@C%>/K@ W$R@0C%>C@#EXT[@[EX=C@<EXZ[@)C3@C@]DPF[@@C3[NL
)@@G@@C@)C:C[@-EX>C@#EXS"^@C:#/C@ SL*@@@@G/K@ W$C@#EXP[@@C%?(@@C%?/K@ V<R@)C%?NM
)@@G@@C@]EXT[@@C%!C@+EXU[@)C%,C[]EXV[[@C2.C@]EXW[@@C2"C@+EXP[@)C%\(@@C%\/K@ VZNN
@EOF
@COPY,IO  TEMP.1021-005-006,1021-005-006.
@FREE     TEMP.
