<!--This file created 6/5/97 10:01 PM by Claris Home Page version 2.0-->
<HTML>
<HEAD>
   <TITLE> Data Base Editor [DBE] Level 9R1 Programmer's Reference
   </TITLE>
   <META NAME=GENERATOR CONTENT="Claris Home Page 2.0">
   <X-SAS-WINDOW TOP=42 BOTTOM=765 LEFT=4 RIGHT=534>
<!DOCTYPE PUBLIC HTML "-//IETF//DTD HTML 2.0//EN" >
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P><CENTER><B>Data Base Editor</B></CENTER></P>

<P><CENTER><B>Programmer's Reference Manual</B></CENTER></P>

<P>This Programmer's Reference Manual corresponds to level 9R1 of
DBE. Features described in this document, while being implemented as
described herein, are subject to change or deletion at any time.</P>

<P>This manual provides instruction and reference to users wishing to
learn about the "programmability" of the Database Editor. Those users
interested in using the standard reporting capabilities or the
pre-programmed DBE functions should consult the "Database Editor
User's Guide".</P>

<P>Please note that DBE is not an official software product of UNISYS
Corporation and therefore falls into none of the standard software
support categories.</P>

<P>Problem reports may be submitted to:</P>

<P>Laura McQuade Ron Lammardo Unisys Corporation NYS Dept. of Social
Services 255 Washington Avenue Extension 40 N. Pearl St. Albany, NY
12205 Albany, NY 12243</P>

<P>Such reported problems will be handled on an "as time allows"
basis.</P>

<P>This document is intended to provide the reader with all
information necessary to write macros using the DBE macro language.
</P>

<P>An additional DBE document, the 'Database Editor Technical Guide',
provides a technical overview of the construction, generation and
maintenance of the processor itself. The technical document will
likely be of interest only to the technician whose job it is to
maintain DBE.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | | </B></CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>1. INTRODUCTION</H1>

<P>This manual is intended to serve as a guide for the DBE user who
plans on developing DBE macros. Readers of this manual should already
have a familiarity with DBE and the material presented in the
"Database Editor User's Guide."</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Modes of Operation | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.1. DBE Modes of Operation</H2>

<P>There are four basic modes in which the DBE processor may operate:
</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>1. CONVERSATIONAL MODE. This is the mode where command inputs to
DBE are coming directly from the user. This is the most elementary
mode of operation, and is the mode DBE is in initially when it is
invoked.</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>2. MACRO MODE. This is a secondary mode of operation whereby a
user has requested that a macro be executed. From this time onward,
commands will be taken from within the macro being executed rather
than from the user. The macro executing may invoke other macros. When
the macro being executed halts (via STOP or RETURN), the user will
again be in CONVERSATIONAL MODE.</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>3. MACRO SUSPEND MODE. This is a third mode of operation that may
be entered voluntarily by the user or automatically following a macro
abort. This mode of operation is similar to CONVERSATIONAL mode in
that commands are entered from the user, but statements within macros
may also be executed. Hereafter, this mode may be considered
equivalent to CONVERSATIONAL mode - consult the chapter on DEBUGGING
FACILITIES for information on the specific benefits of this mode.
</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>4. USAGE, or DEFINITION MODE. This is a special mode available
only to a restricted set of users (known as MASTER users). It is
within this mode of operation that commands may be entered by the
user to register/deregister users and terminals with the DBE Security
System. This mode of operation is available only if DBE has been
generated with the Security System activated. Consult the "Database
Editor Technical Guide" for more information on this mode.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | Batch vs. Demand Behavior | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.2. Batch vs. Demand Behavior</H2>

<P>Certain commands or statements may behave slightly differently in
BATCH mode than in DEMAND mode. The basic differences in behavior
will be quantity/format of printout produced by the command (taking
advantage of the 132-col batch print limit). The commands that will
be affected by this are:</P>

<P>&nbsp;</P>

<P>PRINT</P>

<P>PRINT!</P>

<P>OUTPUT</P>

<P>HISTOGRAM</P>

<P>In addition, certain system macros will also produce different
formats or quantities of output when in BATCH mode. These macros are:
</P>

<P>&nbsp;</P>

<P>PGDUMP</P>

<P>DATA</P>

<P>OVERFLOW</P>

<P>OVERFLOW-ALL</P>

<P>PAGE-USAGE</P>

<P>PAGE-USAGE-ALL</P>

<P>R$SCAN</P>

<P>SCAN-ONE</P>

<P>SIZE-REPORT</P>

<P>TOC</P>

<P>The following logic is used internally to determine whether DBE is
in BATCH or DEMAND mode:</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>1. The system-supplied indicator is used at program start-up to
make a "first guess."</P>

<P>&nbsp;</P>

<P>2. If DBE is found to have been executed while within @BRKPT mode,
BATCH mode will be assumed (regardless of #1).</P>

<P>&nbsp;</P>

<P>3. If DBE was executed with the "D" option set, DEMAND mode will
be assumed (regardless of #1 or #2).</P>

<P>At any time during the DBE session, the user (or a macro) may
manipulate the "D" option via the ON and OFF commands to set or clear
DEMAND mode status.</P>

<P>The current status (DEMAND/BATCH) is always available for the DBE
commands that require such information and is always available to the
user (or macros) through the variable MODE.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Files and @USE Names | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.3. Files and @USE Names Used by DBE</H2>

<P>The following @USE names will be automatically defined upon entry
to DBE:</P>

<P>&nbsp;</P>

<P>1. CSINTNAME$. This is a @USE name attached to the file from which
DBE was executed.</P>

<P>&nbsp;</P>

<P>2. DBE$SYSLIB. This is a @USE name attached to the file containing
the DBE system macros.</P>

<P>&nbsp;</P>

<P>3. DBE$HELPLIB. This is a @USE name attached to the file
containing the symbolic elements required for the on-line assistance
macros.</P>

<P>&nbsp;</P>

<P>The following @USE names will be conditionally defined:</P>

<P>&nbsp;</P>

<P>4. DBE$PF. This will be attached to the current user macro library
(if any).</P>

<P>&nbsp;</P>

<P>5. SCHEMA$FILE$. This will be attached to the EXEC file from which
the currently-loaded schema came. If the currently-loaded schema is a
TIP schema, this @USE name will be undefined.</P>

<P>&nbsp;</P>

<P>6. AREA$FILE$. This will be attached to the EXEC file constituting
the current area. If the current area is a TIP file, this @USE name
will be undefined.</P>

<P>&nbsp;</P>

<P>7. ALT$FILE$$$$. This will be attached to the current EXEC
hardcopy file (if any). If HARDCOPY mode is currently inactive, or
HARDCOPY output is being sent to a TIP printer, this @USE name will
be undefined.</P>

<P>&nbsp;</P>

<P>8. In addition, each Exec User file has an @USE name attached to
it - that @USE name will be the fileid given to the file when it was
OPENed. Consult chapter 9 for more information on user files.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Internal Storage | </B></CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.4. DBE Internal Storage Representation</H2>

<P>DBE is a FIELDATA-based processor. Character strings and macro
source statements will therefore be represented in FIELDATA. DBE does
have the ability to read ASCII data from a file or database and print
that data at the terminal (in either FIELDATA or ASCII form) or write
it to a disc or tape.</P>

<P>Attempts to use full upper-lower case text in messages printed by
DBE macros may be thwarted by the automatic ASCII-FIELDATA conversion
performed upon macros when they are executed. Note that it will be
possible to preserve the ASCII representation of data retrieved from
a file or database, but not that within a macro itself or for data
read from the terminal.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Language Elements | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.5. An Introduction to DBE Language Elements</H2>

<H3>1.5.1 Expressions</H3>

<P>Most DBE statements allow the use of expressions. These are
standard numeric expressions as per most programming languages
except:</P>

<P>&nbsp;</P>

<P>1. All expressions are limited to INTEGER values not exceeding one
36-bit word in precision. Standard ones-complement representation is
used to store negative values internally.</P>

<P>&nbsp;</P>

<P>2. All expressions may actually provide 1) an INTEGER numeric
value, 2) a six-character FIELDATA string, 3) a four-character ASCII
string or 4) a BOOLEAN, or LOGICAL value of TRUE or FALSE (an
expression having the binary value of 0 is considered FALSE while all
other values will be considered TRUE). The actual meaning of the
expression is implied by the manner in which it is used. Since DBE is
a totally TYPELESS language, expression values are open to
interpretation in much the same way as a word of computer memory
would be to an Assembler program.</P>

<P>The following sections describe the various components of
expressions in DBE.</P>

<H4>1.5.1.1 Integers</H4>

<P>Decimal or Octal integer numbers may be used, providing the number
falls in the range 0400000000000 - 0377777777777 Octal, or
-34359738367 - 34359738367 Decimal. These are the precision limits to
a single 36-bit ones-complement value. If an integer is specified
with a leading zero, it will be treated as an OCTAL number. Integers
beginning with the digits one through nine are treated as DECIMAL.
</P>

<H4>1.5.1.2 Numeric Literals</H4>

<P>Hexadecimal, Octal or Binary numbers may be specified using
numeric literals. The values of such literals cannot exceed 36 bits
of precision.</P>

<H4>1.5.1.3 Variables</H4>

<P>&nbsp;</P>

<P>Variables are SCALAR, ONE-DIMENSION ARRAYS or TWO-DIMENSION
arrays. The two types of arrays are similar to arrays in most
programming languages with the exception that each item of the array
is limited to a single word (36 bits) of storage - a mechanism does
exist however to take all or a portion of an array as a single entity
known as a SUBSET. SUBSETs will be discussed in detail later. SCALAR
variables are single-word non-subscripted variables, capable of
holding any 36-bit value. When referencing an element of an array,
standard (...) notation is used. The first word of an array is word
one.</P>

<H4>1.5.1.4 Strings</H4>

<P>Strings of ASCII or FIELDATA characters may be used within
expressions, so long as they do not require more than a single word
of storage. Such strings will be treated as right-justified, zero-bit
filled quantities. For example, the string 'A1' would be treated as
being the octal value 0661 when used within an expression.</P>

<P>Strings are denoted as a sequence of cheracters imbedded within
single-quote (apostrophe) marks. If the apostrophe character itself
is to be used as a character within the string, this fact is denoted
by using two consecutive apostrophes as the desired point. For
example, the string 'IT''S' would actually be the string representing
the contraction - IT'S.</P>

<P>Strings, by default, are considered to be FIELDATA. If a string is
to be ASCII, the letter "A" must IMMEDIATELY follow the last
apostrophe - there must be no space(s) between the ' and the "A".
Thus, the string 'A1' would have the octal value 0661 while the
string 'A1'A would have the octal value 0101061.</P>

<P>&nbsp;</P>

<P>There are also uses for FIELDATA strings in excess of 6
characters. These strings are NOT ALLOWED IN EXPRESSIONS however. The
use of these longer strings will become apparent in the documentation
of DBE statements such as LET and PARAMETER.</P>

<H4>1.5.1.5 Tables</H4>

<P>Any of the schema/subschema/page tables known to DBE are available
within expressions, provided a specific word of the table is
referenced by subscripting via [...]. For example, ART[10] refers to
the word ten of the current Area Reference Table. Note that the first
word of any table is word zero.</P>

<H4>1.5.1.6 Partial-word Designators (J-designators)</H4>

<P>When referencing a word of an array or table or when referencing a
SCALAR variable, a selected subsection of the 36-bit value of that
item may be referenced by use of a J-DESIGNATOR. Thus, the first half
(18 bits) of word 15 of the current Area Reference Table would be
selected by specifying ART[15]:H1. All j-designators recognized by
the 1100-series Assemblers (ASM or MASM) are recognized as well as a
group peculiar to DBE. In addition, the user may custom-design
j-designators via the PWORD command.</P>

<P>&nbsp;</P>

<H4>1.5.1.7 Operators</H4>

<P>None of the previous items provide any real benefit whatsoever
without the arithetic operators. In addition to the standard four
arithmetic operators (+, -, * and /) there are operators to perform
remainder division, arithmetic shifts and bit-logical operations.
</P>

<P>Expressions making use of only the above type of operators are
known as SIMPLE ARITHMETIC EXPRESSIONS. There is only one case where
DBE restricts the use of expressions to the SIMPLE ARITHMETIC
EXPRESSION category - within SUBSET references (more on that later).
</P>

<P>Additional operators available to expand beyond the SIMPLE
ARITHMETIC category are the various relational operators (&lt;, =,
etc.) and the logical combinative operators (OR, AND, XOR).</P>

<H4>1.5.1.8 Parenthesis</H4>

<P>There is a prescribed precedence of operation with the DBE
expression operators. If this order of evaluation needs to be
altered, elements of the expression may be grouped together with
parenthesis. This is similar to other programming languages.</P>

<P>As an example, according to standard precedence rules, the
expression 3*4+1 would produce the value 13. However, the expression
3*(4+1) would produce the value 15.</P>

<H3>1.5.2 Statement Types</H3>

<P>The various commands discussed in the "Database Editor User's
Guide" as well as in this manual may be thought of as the statements
in the DBE macro programming language. While not all statements may
be used within a macro, and not all commands may be used in
CONVERSATIONAL mode, there is a large "crossover" of statements that
may be used in either manner.</P>

<P>All DBE commands fit into one of the following categories:</P>

<P>&nbsp;</P>

<P>1. SCHEMA/DATABASE I/O COMMANDS. These commands are described
completely in the "Database Editor User's Guide" and all, with the
exception of the SCHEMA and SUBSCHEMA commands may be executed in
either CONVERSATIONAL or MACRO mode. The SCHEMA and SUBSCHEMA
commands cannot be executed while within MACRO mode.</P>

<P>&nbsp;</P>

<P>2. TABLE PRINTING COMMANDS. Also described in the DBE User's
Guide, these commands are unrestricted.</P>

<P>&nbsp;</P>

<P>3. MISCELLANEOUS COMMANDS. These commands are also described in
the DBE User's Guide, and are unrestricted.</P>

<P>Note: The remaining command categories are presented in this
manual:</P>

<P>&nbsp;</P>

<P>4. SYSTEM COMMANDS. These commands are illegal within a macro.
These commands control such activities as 1) Creating macros, 2)
Deleting macros, 3) Listing macros and 4) Saving macros.</P>

<P>&nbsp;</P>

<P>5. DATA DEFINITION/DECLARATION STATEMENTS. These statements allow
1) User data items (variables) to be declared and given values, 2)
Parameters to be retrieved from the macro call, 3) Variables to be
shared between two macros. Some of these statements are legal only
within macros.</P>

<P>&nbsp;</P>

<P>6. PROCEDURAL CONTROL STATEMENTS. These statements allow 1)
Conditional statement execution, 2) Loop control, 3) Branching
capabilities and 4) Macro termination. These are intended for use
only within macros.</P>

<P>&nbsp;</P>

<P>7. I/O STATEMENTS. These statements allow I/O operations to be
performed to the terminal/printer, disc files and tape files.</P>

<P>&nbsp;</P>

<P>8. HIGH-LEVEL STATEMENTS. These statements enable 1) Arrays to be
sorted (word-by-word), 2) Gross record counts to be taken for the
current area and 3) Histograms to be printed.</P>

<P>&nbsp;</P>

<P>9. SORT/MERGE STATEMENTS. These statements provide an interface to
the standard 1100-series SORT/MERGE package. At present, only SORT
facilities are supported.</P>

<P>&nbsp;</P>

<P>10. DEBUGGING COMMANDS. These commands provide a powerful source
language debugging facility. None of these commands are intended for
use within macros.</P>

<P>In addition to the various statement types, there are a series of
system macros that have been developed for use within macros. These
macros provide a powerful set of utility "subroutines" and
"functions" that may greatly assist the macro designer.</P>

<H3>1.5.3 Statement Formats</H3>

<P>DBE is a free-form language - statements may begin anywhere on an
input line, or within a macro text line. Statements may [optionally]
have one- to six-character labels associated with them. Labels may be
composed of any characters other than "=", "*", "@", space or ":".
</P>

<P>Comments may occur on any DBE statement by placing a commercial
at-sign (@) after the last meaningful part of the line, followed by
the desired comment. An @ within quotes DOES NOT signify the start of
a comment. Lines may be taken IN THEIR ENTIRETY as comments by simply
making the first non-blank character of the line an @.</P>

<P>So, the general format of any DBE statement is as follows:</P>

<P><CENTER>[label:] [text] [@ comment]</CENTER></P>

<P>Note the implication that entirely blank lines are legal. Blank
lines will be ignored by the DBE command scanner.</P>

<P>The label MUST begin in column one. The following are some
examples:</P>

<P>Columns 1 2 3 4 5 6
123456789012345678901234567890123456789012345678901234567890 LABEL:
AREA TEST-AREA LB#2: RECORD MY-RECORD-NAME %"+(): @ THIS IS A COMMENT
LINE (HOWS THAT FOR AN ODD LABEL)</P>

<P>LABEL: @ ANOTHER COMMENT - THIS IS A BAD LABEL (NOT COL 1) LAB@EL:
@ ANOTHER BAD LABEL (IMBEDDED @)</P>

<P>@ THIS IS A COMMENT LINE CONTAINING NO EXECUTABLE CODE</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Language Elements | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | Subsets | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>1.5.4 Subsets</H3>

<P>One type of SUBSET is a selected set of contiguous words taken
from a table or array. Using this facility, all or a portion of an
array or table may be referenced as a single entity (this entity may
NOT, however, be used as part of an expression.</P>

<P>A second type of SUBSET allows individual bytes OF ARBITRARY SIZE
(&lt;= 36 bits) to be selected from an array. This second facility
provides an extremely powerful and flexible string-processing
facility.</P>

<P>Subsets will be discussed in more detail in a later section.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Language Elements | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | Functions | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>1.5.5 Functions</H3>

<P>A variety of DBE FUNCTIONS exist to assist the programmer. Some of
the functions that may be performed by these functions are 1)
Performing the function of the DMR GS11 (DMSCALC) routine, 2)
Encoding or Decoding database keys and pointers or 3) Submitting
control images to the Exec (via ER CSF$).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | DBE Language Elements | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | Macros | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>1.5.6 Macros</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>Macros are a collection of DBE commands and statements "packaged"
together to form a "program". This program is accessed by referencing
its name in the same way one would execute any of the DBE
commands/statements or the DBE LET statement functions.</P>

<P>Macros may be temporary to the current DBE session or held across
multiple DBE sessions by storing them as source elements within
program files using their names for the element name (with versions
of spaces). Such macros are system-supplied (these macros are known
as SYSTEM MACROS) or are user-written (these are USER MACROS). All
SYSTEM MACROS are kept in a file specified as the System Library
during the DBE system generation. User macros are kept in a file of
the user's choice. To access user macros, the file in which the
macros are stored must be:</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>1. Assigned to the user's run with a @USE name of DBE$PF or...
</P>

<P>&nbsp;</P>

<P>2. Specified as spec 1 of the DBE processor call or...</P>

<P>&nbsp;</P>

<P>3. Specified on a call to the LIBRARY macro.</P>

<P>Users may execute macros directly, or from within other macros.
Macros may serve the basic function of a command, thus extending the
apparant DBE command set, or may return values similar to the
technique used by the DBE FUNCTIONs, thus extending the DBE FUNCTION
set.</P>

<P>The "Database Editor User's Guide" describes a number of system
macros. Those macros were developed with the intention that they
would be used as "commands" directly by the user. There is NO REASON
why they could not be used as "statements" within user-written macros
however.</P>

<P>This manual will discuss a number of system macros that have been
written for the express purpose of providing "utility subroutines"
for the macro programmer.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 1 | Accessing the DBE Processor | </B>
</CENTER></P>

<P><CENTER><B>| INTRODUCTION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>1.6. Accessing the DBE Processor</H2>

<P>&nbsp;</P>

<P>DBE is called as follows:</P>

<P>&nbsp;</P>

<P>@dbe-file.DBE[,options] [library-filename.][,pid]</P>

<P>where "dbe-file" represents the qualifier*filename of the file in
which the DBE absolute resides.</P>

<P>The first spec field is a filename in standard format. If present,
the @USE name of DBE$PF will be attached to it, thus making this file
the user macro library. See the previous section for more
information.</P>

<P>The second spec field, if present, specifies that hardcopy should
be generated to a TIP printer rather than to the on-site high-speed
printers. The PID number of the tip printer selected will be the
value of this field. Note that this feature will be available only
for versions of DBE that have been configured for TIP.</P>

<P>&nbsp;</P>

<H3>1.6.1 Options</H3>

<P>A Accept errors in batch mode. This option (ignored in demand
mode) will cause DBE to recover from DBE-detected errors (not
contingency errors) should they occur. The normal action for batch
jobs in this case is for DBE to be terminated. Macros will still be
terminated</P>

<P>&nbsp;</P>

<P>B Brief mode is wanted. Only output from the following commands
will be printed:</P>

<P>&nbsp;</P>

<P>LIST</P>

<P>OUTPUT</P>

<P>PRINT</P>

<P>WRITE</P>

<P>&nbsp;</P>

<P>C Simulate console I/O at the terminal. This is useful for
debugging macros which do I/O involving the system console. If this
option is on, the output to the console will appear at the terminal
in the form:</P>

<P>&nbsp;</P>

<P>****CONSOLE:</P>

<P>&lt;output&gt;</P>

<P>If the operator was to respond, the terminal operator may then
enter the desired response.</P>

<P>&nbsp;</P>

<P>D This option is used to declare the user to be in 'demand' mode.
Its effect will be to set the system variable 'MODE' to zero rather
than to one. This option may be turned 'OFF' via the DBE 'OFF'
command (thus simulating batch mode) even if it was not explicitly
turned 'ON'. See the section on 'Processor Operation' in this chapter
for more information.</P>

<P>&nbsp;</P>

<P>E Disable the KEYIN$ handler. This option is only valid on the DBE
processor call.</P>

<P>&nbsp;</P>

<P>F Run at REALTIME priority. The level of realtime as well as the
ability to run realtime is controlled via a DBE sysgen parameter.
</P>

<P>&nbsp;</P>

<P>G Do not print DBE processor identification signon or signoff
messages.</P>

<P>&nbsp;</P>

<P>H A hardcopy duplicate of all DBE-produced printout will be sent
to the current hardcopy device when this option is on. See the
'HARDCOPY' command for more information.</P>

<P>&nbsp;</P>

<P>I Not used by DBE - reserved for site definition.</P>

<P>&nbsp;</P>

<P>J Not used by DBE - reserved for site definition.</P>

<P>&nbsp;</P>

<P>K Not used by DBE - reserved for site definition.</P>

<P>&nbsp;</P>

<P>L Not used by DBE - reserved for site definition.</P>

<P>&nbsp;</P>

<P>M Not used by DBE - reserved for site definition.</P>

<P>&nbsp;</P>

<P>N No printing (except for error messages) will appear at the
terminal. This can be used in conjunction with the 'H' option to
simulate a '@BRKPT' situation. Since option letters can be
manipulated via the 'ON' and 'OFF' commands, the user can write
macros that, in effect, do breakpoints. (See the 'SITE' and 'SEND'
macros.) Should an error occur within a macro while the 'N' option is
in effect, errors deemed as "recoverable" (see Appendix A) will not
have their messages printed. This gives the macro writer the ability
to suppress messages that are of a warning nature.</P>

<P>&nbsp;</P>

<P>O Not used.</P>

<P>&nbsp;</P>

<P>P Cause PAUSE macro to act as if in batch mode.</P>

<P>&nbsp;</P>

<P>Q Have DECODE function return a result of zero instead of erroring
when an invalid area code is processed.</P>

<P>&nbsp;</P>

<P>R Reverse the order in which the macro library files are searched.
See the chapter on macros for more information.</P>

<P>&nbsp;</P>

<P>S Suppress the printing of DBE system news at DBE sign-on time.
This is useful when calling DBE within @ADD runstreams. See the
'NEWS' macro for more information.</P>

<P>This option cannot be manipulated via the 'ON' and 'OFF' commands.
</P>

<P>&nbsp;</P>

<P>T Trace conversational mode commands as they are input, whether
keyed from a terminal or @ADD'ed. Note that commands executed by a
macro can only be traced using the 'TRACE' command in DEBUG mode.
</P>

<P>&nbsp;</P>

<P>U Not used.</P>

<P>&nbsp;</P>

<P>V Not used.</P>

<P>&nbsp;</P>

<P>W Not used.</P>

<P>&nbsp;</P>

<P>X Abort DBE if DBE-detected errors occur. This option (ignored by
batch runs) allows the demand user to, in effect, become a batch job
as far as error-handling is concerned.</P>

<P>&nbsp;</P>

<P>Y 'AREA' commands will reference training mode areas.</P>

<P>&nbsp;</P>

<P>Z Used for debugging purposes only. SETCTR 1,2</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>2. EXPRESSIONS</H1>

<P>The purpose of this chapter is to provide an in-depth study of the
components of DBE expressions, both SIMPLE and FULL.</P>

<P>Remember that ALL DBE expressions will have 36-bit values, the
meaning of which depends on how the expression is used. Reviewing the
uses for expressions, they may:</P>

<P>&nbsp;</P>

<P>1) Be used simply as a 36-bit integer value</P>

<P>&nbsp;</P>

<P>2) Be used to signify a TRUE/FALSE condition, where a value of
zero means FALSE and anything else means TRUE</P>

<P>&nbsp;</P>

<P>3) Be used to represent a 6-character FIELDATA or 4-character
ASCII string.</P>

<H2>2.1. Integers</H2>

<P>Integers may be expressed as unsigned decimal, signed decimal or
octal. Octal integers are denoted by having a leading zero. Octal
integers should not contain the digits 8 or 9. Decimal numbers are
simply specified in their decimal form with or without a leading
sign. For example:</P>

<P>This... Produces this value (internally).... 010 000000000010</P>

<P>10 000000000012 +10 000000000012 -10 777777777765</P>

<H2>2.2. Numeric Literals</H2>

<P>Through the use of numeric literals, hexadecimal, octal or binary
numbers may be used in expressions. Such quantities are limited to 36
bits of precision. These literals are formed as follows:</P>

<P><CENTER>Hexadecimal Literals</CENTER></P>

<P>&nbsp;</P>

<P>X'hexadecimal value' or H'hexadecimal value'</P>

<P><CENTER>Octal Literals</CENTER></P>

<P>O'octal value'</P>

<P><CENTER>Binary Literals</CENTER></P>

<P>&nbsp;</P>

<P>B'binary value'</P>

<P>Note that the OCTAL LITERAL in fact duplicates the capabilities
allowed by the use of an integer with a leading zero. Octal literals
are included with the other numeric literals primarily for
compatability purposes. Note also that two forms of hexadecimal
literals exist - X'...' and H'...'. The two forms are equivalent.
</P>

<P>The following are all examples of numeric literals with the
decimal value of 510:</P>

<P>B'111111110' O'776' H'1FE' X'1FE'</P>

<H2>2.3. Variables</H2>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Variables | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>There are two basic categories of variables - USER and SYSTEM.
Each category may have three types - SCALAR, 1-DIMENSION ARRAY and
2-DIMENSION array (presently, however, no 2-dimension system
variables exist).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Variables | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | User Variables | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.3.1 User Variables</H3>

<P>Users may create variables as needed, whether in CONVERSATIONAL,
MACRO or MACRO SUSPEND mode. There is a finite limit to the number of
defined variables, as specified in the DBE system generation -
consult your site DBE-support individual for the exact number. This
limit applies to only ANY ONE MACRO (for purposes of this discussion,
CONVERSATIONAL MODE will be considered to be one macro). Thus, if the
variable limit is 64, then NO ONE MACRO may define more then 64
variables. If macro "M1" calls macro "M2", then macro "M1" may have
its own set of 64 variables and macro "M2" may have its own set. In
addition, there would be 64 variables available in CONVERSATIONAL
MODE.</P>

<P>Variables may be defined as arrays (1- or 2-dimensional) or may be
implicitly considered to be scalars. Note that no variable is
considered defined until it has been either given a value (in the
case of SCALARs), DIMENSIONed (in the case of arrays) or implicitly
defined as required via the GLOBAL statement. Attempting to refer to
a variable prior to defining it will cause an error.</P>

<P>Scalars are referred to simply by name, while arrays require one
or two subscripts. The subscript mechanism works similarly to other
programming languages, selecting a SINGLE WORD of the array. Thus, if
variable "A" is a one-dimension array and variable "B" is a
two-dimension array, then we would refer to the first element of "A"
as "A(1)" and we would refer to the fourth "column" of "row" 1 of "B"
as "B(1,4)".</P>

<P>The first element of an array (or the first row/column) is
numbered 1. Any attempt to use a subscript value less than 1 or
higher than the number of words allocated (or the number of rows or
columns) will result in an error - all subscript references WILL be
checked.</P>

<P>The user may use variable names 1-12 characters long. The set of
characters that may be used in a variable name are as follows:</P>

<P><CENTER>A-Z, 0-9, $, ?, ^ and #</CENTER></P>

<P>Note however that the first character of a variable name MUST be
either a letter or the symbol $. Thus, the following are legal
variable names:</P>

<P>&nbsp;</P>

<P>PAGE#</P>

<P>AREA$TYPE</P>

<P>PAGE^</P>

<P>IS$REC$CALC?</P>

<P>VAR00001</P>

<P>The following are NOT legal variable names:</P>

<P>&nbsp;</P>

<P>AREA-TYPE (- not allowed, would probably be treated as a minus
sign)</P>

<P>&nbsp;</P>

<P>#RECS$ON$PG (doesn't start w/ A-Z or $)</P>

<P>&nbsp;</P>

<P>IS$AREA$DARP? (too long - cannot exceed 12 characters)</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Variables | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | System Variables | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.3.2 System Variables</H3>

<P>TOCLVL 4 The various system variables are pre-defined by DBE, and
their names may not be duplicated by user variables without running
the risk of un- predictable results. System variables do not count in
the number of variables for any one macro. */ACODE</P>

<H4>2.3.2.1 ACODE: Scalar</H4>

<P>This variable will contain the schema-specified area code of the
current area (if any). If no area is current or no schema has been
loaded, the value will be zero. *// */APP$BDI</P>

<H4>2.3.2.2 APP$BDI: Scalar</H4>

<P>This variable will contain the BDI of the UDS Global D-Bank for
the currently based UDS Application. If no application is current,
the value will be zero.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$NAME</P>

<H4>2.3.2.3 APP$NAME: Scalar</H4>

<P>This is the name of the currently based UDS Application in
FIELDATA format. If no application is current, the value will be
spaces.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$NBR</P>

<H4>2.3.2.4 APP$NBR: Scalar</H4>

<P>This is the number of the currenltly based UDS Application (1-9).
If no application is current, the value will be zero.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$QUAL</P>

<H4>2.3.2.5 APP$QUAL: One-dimension array - 2 words</H4>

<P>This is the Application Qualifier for the currently based UDS
Application in FIELDATA format. If no application is current, the
value will be zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$THRDNUM</P>

<H4>2.3.2.6 APP$THRDNUM: Scalar</H4>

<P>This is the currently selected thread number within the current
UDS application. If no application is current or no thread has been
selected, the value will be zero.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$TSTEADDR</P>

<H4>2.3.2.7 APP$TSTEADDR: Scalar</H4>

<P>This is the BDI (H1) and address (H2) of the Thread Summary Table
Entry (TSTE) for the current thread in the current UDS application.
If no application is current or no thread has been selected, the
value will be zero.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */APP$UDS</P>

<H4>2.3.2.8 APP$UDS: Scalar</H4>

<P>This flag identifies if the current UDS Application (1-9) is
actually under UDS control (value of 1) or a "Pseudo" application. If
no application is current, the value will be zero.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */AREAP</P>

<H4>2.3.2.9 AREAP: Scalar</H4>

<P>Set to one if the pages of the current area cannot be accessed,
either due to an "AREA,P" command or an error occurring while reading
during an "AREA" command. *// */ART</P>

<H4>2.3.2.10 ART^: Scalar</H4>

<P>This is the word number within the Schema Reference Table {SCRT}
of the currently-loaded schema where the Area Reference Table {ART}
of the current area may be found. If there is no schema loaded, or no
area is current, this value will be zero.</P>

<P>This is useful in locating certain SCRT subentries which are
pointed to from the ART in a ART[0]-relative manner. *// */ASEQ</P>

<H4>2.3.2.11 ASEQ: Scalar</H4>

<P>This variable will contain the sequence number of occurrence of
the current area's Area Reference Table {ART} within the
currently-loaded schema. If no area is current or no schema is
loaded, this value will be -1. *// */CARCTL</P>

<H4>2.3.2.12 CARCTL: Scalar</H4>

<P>This variable contains the carriage-control value for the most
recently acquired print-file record. The contents of this variable
will be valid ONLY after a record has been read from an SDF PRINT$
file via the GET statement. A negative value indicates that a page
eject is to occur before the current image would be printed. A zero
value indicates that the current image is to be over-printed on the
current line (unless the current image is a print-control image - see
the PRTCN variable). A non-zero positive value indicates the number
of lines to be skipped before printing the current image. For an
example on the use of this variable, study the system macro SYM. *//
*/CHARSC</P>

<H4>2.3.2.13 CHARSC: Scalar</H4>

<P>This contains the number of characters presently in use in the
console WRITE buffer. *// */CHARSW</P>

<H4>2.3.2.14 CHARSW: Scalar</H4>

<P>This variable contains the number of characters presently in use
in the standard terminal/printer WRITE buffer. *// */CHRSET</P>

<H4>2.3.2.15 CHRSET: Scalar</H4>

<P>This variable contains an indicator of the characterset of the
image most-recently read (via GET) from an SDFI file. A value of zero
means FIELDATA while a value of one means ASCII *// */CONDWD</P>

<H4>2.3.2.16 CONDWD: Scalar</H4>

<P>This variable contains the 36-bit value of the runs CONDITION
WORD. When it is referenced, the current condition word contents will
be retrieved (via ER COND$) and assigned as the value of CONDWD.</P>

<P>This is the ONLY system variable WHICH THE USER MAY MODIFY. Any
value may be given TO THE FINAL THIRD-WORD (right-most 12 bits) only.
Any change made to CONDWD will be passed to the system via ER SETC$.
</P>

<P>DBE will reject any attempts to modify portions of CONDWD other
than bits 11-0. *// */COPIES</P>

<H4>2.3.2.17 COPIES: Scalar</H4>

<P>This contains the number of Exec HARDCOPY print files that will be
@SYMed when hardcopy mode is terminated. The value of this variable
is defined via the HARDCOPY command. Specification of TIP hardcopy
will force this value to 1 (which is also the default Exec hardcopy
value). *// */DATE</P>

<H4>2.3.2.18 DATE: Scalar</H4>

<P>This is the current date in FIELDATA format (MMDDYY). Note that
this value is set when DBE starts executing and will not be changed
during that execution even if the date should change. *// */DBELEVEL
</P>

<H4>2.3.2.19 DBE^LEVEL^: Scalar</H4>

<P>This is the level of DBE currently being run in FIELDATA format.
The "R" is included before the revision number as in "9R1". *//
*/DBEGEN</P>

<H4>2.3.2.20 DBE^GEN^: Scalar</H4>

<P>This is the gen numberof the current DBE in FIELDATA format. *//
*/DBEGENDATE</P>

<H4>2.3.2.21 DBE^GENDATE^: Scalar</H4>

<P>This is date the version of DBE being executed was created in
FIELDATA format (YYMMDD). *// */DD$FILE</P>

<H4>2.3.2.22 DD$FILE: One-dimension array - 5 words</H4>

<P>This is the qualifier*file for the DD/UREP processor for the
currently based UDS application group. If no application is current,
the value will be all zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */DDL$FILE</P>

<H4>2.3.2.23 DDL$FILE: One-dimension array - 5 words</H4>

<P>This is the qualifier*file for the DDL/SDDL processor for the
currently based UDS application group. If no application is current,
the value will be all zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */DEVICE</P>

<H4>2.3.2.24 DEVICE: Scalar</H4>

<P>This will be the device-id of the current HARDCOPY specifications.
If hardcopy output is going to an Exec file, DEVICE contains the
FIELDATA print-queue name (left-justified, space-filled). If hardcopy
output is going to a TIP printer, DEVICE contains the binary value of
the printer's PID.</P>

<P>By checking the first sixth of DEVICE (DEVICE:S1), the type of
hardcopy may be determined (DEVICE:S1=0 means TIP, else EXEC). *//
*/DID</P>

<H4>2.3.2.25 DID: Scalar</H4>

<P>This will be the DID for the current hardcopy pid. *// */DMR$QUAL
</P>

<H4>2.3.2.26 DMR$QUAL: One-dimension array - 2 words</H4>

<P>This is the DMS default Qualifier for the currently based UDS
Application in FIELDATA format. If no application is current, the
value will be zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */DMSDTS</P>

<H4>2.3.2.27 DMSDTS: One-dimension array - 2 words</H4>

<P>This variable contains the earliest and latest DMS Date/Time
stamps after the "SCAN" function has been executed against an area.
The format is identical to that in the Page Header (word 5). If no
area is current or a "SCAN" has not been executed, the value will be
zeros. *// */DMU$FILE</P>

<H4>2.3.2.28 DMU$FILE: One-dimension array - 5 words</H4>

<P>This is the qualifier*file for the DMU processor for the currently
based UDS application group. If no application is current, the value
will be all zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */ECODE</P>

<H4>2.3.2.29 ECODE: Scalar</H4>

<P>This will be the error code of the most-recently encountered DBE
error. Thus, if the last error was:</P>

<P>&nbsp;</P>

<P>&lt;27&gt; SYNTAX ERROR</P>

<P>then ECODE will have the value 27. If no errors have occurred, or
the error status has been reset (see the ERRPR command), this value
will be a negative number. *// */EINFO</P>

<H4>2.3.2.30 EINFO: Scalar</H4>

<P>If the most-recently encountered error has extra information
contained in the text message, this variable will contain the first
36 bits of that information. For example, if the last error was:</P>

<P>&nbsp;</P>

<P>&lt;77&gt; BAD RECORD SLOT OR HEADER ON PAGE 14</P>

<P>then EINFO will have the value 14. If the last error was:</P>

<P>&nbsp;</P>

<P>&lt;30&gt; USER VARIABLE 'USER$VARIABL' IS NOT DEFINED</P>

<P>then EINFO will have the value 'USER$V'.</P>

<P>If the most-recent error had no extra information (or there has
been no error) this value will be zero. *// */EVAL</P>

<H4>2.3.2.31 EVAL: Scalar</H4>

<P>This will be the result of the last EVALUATE command. If no
EVALUATE has been done, the value will be zero. *// */FAC</P>

<H4>2.3.2.32 FAC: Scalar</H4>

<P>This will be the facility status code returned by the last dynamic
@ASG, @USE, @FREE, etc. Note that not all such requests are directly
invoked by the user. This value should be checked as soon as possible
after a user-specified CSF request (see the CSF function) to insure
that the correct status bits are being checked. *// */FCODE</P>

<H4>2.3.2.33 FCODE: Scalar</H4>

<P>This will be the feature code of the schema Feature Reference
Table {FRT} last referenced by the FEATURE command. If there is no
schema loaded or if no feature has been selected, this will have a
value of -1. *// */FITYPE</P>

<H4>2.3.2.34 FITYPE: Scalar</H4>

<P>This will be the file-type indicator for the most-recently OPENed
SDF input file. The values will be as follows:</P>

<P>&nbsp;</P>

<P>0: No OPEN has been done yet or filetype is undefined</P>

<P>'C': Symbiont card input/punch file</P>

<P>'F': FORTRAN data file</P>

<P>'I': Symbiont input file as created by @FILE</P>

<P>'P': Symbiont print file</P>

<P>'S': Symbolic element or SDF data file</P>

<P>'T': Symbiont paper tape input/punch file *// */FSEQ</P>

<H4>2.3.2.35 FSEQ: Scalar</H4>

<P>This is the sequence number of occurrence within the Schema
Reference Table {SCRT} of the current Feature Reference Table {FRT}.
If no schema is loaded or no feature has yet been selected via the
FEATURE command, this value will be zero. *// */IOFILE</P>

<H4>2.3.2.36 IOFILE: Scalar</H4>

<P>This will be the fileid (FIELDATA, left-justified and
space-filled) of the most-recently referenced SDFI/SDFO, DISC or TAPE
file. If no such file has been referenced the value will be zero. *//
*/IRU$FILE</P>

<H4>2.3.2.37 IRU$FILE: One-dimension array - 5 words</H4>

<P>This is the qualifier*file for the IRU processor for the currently
based UDS application group. If no application is current, the value
will be all zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */IRU$QUAL</P>

<H4>2.3.2.38 IRU$QUAL: One-dimension array - 2 words</H4>

<P>This is the IRU default Qualifier for the currently based UDS
Application in FIELDATA format. If no application is current, the
value will be zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */LAST</P>

<H4>2.3.2.39 LAST: Scalar</H4>

<P>The offset of the final word in the current table. This variable
will be zero-relative if a table is current, and will be one-relative
if an array is current. *// */LGSTAT</P>

<H4>2.3.2.40 LGSTAT: Scalar</H4>

<P>This will contain the LEG status for the last I/O performed
against a TIP/DMS file. This includes TIP/DMS user files, TIP/DMS
Schema files and TIP/DMS Area files. This value will be the
PFD/DMSL2/DMSL1 status field returned in the ER DM$IOW packet
(consult the "TIP Installation Reference - UP-8295" for more
information). The various status flags in this variable are as
follows:</P>

<P>&nbsp;</P>

<P>LGSTAT:H1 Always zero</P>

<P>LGSTAT:B18 0: normal value 1: Leg 2 disabled on last I/O request
</P>

<P>LGSTAT:B17 same as above, but for LEG 1</P>

<P>LGSTAT:B16 0: normal 1: DNR/DNW encountered for LEG 2 on last I/O
request</P>

<P>LGSTAT:B15 same as above, but for LEG 1</P>

<P>LGSTAT:B14 0: normal value 1: DNR/DNW set for LEG 2 on last I/O
request</P>

<P>LGSTAT:B13 same as above, but for LEG 1</P>

<P>LGSTAT:S5 standard I/O error code for LEG 2</P>

<P>LGSTAT:S6 standard I/O error code for LEG 1 *// */LOGTYPE</P>

<H4>2.3.2.41 LOGTYPE: Scalar</H4>

<P>This will contain the type of logging configured for DBE as
follows:</P>

<P>&nbsp;</P>

<P>0: No logging is configured</P>

<P>1: Logging is via "ER LOG$" (Fieldata entries)</P>

<P>2: Logging is via "ER SYSLOG$" (ASCII entries) *// */LOGBUF</P>

<H4>2.3.2.42 LOGBUF: One-dimension array - variable length</H4>

<P>This will contain the LOG$ / SYSLOG$ packet and the log buffer(s)
themselves. The length depends on the type of logging configured (see
the LOGTYPE variable).</P>

<P>This variable is only defined if logging is enabled.</P>

<P>See the DBE User's Guide for the layout of LOGBUF. *// */LSTPG
</P>

<H4>2.3.2.43 LSTPG: Scalar</H4>

<P>This variable specifies the highest page actually allocated in the
current area. For EXEC areas, this is taken from the HIGHEST TRACK
WRITTEN. If there is no current area, the value will be zero. *//
*/MA</P>

<H4>2.3.2.44 MA: One-dimension array - Sized by Generation Parameter
</H4>

<P>This variable is actually the entire Macro Area, defined as an
array for Macros to search and acess on a word by word basis. *//
*/MAXPG</P>

<H4>2.3.2.45 MAXPG: Scalar</H4>

<P>This variable specifies the number of the largest page
theoretically allocatable in the current area. If there is no current
area, the value will be zero.</P>

<P>The value of this variable is calculated using the number of
available tracks in the file (maximum) and the page size in words.
The DARP page zero will be taken into account if the area is a DARP
area. For TIP/DMS areas, this value will be calculated from the TREG
record count and record size information vs. the areas page size.
</P>

<P>Remember that this is NOT the number of pages actually defined at
present, but is the MAXIMUM number of pages that COULD be allocated.
*// */MODE</P>

<H4>2.3.2.46 MODE: Scalar</H4>

<P>This is a zero if DBE is running in DEMAND mode, 1 if it is
running in BATCH mode. Consult section 1.2 for the method used in
determining the value of MODE. *// */MSTIME</P>

<H4>2.3.2.47 MSTIME: Scalar</H4>

<P>This contains the current time in millisecons-past-midnight
format. The time will be taken freshly each time this variable is
referenced. *// */NCSLOT</P>

<H4>2.3.2.48 NCSLOT: Scalar</H4>

<P>This is the number of calc chains on the current page. If no page
is current, the value will be zero. If the page is an overflow page
(which therefore has no calc chains), the value will also be zero.
The page header calc chain (PH[7]) IS counted in this value. *//
*/NRSLOT</P>

<H4>2.3.2.49 NRSLOT: Scalar</H4>

<P>This is the number of record slots allocated on the current page.
If no page is current, or the page has no record slots allocated, the
value will be zero. Note that this is NOT the actual number of
records since some of the slots may actually be off-page pointers or
may have the deleted-record bit set. *// */NWORDS</P>

<H4>2.3.2.50 NWORDS: Scalar</H4>

<P>This is the number of words read on the last TREAD or GET command.
*// */OPTS</P>

<H4>2.3.2.51 OPTS: Scalar</H4>

<P>This is a bit-mask of the options specified to the
currently-executing macro. Consult the discussion of the
J-designators A-Z for information on how to use this value. *//
*/ORUNID</P>

<H4>2.3.2.52 ORUNID: Scalar</H4>

<P>This is the FIELDATA original runid of the current run. Compare
with the variable RUNID. *// */PGNUM</P>

<H4>2.3.2.53 PGNUM: Scalar</H4>

<P>This is the page number of the current page. If no page is
current, the value will be -1. Note that for DARP areas, zero will be
a legal page number. *// */POPTS</P>

<H4>2.3.2.54 POPTS: Scalar</H4>

<P>This variable contains the CURRENT processor options. This will be
updated by the ON and OFF commands to always reflect the current DBE
option bits. The format of this variable is according to Exec
Master-bit notation. The values of this variable may be checked in a
similar fashion to those for the OPTS variable. *// */PROJID</P>

<H4>2.3.2.55 PROJID: One-dimension array - 2 words</H4>

<P>This will contain the 12-character FIELDATA project-id of the run.
*// */PRTCN</P>

<H4>2.3.2.56 PRTCN: Scalar</H4>

<P>This will contain a flag indicating if the SDF image just read via
GET is a text image (value 0) or a print-control image (value 1). The
value of this variable is undefined except after a GET of an SDF
file. *// */PSEQ</P>

<H4>2.3.2.57 PSEQ: Scalar</H4>

<P>This is the sequence number of occurrence within the Path Index
Table {PIT} of the last path accessed by the PATH command. If no
subschema is loaded, or the current subschema is not a QLP subschema
or no path has been referenced, the value will be zero. *// */QUAL
</P>

<H4>2.3.2.58 QUAL: One-dimension array - 2 words</H4>

<P>This will contain a the 12-character FIELDATA Exec area qualifier
currently in effect. Consult the "Database Editor User's Guide" (QUAL
command) for information on how this value is defined. *// */RAFILE
</P>

<H4>2.3.2.59 RAFILE: One-dimension array - 5 words</H4>

<P>This will contain the current RDMS Area TIP Code or
Qualifier*File-Name in Fieldata. If no RDMS area is current, the
value will be zeros. *// */RAPNUM</P>

<H4>2.3.2.60 RAPNUM: Scalar</H4>

<P>This is the number of the RDMS Allocation Page currently based. If
no Allocation Page is current, the value will be zero. *// */RBTCNT
</P>

<H4>2.3.2.61 RBTCNT: Scalar</H4>

<P>This is the number of B-Trees in the current RDMS area. If no RDMS
area is current, the value will be zero. *// */RFPAGE</P>

<H4>2.3.2.62 RFPAGE: Scalar</H4>

<P>This is the number of the first Data Page in the current RDMS
area. The page number will vary depending on page size. If no RDMS
area is current, the value will be zero. *// */RLSTPA</P>

<H4>2.3.2.63 RLSTPA: Scalar</H4>

<P>This is the last page allocated by RDMS in the current RDMS area.
Compare this to the RLSTPG variable. If no RDMS area is current, the
value will be zero. *// */RLSTPG</P>

<H4>2.3.2.64 RLSTPG: Scalar</H4>

<P>This is the last page written in the current RDMS area. For exec
areas, this will be calculated from the HIGHEST TRACK WRITTEN. For
TIP areas, this will be the physical file size. If no RDMS area is
current, the value will be zero. *// */RMAXPG</P>

<H4>2.3.2.65 RMAXPG: Scalar</H4>

<P>This variable specifies the number of the largest page
theoretically allocatable in the current RDMS area. If there is no
RDMS area current, the value will be zero.</P>

<P>The value of this variable is calculated using the number of
available tracks in the file (maximum) and the page size in words.
For TIP/DMS areas, this value will be calculated from the TREG record
count and record size information vs. the areas page size.</P>

<P>Remember that this is NOT the number of pages actually defined at
present, but is the MAXIMUM number of pages that COULD be allocated.
*// */RNSLOT</P>

<H4>2.3.2.66 RNSLOT: Scalar</H4>

<P>This is the number of active record slots on the current RDMS
page. If no RDMS page is current, or the page has no slots, the value
will be zero. *// */RPGNUM</P>

<H4>2.3.2.67 RPGNUM: Scalar</H4>

<P>This is the page number of the current RDMS page. If no page is
current, the value will be -1. *// */RCODE</P>

<H4>2.3.2.68 RCODE: Scalar</H4>

<P>This is the record code of the last record accessed by a RECORD
command. If no schema is loaded or no record has been so referenced,
the value will be zero. *// */RESULT</P>

<H4>2.3.2.69 RESULT: Scalar</H4>

<P>This will be zero, or the first 36-bits of the value returned by
the most-recently executed macro (see the RETURN statement). If the
macro did not explicitly return a value, a value of zero will be
implied. *// */RRT</P>

<H4>2.3.2.70 RRT^: Scalar</H4>

<P>This will be the location of the current Record Reference Table
{RRT} within the Schema Reference Table {SCRT}. If no schema has been
loaded, or no record has been accessed via the RECORD command, this
value will be zero. *// */RSEQ</P>

<H4>2.3.2.71 RSEQ: Scalar</H4>

<P>This will be the sequence-number of occurrence of the current
Record Reference Table {RRT} with the Schema Reference Table {SCRT}.
If no schema has been loaded, or no record has been accessed via the
RECORD command, this value will be zero. *// */RUNID</P>

<H4>2.3.2.72 RUNID: Scalar</H4>

<P>This will be the FIELDATA generated runid of the current run.
Compare with the ORUNID variable. *// */SCANTOTALIO</P>

<H4>2.3.2.73 SCANTOTALIO: Scalar</H4>

<P>This variable contains the total number of I/Os to fetch a calc
record on each page of a DARP area. This variable is set by the SCAN
function when it is executed with the "Q" option. If no area is
current or a SCAN function has not been executed, the value will be
zero. *// */SCHADR</P>

<H4>2.3.2.74 SCHADR: Scalar</H4>

<P>This will be the sector address where the currently-loaded schema
was found within the schema file (TIP/DMS or EXEC).</P>

<P>If no schema is loaded, this value will be zero. *// */SCHELT</P>

<H4>2.3.2.75 SCHELT: One-dimension array - 2 words</H4>

<P>This will be the 12-character FIELDATA element name of the
currently loaded schema. If no schema is loaded, the value will be
all zeros.</P>

<P>This variable enables the actual schema element to be determined
(DBE allows schemas to be loaded from files and elements other than
those generated within the schema File Decription Table {FDT} and
Schema Reference Table {SCRT}). *// */SCHFIL</P>

<H4>2.3.2.76 SCHFIL: One-dimension array - 8 words</H4>

<P>This will be a 48-character FIELDATA string containing the schema
QUAL*FNAME/RKEY/WKEY as entered on the SCHEMA command. If no schema
is currently loaded, the value will be all zeros. If the
currently-loaded schema came from a TIP/DMS file, SCHFIL(1):H1 will
be zero and SCHFIL(1):H2 will contain the TIP/DMS file number (in
binary, not FIELDATA). *// */SCHLEV</P>

<H4>2.3.2.77 SCHLEV: Scalar</H4>

<P>This will contain the level of @DDL used to generate the
currently-loaded schema. This may be used as an indicator of the
DMS/1100 level to which that schema corresponds. By examining this
variable, user-written macros may adjust their behavior to compensate
for DMS/1100 level differences or changes in the internal schema
tables from one level to another. The DBE processor and DBE system
macros DO use this variable to accomplish such compensations.</P>

<P>If no schema is loaded, this value will be zero. If a schema is
loaded, the decimal value will be calculated according to the
following method:</P>

<P>&nbsp;</P>

<P>SCHLEV = DDL-level-# * 10 + DDL-release-#</P>

<P>For example, for DMS 8R1, the value of SCHLEV would be 81. For DMS
9R1, it would be 83, etc. *// */SCHNAME</P>

<H4>2.3.2.78 SCHNAME: One-dimension array - 2 words</H4>

<P>This will be the current schema's 12-character FIELDATA name. If
no schema is loaded, this value will be all zeros. *// */SCHVER</P>

<H4>2.3.2.79 SCHVER: One-dimension array - 2 words</H4>

<P>This will be the schema element's 12-character FIELDATA version
name (if any). If no schema is loaded, this value will be all zeros.
If the current schema element had no version name, this value will be
12 FIELDATA spaces. *// */SCODE</P>

<H4>2.3.2.80 SCODE: Scalar</H4>

<P>This will be the set code of the last set referenced on a SET
command. If no SET command has been done or no schema has been
loaded, this value will be zero. *// */SFS$QUAL</P>

<H4>2.3.2.81 SFS$QUAL: One-dimension array - 2 words</H4>

<P>This is the SFS default Qualifier for the currently based UDS
Application in FIELDATA format. If no application is current, the
value will be zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */SITEID</P>

<H4>2.3.2.82 SITEID: Scalar</H4>

<P>This will be the 6-character FIELDATA siteid for the user's
terminal. If DBE is being run in ACTUAL BATCH mode (not just @BRKPT
or OFF D), the value will be zero.</P>

<P>This variable does not exist on DBE versions configured without
the DBE Security Manager. *// */SRT</P>

<H4>2.3.2.83 SRT^: Scalar</H4>

<P>This is the location of the current Set Reference Table {SRT}
within the Schema Reference Table {SCRT}. If no schema is loaded, or
no SET command has been done, this value will be zero. *// */SSACODE
</P>

<H4>2.3.2.84 SSACODE: Scalar</H4>

<P>The subschema code of the current area, as selected by either the
"AREA" or "SSAREA" commands. *// */SSASEQ</P>

<H4>2.3.2.85 SSASEQ: Scalar</H4>

<P>The sequence of the current area in the subschema, as selected by
either the "AREA" or "SSAREA" commands. *// */SSELT</P>

<H4>2.3.2.86 SSELT: One dimension array - 2 words</H4>

<P>The element name of the current absolute subschema as specified on
the last "SUBSCH" command. If no subschema is loaded, the value will
be all blanks. *// */SSEQ</P>

<H4>2.3.2.87 SSEQ: Scalar</H4>

<P>This is the sequence number of occurrence of the current Set
Reference Table {SRT} within the Schema Reference Table {SCRT}. If no
schema is loaded or no SET command has been performed, this value
will be zero. *// */SSFILE</P>

<H4>2.3.2.88 SSFILE: One dimension array - 8 words</H4>

<P>The file name or number of the current absolute subschema as
specified on the last "SUBSCH" command. If no subschema is loaded,
the value will be all blanks. *// */SSLEV</P>

<H4>2.3.2.89 SSLEV: Scalar</H4>

<P>This will contain the level of @SDDL used to generate the
currently-loaded subschema.</P>

<P>See the "SCHLEV" variable for details on how the SSLEV variable is
computed. *// */SSNAME</P>

<H4>2.3.2.90 SSNAME: One-dimension array - 2 words</H4>

<P>The name of the current subschema as specified on the last
"SUBSCH" command. If no subschema is loaded, the value will be all
blanks. *// */SSRCODE</P>

<H4>2.3.2.91 SSRCODE: Scalar</H4>

<P>The subschema code of the current record, as selected by either
the "RECORD" or "SSRECORD" commands. *// */SSRSEQ</P>

<H4>2.3.2.92 SSRSEQ: Scalar</H4>

<P>The sequence of the current record in the subschema, as selected
by either the "RECORD" or "SSRECORD" commands. *// */SSSCODE</P>

<H4>2.3.2.93 SSSCODE: Scalar</H4>

<P>The subschema code of the current set, as selected by either the
"SET" or "SSSET" commands. *// */SSSSEQ</P>

<H4>2.3.2.94 SSSSEQ: Scalar</H4>

<P>The sequence of the current set in the subschema, as selected by
either the "SET" or "SSSET" commands. *// */SSVER</P>

<H4>2.3.2.95 SSVER: Scalar</H4>

<P>The version name of the current absolute subschema as specified on
the last "SUBSCH" command. If no subschema is loaded, the value will
be all blanks. *// */SUDS$FILE</P>

<H4>2.3.2.96 SUDS$FILE: One-dimension array - 5 words</H4>

<P>This is the qualifier*file for the SUDS processor for the
currently based UDS application group. If no application is current,
the value will be all zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */SUPS</P>

<H4>2.3.2.97 SUPS^: One-dimension array - 8 words</H4>

<P>This array contains current run SUP counts as follows:</P>

<P>SUPS(1) Total Sups</P>

<P>SUPS(2) Max Sups</P>

<P>SUPS(3) Core Block Sups</P>

<P>SUPS(4) CPU Sups</P>

<P>SUPS(5) I/O Sups</P>

<P>SUPS(6) CC/ER Sups</P>

<P>SUPS(7) Wait Sups</P>

<P>SUPS(8) ISP Sups *// */SYMID</P>

<H4>2.3.2.98 SYMID: Scalar</H4>

<P>The @SYM banner id as set by the HARDCOPY command. If the HARDCOPY
command has not been issued the default will be the generated runid.
*// */SYSTEM</P>

<H4>2.3.2.99 SYSTEM: One-dimension array - 5 words</H4>

<P>This is a FIELDATA array containing the following information on
the system on which DBE is running (note that DBE SUBSET notation is
being used to describe the location of information within SYSTEM):
</P>

<P>&nbsp;</P>

<P>&lt;SYSTEM:1,2&gt; System hardware type. For example, '1100/60 ',
'1100/80 ', '1100/90 ', etc.</P>

<P>&nbsp;</P>

<P>&lt;SYSTEM:3,4&gt; Exec (OS/1100) base level. For example, '37R2C
'. This is the level as specified by your site. If your site has more
than one 1100-series system and different Exec levels are used (i.e.
'37R2C/SYS1 ' and '37R2C/SYS2 ') you may develop DBE macros that can
behave differently, depending on the system on which they are
running.</P>

<P>&nbsp;</P>

<P>SYSTEM(5) The Site code. This is another possible way of a site
with multiple systems differentiating their computers - check with
your system support personnel to see which technique (if any) is
being used at your site. *// */TABLE</P>

<H4>2.3.2.100 TABLE: One-dimension array - 2 words</H4>

<P>This is the 1-6 or 1-12 character FIELDATA name of the current
table. If no table is current (See the chapter on Buffer Printing
Commands in the DBE User's Guide), both words will be zero. If the
current table is an actual table (ART, FDT, PAGE, etc.) the first
word will be the six-character FIELDATA table name (Left-justified,
space-filled) and the second word will be zero. If the current table
is a variable (SYSTEM or USER) the contents of TABLE will be a
12-character variable name (l.j.s.f.). *// */TCS$QUAL</P>

<H4>2.3.2.101 TCS$QUAL: One-dimension array - 2 words</H4>

<P>This is the TCS default Qualifier for the currently based UDS
Application in FIELDATA format. If no application is current, the
value will be zeros.</P>

<P>Note that this variable is actually a subset of the table
"UDSVAR". *// */TIME</P>

<H4>2.3.2.102 TIME: Scalar</H4>

<P>This will be the 6-character FIELDATA time (HHMMSS). The time will
be taken freshly each time this variable is referenced. *// */TRAIN
</P>

<H4>2.3.2.103 TRAIN: Scalar</H4>

<P>Set to 1 if the current area is in training mode (See the DBE
processor "Y" option). *// */TSIZE</P>

<H4>2.3.2.104 TSIZE: Scalar</H4>

<P>This will be the size (in words) of the current table. If no table
is current, the value will be zero. *// */UCL</P>

<H4>2.3.2.105 UCL: Scalar</H4>

<P>This will be the User Clearance Level Bits for the current user.
Consult the "Database Editor Technical Guide" for interpretation of
this variable.</P>

<P>This variable will not exist on DBE versions configured without
the DBE Security Manager. *// */USERID</P>

<H4>2.3.2.106 USERID: One-dimension array - 2 words</H4>

<P>This will be the 12-character FIELDATA USERID of the current DBE
user (if the user is actually on a DEMAND terminal) or the
12-character FIELDATA ACCOUNT NUMBER (if the user is actually a BATCH
run or if DEMAND security has been configured by ACCOUNT NUMBER).
</P>

<P>This variable will not exist on DBE versions configured without
the DBE Security Manager. *// */UDS$LEVEL</P>

<H4>2.3.2.107 UDS$LEVEL: Scalar</H4>

<P>This will be the UDS level for the currently based UDS application
group with the "R" removed. For example, UDS 5R3 would have a value
of 53. *// */$</P>

<H4>2.3.2.108 $: Scalar</H4>

<P>This will be the current location within the current table. If no
table is current, this value will be unpredictable. *//</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Tables | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>2.4. Tables</H2>

<P>Tables in the Database Editor are treated much as if they were
one-dimension arrays. The only exceptions to this statement are:</P>

<P>&nbsp;</P>

<P>1. They are "subscripted" using the characters [] rather than ().
</P>

<P>&nbsp;</P>

<P>2. Their "subscripts" run from 0 -&gt; n-1 rather than 1 -&gt; n
(where "n" is the size in words.</P>

<H3>2.4.1 Defined Tables</H3>

<P>Like SYSTEM VARIABLES, tables provide a fixed collection of names
under which certain structures may be referenced. Unlike system
variables, tables may change their size or even become unaccessable,
depending on operating conditions at the time.</P>

<P>Tables also differ from SYSTEM VARIABLES in that they can be
modified by the users via the array-subsetting functions.</P>

<P>The following sections discuss the various tables. TOCLVL 4
*/ATTBUF</P>

<H4>2.4.1.1 ATTBUF - Audit Trail Buffer</H4>

<P>This table is used to hold audit trail blocks as used by the ATT
system macros. It is intially sized as 1 word but can be reszied via
the ATTSIZE command. *// */ATTCTL</P>

<H4>2.4.1.2 ATTCTL - Audit Trail Control Table</H4>

<P>This table is used by the system ATT related macros to keep track
of audit trail record location, sector positioning, etc. It is not
intended for user use. *// */ACT</P>

<H4>2.4.1.3 ACT - Area Control Table</H4>

<P>This table is defined whenever BOTH a QLP subschema has been
loaded, and an area has been selected. The contents of this table are
the Area Code Table entry for the current area as found in the
subschema absolute. *// */ART</P>

<H4>2.4.1.4 ART - Area Reference Table</H4>

<P>This table within the Schema Reference Table {SCRT} is established
each time the AREA command is executed, and contains the reference
table for the current area. If no schema is loaded, or no area has
been selected (with the AREA command) this table will be undefined
and unavailable. *// */CLCBND</P>

<H4>2.4.1.5 CLCBND - Calc Page Boundary Table</H4>

<P>This table is used to pass lower/upper page boundaries to the
RANDENTIAL function. It is never modified by any system statements or
functions. *// */CMDBUF</P>

<H4>2.4.1.6 CMDBUF - Latent Command Buffer</H4>

<P>This is a special-purpose buffer available at all times. The
purpose of this table is to allow a macro to specify a DBE statement
to be executed at the return-point to CONVERSATIONAL mode (a
statement to be executed when macro execution terminates). The macro
simply moves the desired statement (as a character string) into this
table. The contents of this table may be changed as many times as
desired, but only the command contained within it when MACRO mode
terminates will be executed. If a command has been moved in and it is
desired to cancel it, simply set the first word of the table to zero.
The buffer is cleared to zeros after the command is executed. *//
*/CSLOT</P>

<H4>2.4.1.7 CSLOT - Calc Chain Slots</H4>

<P>This table is constructed each time a new page is read from the
current database via the PAGE command. The contents will be the calc
chain pointers from the page header (PH[7]) and from the bottom of
the page. Word CSLOT[0] will be the page header calc chain pointer
(PH[7]), word CSLOT[1] will be the bottom chain on the page, etc. You
may determine the actual number of entries in the table either via
the SIZE function or by checking the system variable NCSLOT. *//
*/DBPDT</P>

<H4>2.4.1.8 DBPDT - Database Procedure Description Table</H4>

<P>If the currently-loaded schema references any database procedures
(this included DMSCALC and RANDENTIAL), this table will be defined
and will contain the description entries for each dbp. *// */DCT</P>

<H4>2.4.1.9 DCT - Database Data Name Control Table</H4>

<P>This table is defined only when there is a QLP subschema loaded.
Consult the SUBSCHEMA command documentation in the DBE User's Guide
for more information. *// */DDT</P>

<H4>2.4.1.10 DDT - Data Name Description Table</H4>

<P>This table is defined whenever a subschema is loaded. It consists
of a 2-word header followed by a 1-word entry for each data name in
the subschema that does not use mapping. *// */DNS</P>

<H4>2.4.1.11 DNS - Data Name Storage Area</H4>

<P>This table is defined only when a QLP subschema is loaded. It
provides a storage area for the various database data names. Consult
the documentation on the SUBSCHEMA command in the DBE User's Guide
for more information. *// */DNT</P>

<H4>2.4.1.12 DNT - Data Name Table</H4>

<P>This table is defined whenever a subschema is loaded. It consists
of a 3-word header followed by an entry for each data name in the
subschema. Each entry consists of 3 words plus a variable portion
containing the name of the item. *// */DSW</P>

<H4>2.4.1.13 DSW - D$WORK Area</H4>

<P>This table is defined only when a QLP subschema is loaded. It
provides D$WORK/S$WORK storage for QLP. Consult the documentation on
the SUBSCHEMA command in the DBE User's Guide for more information.
*// */FDT</P>

<H4>2.4.1.14 FDT - File Description Table</H4>

<P>This table is defined only when a schema is loaded. This is the
first part of all schemas. *// */FRT</P>

<H4>2.4.1.15 FRT - Feature Reference Table</H4>

<P>This contains the current Feature Reference Table (as established
by the FEATURE command). *// */GED</P>

<H4>2.4.1.16 GED - Global Encode/Decode</H4>

<P>If the current FRT references a Global Encode/Decode table, this
will be that GED table. *// */ICT</P>

<H4>2.4.1.17 ICT - Item Code Table</H4>

<P>This table is defined whenever BOTH a QLP subschema has been
loaded, and a record has been selected. The contents of this table
are the Item Code Table entry for the current record as found in the
subschema absolute. This table provides a means of translating item
codes to item names. Consult the SUBSCHEMA command documentation of
the DBE User's Guide for more information. *// */IDT</P>

<H4>2.4.1.18 IDT - Item Description Table</H4>

<P>This table is defined each time a RECORD command is executed. The
table contains the Item Description Entries for each group/elementary
item in the current record. *// */INI</P>

<H4>2.4.1.19 INI - Item Name Index</H4>

<P>This table is defined whenever a subschema is loaded. It consists
of a 2-word header followed by a 2-word entry for each item in the
subschema. *// */INT</P>

<H4>2.4.1.20 INT - Item Name Table</H4>

<P>This table is defined whenever BOTH a QLP subschema has been
loaded, and a record has been selected. The contents of this table
are the Item Name Table entry for the current record as found in the
subschema absolute. *// */IOBUF</P>

<H4>2.4.1.21 IOBUF - General I/O Buffer</H4>

<P>This table is available at any time for use as a general GET
buffer. Consult the chapter on I/O for more information. *// */KEYBUF
</P>

<H4>2.4.1.22 KEYBUF - KEYIN$ Handler Buffer</H4>

<P>This table is available for use by a macro to pass a message when
the KEYIN$ handler is activated.</P>

<P>The first two words of the array MUST be the macro name or the
contents of the buffer will not be displayed. The first two words
(macro name) are not displayed by the KEYIN$ handler. *// */NHT</P>

<H4>2.4.1.23 NHT - Name Hash Table</H4>

<P>This table is defined only when a QLP subschema is loaded. This is
the portion of a SUBSCHEMA that provides the characteristics of each
database item. Consult the SUBSCHEMA documentation of the DBE User's
Guide for more information. *// */PAGE</P>

<H4>2.4.1.24 PAGE or PG - Database Page</H4>

<P>&nbsp;</P>

<P>This table is defined only when a database page has been loaded
via the PAGE command. The entire database page is available within
this table, exactly as stored on disc. *// */PDT-</P>

<H4>2.4.1.25 PDT- Path Description Table</H4>

<P>This table is defined only when a QLP subschema is loaded and a
PATH command has been executed. It provides a description of a QLP
path. Consult the SUBSCHEMA and PATH documentation of the DBE User's
Guide for more information. *// */PH</P>

<H4>2.4.1.26 PH - Database Page Header</H4>

<P>This table is defined only when a database page has been loaded
via the PAGE command. The 10-word database page header is available
within this table. *// */PIT-</P>

<H4>2.4.1.27 PIT- Path Index Table</H4>

<P>This table is defined only when a QLP subschema is loaded. This is
the portion of a SUBSCHEMA that provides an index to the PDTs. When
no path is current, this table consists of only the 1-word header,
defining the number of paths in the subschema. When a path becomes
current, the table contains the actual PIT entry for that path.
Consult the SUBSCHEMA and PATH documentation of the DBE User's Guide
for more information. *// */P0</P>

<H4>2.4.1.28 P0 - DARP Area Page Zero</H4>

<P>This table is defined only when a DARP area has been accessed via
the AREA command. The 12-word database page header for page 0 along
with the Dynamic Area Entry {DAE} for that area will be available in
this table. *// */RAP</P>

<H4>2.4.1.29 RAP - RDMS Allocation Page</H4>

<P>This table is defined when an RAP command has been accessed. It
contains a 28 word Allocation Page Table for the current RDMS area.
*// */RCDT</P>

<H4>2.4.1.30 RCDT - Record Code Table</H4>

<P>This table is defined only when a QLP subschema is loaded. Consult
the SUBSCHEMA documentation of the DBE User's Guide for more
information. *// */RDT</P>

<H4>2.4.1.31 RDT - Record Description Table</H4>

<P>This table is defined only when a record has been accessed via the
RECORD command. The schema-defined Record Description Table for that
record will be available in this table. Note that the table will be
read from disc, if not already in core (see the SCHEMA table
description). *// */RFCP</P>

<H4>2.4.1.32 RFCP - RDMS File Control Page Table</H4>

<P>This table is defined when an RDMS area command is executed. It
contains the first 224 words of the RDMS area which makes up the File
Control Page. *// */RFT</P>

<H4>2.4.1.33 RFT - Record Feature Table</H4>

<P>This table, established by the RECORD command, contains the Record
Feature Table (if any) for the current record. *// */RIT</P>

<H4>2.4.1.34 RIT - Record Information Table</H4>

<P>This table is defined whenever BOTH a QLP subschema has been
loaded, and a record has been selected. The contents of this table
are the Record Information Table entry for the current record as
found in the subschema absolute. *// */RP1</P>

<H4>2.4.1.35 RP1 - RDMS Page 1</H4>

<P>This table is defined when an RDMS area command is executed. It
contains the first 448 words of an RDMS area. It is actually a
concatenation of the RFCP and all RAP tables. *// */RPAGE</P>

<H4>2.4.1.36 RPAGE - RDMS Page Table</H4>

<P>This table is defined when an RDMS database page is loaded via the
RPAGE command. The entire datbase page is available within this
table, exactly as stored on disc. *// */RPH</P>

<H4>2.4.1.37 RPH - RDMS Page Header</H4>

<P>This table is defined whenever the RPAGE table is defined and
consists of the first 10 words of the RPAGE table. *// */RRSLOT</P>

<H4>2.4.1.38 RRSLOT - RDMS Record Slot Table</H4>

<P>This table is defined when the RPAGE table is defined and there
are active slots on the RDMS page. This table is actually the bottom
of the RPAGE table. *// */RRT</P>

<H4>2.4.1.39 RRT - Record Reference Table</H4>

<P>This table is defined only when a record has been accessed via the
RECORD command. The schema-defined Record Reference Table for that
record will be available in this table. *// */RSLOT</P>

<H4>2.4.1.40 RSLOT - Record Slot Table</H4>

<P>This table is re-created each time a database page is read via the
PAGE command. The table contents will be all end-of-page record slots
from the page in bottom-up (PAGE-wise) order. The actual number of
entries in this table may be obtained by the SIZE function or the
system variable NRSLOT. *// */RTREG</P>

<H4>2.4.1.41 RTREG - RDMS TIP Registration Information</H4>

<P>This table is available only following an RAREA command against a
TIP RDMS area. This contains the FCSS LF information for that area.
Consult the "Transaction Processing Programmer's Refernece Manual -
UP-8296 (current version)" for information on the interpretation of
the LF function. *// */SART</P>

<H4>2.4.1.42 SART - Subschema Area Reference Table</H4>

<P>This table is defined whenever BOTH a subschema has been loaded,
and an area has been selected. The contents of this table are the
Area Reference Table for the current area as found in the subschema
absolute. *// */SCHEMA</P>

<H4>2.4.1.43 SCHEMA (not available on all DBE versions)</H4>

<P>The SCHEMA table defines a table that contains the ENTIRE absolute
schema just loaded by the SCHEMA command.</P>

<P>This table may not be defined to the version of DBE you are using.
An option of the DBE system generation is to inhibit the READ of the
complete schema, reading only the File Description Table {FDT} and
Schema Reference Table {SCRT} when the SCHEMA command is done. Record
and Set Description Tables {RDT/SDT} would then be "paged"
dynamically when the RECORD and SET commands are executed.</P>

<P>This partial-schema-read is much more efficient in terms of memory
usage, and is therefore the recommended configuration. *// */SCRT
</P>

<H4>2.4.1.44 SCRT - Schema Reference Table</H4>

<P>This table is re-created each time a schema is accessed via the
SCHEMA command. The table contents will be the ENTIRE Schema
Reference Table of that schema. Note that all Area, Record, Set and
Feature Reference Tables will be contained within this table, even
though they are each accessable by their own table names (ART, RRT,
SRT and FRT). *// */SCT</P>

<H4>2.4.1.45 SCT - Set Code Table</H4>

<P>This table is defined only when a QLP subschema is loaded. This
provides a means to translate a set code to a set name. Consult the
SUBSCHEMA documentation of the DBE User's Guide for more information.
*// */SDT</P>

<H4>2.4.1.46 SDT - Set Description Table</H4>

<P>This table is defined when a set is accessed via the SET command.
The table contents will be the Set Description Table for that set.
Note that the table will be read from disc, if not already in core
(see the SCHEMA table description). *// */SFD</P>

<H4>2.4.1.47 SFD - Subschema File Description Table</H4>

<P>This table is defined only when a subschema (of any type) is
loaded. This contains the subschema equivalent of the FDT. Consult
the SUBSCHEMA documentation of the DBE User's Guide for more
information. *// */SHT</P>

<H4>2.4.1.48 SHT - Subschema Header Table</H4>

<P>This table is defined only when a QLP subschema is loaded. This
contains the QLP subschema Header Table. Consult the SUBSCHEMA
documentation of the DBE User's Guide for more information. *// */SIT
</P>

<H4>2.4.1.49 SIT - Set Information Table</H4>

<P>This table is defined whenever BOTH a QLP subschema has been
loaded, and a set has been selected. The contents of this table are
the Set Information Table entry for the current set as found in the
subschema absolute. *// */SRDT</P>

<H4>2.4.1.50 SRDT - Subschema Record Description Table</H4>

<P>This table is defined whenever BOTH a subschema has been loaded,
and a record has been selected. The contents of this table are the
Record Description Table for the current record as found in the
subschema absolute. *// */SRRT</P>

<H4>2.4.1.51 SRRT - Subschema Record Reference Table</H4>

<P>This table is defined whenever BOTH a subschema has been loaded,
and a record has been selected. The contents of this table are the
Record Reference Table for the current record as found in the
subschema absolute. *// */SRT</P>

<H4>2.4.1.52 SRT - Set Reference Table</H4>

<P>This table is defined when a set is accessed via the SET command.
The table contents will be the Set Reference Table for that set. *//
*/SSCD</P>

<H4>2.4.1.53 SSCD - Subschema Description Table</H4>

<P>This table is defined whenever a subschema is loaded. It contains
an entry for each area, record and set defined in the subschema. *//
*/SSDT</P>

<H4>2.4.1.54 SSDT - Subschema Set Description Table</H4>

<P>This table is defined whenever BOTH a subschema has been loaded,
and a set has been selected. The contents of this table are the Set
Description Table for the current set as found in the subschema
absolute. *// */SSRT</P>

<H4>2.4.1.55 SSRT - Subschema Set Reference Table</H4>

<P>This table is defined whenever BOTH a subschema has been loaded,
and a set has been selected. The contents of this table are the Set
Reference Table for the current set as found in the subschema
absolute. *// */SST</P>

<H4>2.4.1.56 SST - Subschema Reference Table</H4>

<P>This table is defined only when a subschema (of any type) is
loaded.</P>

<P>This contains the subschema equivalent of the SCRT. Consult the
SUBSCHEMA documentation of the DBE User's Guide for more information.
*// */SUBCH</P>

<H4>2.4.1.57 SUBCH - Subschema (not available on all DBE versions)
</H4>

<P>The SUBSCHEMA table defines a table that contains the ENTIRE
absolute schema just loaded by the SUBSCHEMA command.</P>

<P>This table may not be defined to the version of DBE you are using.
An option of the DBE system generation is to inhibit the READ of the
complete subschema, reading only the File Description Table {SFD} and
Subchema Reference Table {SST} when the SUBSCHEMA command is done.
Record and Set Description Tables {SRDT/SSDT} would then be "paged"
dynamically when the RECORD and SET commands are executed.</P>

<P>This partial-subschema-read is much more efficient in terms of
memory usage, and is therefore the recommended configuration. *//
*/TREG</P>

<H4>2.4.1.58 TREG - TIP Registration Information</H4>

<P>This table is available only following an AREA command against a
TIP/DMS area. This contains the FCSS LF information for that area.
Consult the "Transaction Processing Programmers Reference Manual -
UP-8296 (current version)" for information on the interpretation of
the LF information. *// */UDSVAR</P>

<H4>2.4.1.59 UDSVAR - UDS Variable Table</H4>

<P>This table is the "GROUP" element which holds the various UDS
System Variables, thereby allowing modification by macros.</P>

<P>It is recommended that this array NOT be modified by other than
System Supplied macros as unexpected results may occur. *// */USRBUF
</P>

<H4>2.4.1.60 USRBUF - User Buffer</H4>

<P>This buffer is intended for general use by users and user written
macros. It allows macros to be written to access data in table format
("TABLE[#] - 0 relative") instead of array format ("TABLE(#)" - 1
relative). *//</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Partial-word Designators | </B>
</CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>2.5. Partial-word Designators</H2>

<P>&nbsp;</P>

<P>When scalar variables, elements of arrays or elements of tables
are accessed, the entire 36-bit contents are used. If only a selected
subset of those 36 bits is desired, J-DESIGNATORS may be used. As in
1100-series Assembler Language (ASM/MASM), the J-DESIGNATOR is used
to select a portion of a word - that portion is available as a
right-alligned, zero/one-bit filled (depending on the J-DESIGNATOR)
quantity. Assume the following information:</P>

<P>&nbsp;</P>

<P>Scalar variable SCALER$ITEM has the value 0123456765432</P>

<P>&nbsp;</P>

<P>Array element ARRAY(5) has the value -1 (0777777777776)</P>

<P>&nbsp;</P>

<P>Table element PH[4] has the value 'FSLOAD' (0133021240611)</P>

<P>&nbsp;</P>

<P>Given the previous assumptions, observe the following examples:
</P>

<P>&nbsp;</P>

<P>1. The first third (first 12-bits) of SCALAR$ITEM are accessed as
SCALAR$ITEM:T1, and have the 36-bit value of 000000001234. The second
third of SCALAR$ITEM is accessed as SCALAR$ITEM:T2, and would have
the value 0777777775676 (the 1100 sign-extends third word references
automatically - DBE adheres to this convention).</P>

<P>&nbsp;</P>

<P>2. The right-most bit (bit zero) of ARRAY(5) would be referenced
as ARRAY(5):B0, and would have the 36-bit value 000000000000. The
left-most bit (bit 35) of ARRAY(5) would be referenced as
ARRAY(5):B35, and would have the value 000000000001.</P>

<P>&nbsp;</P>

<P>3. The fourth character of PH[4] (assuming that we are treating
PH[4] as a FIELDATA string) is stored in the fourth sixth of the
word. This is referenced as PH[4]:S4 and would have the 36-bit value
000000000024 ('@@@@@O'). Note that the first quarter of PH[4] could
be accessed as PH[4]:Q1, yielding a binary value of 000000000133
(which, happens to be a right-alligned, NUL-filled ASCII "[").</P>

<P>The entire set of J-DESIGNATORS are discussed in the following
sections. Those denoted with an "*" in the section header are DBE
extensions to the standard 1100-series set of J-designators.</P>

<H3>2.5.1 Half-word, 0-bit filled (H1, H2)</H3>

<P>These allow the first- or second-half of a word to be accessed.
The result is a 36-bit value, right-alligned and zero-bit filled.
</P>

<H3>2.5.2 Half-word, Sign-bit filled (XH1, XH2)</H3>

<P>This allow the first- or second-half of a word to be accessed. The
result is a 36-bit value, right-alligned and sign-bit filled. The
sign bit is defined as the leading bit of the selected half-word.
</P>

<H3>2.5.3 Third-word, Sign-bit filled (T1, T2, T3)</H3>

<P>These select the desired third of a word, returning a 36-bit
right-alligned, sign-bit filled value.</P>

<H3>2.5.4 Third-word, 0-bit filled (NT1, NT2, NT3) *</H3>

<P>These select the desired third of a word, returning a 36-bit
right-alligned, zero-bit filled value. These are extensions to the
basic 1100-series J-designator set.</P>

<H3>2.5.5 Quarter-word, 0-bit filled (Q1, Q2, Q3, Q4)</H3>

<P>These select the desired fourth of a word, returning a 36-bit
right-alligned, zero-bit filled value.</P>

<H3>2.5.6 Sixth-word, 0-bit filled (S1, S2, S3, S4, S5, S6)</H3>

<P>These select the desired sixth of a word, returning a 36-bit
right-alligned, zero-bit filled value.</P>

<H3>2.5.7 2/3-word, 0-bit filled (R24)</H3>

<P>This selects the rightmost 24 bits of a word, returning a 36-bit
right-alligned, zero-bit filled value.</P>

<H3>2.5.8 Individual bit, 0-bit filled (B35 ... B0) *</H3>

<P>These select the desired bit of a word, returning a 36-bit
right-alligned, zero-bit filled value. There are 36 such
j-designators, B35 thru B0, representing each bit from 35 (the
left-most bit of a word) through bit 0 (the right-most bit of a
word). These are extensions to the basic 1100-series J-designator
set.</P>

<H3>2.5.9 User-definable, (J0, J1, ... J9) *</H3>

<P>These J-designators are definable by the user via the PWORD
command. The following attributes may be defined:</P>

<P>&nbsp;</P>

<P>1. The starting bit to be selected by the J-designator</P>

<P>&nbsp;</P>

<P>2. The number of bits to be selected (counting the starting bit)
</P>

<P>&nbsp;</P>

<P>3. The fill technique to be used (zero-fill or sign-fill)</P>

<P>These are (obviously) an extension of the 1100-series J-designator
set.</P>

<H3>2.5.10 Option Bit, 0-bit filled (A-Z)</H3>

<P>These select the corresponding option bit (A=A-option, B=B-option,
etc.) from a word containing option-bit spacifications in standard
1100-series master-bit notation. Such notation calls for the first
ten bits of a word (35-26) to be unused, while the remaining 26 bits
(25-0) represent the presence or absence of option letters (B25=A,
B24=B, etc.). DBE supports two system variables that contain
master-bit values. These variables are therefore prime candidates for
use with these J-designators. The variables are OPTS and POPTS.</P>

<P>Some system macros that may illustrate this concept at work are:
</P>

<P>&nbsp;</P>

<P>PAGE-USAGE</P>

<P>PFS</P>

<P>PRT</P>

<P>TOC</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Byte Subsets | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>2.6. Byte subsets</H2>

<P>In addition to the data elements described previously as being
legal within expressions, BYTE SUBSETS may be used as well. These
structures, allowing arbitrary bytes to be selected from an array,
are discussed in detail in the next chapter.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>2.7. Operators</H2>

<P>DBE has a rich set of operators - some of which you might not
ordinarily think of as operators in other languages. Remember that
DBE basically deals with two types of expressions, SIMPLE and
COMPLEX. With only a single exception - use of expressions within
SUBSET specifications - ALL expressions may be either type.</P>

<P>DBE makes the distinction between the two expressions by the
presence (or absence) of logical operators (=, &lt;, &gt;, etc.) and
the boolean connectives (AND, OR, XOR). Expressions with such
operators are treated as LOGICAL expressions in most languages, while
those without are generally treated as ARITHMETIC. Using this naming
convention for a moment (DBE doesn't really worry about
distinguishing between the two), let us see how the two are handled.
</P>

<P>&nbsp;</P>

<P>1. When a LOGICAL expression is executed, the result is either 1
for TRUE, or 0 for FALSE. If that expression is used as a condition
on a decision-making statement (for example, IF) the behavior will be
obvious). When used as an arithmetic expression, its value is simply
treated as 0 or 1.</P>

<P>Observe the following:</P>

<P>&nbsp;</P>

<P>LET VAR#1 = 5 &lt; 6 (VAR#1 gets the value 1)</P>

<P>IF 5 &lt; 6 THEN (condition is TRUE)</P>

<P>LET VAR#1 = 6 &lt; 5 (VAR#1 gate the value 0)</P>

<P>IF 6 &lt; 5 THEN (condition is FALSE)</P>

<P>&nbsp;</P>

<P>2. When a SIMPLE expression is executed, an arithmetic result is
generated. If that result is used in the standard arithmetic sense,
the result is obvious. If used as a logical expression (on an IF for
example), the value will be assumed to be FALSE if the arithmetic
expression evaluated to zero - any other value of the expression will
be treated as TRUE.</P>

<P>Observe the following:</P>

<P>&nbsp;</P>

<P>LET VAR#1 = 5 + 5 (VAR#1 gets the value 11)</P>

<P>IF 5 + 5 THEN (condition is TRUE)</P>

<P>LET VAR#1 = 5 - 5 (VAR#1 gets the value 0)</P>

<P>IF 5 - 5 THEN (condition is FALSE)</P>

<P>Note that the two types (LOGICAL/ARITHMETIC) could be combined in
the same expression:</P>

<P>&nbsp;</P>

<P>5 + (6 * (5 &lt; 6)) has a value of 11</P>

<P>5 + (6 * (5 &gt; 6)) has a value of 5</P>

<P>A LOGICAL expression, or combination involving a LOGICAL
expression is what DBE defines as a COMPLEX expression.</P>

<P>There is a fixed precedence of operation of operators in DBE. This
precedence may be altered by the use of parenthesis. The following
sections describe the various operators, in order of precedence - the
first having the highest (evaluated first), and so forth.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | Unary + and - | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.7.1 Unary + and -</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>These are used to indicate the SIGN of an item (integer, scalar
variable, array element or table element). Unary PLUS, while
supported, serves no actual purpose. Unary MINUS, reverses the sign
of the item.</P>

<P>&nbsp;</P>

<P>+4 Same as just "4"</P>

<P>+VAR#1 Same as just "VAR#1"</P>

<P>+ARRAY(7) Same as just "ARRAY(7)"</P>

<P>-4 Value of negative 4</P>

<P>-VAR#1 Negates the value of "VAR#1"</P>

<P>-ARRAY(7) Negates the value of "ARRAY(7)"</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | Algebraic Shift | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>remain 8</P>

<H3>2.7.2 Algebraic Shift (*/)</H3>

<P>&nbsp;</P>

<P>The *// operator (two symbols, * and /, but considered a single
operator - do not insert spaces between the * and /) is a dyadic
operator. The value of its LEFT argument is ALGEBRAICALLY SHIFTED by
the number of bits indicated by its RIGHT argument. If the RIGHT
argument is positive, a LEFT SHIFT is done. If the RIGHT argument is
negative, a RIGHT SHIFT is done. This is an ALGEBRAIC shift in that
during a RIGHT SHIFT the sign of the left argument is preserved.</P>

<P>This can be useful in doing powers-of-2 multiplications or
divisions, using schema table SHIFT BITS entries to decode items or
in generating bit-flag constants. Some examples follow:</P>

<P>&nbsp;</P>

<P>4 *// 2 Result (Decimal): 16</P>

<P>-8 *// -1 Result (Decimal): -4</P>

<P>1 *// 2 Result (Binary): 0000....00100</P>

<P>Note an interesting application of this last example - dynamically
generating a bit mask with which to test the OPTS variable. Let us
assume that the FIELDATA option letter to be tested is in the scalar
variable LETTER, and we do not know what letter is there, but want to
generate a general mask for it:</P>

<P>&nbsp;</P>

<P>'Z'-LETTER will generate 0 (LETTER=Z) ... 25 (LETTER=A)</P>

<P>&nbsp;</P>

<P>1*/('Z'-LETTER) will generate 1 shifted left the correct number of
bits to provide a "mask" for checking OPTS (a one-bit will be in the
correct position for checking that option bit). See the "**" operator
for information on how this mask would then be used.</P>

<P>Note that 1*/'Z'-LETTER would have the wrong effect (due to the
high precedence of */. The effect would actually be that of
(1*/'Z')-LETTER.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | *, /, \, %, ** | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.7.3 Multiplication, Division and Bit AND</H3>

<P>The following operators are considered to be at the same
precedence level. Use of these operators consecutively in an
expression will cause left-to-right evaluation in that group, unless
() are used.</P>

<H4>2.7.3.1 Multiplication (*)</H4>

<P>This takes the 36-bit integer product of its left and right
arguments. Significant bits past the 36 bit limit are dropped.</P>

<H4>2.7.3.2 Integer Division (/)</H4>

<P>This takes the 36-bit quotient of the division of its left
argument by its right argument. Attempts to divide by zero will
generate a result of zero. Some examples:</P>

<P>&nbsp;</P>

<P>3 / 4 Result: 0</P>

<P>4 / 3 Result: 1</P>

<P>9 / 8 Result: 1</P>

<P>Note by the last example that no attempt is made to round. To
accomplish rounding, use the following technique:</P>

<P>To divide "n" by "m" using a rounding technique rather than the
standard truncation, do the oparetion as:</P>

<P>&nbsp;</P>

<P>(n + (m - 1)) / m</P>

<H4>2.7.3.3 Integer Remainder, or Modulus (\)</H4>

<P>This form of division generates the remainder of the left argument
divided by the right. As with /, an attempt to divide by zero will
always generate a result of zero. Some examples:</P>

<P>&nbsp;</P>

<P>3 \ 3 Result: 0</P>

<P>3 \ 4 Result: 3</P>

<P>4 \ 3 Result: 1</P>

<H4>2.7.3.4 Percentage Division (%)</H4>

<P>This is a special variation of the / operation that first
multiplies the left argument by 100 (generating a 72-bit internal
result) and then divides the internal result by the right argument.
The result is an integer that represents the percentage. Some
examples:</P>

<P>&nbsp;</P>

<P>3 / 3 Result: 100</P>

<P>4 / 3 Result: 133</P>

<P>3 / 4 Result: 75</P>

<P>Note how the / and % operators could be conbined to produce
results that could simulate (in printed output) a fixed-point
arithmetic result:</P>

<P>&nbsp;</P>

<P>4%3 Result: 175 (Call this N)</P>

<P>N/100 Result: 1 (Call this X)</P>

<P>N\100 Result: 75 (Call this Y)</P>

<P>If, using a FORMATed WRITE, you write out X and Y with an
intervening period, the sequence 1.75 would be printed.</P>

<H4>2.7.3.5 Bit-wise And (**)</H4>

<P>This operator ANDs the bits of its left argument against the bits
of its right argument producing a 36-bit result with one-bits
wherever both arguments had a corresponding one bit, zero elsewhere.
Do NOT confuse this with the operator AND discussed later.</P>

<P>Some examples follow:</P>

<P>&nbsp;</P>

<P>0123456765432 ** 0707070707070 --&gt; Result: 0103050705030</P>

<P>0123456765432 ** 0777777000000 --&gt; Result: 0123456000000</P>

<P>If the result of the bit mask example discussed earlier for the
*// operator were called MASK, then OPTS ** MASK will be non-zero of
the option bit specified by LETTER were set, zero otherwise.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | +, -, ++, -- | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.7.4 Addition, Subtraction, Bit OR, Bit XOR</H3>

<P>The following operators are considered to be at the same
precedence level. Use of these operators consecutively in an
expression will cause left-to-right evaluation in that group, unless
() are used.</P>

<H4>2.7.4.1 Addition (+)</H4>

<P>This operator will produce the 36-bit arithmetic sum of its two
arguments.</P>

<H4>2.7.4.2 Subtraction (-)</H4>

<P>This operator will produce the 36-bit arithmetic difference formed
by subtracting its right argument from its left argument.</P>

<H4>2.7.4.3 Bit OR (++)</H4>

<P>This operator will perform a bit-wise OR operation of the left
argument versus the right argument, producing a 36-bit result with a
one set in any bit position where either argument had a one bit, zero
at any other bit positions. Some examples:</P>

<P>&nbsp;</P>

<P>0111111222222 ++ 0444444111111 --&gt; Result: 0555555333333</P>

<P>0777777000000 ++ 0000000777777 --&gt; Result: 0777777777777</P>

<H4>2.7.4.4 Bit XOR (--)</H4>

<P>This operator will perform a bit-wise XOR operation of the left
argument versus the right argument, producing a 36-bit result with a
one set in any bit position where the argument had differing bits,
zero at any other bit positions. Some examples:</P>

<P>&nbsp;</P>

<P>0333333333333 -- 0222222222222 --&gt; Result: 0111111111111</P>

<P>0777777000000 -- 0000000777777 --&gt; Result: 0000000000000</P>

<H3>2.7.5 Relational Operators</H3>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | &lt;, &gt;, =, &lt;&gt;, &gt;=, &lt;= |
</B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>The following operators are considered to be at the same
precedence level. Use of these operators consecutively in an
expression (i.e. 1=0=1) is syntactically acceptable to DBE but will
cause unpredictable results. These operators are intended for use
only in the following situations: remain 6</P>

<P><CENTER>simple-expression = simple-expression {using = as an
example}</CENTER></P>

<P><CENTER>or</CENTER></P>

<P><CENTER>s-e = s-e OR s-e = s-e {using =/OR as an example}
</CENTER></P>

<P>The connective OR is discussed later.</P>

<H4>2.7.5.1 Less-than (&lt;)</H4>

<P>This returns a 1 if the left argument is arithmetically less than
the right argument, zero otherwise.</P>

<H4>2.7.5.2 Greater-than (&gt;)</H4>

<P>This returns a 1 of the left argument is arithmetically greater
than the right argument, zero otherwise.</P>

<H4>2.7.5.3 Equal-to (=)</H4>

<P>This returns a 1 of the left argument is arithmetically equal to
the right argument, zero otherwise.</P>

<P>Note that DBE differentiates between zero (0000000000000) and
negative zero (0777777777777), and would not consider the two equal.
Since negative-zero values are converted to positive zero values
during arithmetic operations however, the expression "0=0+-0" has a
value of 1.</P>

<H4>2.7.5.4 Less Than or Equal To (&lt;= or =&lt;)</H4>

<P>&nbsp;</P>

<P>This returns a 1 of the left argument is arithmetically less than
OR arithmetically equal to the right argument, zero otherwise. Note
that "-0&lt;=0" has the value 1.</P>

<H4>2.7.5.5 Greater Than or Equal To (&gt;= or =&gt;)</H4>

<P>&nbsp;</P>

<P>This returns a 1 of the left argument is arithmetically greater
than OR arithmetically equal to the right argument, zero otherwise.
Note that "0&gt;=-0" has the value 1.</P>

<H4>2.7.5.6 Not Equal (&lt;&gt; or &gt;&lt;)</H4>

<P>&nbsp;</P>

<P>This returns a 1 of the left argument is arithmetically unequal to
the right argument, zero otherwise. Note that "0&lt;&gt;-0" has the
value 1.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 2 | Operators | </B></CENTER></P>

<P><CENTER><B>| EXPRESSIONS | AND, OR, XOR | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>2.7.6 Logical Connectives</H3>

<P>These operators are all of equal precedence. If specified
consecutively, they will be executed in a strict left-to-right basis,
unless () are used. Note that DBE does not give AND a precedence
higher than that of OR - to do so requires ().</P>

<H4>2.7.6.1 Logical AND (AND)</H4>

<P>This operator combines the truth values of two expressions into a
single result such that if both arguments are TRUE (non-zero), the
result will be TRUE (one) - all other possible combinations yield
FALSE (0).</P>

<H4>2.7.6.2 Logical OR (OR)</H4>

<P>This operator combines the truth values of two expressions into a
single result such that if either argument is TRUE (non-zero), the
result will be TRUE (one) - if neither was TRUE (non-zero), the
result is FALSE (0).</P>

<H4>2.7.6.3 Logical XOR (XOR)</H4>

<P>This operator combines the truth values of two expressions into a
single result such that if ONLY ONE of the arguments is TRUE
(non-zero), the result will be TRUE (one) - both are TRUE (non-zero)
or both are FALSE (0), the result will be FALSE (0). will cause
left-to-right evaluation in that group, unless () are used. TOCLVL 3
SETCTR 1,3</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | | </B></CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>3. DESCRIPTIVE NOTATION</H1>

<P>Throughout the remainder of this manual it will be necessary to
describe the syntax of statements, clauses and other syntactical
elements.</P>

<P>To accomplish this with minimum diffuculty in a manner familiar to
the reader, the COBOL REFERENCE FORMAT notation will be used. Since
the medium involved is limited by the characteristics of printers,
certain slight modifications will be made. The following sections
decribe the complete DBE REFERENCE FORMAT.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | Reserved Words / Symbols | </B>
</CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>3.1. Reserved Words and Use of Symbols</H2>

<P>DBE reserved words and special symbols required will be
represented (in the case of the reserved words) in UPPER CASE. For
the benefit of the reader that does not have an upper/lower case
printing facility available on which to produce this document, the
reserved words will not only be in UPPER CASE, but will be
underlined.</P>

<P>Some examples (taken from material in the DBE User's Guide):</P>

<P>&nbsp;</P>

<P>BYE</P>

<P>---</P>

<P>&nbsp;</P>

<P>AREA</P>

<P>----</P>

<P>&nbsp;</P>

<P>SCHEMA</P>

<P>------</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | User-supplied Items | </B></CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>3.2. User-supplied Items</H2>

<P>Items to be supplied by the user (not actually reserved words or
symbols) will be specified in lower case. These would represent
generic categories of allowable entries such as "variable",
"array-name" or "table-name".</P>

<P>Such items will not be underlined, so for upper-case only printers
the difference between reserved words and generic items would be the
presence or absence of underlining.</P>

<P>Some examples (again from the DBE User's Guide):</P>

<P>&nbsp;</P>

<P>AREA area-name</P>

<P>----</P>

<P>&nbsp;</P>

<P>AREA area-code</P>

<P>----</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>EVALUATE expression</P>

<P>--------</P>

<P>&nbsp;</P>

<P>PRINT starting-word,ending-word table/array-name</P>

<P>-----</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | Optional Specifications | </B>
</CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>3.3. Optional Specifications</H2>

<P>Clauses or items that may optionally be present in an entity being
described will be denoted by []. Remember that the [] are not
actually part of the syntax of the entity itself, but are just used
for the explanation.</P>

<P>Some examples are:</P>

<P>&nbsp;</P>

<P>AREA[,options] area-name</P>

<P>----</P>

<P>&nbsp;</P>

<P>AREA[,options] area-code</P>

<P>----</P>

<P>&nbsp;</P>

<P>EVALUATE[,options] expression</P>

<P>--------</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | Repetition | </B></CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>3.4. Repetition</H2>

<P>Frequently, the syntax of an entity may allow certain items to be
repeated. This will be represented via the elipsis (...) sequence.
</P>

<P>Some examples follow (sorry, can't quote a User's Guide example):
</P>

<P>&nbsp;</P>

<P>MONITOR[,option] macro-name variable[,variable]...</P>

<P>-------</P>

<P>&nbsp;</P>

<P>WRITE format-label expression[,expression]...</P>

<P>-----</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | Selections | </B></CENTER></P>

<P><CENTER><B>| DESCRIPTIVE NOTATION | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>3.5. Selections</H2>

<P>Many items allow choices between two or more selections. The COBOL
REFERENCE FORMAT uses vigule (curly-bracket) characters to denote
this. The DBE REFERENCE FORMAT cannot however, since a FIELDATA
printer would represent the virgule characters as [] - a sure cause
of confusion.</P>

<P>Because of that limitation, large virgule will be constructed from
(, ) and - characters as shown in the following examples:</P>

<P>&nbsp;</P>

<P>( area name )</P>

<P>( area code )</P>

<P>AREA[,options] [ - - ]</P>

<P>---- ( # expression )</P>

<P>( subset )</P>

<P>&nbsp;</P>

<P>(,T tip/dms-file-number schema-name )</P>

<P>SCHEMA[- -]</P>

<P>------ ( qual-file-elt-version [schema-name] ) SETCTR 1,4 TOCLVL 3
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>4. SUBSETS</H1>

<P>As defined previously in chapter one, one type of subset is a
selected portion of an array or table. That portion may be the entire
array/table, or a selected series of contiguous words.</P>

<P>The second type of subset, the BYTE SUBSET, is a selected byte of
an array (where the user gets to specify the byte size).</P>

<P>The purpose if this chapter is NOT to describe how subsets are
used, for that will be done in the chapters on command descriptions.
The purpose of this chapter is to describe WHAT subsets are.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 3 | Table Subsets | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>4.1. Table Subsets</H2>

<P>The general format of a table subset is as follows:</P>

<P>&nbsp;</P>

<P>&lt;table-name[:starting-word,ending-word]&gt;</P>

<P>| | |</P>

<P>Name of table ---------------: | |</P>

<P>| |</P>

<P>SIMPLE expressions -----------------------:-------------:</P>

<P>Some subset examples are:</P>

<P>&nbsp;</P>

<P>&lt;ART&gt; The entire Area Reference Table</P>

<P>&lt;PH:0,2&gt; The first three words of the current page header
</P>

<P>&lt;PH:I,I+3&gt; The four words of PH starting with word #I</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | Array Subsets | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>4.2. Array Subsets</H2>

<P>Like TABLE SUBSETS, ARRAY SUBSETS are entire arrays or selected
consecutive words of an array. There are actually two slightly
different types of array subsets, depending on whether the array is
one- or two-dimension in structure.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | Array Subsets | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | Array Word Subsets | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>4.2.1 Array Word Subsets</H3>

<P>This first type of subset merely selects consecutive words from an
array regardless of the structure (dimension) of the array.</P>

<P>The syntactical format of the WORD ARRAY SUBSET is identical to
that of the TABLE SUBSET, with the obvious change of using the array
name instead of a table name. Remember that word numbers for arrays
run from 1 to "n", where "n" is the number of words in the array.
</P>

<P>Using WORD ARRAY SUBSETS to extract consecutive words from a
one-dimension array is no different than using TABLE SUBSETS. To
understand the implication of this for two-dimension arrays however,
you need to know how two-dimension arrays are stored internally.</P>

<P>remain 17 The following illustrates the internal storage layout of
a 3-row by 2-column array with the value 'THIS IS A DEMONSTRATION OF
SUBSETS':</P>

<P>&nbsp;</P>

<P>: Column 1 : Column 2 :</P>

<P>:------------:------------:</P>

<P>| word #1 | word #2 |</P>

<P>Row #1 | value: | value: |</P>

<P>| 'THIS I' | 'S A DE' |</P>

<P>:------------:------------:</P>

<P>| word #3 | word #4 |</P>

<P>Row #2 | value: | value: |</P>

<P>| 'MONSTR' | 'ATION ' |</P>

<P>:------------:------------:</P>

<P>| word #5 | word #6 |</P>

<P>Row #3 | value: | value: |</P>

<P>| 'OF SUB' | 'SETS ' |</P>

<P>:------------:------------:</P>

<P>Using the above array (assume it is named ARRAY) in subsets:</P>

<P>&nbsp;</P>

<P>&lt;ARRAY&gt; Selects the entire array</P>

<P>&lt;ARRAY:3,4&gt; Selects words 3-4 ('MONSTRATION')</P>

<P>&lt;ARRAY:1,6&gt; Selects the entire array</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | Array Subsets | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | Row Array Subsets | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H3>4.2.2 Row Array Subsets</H3>

<P>This type of array subset allows only two-dimension arrays to be
reference The syntax of this format is:</P>

<P>&nbsp;</P>

<P>&lt;array-name(row-number)[:starting-word,ending-word]&gt;</P>

<P>| | | |</P>

<P>Array name-------: | | |</P>

<P>| | |</P>

<P>Any type of expression------: | |</P>

<P>| |</P>

<P>SIMPLE expression only---------------------: |</P>

<P>|</P>

<P>SIMPLE expression only----------------------------------:</P>

<P>Remember that rows and columns are numbered starting with 1. Using
the sample ARRAY used in the previous section, the following are
possible subsets:</P>

<P>&nbsp;</P>

<P>&lt;ARRAY(1)&gt; All of row 1 - 'THIS IS A DE'</P>

<P>&lt;ARRAY(1):1,2&gt; All of row 1 (rows each have 2 columns in
this array)</P>

<P>&lt;ARRAY(3):2,2&gt; Word 2 of row 3 - 'UBSETS'</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | Byte Subsets | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>4.3. Byte Subsets</H2>

<P>&nbsp;</P>

<P>The general format of a byte subset is as follows - note that</P>

<P>the [ and ] are PART OF THE SUBSET:</P>

<P>&nbsp;</P>

<P>[array-name:byte-number,byte-size]</P>

<P>| | |</P>

<P>Name of array used for subset ------: | |</P>

<P>| |</P>

<P>Byte number to be selected (first byte is 1) ---: |</P>

<P>|</P>

<P>Byte size in bits (if absent, 6 is assumed) ---------------:</P>

<P>&nbsp;</P>

<P>Assume that array "ARRAY" has 5 words. Some examples follow:</P>

<P>&nbsp;</P>

<P>[ARRAY:5,6] Select the 5th FIELDATA byte of ARRAY</P>

<P>[ARRAY:5] Select the 5th FIELDATA byte of ARRAY</P>

<P>[ARRAY:3,9] Select the 3rd ASCII byte of ARRAY</P>

<P>[ARRAY:29,1] Select the 29th 1-bit byte of ARRAY</P>

<P>[ARRAY:I,3] Select the Ith 3-bit byte of ARRAY</P>

<P>Note that the entire array is considered to be a string of bytes,
where the length of the byte is AS SPECIFIED in the subset. Word
boundaries are ignored and wasted bits, if any, will be at the end of
the array.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 4 | Concluding Comments | </B></CENTER></P>

<P><CENTER><B>| SUBSETS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H2>4.4. Concluding Comments</H2>

<P>BYTE SUBSETS are used within expressions or on the LET statement
as a receiving field. The ARRAY and TABLE subsets, however, are used
in different ways (although they too could be the receiving fields on
LET statements).</P>

<P>When the syntax of a statement calls for a "subset", the reader
may assume that either an ARRAY or TABLE subset may be specified. In
the event that only a specific type of subset is allowed, it will be
specifically mentioned in the reference format of the statement (i.e.
"array-subset" or "table-subset"). The term "subset" DOES NOT imply
the use of a BYTE SUBSET.</P>

<P>Throughout the remainder of the manual, whenever the term "subset"
setctr 1,5</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 5 | | </B></CENTER></P>

<P><CENTER><B>| SYSTEM COMMANDS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>5. SYSTEM COMMANDS</H1>

<P>The commands in this chapter are intended for use as system
commands - that is they control the operative environment of the DBE
processor when the user is working with macros. These commands
provide the ability to SAVE, LIST, DELETE and define macros.</P>

<P>Macros are stored as SOURCE alements in the DBE system file, or in
the user's current library (DBE$PF). When a command is entered, the
following sequence will be performed:</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>|---------------------------------------------------------------|
| The command list is searched |
|---------------------------------------------------------------| |
Yes \ Found in command list? No |
|---------------------------------------------------------------| |
Execute | Yes \ Does input evaluate as an expression? No | | command
|-----------------------------------------------------| | | | Process
| Yes \ Found as elt in library #1? No | | | | as a
|-------------------------------------------| | | | PRINT | Load and
| Yes \ Found as elt in | | | | command | run a | \ library #2? No |
| | | | | macro |--------------------------------| | | | | | | | Load
and | DBE error e$27 | | | | | | | | run a | (Syntax error) | | | | |
| | | macro | | | | | | | | | | | | | | | | | | | | | | | | | | V | V
| V | V | V |
|---------------------------------------------------------------| |
Execute next command |
|---------------------------------------------------------------|
</P>

<P>The actual files associated with "library #1" and "library #2" are
the DBE system library and the current user library (DBE$PF). The
order of consideration of these two libraries is as specified by the
presence or absence of the processor R option.</P>

<P>Once a macro has been loaded, it will be executed. Note that the
macro area is of a fixed (at DBE sysgen time) size. Once the macro
area is full, any macro that was loaded from a file and is not
presently involved execution will be deleted from the in-core macro
area to make room for the desired new macro.</P>

<P>The commands in this chapter deal (primarily) with manipulation of
the macro area.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 5 | CONVERSATIONAL | DELETE | </B>
</CENTER></P>

<P><CENTER><B>| SYSTEM COMMANDS | Mode | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*/DELETE</P>

<H2>5.1. DELETE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( * )</P>

<P>DELETE - -</P>

<P>------ ( macro-name[,macro-name]... )</P>

<P>&nbsp;</P>

<P>This command will either erase the entire macro area (DELETE *) or
delete the specified macros from the macro area.</P>

<P>If a macro deleted by this command came from the system library or
a user library it will still be present in the file from which it
came. If a macro deleted by this command was created via the MACRO
command, the text of the macro is lost.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 5 | CONVERSATIONAL | LIST | </B>
</CENTER></P>

<P><CENTER><B>| SYSTEM COMMANDS | Mode | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */LIST</P>

<H2>5.2. LIST</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( line-number )</P>

<P>LIST[[,options] macro-name [- -]]</P>

<P>----- ( first-line,last-line )</P>

<P>&nbsp;</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>L: List macro with annotations for correction images inserted by
DBE sysgen or @ELT,SU. This is intended for use primarily by the DBE
sysgen process.</P>

<P>&nbsp;</P>

<P>N: List the macro with no sequence numbers.</P>

<P>Executed with no options or parameters, this command will print
the names and sizes (in words) of all macros presently loaded in the
macro area. At the conclusion of this listing the total number of
words remaining in the macro area will be printed.</P>

<P>Executed with a macro name, the macro specified will be printed.
When listing macros, the macros will automatically be indented to
reflect nesting of control structures.</P>

<P>If desired, expressions may be supplied to indicate the specific
single line to be printed (line-number) or the range of line numbers
to be printed (first-line,last-line).</P>

<P>If the macro was not loaded into the macro area prior to the
execution of the LIST statement, it will be loaded automatically.
</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 5 | CONVERSATIONAL | MACRO | </B>
</CENTER></P>

<P><CENTER><B>| SYSTEM COMMANDS | Mode | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */MACRO</P>

<H2>5.3. MACRO</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>MACRO macro-name</P>

<P>-----</P>

<P>.</P>

<P>.</P>

<P>macro text</P>

<P>images</P>

<P>.</P>

<P>.</P>

<P>@EOF</P>

<P>This statement allows macros to be keyed in directly from the
terminal in a manner similar to the @ED MACRO command. The name of
the macro will be specified as a parameter on the MACRO command - the
name must be 1-12 characters long from the set A-Z, 0-9, $ and -.
</P>

<P>Following the MACRO command, all text entered will be stored
directly into the macro area as the next statement in the macro being
defined. At this point, the prompt to the user will be "MAC:". After
the final statement has been entered, an @EOF terminates the macro
definition and returns the user to normal operation.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 5 | MACRO/ | SAVE | </B></CENTER></P>

<P><CENTER><B>| SYSTEM COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */SAVE</P>

<H2>5.4. SAVE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>SAVE[,options] macro-name</P>

<P>----</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>C: Compress all text to start at col 2 (labels in col 1)</P>

<P>&nbsp;</P>

<P>L: Left-align all statement text in col 8</P>

<P>NOTE: the fastest results will be achieved by use of the C option.
</P>

<P>This macro will save the text of the specified macro to TPF$.</P>

<P>The macro text will be saved in the same indented format as would
be generated by the LIST command.</P>

<P>Note that this IS legal within macro mode. SETCTR 1,6 TOCLVL 3
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | | </B></CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>6. DATA DECLARATIONS</H1>

<P>Variables and tables may be declared in DBE for use either within
macros or in CONVERSATIONAL mode. Within macros, variables are
defined only for the duration of the macros execution - leaving a
macro and re-entering it later will cause a completely new set of
variables to be defined (with initial values of zero).</P>

<P>All variables must be declared, either explicitly or implicitly,
before they may be used. Examples of EXPLICIT declarations are:</P>

<P>&nbsp;</P>

<P>1. Creating an array via the DIMENSION statement.</P>

<P>&nbsp;</P>

<P>2. "Borrowing" a variables description from the calling macro via
the GLOBAL statement.</P>

<P>Examples of IMPLICIT definitions are:</P>

<P>&nbsp;</P>

<P>1. Assigning a value to a previously undefined variable, thus
defining it as a SCALAR.</P>

<P>&nbsp;</P>

<P>2. Accepting a previously undefined variable as a macro parameter,
thus defining it as a SCALAR.</P>

<P>&nbsp;</P>

<P>3. Specifying an undefined variable as the receiving field on any
DBE statement that assigns values to variables (TREAD, REPEAT, etc.).
</P>

<P>Thus it can be seen that the implicit definition of any user
variable is that of a SCALAR, while the use of a variable as an array
must be explicitly requested.</P>

<P>Note that an implication of the above rules is that no variable
may be used in any context OTHER than the above until one of the
above has been done. Take, for example, the following sequence:</P>

<P>&nbsp;</P>

<P>*:&gt;MACRO DEMO1</P>

<P>MAC:&gt;LET VAR001 = VAR001 + 15</P>

<P>MAC:&gt;@EOF</P>

<P>*:&gt;DEMO1</P>

<P>*:&gt;MACRO DEMO2</P>

<P>MAC:&gt;LET VAR001 = VAR002 + 1</P>

<P>MAC:&gt;@EOF</P>

<P>*:&gt;DEMO2</P>

<P>&lt;30&gt; USER VARIABLE 'VAR002' IS NOT DEFINED</P>

<P>ABOVE ERROR OCCURRED IN STATEMENT 1 OF MACRO DEMO2</P>

<P>The first macro executed correctly because the variable VAR001 was
defined at the moment the LET statement executed (because it was the
receiving field). The second macro failed because there had not yet
been a definition of VAR002.</P>

<P>The statements described in this chapter are those that EXPLICITLY
or IMPLICITLY define user variables.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | MACRO/ | DIMENSION | </B></CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */DIMENSION</P>

<H2>6.1. DIMENSION</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( #-of-words ) DIMENSION array-name(- -)[,...] --------- (
#-of-rows,#-of-cols ) DIM ---</P>

<P>&nbsp;</P>

<P>The word DIMENSION may be abbreviated as DIM.</P>

<P>The following are some examples of the DIMENSION statement at
work:</P>

<P>&nbsp;</P>

<P>DIMENSION A(20) Creates a twenty-word one-dimension array named
"A".</P>

<P>DIM ARRAY(6,10) Creates a sixty-word two-dimension array named
"ARRAY" - there are 6 rows of ten words each.</P>

<P>DIM A(2,2),B(6) Creates a 4 word (2x2) array named "A" and a
6-word array named "B".</P>

<P>The DIMENSION statement is a RUN-TIME statement, not a
COMPILE-TIME statement (appropriate, since DBE is not a compiler).
The implication of this is that dimensions may be specified not just
as static integers but as expressions, allowing array sizes to be
calculated at run-time.</P>

<P>When an array is created, its elements are all set to zero.</P>

<P>An array may be DIMENSIONed any number of times during a macros
execution. If the new size of the array (rows*columns) is less than
or equal to the previous size, the same memory area will be used with
all elements set to zero. If the new size is greater than the
previous, a new memory area is made available and will be set to
zero. The old area occupied by the array IS NOT RELEASED until
control returns to CONVERSATIONAL mode.</P>

<P>The DBE dbank will be expanded to accomodate the newly-created
array(s) - be aware however that the total size of DBE cannot exceed
262K words. If an array is DIMENSIONed and there is insufficient
memory available in which to allocate the array, a DBE error message
is issued as follows:</P>

<P>DIMENSION ARRAY1(500),ARRAY2(9000,9000),ARRAY3(777) &lt;62&gt;
ARRAY "ARRAY2" TOO LARGE - NOT DIMENSIONED</P>

<P>No attempt will be made to continue processing the DIMENSION
statement once this error occurrs (so ARRAY3 is never DIMENSIONed).
</P>

<P>Scalar variables may be used freely and converted into arrays when
desired. Once converted to an array, however, a variable cannot be
converted back into a scalar during that execution of the macro. If
the macro is ever re-executed, all variables are cleared and will be
re- defined and reallocated, so the variable will at that time be
restored to scalar status.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | MACRO Mode | GLOBAL | </B></CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */GLOBAL</P>

<H2>6.2. GLOBAL</H2>

<P>&nbsp;</P>

<P>GLOBAL variable-1[,variable-2]... ------</P>

<P>This statement is intended for use within a macro THAT IS CALLED
BY ANOTHER MACRO. The macro with the GLOBAL statement will be
"stealing" variables from its caller by making them available through
this statement.</P>

<P>Observe the following sequence:</P>

<P>*:&gt;MACRO MACRO1 MAC:&gt;DIMENSION ARRAY(3) MAC:&gt;LET VAR001 =
15 MAC:&gt;LET &lt;ARRAY&gt;='THIS IS A DEMO' MAC:&gt;MACRO2
MAC:&gt;@EOF *:&gt;MACRO MACRO2 MAC:&gt;GLOBAL VAR001,ARRAY,SNIDELY
MAC:&gt;@EOF *:&gt;MACRO1 &lt;30&gt; USER VARIABLE 'SNIDELY' IS NOT
DEFINED ABOVE ERROR OCCURRED IN STATEMENT 1 OF MACRO MACRO2</P>

<P>MACRO CALLED AT STATEMENT 4 OF MACRO MACRO1</P>

<P>What MACRO2 was trying to do was "steal" the variables VAR001,
ARRAY and SNIDELY from MACRO1. It succeeded in getting the first two,
but failed on the third (SNIDELY) because MACRO1 did not have a
variable named SNIDELY.</P>

<P>Had MACRO2 not attempted to "steal" the variable SNIDELY,
execution would have continued and the variables VAR001 and ARRAY
would now be shared between the two macros. This provides a feature
similar to FORTRAN COMMON or COBOL COMMON-STORAGE.</P>

<P>Note that the variables are available in their entirety ACCORDING
TO THE DEFINITION specified in the calling macro - thus MACRO2 must
use VAR001 in a manner consistent with a scalar and it must use ARRAY
in a menner consistent with a 3-word one-dimension array.</P>

<P>Whenever possible, the use of GLOBAL should be avoided in macros
that are intended to serve as GENERAL-PURPOSE macros available to all
(or simply "other") users - this is just intended as a means to
facilitate subprogramming where the authors of the "main" and "sub"
macros have collaborated. See the PARAMETER statement for a more
general alternative.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | MACRO/ | LET | </B></CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */LET</P>

<H2>6.3. LET</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( ( scalar[:j-designator] ) ( expression ) )</P>

<P>( - array-element[:j-designator] - = - function-call - )</P>

<P>( ( byte-subset ) ( macro-call ) )</P>

<P>( ) LET - ( subset ) - --- ( ( 'character-string' ) )</P>

<P>( subset = - - )</P>

<P>( ( function-call ) )</P>

<P>( ( macro-call ) )</P>

<P>This statement assigns values to variables and subsets according
to the rules set forth in the above format.</P>

<P>The receiving item "array-element" refers to a properly
subscripted element of a one- or two-dimensional array. The sending
item "function-call" refers to one of the various DBE FUNCTIONS
(covered in the next chapter) and the sending item "macro-call"
refers to the calling of a macro by specifying its name and
parameters after the "=" of a LET - the macro returns a value via the
RETURN statement.</P>

<P>In the event the receiving field is a scalar, the variable will
created and given a value of zero. This creation happens only the
first time the variable is specified as the receiving field of a LET.
</P>

<P>Assume the following variables/tables exist:</P>

<P>&nbsp;</P>

<P>VAR001 Scalar</P>

<P>ARRAY1(10) Array</P>

<P>ARRAY2(5,3) Array</P>

<P>FDT File Description Table for current schema</P>

<P>Using these, the following are some examples of the LET statement:
</P>

<P><CENTER>LET VAR001:H2 = 15</CENTER></P>

<P>Assigns the value 15 to the right-half of VAR001. The left half
remains unchanged.</P>

<P><CENTER>LET VAR001 = FDT[6] / 23 + 2</CENTER></P>

<P>The value of the given expression will be saved in VAR001 (since
no J-designator was specified, the entire variable is effected).</P>

<P>&nbsp;</P>

<P>LET ARRAY1(3) = 15</P>

<P>The third word of ARRAY1 is set to 15.</P>

<P>&nbsp;</P>

<P>LET ARRAY1(3):Q2 = 15</P>

<P>The second quarter of the third word of ARRAY1 is set to 15.</P>

<P>&nbsp;</P>

<P>LET ARRAY2(1,2) = 1</P>

<P>The second word of the first row of ARRAY2 is set to 1.</P>

<P>&nbsp;</P>

<P>LET ARRAY2(1,2):B12 = 1</P>

<P>The twelfth bit of the second word of the first row is set to 1.
</P>

<P>&nbsp;</P>

<P>LET &lt;ARRAY1&gt; = &lt;FDT&gt;</P>

<P>The first 10 words of the File Description Table are copied into
ARRAY1. If the receiving field of this type of LET is too small,
truncation occurs. If the receiving field is too large, unaffected
words at the right of the receiving field are zero-filled.</P>

<P>&nbsp;</P>

<P>LET &lt;ARRAY2&gt; = 'THIS IS A DEMONSTRATION OF THE LET STMNT'
</P>

<P>The given character string is moved into ARRAY2. Since ARRAY2 is a
two-dimension array, refer back to Chapter 4 for a discussion on the
internal representation of two-dimension arrays.</P>

<P>With this type of LET, if the receiving field is too small,
truncation will occur. If the receiving field is larger, FIELDATA
space-filling will occur.</P>

<P>&nbsp;</P>

<P>LET VAR001 = CSF('@ASG,T TEMP.')</P>

<P>The CSF function is called, and its result is saved in VAR001.
</P>

<P>&nbsp;</P>

<P>LET VAR001 = MY-MACRO 15,888,'THIS IS THE 3RD PARAMETER'</P>

<P>The macro MY-MACRO is executed and its result (specified by a
RETURN statement within MY-MACRO) is saved in VAR001. Everything
after the name of the macro is a parameter to the macro.</P>

<P>Any macro can be executed in this manner.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | MACRO Mode | PARAMETER | </B>
</CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */PARAMETER</P>

<H2>6.4. PARAMETER</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-subset ) ( array-subset )</P>

<P>( array-name ) ( array-name ) PARAMETER - -[:flag][,- -[:flag]]...
--------- ( array-element ) ( array-element )</P>

<P>( scalar ) ( scalar )</P>

<P>The "flag" mentioned above is an expression.</P>

<P>The different types of PARAMETER specifications mentioned above
are used to specify that differing types of parameters are to be
received. To understand this fully, consider the following legal
parameter types:</P>

<P>&nbsp;</P>

<P>1. EXPRESSIONS - pass an expression to a macro and have its value
available for use.</P>

<P>&nbsp;</P>

<P>2. CHARACTER STRING or KEY WORD - pass a string (within quotes) or
a word (without quotes, imbedded @ or imbedded spaces) as a FIELDATA
string argument.</P>

<P>&nbsp;</P>

<P>3. AN ARRAY SUBSET - pass a subset to a macro and have its
contents available in a CALL-BY-VALUE manner (that is, if the called
macro makes a change to the subset contents, that change is NOT known
to the calling macro).</P>

<P>&nbsp;</P>

<P>4. AN ARRAY SUBSET (TYPE 2) - pass a subset to a macro and have
its contents available in a CALL-BY-ADDRESS manner (that is, changes
made within the called macro ARE known to the calling macro).</P>

<P>The following examples cover each case. Remember that any desired
combination of parameter types may be used. You are limited by a DBE
System-generation specification in the NUMBER OF PARAMETERS that any
one macro may have - consult the DBE support individual(s) at your
site for more information.</P>

<H3>6.4.1 Expressions as Parameters</H3>

<P>To receive an arithmetic expression as a parameter, a PARAMETER
spacification of "scalar" or "array-element" must be used. For
example:</P>

<P>&nbsp;</P>

<P>*:&gt;MACRO DEMO1 *:&gt;MACRO DEMO2 MAC:&gt;PARAMETER VAR001
MAC:&gt;DIMENSION ARRAY(5) MAC:&gt;EVALUATE,D VAR001
MAC:&gt;PARAMETER ARRAY(3) MAC:&gt;@EOF MAC:&gt;EVALUATE,D ARRAY(3)
*:&gt;DEMO1 MAC:&gt;@EOF 0 *:&gt;DEMO2 *:&gt;DEMO1 15 0 15
*:&gt;DEMO2 15 *:&gt;DEMO1 077 15 63 *:&gt;DEMO2 077 *:&gt;DEMO1 'A'
63 6 *:&gt;DEMO2 'A'</P>

<P>6</P>

<P>Note how the receiving variable in each case gets the value zero
if no parameter was specified.</P>

<H3>6.4.2 Keywords, CALL-BY-VALUE Subsets and Strings</H3>

<P>Each of these three types of arguments will be handled in a
similar manner - by specifying an array-subset as the parameter
field. For example:</P>

<P>&nbsp;</P>

<P>*:&gt;MACRO DEMO3 MAC:&gt;DIMENSION ARRAY(3) MAC:&gt;LET
&lt;ARRAY&gt;='XXXXXXXXXXXXXXXXXX' MAC:&gt;PARAMETER &lt;ARRAY&gt;
MAC:&gt;PRINT,F 1,3 ARRAY MAC:&gt;@EOF *:&gt;DEMO3 ARRAY(1) '
XXXXXXXXXXXX' *:&gt;DEMO3 KEYWORD ARRAY(1) 'KEYWORD ' *:&gt;DEMO3
'HERES A STRING' ARRAY(1) 'HERES A STRING ' *:&gt;DEMO3 'HERES A
REALLY LONG STRING THAT CANT FIT' ARRAY(1) 'HERES A REALLY LON'
*:&gt;DIMENSION TEST(2) *:&gt;LET &lt;TEST&gt;='TESTING...'
*:&gt;DEMO3 &lt;TEST&gt; ARRAY(1) 'TESTING... @@@@@@' *:&gt;DIMENSION
BIGGER$TEST(902) *:&gt;LET &lt;BIGGER$TEST&gt;='HERE IS ANOTHER VERY
LONG STRING' *:&gt;DEMO3 &lt;BIGGER$TEST&gt; ARRAY(1) 'HERE IS
ANOTHER VE'</P>

<P>This illustrated each possibility. Note that parameters too long
for the receiving actual parameter field are always truncated (with
no warning message). Note also how short strings/keywords are padded
with FIELDATA spaces and short subsets are padded with zeros.</P>

<P>In the event that no paremeter is supplied, THE FIRST WORD of the
receiving (actual) parameter is set to FIELDATA SPACES.</P>

<H3>6.4.3 CALL-BY-ADDRESS subsets</H3>

<P>*:&gt;MACRO DEMO4 MAC:&gt;DIMENSION ARRAY(3) MAC:&gt;PARAMETER
ARRAY MAC:&gt;PRINT!,F ARRAY MAC:&gt;@EOF *:&gt;DEMO4 ARRAY(1) '
@@@@@@@@@@@@' EOF: 3 *:&gt;DEMO4 KEYWORD ARRAY(1) 'KEYWORD ' EOF: 3
*:&gt;DEMO4 'CHARACTER STRING' ARRAY(1) 'CHARACTER STRING ' EOF: 3
*:&gt;DIMENSION LITTLE$TEST(2) *:&gt;LET &lt;LITTLE$TEST&gt;='TINY
STRING' *:&gt;DEMO4 &lt;LITTLE$TEST&gt; ARRAY(1) 'TINY STRING ' EOF:
2 *:&gt;DIMENSION BIG$TEST(7) *:&gt;LET &lt;BIG$TEST&gt;='HERES A
BIGGER SUBSET TO TRY IN DEMO4' *:&gt;DEMO4 &lt;BIG$TEST&gt; ARRAY(1)
'HERES A BIGGER SUBSET TO TRY IN DEMO4 ' EOF: 7</P>

<P>Note how keywords and character strings may be supplied as with
the previous example. When subsets are passed as arguments, the
receiving field ("ARRAY" in this case) is AUTOMATICALLY REDIMENSIONED
to fit the size of the argument - because of this subsets are never
filled or truncated. With subset arguments using this type of
PARAMETER specification, changes made within the macro to the
parameter ("ARRAY") ARE felt in the array from which the calling
macros subset came.</P>

<H3>6.4.4 Using the FLAG Parameter Feature</H3>

<P>The optional "flag" field on each PARAMETER specification allows
the "absent parameter" value to be altered. When the receiving field
on a PARAMETER specification is a scalar or array element, a default
"absent parameter" of zero is used. When the receiving field on a
PARAMETER specification is a subset or array name, a default "absent
parameter" of FIELDATA spaces is used.</P>

<P>By specifying the ":flag" (where the flag is actually an
expression), the "absent parameter" value FOR THE PARAMETER ON WHICH
THE :FLAG WAS SPECIFIED will be changed.</P>

<P>The following example illustrates this:</P>

<P>*:&gt;MACRO DEMO5 MAC:&gt;DIMENSION ARRAY1(3),ARRAY2(1)
MAC:&gt;PARAMETER VAR001:-1,&lt;ARRAY1&gt;:0,ARRAY2:'*NONE*'
MAC:&gt;EVALUATE,D VAR001 MAC:&gt;PRINT,F 1,3 ARRAY1 MAC:&gt;PRINT!,F
ARRAY2 MAC:&gt;@EOF *:&gt;DEMO5 -1 ARRAY1(1) '@@@@@@@@@@@@@@@@@@'
ARRAY2(1) '*NONE*' EOF: 1 *:&gt;DEMO5 999,,HELLO 999 ARRAY1(1)
'@@@@@@@@@@@@@@@@@' ARRAY2(1) 'HELLO ' EOF: 1 *:&gt;DEMO5 ,'THIS IS A
PARAMETER' -1 ARRAY1(1) 'THIS IS A PARAMETE' ARRAY2(1) '*NONE*' EOF:
1</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 6 | MACRO/ | PWORD | </B></CENTER></P>

<P><CENTER><B>| DATA DECLARATIONS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */PWORD</P>

<H2>6.5. PWORD</H2>

<P>&nbsp;</P>

<P>PWORD user-definable-j-desig-name starting-bit,#-bits[,EXTEND]
----- ------</P>

<P>This command allows any of the j-designators J0-J9 to be defined.
Once defined, a j-designator remains defined for the remainder of the
DBE session (or until it is re-defined).</P>

<P>The "starting-bit-#" is an expression indicating which bit of a
word is the first bit of the partial-word that this j-designator
describes. This must be a value of 35 (left-most-bit) through 0
(right-most bit). The "#-of-bits" expression indicates the size (in
bits) of the partial-word being defined. The size must be 1-36 bits
long and cannot exceed the size of the right-most portion of a word
from the "starting-bit-#". For example, a size of 2 bits would be the
largest allowable size if the starting bit is 1.</P>

<P>The default fill for user-defined j-designators is to zero-bit
fill. Sign-extension may be specified by the presence of the word
EXTEND following the "size" expression. setctr 1,7</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>7. LET STATEMENT FUNCTIONS</H1>

<P>The syntax of the LET statement called for the user to be able to
enter "function-call"s as the sending field of the LET. This chapter
discusses the format and use of the various functions. Each will be
documented showing the LET statement and the type of receiving field
intended for use with the function.</P>

<P>The generic format of any function call is as follows:</P>

<P>LET receiving-field = function-name ( parameter[,parameter]... )
---</P>

<P>For example:</P>

<P>LET I = CSF('@ASG,T TEMP.') LET &lt;ARRAY&gt; = ALL(99) LET i =
VALUE('2+5/1+VAR001')</P>

<P>Since the various DBE functions are part of the LET command, and
since LET command is legal in both MACRO and CONVERSATIONAL mode, the
entire set of DBE functions may be used in either mode as well.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | ALL | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ALL</P>

<H2>7.1. ALL</H2>

<P>&nbsp;</P>

<P>LET subset = ALL ( expression ) --- ---</P>

<P>This function sets each word of the specified "subset" to the
value indicated by "expression". This is similar to a COBOL MOVE ALL.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | ASCII | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ASCII</P>

<H2>7.2. ASCII</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>('character-string') LET subset = ASCII ( - - ) --- ----- ( subset
)</P>

<P>This function converts its argument to ASCII and saves the ASCII
string in the receiving subset. The receiving subset should be at
least n*3/2 the size of the argument (in words) to completely hold
the result without truncation.</P>

<P>If the receiving subset is larger than the ASCII string, the
receiving field will be padded with ASCII spaces (040040040040).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | BANKREAD | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */BANKREAD</P>

<H2>7.3. BANKREAD</H2>

<P>&nbsp;</P>

<P>LET subset = BANKREAD (bdi,start-address) --- --------</P>

<P>This function copies data from a common bank to the specified
array subset. Data will be transferred starting from the specified
starting address to either the end of the bank or the recieving
subset.</P>

<P>The UDS System Macros make heavy use of this function to read the
UDS Banks.</P>

<P>If the specified BDI is invalid, the following DBE error will
occur:</P>

<P><CENTER>&lt;170&gt; * IS AN INVALID BDI</CENTER></P>

<P>If the starting address is invalid, the following DBE error will
occur:</P>

<P><CENTER>&lt;171&gt; REQUESTED ADDRESS OUTSIDE OF BANK RANGE
</CENTER></P>

<P>If the common bank specified is too large to be accessed by DBE,
the following DBE error will occur:</P>

<P><CENTER>&lt;172&gt; BANK EXCEEDS DBE STORAGE LIMITS</CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | BANKSIZE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */BANKSIZE</P>

<H2>7.4. BANKSIZE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element) LET - - = BANKSIZE (bdi) --- ( scalar ) --------
</P>

<P>This function returns the ending address for the specified common
bank in H1 of the recieving word and the starting address in H2.</P>

<P>If the specified BDI is invalid, the following DBE error will
occur:</P>

<P><CENTER>&lt;170&gt; * IS AN INVALID BDI</CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | BLOCK | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */BLOCK</P>

<H2>7.5. BLOCK</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = BLOCK ( -
- ) --- ( scalar[:j-designator] ) ----- ( subset )</P>

<P>This function retrieves the current block number of a tape file.
</P>

<P>The fileid of the tape file is supplied as the argument of the
function (as either a character string or subset reference). Assuming
the fileid is indeed that for an OPEN TAPE file, the current block
number (1-n) will be returned. If the fileid is not that for an OPEN
TAPE file, a DBE error will result as follows:</P>

<P>&nbsp;</P>

<P>&lt;166&gt; TAPE SPECIFIED HAS NOT BEEN OPENED</P>

<P>Consult the chapter on I/O commands for more information on tape
files.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | CALCASE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */CALCASE</P>

<H2>7.6. CALCASE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) ( 'character-string' ) LET - - = CALCASE ( - - )
--- ( scalar ) ------- ( subset )</P>

<P>This function provides an interface to the DMS/1100 CALCASE calc
procedure.</P>

<P>The function requires that a schema be loaded. The AREA command
must have been used to select the area in which a record is to be
"located" and the RECORD command must have been used to specify the
type of record involved. The CALCASE function will verify that the
current record can actually be stored in the current area.</P>

<P>The argument to the function is the key value to be given to the
CALCASE database procedure. The key must already be in the
appropriate characterset (see the ASCII function).</P>

<P>The result of this procedure will be a 36-bit result containing
the page number to which the key calcs in H1 and the calc chain
number on that page in H2. Since the result is a 36-bit value,
j-designators should not be used on the receiving field j-designators
are syntactically acceptable however.</P>

<P>Note that this function does not attempt to locate the record or
the page on which it resides. It will be the responsibility of the
user/macro that called the CALCASE function to load the page and
search the calc chain if the actual record is to be found. There is a
system macro documented in the DBE User's Guide (CALCASE) that
performs this complete operation.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | CHECKSUM | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */CHECKSUM</P>

<H2>7.7. CHECKSUM</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element) LET - - = CHECKSUM --- ( scalar ) --------</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>-or-</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element) LET,R - - = CHECKSUM ('&lt;checksum-type&gt;')
----- ( scalar ) --------</P>

<P>&nbsp;</P>

<P>Format 1 of the CHECKSUM function returns the UDS Checksum for the
currently loaded DMS database page.</P>

<P>If no page is loaded, the following DBE error will occur when this
function is called:</P>

<P><CENTER>&lt;13&gt; NO PAGE IS LOADED</CENTER></P>

<P>Format 2 of the CHECKSUM function returns the UDS Checksum based
on the value of &lt;checksum-type&gt; as follows:</P>

<P>RPAGE - Checksum current RDMS page</P>

<P>RAP - Checksum the current RDMS Allocation Page</P>

<P>RFCP - Checksum the RDMS File Control Page</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | COREADR | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */COREADR</P>

<H2>7.8. COREADR</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = COREADR (
- - ) --- ( scalar[:j-designator] ) ------- ( subset )</P>

<P>This function returns the in-core absolute address of a subset or
character string.</P>

<P>This function was developed SPECIFICALLY for the R$FILE macro (see
the chapter on SORT/MERGE) and, except for some limited processor
debugging potential, is not intended for general use.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | CSF | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */CSF</P>

<H2>7.9. CSF</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = CSF ( - -
) --- ( scalar[:j-designator] ) --- ( subset )</P>

<P>This statement submits a character string or the contents of a
subset to OS/1100 for execution as a control-command. Since this
function uses the CSF$ Executive Request (ER), only those operations
legal for ER CSF$ are supported. At the time this document was
prepared, those functions were:</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>@ADD @CKPT @QUAL</P>

<P>@ASG @FREE @RSTRT</P>

<P>@BRKPT @LOG @START</P>

<P>@CAT @MODE @SYM</P>

<P>@USE</P>

<P>&nbsp;</P>

<P>The value returned from this function is the 36-bit status code
returned by ER CSF$. Consult the "1100 Series Executive System
(Volume 2) Programmers Reference Manual - UP-4144.2 (Current
version)" for more information.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | DECODE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DECODE</P>

<H2>7.10. DECODE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( database-key ) LET subset = DECODE ( - - ) --- ------ (
database-pointer )</P>

<P>Both types of arguments are actually expressions that will be
treated as database-keys or database-pointers.</P>

<P>Using the currently-loaded schema, the argument will be broken
down (or decoded) into its component area-code, page-number and
record/slot number. This 3-word result will be saved in the receiving
subset. The receiving subset MUST BE AT LEAST 3 WORDS LONG. Only the
FIRST three words will be modified.</P>

<P>If no schema is loaded, the following DBE error will occur when
this function is called:</P>

<P>&nbsp;</P>

<P>&lt;8&gt; NO SCHEMA IN CORE</P>

<P>If the portion of the argument that is to contain an area-code
contains a value that does not match the area code of any of the
areas in the currently loaded schema, the following DBE error will
result:</P>

<P>&nbsp;</P>

<P>&lt;6&gt; AREA NOT FOUND IN SCHEMA</P>

<P>This can be overriden by the presence of the processor "Q" option.
If the "Q" option is on and the area code is invalid, the subset
returned will return all zeros instead of causing an error condition.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | DMSCALC | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DMSCALC</P>

<H2>7.11. DMSCALC</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) ( 'character-string' ) LET - - = DMSCALC ( - - )
--- ( scalar ) ------- ( subset )</P>

<P>This function provides an interface to the DMS/1100 GS11 (DMSCALC)
procedure.</P>

<P>The function requires that a schema be loaded. The AREA command
must have been used to select the area in which a record is to be
"located" and the RECORD command must have been used to specify the
type of record involved. The DMSCALC function will verify that the
current record can actually be stored in the current area.</P>

<P>The argument to the function is the key value to be given to the
GS11 CALC procedure. The key must already be in the appropriate
characterset (see the ASCII function).</P>

<P>The result of this procedure will be a 36-bit result containing
the page number to which the key calcs in H1 and the calc chain
number on that page in H2. Since the result is a 36-bit value,
j-designators should not be used on the receiving field j-designators
are syntactically acceptable however.</P>

<P>Note that this function does not attempt to locate the record or
the page on which it resides. It will be the responsibility of the
user/macro that called the DMSCALC function to load the page and
search the calc chain if the actual record is to be found. There is a
system macro documented in the DBE User's Guide (DMSCALC) that
performs this complete operation.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | ENCODE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ENCODE</P>

<H2>7.12. ENCODE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) LET - - = ENCODE ( area-code,page-#,rec/slot-# )
--- ( scalar ) ------</P>

<P>This function allows the user to construct database keys and
pointers given the three items specified as arguments to the function
(area code, page number and record/slot number). Each of the three
arguments is an expression.</P>

<P>There must be a schema loaded for this function to operate.</P>

<P>Since a 36-bit result is generated by this function, j-designators
should not be used on the receiving field.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | EXIST | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */EXIST</P>

<H2>7.13. EXIST</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) ( array-name ) LET - - = EXIST ( - scalar - )
--- ( scalar ) ----- ( table-name )</P>

<P>This function returns a flag indicating whether the specfied
argument is defined. A value of 1 indicates the argument is defined -
0 is undefined. Note that arrays MUST be passed as arguments by NAME
not via subsets.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | FILE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */FILE</P>

<H2>7.14. FILE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = FILE ( - -
) --- ( scalar[:j-designator] ) ---- ( subset )</P>

<P>This function returns the current file number of a DBE OPEN TAPE
file. The argument to this function is the DBE fileid specified as
either a character string or as a subset. If the fileid specified is
that of a currently OPEN TAPE FILE, the current file number (1-n)
will be returned to the receiving field (compare with the BLOCK
function).</P>

<P>If the fileid specified is not that of a TAPE file, DBE error #166
(see the BLOCK function) will result.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | FITEM | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */FITEM</P>

<H2>7.15. FITEM</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( 'character-string' ) LET subset = FITEM ( - - ) --- ----- (
subset )</P>

<P>This function returns the file-definition information on the EXEC
file whose internal filename is supplied as the argument. The
internal filename must be presently attached to the file (see the CSF
function and the chapter on I/O commands) it may be supplied as a
character string or as a subset.</P>

<P>The information returned will take the following format:</P>

<P>&nbsp;</P>

<P>:-------------------------------------------------:</P>

<P>1 | Internal Filename (left-justified, space filled |</P>

<P>|--- ---|</P>

<P>2 | |</P>

<P>|-------------------------------------------------|</P>

<P>3 | Actual Filename (left justified, space filled |</P>

<P>|--- ---|</P>

<P>4 | |</P>

<P>|-------------------------------------------------|</P>

<P>5 | Qualifier (left justified, space filled |</P>

<P>|--- ---|</P>

<P>6 | |</P>

<P>|-------------------------------------------------|</P>

<P>7 | Format varies, dependent on device type |</P>

<P>/ /</P>

<P>/ /</P>

<P>/ /</P>

<P>13 | |</P>

<P>:-------------------------------------------------:</P>

<P>Consult the "1100-series (Volume 2) Executive System Programmer
Reference - UP-4144.2 (Current Version)" for the format of the
variable portion of the packet.</P>

<P>The receiving subset should be at least 13 words long, so that the
entire FITEM$ packet may be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | LF | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */LF</P>

<H2>7.16. LF</H2>

<P>&nbsp;</P>

<P>LET subset = LF ( tip-file-number) --- --</P>

<P>This function is used to perform an "FCSS LF" function for the
specified TIP File. Note that the number MUST be TIP not DMS/TIP.
</P>

<P>Consult the TREG macro and the "1100-series Transaction Processing
Programmer Reference - UP-8296.8 (Current Version)" for the format of
the table returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | MQF$ | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MQF$</P>

<H2>7.17. MQF$</H2>

<P>&nbsp;</P>

<P>LET subset = MQF$ --- ----</P>

<P>This function is used to return UDS Application Information for
the currently based UDS Application.</P>

<P>If there is no UDS Application current, the following DBE error
will occur:</P>

<P><CENTER>&lt;173&gt; NO UDS APPLICATION BASED</CENTER></P>

<P>Consult the "OS 1100 Exec System Software Administration and
Support Reference Manual - UP-8486.16-A (Current Version)" for the
format of the table returned by "ER MQF$".</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | RANDENTIAL | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RANDENTIAL</P>

<H2>7.18. RANDENTIAL</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) LET - - = RANDENTIAL
(subset1,subset2,...,subsetN) --- ( scalar ) ----------</P>

<P>This function provides an interface to the DMS/1100 GS13
(Randential) calc procedure.</P>

<P>The function requires that a schema be loaded. The AREA command
must have been used to select the area in which a record is to be
"located" and the RECORD command must have been used to specify the
type of record involved. The RANDENTIAL function will verify that the
current record can actually be stored in the current area.</P>

<P>The argument to the function are the key values to be given to the
RANDENTIAL calc procedure. The keys must already be in the
appropriate characterset (see the ASCII function). If the number of
arguments passed does not equal the number of keys specified in the
RDT, the error returned will be:</P>

<P>&nbsp;</P>

<P>&lt;179&gt; INCORRECT NUMBER OF KEYS SPECIFIED FOR RANDENTIAL</P>

<P>The result of this procedure will be a 36-bit result containing
the page number to which the key calcs in H1 and the calc chain
number on that page in H2. Since the result is a 36-bit value,
j-designators should not be used on the receiving field j-designators
are syntactically acceptable however.</P>

<P>Note that this function does not attempt to locate the record or
the page on which it resides. It will be the responsibility of the
user/macro that called the RANDENTIAL function to load the page and
search the calc chain if the actual record is to be found. There is a
system macro documented in the DBE User's Guide (RANDENTIAL) that
performs this complete operation.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | RANGE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RANGE</P>

<H2>7.19. RANGE</H2>

<P>&nbsp;</P>

<P>LET subset = RANGE ( subset,expression[,expression]... ) --- -----
</P>

<P>This function is used to generate range counts for use with the
HISTOGRAM statement. The reader might wish to consult the following
system macros for some examples of RANGE (and HISTOGRAM) at work:
</P>

<P>&nbsp;</P>

<P>PAGE-USAGE</P>

<P>OVERFLOW</P>

<P>The use of RANGE is probably best illustrated by example rather
than rigorous definition.</P>

<P>Assume we have an array called DATA$POINTS. We wish to accumulate
a list of data point ranges using the following categories:</P>

<P>&nbsp;</P>

<P>0-9</P>

<P>10-99</P>

<P>100-999</P>

<P>1000-9999</P>

<P>10000 and up</P>

<P>Since we wish to accumulate counts on five different ranges, we
also need an array of size 5 in which to keep the counts - assume we
have one such array called RESULTS.</P>

<P>The RANGE function call to accomplish this is as follows:</P>

<P>&nbsp;</P>

<P>LET &lt;RESULTS&gt;=RANGE(DATA$POINTS,0,10,100,1000,10000)</P>

<P>Simply stated, you need a receiving subset at least as large as
the number of ranges. The ranges themselves are indicated by
stringing out the LOW points of each range, in ascending order as
arguments 2-n of the RANGE function - the first argument of the
function is the raw data point subset.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | SEARCH | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SEARCH</P>

<H2>7.20. SEARCH</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j] ) LET-
-=SEARCH(subset[:j],target[,start][,inc]) ---( scalar[:j] ) ------
</P>

<P>Note: "j" denotes a "j-designator"</P>

<P>This function allows a SEQUENTIAL search to be perfomed on a
subset.</P>

<P>The first argument is the subset to be searched. If a j-designator
is supplied for that subset the comparison will be restricted to only
that portion of the words within the subset.</P>

<P>The second argument is an expression to be used as the search
target - that is the value being looked for within the subset.</P>

<P>If the "target" expression could NOT be located within
"subset[:j]", a value of -1 will be returned.</P>

<P>The optional "inc" argument is the increment to be used when
searching the subset. The default increment is one word. Thus, if you
needed to search a subset containing a series of 7-word tables, you
would specify an increment of seven. The increment is specified at
the start of the search and cannot change during the search - if you
must search a subset containing variable-length entries you must do
so manually (see the REPEAT statement).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | SIZE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SIZE</P>

<H2>7.21. SIZE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) ( array-name ) LET - - = SIZE ( - scalar - ) ---
( scalar ) ---- ( table-name )</P>

<P>This function returns the size (in words) of its argument. Note
that arrays MUST be passed as arguments by NAME not via subsets.</P>

<P>The size of a scalar item will be returned as zero. The size of a
table or one-dimension array will be the number of words comprising
the item. The size of a two-dimension array will be returned as a
full 36-bit result containing the number of rows in H1 and the number
of words per row in H2.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | STATUS | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */STATUS</P>

<H2>7.22. STATUS</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = STATUS ( -
- ) --- ( scalar[:j-designator] ) ------ ( subset )</P>

<P>This function allows the OPEN mode of a DBE user file to be
retrieved. The fileid of the user file is specified as the functions
argument this may be either a character string or subset. Consult the
chapter on DBE I/O commands for more information about fileids.</P>

<P>The value returned will be one of the following:</P>

<P>&nbsp;</P>

<P>0: The fileid was undefined</P>

<P>&nbsp;</P>

<P>1: The file was opened either as TAPE or DISC</P>

<P>&nbsp;</P>

<P>2: The file was opened as SDFI</P>

<P>&nbsp;</P>

<P>3: The file was opened as SDFO</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | VALUE | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */VALUE</P>

<H2>7.23. VALUE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) ( 'string' ) LET - - = VALUE ( -
- ) --- ( scalar[:j-designator] ) ----- ( subset )</P>

<P>This function treats the string of characters provided as its
argument (or the FIELDATA contents of a subset) as an expression,
evaluates that expression and assigns the result to the receiving
field.</P>

<P>This function is useful when reading numeric character strings
from the terminal or from an SDFI file. By using VALUE those strings
may be converted to their 36-bit binary values.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 7 | WBUF | </B></CENTER></P>

<P><CENTER><B>| LET STATEMENT FUNCTIONS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */WBUF</P>

<H2>7.24. WBUF</H2>

<P>&nbsp;</P>

<P>LET subset = WBUF ( [first,last] ) --- ----</P>

<P>Characters "first" through "last" of the WRITE statement output
buffer will be extracted and saved, left-justified/space-filled, in
the receiving subset.</P>

<P>The main use of this function is using the FORMAT capabilities of
the WRITE statement to construct characters strings which are then
saved in a subset.</P>

<P>Consult the chapter on I/O commands for more information on the
WRITE statement and the FORMAT capabilities. SETCTR 1,8 TOCLVL 3</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>8. PROCEDURAL STATEMENTS</H1>

<P>The statements in this chapter provide DBE macros with
decision-making, loop-control and procedural-flow-alteration
capabilities.</P>

<P>Each command will be described with the corresponding
Nassi-Shneiderman</P>

<P>Most of these commands allow the use of blocks of DBE statements.
DBE has no BEGIN-END pairing (as do PASCAL, ALGOL and PL/1) but
rather uses a STATEMENT-PAIRING convention that has, for each
statement in this chapter, a PAIR of DBE statements that make up the
statement and define the block. This concept should be nothing new to
the reader experienced in MASM, with its statement pairing -
$IF/$ENDF, $REPEAT/$ENDR, etc. The reader familiar with FTN will also
find this concept familiar, as with the FTN DO/CONTINUE or IF/END IF.
</P>

<P>DBE procedural statements that provide decision-making or looping
may be nested to ANY depth, provided that each level of the nesting
is properly terminated. For example, the following shows three of the
DBE loop-control statements PROPERLY nested:</P>

<P>remain 16 :-----DO FOREVER | . | . | :---IF A=3 THEN | | . | | . |
| :-WHILE B&gt;0 DO | | | . | | | . | | :-END WHILE | | . | | . |
:---END IF | . | . :-----END DO</P>

<P>While the following shows the same three statements IMPROPERLY
nested:</P>

<P>remain 16 :-------DO FOREVER It is the crossing of the lines | .
connecting the statement pairs | . that makes this an illegal nest- |
:-----IF A=3 THEN ing combination. | | . | | . | | :---WHILE B&gt;0
DO | | | . | | | . | :-|---END IF | | . | | . :---|---END DO</P>

<P>| .</P>

<P>| .</P>

<P>:---END WHILE</P>

<P>Note that each statement has an END for that statement type. This
is the convention used by all DBE block-oriented statements. You
should be aware that ONLY A SINGLE SPACE may separate the END from
the word that follows it.</P>

<P>The DBE LIST command (see Chapter 5) will AUTOMATICALLY indent the
listing of macros that use the block-oriented statements. This will
enhance the readability of the macro listing by visually highlighting
the nesting structure.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO mode | DO FOREVER | </B>
</CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */DO</P>

<H2>8.1. DO FOREVER</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>DO FOREVER -- -------</P>

<P>.</P>

<P>.</P>

<P>block of DBE statements</P>

<P>.</P>

<P>. END DO --- --</P>

<P>This statement creates an "infinite loop" around the block of DBE
statement bracketed by the DO FOREVER and the END DO as follows:</P>

<P><CENTER>:---------------------------------------------------------:
</CENTER></P>

<P><CENTER>| DO FOREVER |</CENTER></P>

<P><CENTER>| :----------------------------------------------------|
</CENTER></P>

<P><CENTER>| | Block of DBE statements |</CENTER></P>

<P><CENTER>| :----------------------------------------------------|
</CENTER></P>

<P><CENTER>| |</CENTER></P>

<P><CENTER>:---------------------------------------------------------:
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | ERROR | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */ERROR</P>

<H2>8.2. ERROR</H2>

<P>&nbsp;</P>

<P>ERROR [label] -----</P>

<P>This statement specifies the label to which control should be
transfered in the event that a DBE error occurs during the macro in
which the ERROR statement occurs.</P>

<P>If no label is specified, the error-trap will be cleared, and no
DBE error recovery will be possible.</P>

<P>When an ERROR label has been registered and a DBE error occurs, NO
is printed once control is transfered to the error-trap label the
macro may issue the desired message.</P>

<P>The system variables ECODE and EINFO may prove quite useful to the
error trap routine since they will contain the information available
about the error.</P>

<P>You may find the ERRPR and RECOVER commands of interest to error
trapping. Both may be found in this chapter.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | ERRPR | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */ERRPR</P>

<H2>8.3. ERRPR</H2>

<P>&nbsp;</P>

<P>ERRPR[,&lt;options&gt;] error-code -----</P>

<P>This statement may be used to print standard DBE error messages,
macro statement "walkback" information or to reset the value of
ECODE.</P>

<H3>8.3.1 Options</H3>

<P>C The description of the specified error will be written to the
console-output buffer, acting as if a "WRITE,C" had been done.</P>

<P>N Do not print walk-back information.</P>

<P>W The description of the specified error will be written to the
write buffer, acting as if a "WRITE" had been done.</P>

<H3>8.3.2 Discussion</H3>

<P>The behavior of this statement will be shown by the following
examples.</P>

<H4>8.3.2.1 Print the Most-recent Error Message</H4>

<P>*:&gt;MACRO TEST01 MAC:&gt;ERROR ETRAP MAC:&gt;LET
VAR001==YUYTD]'$K MAC:&gt; . MAC:&gt; . MAC:&gt;ETRAP: ERRPR
MAC:&gt;EVALUATE,D VAR001 MAC:&gt;@EOF *:&gt;TEST01 &lt;27&gt; SYNTAX
ERROR ABOVE ERROR OCCURRED AT LINE 2 OF MACRO "TEST01" 0 *:&gt;LIST
TEST01 2</P>

<P>2: LET VAR001==YUYTD]'$K</P>

<H4>8.3.2.2 Print the Most-recent Error Message (No walkback)</H4>

<P>*:&gt;MACRO TEST02 MAC:&gt;ERROR ETRAP MAC:&gt;LET
VAR001==YUYTD]'$K MAC:&gt; . MAC:&gt; . MAC:&gt;ETRAP: ERRPR,N
MAC:&gt;EVALUATE,D VAR001 MAC:&gt;@EOF *:&gt;TEST01 &lt;27&gt; SYNTAX
ERROR 0</P>

<P>Notice how the N option suppresses the line-number (or walkback)
information.</P>

<H4>8.3.2.3 Print an Arbitrary Error Message</H4>

<P>*:&gt;ERRPR 27 &lt;27&gt; SYNTAX ERROR *:&gt;EVALUATE,D ECODE 27
*:&gt;ERRPR 30 &lt;30&gt; USER VARIABLE '*' IS NOT DEFINED
*:&gt;EVALUATE,D ECODE 30 *:&gt;ERRPR 999 &lt;999&gt; ---&gt; ERROR
IS UNDEFINED &lt;---</P>

<P>Not only will the appropriate DBE error message be printed, by the
value of ECODE will be set to the error code whose message was
requested. If the error message printed is one that normally contains
extra information (such as message #30 above), the spot in the
message where the extra information would occur will be indicated by
an asterisk (*).</P>

<P>The last example above shows the effect of attempting to print an
undefined error message.</P>

<H4>8.3.2.4 Reseting ECODE</H4>

<P>*:&gt;ERRPR -1 *:&gt;EVALUATE,D ECODE -1</P>

<P>The value -1 is used within DBE to indicate that there has been no
error. Macros may reset the ECODE variable using this format.</P>

<H4>8.3.2.5 Using the "W"/"C" options</H4>

<P>*:&gt; &amp;&amp;&amp;&amp;&amp;&amp; &lt;27&gt; SYNTAX ERROR
*:&gt; write = 'your last error was "' *:&gt; errpr,w *:&gt; write =
'"!',* YOUR LAST ERROR WAS "SYNTAX ERROR"!</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | GOSUB | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | END SUB| </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */GOSUB</P>

<H2>8.4. GOSUB --- END SUB</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>GOSUB label -----</P>

<P>.</P>

<P>.</P>

<P>.</P>

<P>. END SUB --- ---</P>

<P>This statement transfers control to the specified label within the
current macro. When the command END SUB is encountered, control is
returned to the line in the macro immediately following the GOSUB
command. GOSUBs can be nested up to a Generation Defined limit.</P>

<P>Note that GOSUB / END SUB pairs only function within a macro. For
instance:</P>

<P>Macro A executes a gosub. The line after the gosub calls macro B.
Macro B CAN NOT issue an END SUB - it must issue a RETURN and then
macro A can issue the END SUB.</P>

<P>If an END SUB is encountered without a matching GOSUB, the
following DBE error will occur:</P>

<P><CENTER>&lt;123&gt; NO GOSUB RETURN ADDRESS FOR THIS MACRO
</CENTER></P>

<P>If the amount of allowable nested GOSUB commands is exceeded,the
following DBE error will occur:</P>

<P><CENTER>&lt;116&gt; GOSUB RETURN TABLE IS FULL</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | GOTO | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | GO TO | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */GOTO</P>

<H2>8.5. GOTO (or GO TO)</H2>

<P>&nbsp;</P>

<P>( GOTO ) ( ---- ) - - label ( GO [TO] ) ( -- -- )</P>

<P>This statement transfers control to the specified label within the
current macro. Note that the word TO is optional (as in COBOL) the
behavior of the statement will be the same regardless of how it is
used (GOTO, GO TO or simply GO).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | IF | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */IF</P>

<H2>8.6. IF</H2>

<P>This statement provides a basic decision-making capability to DBE
in a manner consistent with many higher-level languages. There are
two types of IF statements:</P>

<P>&nbsp;</P>

<P>1. The SIMPLE IF where, based upon a TRUE/FALSE condition, a
SINGLE DBE statement is executed.</P>

<P>&nbsp;</P>

<P>2. The COMPOUND or COMPLEX IF where based upon a TRUE/FALSE
condition a block of one or more DBE statements is executed.</P>

<P>The following two sections describe each type of IF individually.
</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | IF | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | Format one - SIMPLE IF | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>8.6.1 Simple IF</H3>

<P>&nbsp;</P>

<P>IF expression dbe-statement --</P>

<P>The expression after the IF is evaluated. If the expression
evaluates to a non-zero result, it is considered TRUE and the
statement following the expression is executed.</P>

<P>The statement after the condition may be any DBE statement except
the following:</P>

<P>&nbsp;</P>

<P>DO FOREVER, IF, PAGE, REPEAT, WHILE</P>

<P>Note that since the IF statement is not legal in CONVERSATIONAL
mode that all statements and commands legal only in CONVERSATIONAL
mode are also on this format of the IF.</P>

<P>&nbsp;</P>

<P>Some examples follow:</P>

<P>&nbsp;</P>

<P>IF A&gt;5 LET I=2 Set I to 2 if A is &gt; 5</P>

<P>IF F=1 STOP Halt the macro if F has the value 1</P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| NO \ Does Expression have a non-zero value? |
</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| V | DBE statement following expression |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| Statement following IF :</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | IF | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | Format two - COMPLEX IF |
</B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>8.6.2 Complex IF</H3>

<P>&nbsp;</P>

<P>IF expression THEN -- . ----</P>

<P>.</P>

<P>DBE Statement(s)</P>

<P>.</P>

<P>. [ ELSE [IF expression THEN</P>

<P>---- -- ----</P>

<P>.</P>

<P>.</P>

<P>DBE Statement(S)</P>

<P>.</P>

<P>. ] ... ] END IF --- --</P>

<P>This format of the IF statement allows blocks of DBE statements to
be executed based upon the TRUE (non-zero) or FALSE (zero) value of
an expression.</P>

<P>The statements that may be used in the block are simply those
statements legal within a macro - none of the additional restrictions
of the Simple IF apply here.</P>

<P>Examples of each type of IF possible under this format follow.
</P>

<H4>8.6.2.1 IF --- THEN</H4>

<P>IF A = 17 THEN</P>

<P>LET A = B * 34</P>

<P>LET VAR001 = B % A</P>

<P>GO TO LAB001 END IF</P>

<P>In this case, the three statements shown indented under the IF
will be done if "A" has the value 17. If "A" does not have the value
of 17, those three statements are ignored, and control proceeds to
whatever follow the END IF. The N-S chart describing the behavior of
this type of IF is:</P>

<P>remain 13</P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| NO \ Does "expression" have a non-zero value? |
</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| | | DBE statement #1 |</CENTER></P>

<P><CENTER>: | :------------------------------------------:
</CENTER></P>

<P><CENTER>| | | . |</CENTER></P>

<P><CENTER>| | | . |</CENTER></P>

<P><CENTER>| | | . |</CENTER></P>

<P><CENTER>| | :------------------------------------------:
</CENTER></P>

<P><CENTER>| | | DBE statement #n |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| Statement following END IF |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<H4>8.6.2.2 IF --- THEN --- ELSE</H4>

<P>IF A = 17 THEN</P>

<P>LET A = B * 3</P>

<P>LET VAR001 = A % 17</P>

<P>GO TO LAB001 ELSE</P>

<P>LET A = B * 1113</P>

<P>GO TO LAB001 END IF</P>

<P>Here a choice is made between two blocks of DBE statements. The
first block, following the word THEN and therefore referred to as the
THEN-block, will be done if the expression on the IF is TRUE
(non-zero). The second block, called the ELSE-block since it follows
the ELSE, will be done if the expression was FALSE (had a zero
value).</P>

<P>This is illustrated by the following N-S chart:</P>

<P>remain 13</P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| NO \ Does expression have non-zero value? / YES |
</CENTER></P>

<P><CENTER>:----------------------:--------------------------:
</CENTER></P>

<P><CENTER>| ELSE-block stmnt #1 | THEN-block stmnt #1 |
</CENTER></P>

<P><CENTER>:----------------------|--------------------------|
</CENTER></P>

<P><CENTER>| . | . |</CENTER></P>

<P><CENTER>| . | . |</CENTER></P>

<P><CENTER>| . | . |</CENTER></P>

<P><CENTER>:----------------------|--------------------------:
</CENTER></P>

<P><CENTER>| ELSE-block stmnt #m | THEN-block stmnt #n |
</CENTER></P>

<P><CENTER>:----------------------:--------------------------:
</CENTER></P>

<P><CENTER>| Statement following END IF |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<H4>8.6.2.3 IF --- THEN --- ELSE IF --- THEN --- ELSE</H4>

<P>IF A = 1 THEN</P>

<P>LET VAR001 = 1</P>

<P>LET VAR002 = 10 ELSE IF A = 2 THEN</P>

<P>LET VAR001 = 2</P>

<P>LET VAR002 = 20 ELSE IF A = 3 THEN</P>

<P>LET VAR001 = 3</P>

<P>LET VAR002 = 30 ELSE</P>

<P>LET VAR001 = -1</P>

<P>LET VAR002 = -1 END IF</P>

<P>This form of the IF statement allows a series of (presumably
mutually exclusive) conditions to be evaluated and causes the block
of statements associated with THE FIRST TRUE CONDITION ONLY to be
executed. The ELSE allows a default case to be done if no TRUE
conditions were found. This is the DBE implimentation of a CASE
construct. The N-S chart that describes this form of the IF is as
follows:</P>

<P>remain 21</P>

<P><CENTER>:----------------------------------------------------------------:
</CENTER></P>

<P><CENTER>| NO \ Condition #1 TRUE? / YES |</CENTER></P>

<P><CENTER>:--------------------------------------------:-------------------:
</CENTER></P>

<P><CENTER>| NO \ Condition #2 TRUE? / YES | Cond. #1 Stmnt #1 |
</CENTER></P>

<P><CENTER>|------------------------:-------------------: |
</CENTER></P>

<P><CENTER>| . | Cond. #2 Stmnt #1 | |</CENTER></P>

<P><CENTER>| . | . | |</CENTER></P>

<P><CENTER>| . | . | |</CENTER></P>

<P><CENTER>| . | . | |</CENTER></P>

<P><CENTER>| . | Cond. #2 Stmnt #m | |</CENTER></P>

<P><CENTER>| . | | |</CENTER></P>

<P><CENTER>:------------------------: | |</CENTER></P>

<P><CENTER>| ELSE | | |</CENTER></P>

<P><CENTER>:------------------------: | |</CENTER></P>

<P><CENTER>| ELSE Stmnt #1 | | |</CENTER></P>

<P><CENTER>| . | | |</CENTER></P>

<P><CENTER>| . | | |</CENTER></P>

<P><CENTER>| ELSE Stmnt #z | | |</CENTER></P>

<P><CENTER>:------------------------:-------------------:-------------------:
</CENTER></P>

<P><CENTER>| DBE Statement following END IF |</CENTER></P>

<P><CENTER>:----------------------------------------------------------------:
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | MACSUB | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */MACSUB</P>

<H2>8.7. MACSUB</H2>

<P>&nbsp;</P>

<P>MACSUB [ macro-name parameters ] ------</P>

<P>This statement is used within a macro to call another macro and
have ALL the variables and arrays created/modified by the calling
macro to be available to the calling macro (or conversational mode).
This is an alternative to use of the GLOBAL statement to modify
scalars.</P>

<P>The UDS System Macro U$LOAD makes heavy use of this command as it
defines and dimensions arrays of unknown sizes.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | REPEAT | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | UNTIL | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */REPEAT</P>

<H2>8.8. REPEAT --- UNTIL</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>REPEAT [ scalar = start,increment ] ------</P>

<P>.</P>

<P>.</P>

<P>DBE Statement(s)</P>

<P>.</P>

<P>. UNTIL expression -----</P>

<P>This statement is one of the four DBE loop-control statements (the
other three being DO FOREVER, GOTO and WHILE). The DBE statements
bracketed within the REPEAT and the UNTIL will be repeated until such
time as the condition on the UNTIL becomes TRUE (has a non-zero
value).</P>

<P>As an option, a scalar variable may be specified as a LOOP COUNTER
on the REPEAT. By exercising this option, a variable will be set to
an initial value when the REPEAT loop if first entered (the value of
the "start" expression) and will be incremented by the value of
"increment" before beginning each successive iteration.</P>

<P>As an example, the following will cause the integers from one to
ten to be printed and summed:</P>

<P>*:&gt;MACRO DEMO01 MAC:&gt;LET SUM = 0 MAC:&gt;REPEAT INTEGER =
1,1 MAC:&gt;EVALUATE,D INTEGER MAC:&gt;LET SUM = SUM + INTEGER
MAC:&gt;UNTIL INTEGER = 10 MAC:&gt;EVALUATE,D SUM MAC:&gt;@EOF
*:&gt;DEMO01 1 2 3 4 5 6 7 8 9 10 55</P>

<P>The next example does the same, but for just the ODD integers 1,
3, 5, 7 and 9:</P>

<P>*:&gt;MACRO DEMO02 MAC:&gt;LET SUM = 0 MAC:&gt;REPEAT INTEGER =
1,2 MAC:&gt;EVALUATE,D INTEGER MAC:&gt;LET SUM = SUM + INTEGER
MAC:&gt;UNTIL INTEGER = 9 MAC:&gt;EVALUATE,D SUM MAC:&gt;@EOF
*:&gt;DEMO02 1 3 5 7 9 25</P>

<P>The N-S chart that illustrates this statement is as follows:</P>

<P>remain 20</P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| Set loop-counter (if any) to initial value |
</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| REPEAT |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| | \ Loop counter specified AND not / |</CENTER></P>

<P><CENTER>| | NO \ First time through the loop? / YES|</CENTER></P>

<P><CENTER>| :--------------------------------------------|
</CENTER></P>

<P><CENTER>| | | | Add "increment" value on REPEAT to |</CENTER></P>

<P><CENTER>| | V | Loop counter |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| | DBE statement #1 |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| | . |</CENTER></P>

<P><CENTER>| | . |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| UNTIL "expression" has non-zero value (TRUE) |
</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| Statement after UNTIL |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | RETURN | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */RETURN</P>

<H2>8.9. RETURN</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( 'character-string' ) RETURN [ - subset - ] ------ ( expression )
</P>

<P>This statement allows a macro to transfer control back to the
macro from which it was invoked. If a macro was invoked from
CONVERSATIONAL mode, control returns back to the user and
CONVERSATIONAL mode is re-established.</P>

<P>The optional argument allows the macro to also pass a value back
to its caller. The absence of a value will assume the value of zero
(0).</P>

<P>Following a RETURN, the value specified on the RETURN is available
as follows:</P>

<P>&nbsp;</P>

<P>1. The first 36-bits of the RETURNed value are available in the
system variable RESULT.</P>

<P>&nbsp;</P>

<P>2. If the macro was called via a LET statement as a function, then
the value of the RETURNed result is also available in the LET
statement receiving field. The amount of the value that is available
will be determined by the size of the receiving field. When RETURNing
subsets remember that the subset will be truncated or zero-filled to
fit the receiving field, as necessary. When RETURNing character
strings, remember that they will be truncated or FIELDATA
space-filled, as necessary.</P>

<P>Consult the chapter on DEBUGGING for information on the role the
RETURN statement may play in CONVERSATIONAL mode.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | STOP | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */STOP</P>

<H2>8.10. STOP</H2>

<P>&nbsp;</P>

<P>STOP ----</P>

<P>This statement causes an un-conditional halt of the
currently-executing macro and an immediate return to CONVERSATIONAL
mode. All user variables defined while within MACRO mode are lost.
</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | WAIT | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */WAIT</P>

<H2>8.11. WAIT</H2>

<P>&nbsp;</P>

<P>WAIT[,options] [delay-value] ----</P>

<H3>8.11.1 Options</H3>

<P>None Legal only if no "delay-value" is given</P>

<P>H Treat the "delay-value" as an hhmm value</P>

<P>M Treat the "delay-value" as minutes</P>

<P>S Treat the "delay-value" as seconds This statement allows the
Database Editor to be "put to sleep" for a period of time. That
period of time may be "forever, or until an @@X" (WAIT with no
options), until a specified time (WAIT,H), for a certain number of
seconds (WAIT,S) or a certain number of minutes (WAIT,M).</P>

<P>The following illustrate how WAIT is used.</P>

<H3>8.11.2 Wait Forever</H3>

<P>WAIT ----</P>

<P>This will cause DBE to be permanently suspended. The only event
that can re-awaken DBE is an @@X contingency. remain 10</P>

<H3>8.11.3 Wait Until a Specified Time</H3>

<P>WAIT,H hhmm ---- -</P>

<P>The expression "hhmm" is treated as a 24-hour format time. DBE
will remain suspended until that time.</P>

<H3>8.11.4 Wait One or More Seconds</H3>

<P>WAIT,S number-of-seconds ---- -</P>

<P>Note that the wait must be an integral number of seconds.</P>

<H3>8.11.5 Wait One or More Minutes</H3>

<P>WAIT,M number-of-minutes ---- -</P>

<P>Note that the wait must be an integral number of minutes.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO Mode | WHILE | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | | END WHILE | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */WHILE</P>

<H2>8.12. WHILE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>WHILE expression [DO] ----- --</P>

<P>.</P>

<P>.</P>

<P>.</P>

<P>DBE Statement(s)</P>

<P>.</P>

<P>.</P>

<P>. END WHILE -----</P>

<P>This statement pair causes a block of one or more DBE statements
to be repeated for as long as an expression (on the WHILE statement)
remains TRUE (non-zero).</P>

<P>For example:</P>

<P>LET INTEGER = 1 LET SUM = 0 WHILE INTEGER &lt; 11 DO</P>

<P>EVALUATE,D INTEGER</P>

<P>LET SUM = SUM + INTEGER</P>

<P>LET INTEGER = INTEGER + 1 END WHILE</P>

<P>Compare this against an equivalent section of macro code - the
first REPEAT example.</P>

<P>The N-S chart that describes this statements behavior is as
follows:</P>

<P>remain 13</P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER>| WHILE condition DO |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| | DBE statement #1 |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| | . |</CENTER></P>

<P><CENTER>| | . |</CENTER></P>

<P><CENTER>| | . |</CENTER></P>

<P><CENTER>| :--------------------------------------------:
</CENTER></P>

<P><CENTER>| | DBE statement #n |</CENTER></P>

<P><CENTER>|-------------------------------------------------:
</CENTER></P>

<P><CENTER>| DBE statement following END WHILE |</CENTER></P>

<P><CENTER>:-------------------------------------------------:
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 8 | MACRO/ | XQT | </B></CENTER></P>

<P><CENTER><B>| PROCEDURAL COMMANDS | CONVERSATIONAL | * | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */XQT</P>

<H2>8.13. XQT and *</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>XQT subset ---</P>

<P>*</P>

<P>The XQT command causes the contents of the specified subset to be
executed as a DBE command.</P>

<P>The "*" command causes the current contents of the WRITE buffer to
be executed as a command. The WRITE buffer IS ERASED after execution
of its contents.</P>

<P>While these statements are legal in either MACRO or CONVERSATIONAL
mode, the command being remotely executed by these statements must be
legal in the current mode. *// SETCTR 1,9 TOCLVL 5</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>9. I/O STATEMENTS</H1>

<P>This chapter discusses the various DBE I/O statements. They are
broken down into their three basic components:</P>

<P>&nbsp;</P>

<P>1. SYSTEM LOG I/O statements.</P>

<P>&nbsp;</P>

<P>2. TERMINAL/PRINTER I/O statements.</P>

<P>&nbsp;</P>

<P>3. DISC/TAPE file-oriented I/O statements.</P>

<P>The three types of statements are generally available in both
MACRO and CONVERSATIONAL mode (with the exception of the FORMATted
WRITE).</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | SYSTEM LOG | LOG | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */LOG</P>

<H2>9.1. System Log I/O</H2>

<H3>9.1.1 LOG</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>LOG (subset)</P>

<P>---</P>

<P>The LOG command is used to place user entries into the System Log
via ER LOG$. The Log entry will consist of a "Before Look" and "After
Look" (supplied as the subset parameter) for the current word of the
table being modified.</P>

<P>This command is intended mainly for use in Database Update Macros.
</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*//</P>

<H2>9.2. Terminal and Printer I/O</H2>

<P>*/WRITE</P>

<H3>9.2.1 WRITE</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( = format-item-1[,format-item-2]... )</P>

<P>( subset ) WRITE[,options] - * - ----- ( ( expression ) (
expression ) )</P>

<P>( label - -[, - -]... )</P>

<P>( subset ) ( subset )</P>

<H4>9.2.1.1 Options</H4>

<P>None Perform output to terminal/terminal write buffer.</P>

<P>A Used ONLY when the argument to WRITE is a subset. This writes
the subset to the terminal using an ASCII print. The contents of the
subset are assumed to be in ASCII.</P>

<P>C Perform output to console/console write buffer.</P>

<P>R Following the "WRITE" command, execute a "RETURN" command.</P>

<P>S Following the "WRITE" command, execute a "STOP" command.</P>

<P>For WRITE statements other than subset WRITEs, there are two
buffers maintained - the standard WRITE buffer and the console write
buffer. The latter is used on any WRITE,C (except WRITE,C subset)
while the former is used on other WRITEs.</P>

<P>An imaginary pointer, called the column pointer, is maintained.
This is the current character position within the WRITE or WRITE,C
buffer - the current values of these are available under the system
variables of CHARSW and CHARSC, respectively.</P>

<P>Output is accomplished by concatenating images in either WRITE
buffer and, when finished, causing them to print via the * FORMAT
item or WRITE *. It is important to remember that only when a *
FORMAT item (or WRITE *) is encountered will output actually be
printed.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE = | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | List-oriented WRITEs |
</B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>9.2.2 List-oriented WRITEs (WRITE =)</H3>

<P>Index WRITE = This format of WRITE allows character-strings to be
written to the console or terminal without the need to specify a
FORMAT (discussed later). The items following the = may be any
designated as legal on a WRITE =. The entire set of legal FORMAT
items is given at the end of the WRITE discussion.</P>

<P>Some examples are as follows:</P>

<P>WRITE = 'HELLO THERE',*</P>

<P>Write the string 'HELLO THERE' to the terminal.</P>

<P>WRITE,C = C34,'THIS IS A STRING',*</P>

<P>Write 'THIS IS A STRING' to the operators console. The string will
appear beginning in column 34.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE <subset> | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | Free-form buffer WRITEs |
</B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>This form of the WRITE statement assumes that the user has a
character string already established in a subset. The contents of the
subset will be written to the terminal (or console). A line-spacing
of 1 will be assumed on this format of the WRITE statement.</P>

<P>The WRITE statement will assume that the buffer contents are
FIELDATA characters, and will print accordingly.</P>

<P>Presence of the optional "A" option will change the assumption to
that of ASCII characters. DBE WILL NOT convert the subset to ASCII
prior to writing the subset - it is the programmers responsibility to
ensure that the subset contains the desired LEGAL ASCII CHARACTERS.
</P>

<P>Some examples follow:</P>

<P>*:&gt;DIMENSION BUFFER(14) *:&gt;LET &lt;BUFFER&gt;='THIS IS A
FIELDATA WRITE' *:&gt;WRITE &lt;BUFFER&gt; THIS IS A FIELDATA WRITE
</P>

<P>*:&gt;DIMENSION ASCII$STUFF(20) *:&gt;LET
&lt;ASCII$STUFF:2,7&gt;=ASCII('THIS IS AN ASCII WRITE: ') *:&gt;LET
&lt;ASCII$STUFF:8,20&gt;=ASCII('THIS SHOULD APPEAR AT LINE 1 COL 1')
*:&gt;LET ASCII$STUFF(1):H1=033145 @ ESC LC-E (HOME CURSOR) *:&gt;LET
ASCII$STUFF(1):H2=033000 ++ 'M'A @ ESC-M (ERASE UNPROT-DISPLAY)
*:&gt;WRITE,A &lt;ASCII$STUFF&gt; THIS IS AN ASCII WRITE: THIS SHOULD
APPEAR AT LINE 1 COL 1</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE * | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | Buffer-print WRITEs | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>9.2.3 Buffer-Print WRITEs (WRITE *)</H3>

<P>This type of WRITE statement prints the contents of the terminal
(or console) write buffer, erases the buffer to spaces and positions
the buffers column pointer back to column 1.</P>

<P>This is equivalent to using the * format item.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE label | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | FORMATted WRITE | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>9.2.4 Formatted WRITE</H3>

<P>This is probably the most common form of WRITE statement. This
form provides a facility similar to a FORTRAN FORMATted write or a
PL/1 PUT EDIT. The label on the WRITE belongs to a FORMAT statement
described elsewhere in the macro.</P>

<P>The expressions and subsets provide a series of 36-bit words whose
values will be edited into a specific format as per the FORMAT
statement.</P>

<P>No more than 33 words worth of information may be provided on any
one WRITE statement.</P>

<P>The following examples illustrate some of the uses of this type of
WRITE statement. The next section discusses each of the possible
FORMAT items in detail.</P>

<P>WRITE FMT1 VAR001 FMT1: FORMAT 'THE VALUE OF VAR001 IS: ',D6,*(3)
</P>

<P>Copy the given character string into the output buffer, edit the
contents of VAR001 into a 6-digit decimal (FIELDATA) value and insert
that value into the buffer following the string and print the buffer
contents after advancing 3 lines.</P>

<P>WRITE AREANM &lt;ART:4,5&gt; AREANM: FORMAT 'THE AREA NAME IS:
',&lt;2&gt;F6,*(-1)</P>

<P>Copy the given string into the WRITE buffer, insert the 2-word
subset &lt;ART:4,5&gt; into the buffer after the string (the subset
is to be inserted as two 6-character FIELDATA strings) and print the
buffer after advancing to the top of a new page.</P>

<P>WRITE = 'WORD 010 OF SCRT = ' WRITE FMT2 SCRT[010]:H1 FMT2: FORMAT
B18,X7 WRITE FMT2 SCRT[010]:H2 WRITE *</P>

<P>This shows how the various types of WRITE may be used in
combination. The string 'WORD 010 OF SCRT = ' is inserted into the
WRITE buffer. Since no * was present, the buffer is NOT printed.</P>

<P>Next, H1 of SCRT[010] is edited in as an 18-bit binary number
(FIELDATA). After editing in the 18-bit number, 7 columns are skipped
(forward) in the buffer.</P>

<P>Then H2 of SCRT[010] is edited in as an 18-bit binary number
(FIELDATA). After editing in the 18-bit number, 7 columns are again
skipped (forward) in the buffer.</P>

<P>Finally, the WRITE * causes the buffer to be printed.</P>

<P>Whenever the WRITE buffer is printed, it is erased after printing
and the buffers column pointer will be reset to column one.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H4>9.2.4.1 WRITE/FORMAT Items</H4>

<P>The general syntax of a FORMAT statement is simply the word FORMAT
followed by a list of the items described in this section, separated
by commas. Note that all FORMAT statements should have labels else
they will be unavailable to the WRITE statements that need them.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | WRITE = | 'character-string' | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.1 'character-string'</H5>

<P>This type of format item inserts a specific FIELDATA character
string into the WRITE (or WRITE,C) buffer starting at the character
position at which the buffer pointer is presently stationed.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | WRITE = | *[expression] | </B>
</CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.2 *[expression]</H5>

<P>This format item prints the buffer to the terminal after advancing
the number of lines specified by "expression", erases the buffer to
FIELDATA spaces and resets the character pointer to zero.</P>

<P>If the "expression" is absent, a value of one will be assumed. If
the value of "expression" is negative, a page-eject will be done
prior to the WRITE. If the value is zero and you are writing to the
printer (via @BRKPT mode) overprinting will occur. If the value is
zero and you are writing to the terminal, one will be assumed.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]Aw | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.3 [<n>]Aw</H5>

<P>Index A Format Item This format edits the next "n" words from the
list on the WRITE statement (if no &lt;n&gt; is supplied, &lt;1&gt;
is assumed) will be treated as containing ASCII characters. The
right-most "w" characters of each word will be converted to FIELDATA
and will be stored in the current character position(s) of the WRITE
buffer.</P>

<P>As an example, the following inserts the characters 'ABC' into the
WRITE buffer:</P>

<P>WRITE FMT1 'A'A,'BC'A FMT1: FORMAT A1,A2</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]B[w] | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.4 [<n>]B[w]</H5>

<P>This format edits the next "n" words from the list on the WRITE
statement (if no &lt;n&gt; is supplied, &lt;1&gt; is assumed) will be
edited in a binary (FIELDATA 0/1) form into the WRITE buffer. Only
the right-most "w" bits (defaulting to 36 if no "w" is given) of each
word will be used. If the value of "w" exceeds 36, "w"-36 leading
spaces will be inserted.</P>

<P>The following inserts -1 as a 36-bit binary value into the WRITE
buffer:</P>

<P>WRITE BINFMT -1 BINFMT: FORMAT B36</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | WRITE = | Cn | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.5 Cn</H5>

<P>This format item positions the column pointer to column "n". The
following example inserts a "*" in columns 1, 15 and 100 of the WRITE
buffer:</P>

<P>WRITE = C1,'*',C15,'*',C100,'*'</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]D[w] | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.6 [<n>]D[w]</H5>

<P>This format item inserts "n" words from the WRITE list (if no
&lt;n&gt; is specified a default of &lt;1&gt; is assumed) into the
write buffer as a series of decimal (FIELDATA) numbers each
right-justified in a field of "w" spaces. If any number is too large
for a field of "w" characters, the field will be overflowed on the
right. If no "w" is specified the number will be edited into a
variable-length field.</P>

<P>The following inserts the number 1 into a five-character field and
-17 into a four-character field:</P>

<P>WRITE DECFMT 1,-17 DECFMT: FORMAT D5,D4</P>

<P>The following illustrates how the variable-length field may be
used to improve readability:</P>

<P>*:&gt;MACRO DEMO01 MAC:&gt;LET V1=15 MAC:&gt;LET V2=99999
MAC:&gt;WRITE FMT1 V1,V2 MAC:&gt;FMT1: FORMAT 'V1 = ',D6,', V2 =
',D6,* MAC:&gt;WRITE FMT2 V1,V2 MAC:&gt;FMT2: FORMAT 'V1 = ',D,', V2
= ',D,* MAC:&gt;@EOF *:&gt;DEMO01 V1 = 15, V2 = 99999 V1 = 15, V2 =
99999</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]Fw | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.7 [<n>]Fw</H5>

<P>This format edits the next "n" words from the list on the WRITE
statement (if no &lt;n&gt; is supplied, &lt;1&gt; is assumed) will be
treated as containing FIELDATA characters. The right-most "w"
characters of each word will be stored in the current character
position(s) of the WRITE buffer.</P>

<P>As an example, the following inserts the characters 'ABC' into the
WRITE buffer:</P>

<P>WRITE FMT1 'A','BC' FMT1: FORMAT F1,F2</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]H[w] | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.8 [<n>]H[w]</H5>

<P>This format item inserts "n" words from the WRITE list (if no
&lt;n&gt; is specified a default of &lt;1&gt; is assumed) into the
write buffer as a series of hexadecimal (FIELDATA) numbers each
right-justified in a field of "w" spaces. If any number is too large
for a field of "w" characters, the field will be overflowed on the
right. If no "w" is specified the number will be edited into a
variable-length field. No more than nine (9) hexadecimal digits may
be printed in a field (excess character positions will be
left-alligned spaces).</P>

<P>The following inserts the number 15 into a five-character field
and 57005 into a twelve-character field:</P>

<P>WRITE DECFMT 15,57005 DECFMT: FORMAT H5,H12,*</P>

<P>With the resulting printout being:</P>

<P>000F DEAD</P>

<P>The following illustrates how the variable-length field may be
used to improve readability:</P>

<P>*:&gt;MACRO DEMO01 MAC:&gt;LET V1=15 MAC:&gt;LET V2=99999
MAC:&gt;WRITE FMT1 V1,V2 MAC:&gt;FMT1: FORMAT 'V1 = ',H6,', V2 =
',H6,* MAC:&gt;WRITE FMT2 V1,V2 MAC:&gt;FMT2: FORMAT 'V1 = ',H,', V2
= ',H,* MAC:&gt;@EOF *:&gt;DEMO01 V1 = 00000F, V2 = 01869F V1 = F, V2
= 1869F</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]O[w] | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.9 [<n>]O[w]</H5>

<P>Index O Format Item This format item inserts "n" words from the
WRITE list (if no &lt;n&gt; is specified a default of &lt;1&gt; is
assumed) into the write buffer as a series of octal (FIELDATA)
numbers each right-justified in a field of size "w". If "w" is 12 or
less, leading zeros will be inserted (if required). If "w" is greater
than 12, "w"-12 spaces will be inserted before the number and the
number will be edited into a 12-digit format. If any number is too
large for a field of "w" characters, the field will be overflowed on
the right. If no "w" is specified the number will be edited into a
variable-length field.</P>

<P>The following inserts the number 1 into a five-character field and
-1 into a four-character field:</P>

<P>WRITE OCTFMT 1,-1 DECFMT: FORMAT O5,O4</P>

<P>The following illustrates how the variable-length field may be
used to improve readability:</P>

<P>*:&gt;MACRO DEMO01 MAC:&gt;LET V1=15 MAC:&gt;LET V2=63
MAC:&gt;WRITE FMT1 V1,V2 MAC:&gt;FMT1: FORMAT 'V1 = ',O6,', V2 =
',O6,* MAC:&gt;WRITE FMT2 V1,V2 MAC:&gt;FMT2: FORMAT 'V1 = ',O,', V2
= ',O,* MAC:&gt;@EOF *:&gt;DEMO01 V1 = 000017, V2 = 000077 V1 = 015,
V2 = 077</P>

<P>Note how, even with the variable field size a leading zero is
inserted to signify that the values are octal.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | WRITE = | R | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.10 R</H5>

<P>This format code erases the buffer to FIELDATA spaces and resets
the column pointer but DOES NOT print the buffer contents.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]WA | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.11 [<n>]WA</H5>

<P>Index WA Format Item Edits &lt;n&gt; words (default=&lt;1&gt;)
from the WRITE list into the WRITE BUFFER. The words are assumed to
contain ASCII characters - and they will be converted to FIELDATA and
those bytes that were not ASCII space (040) or ASCII nul (000) will
be inserted into the buffer.</P>

<P>One excellent use of this format item is the insertion of Record
and Set names in a variable length form. Observe the following macro
which prints the name of the current record along with its record
code:</P>

<P>*:&gt;MACRO DEMO02 MAC:&gt;WRITE RCNAME
&lt;RRT:010,7+RRT[1]:S3&gt;,RRT[0]:H2 MAC:&gt;RCNAME: FORMAT 'THE
CURRENT RECORD IS "',&lt;RRT[1]:S3&gt;WA,'" (CODE ',D,')',*
MAC:&gt;@EOF *:&gt;DEMO02 THE CURRENT RECORD IS "DEMO-REC-0001" (CODE
14) *:&gt;RECORD 17 *:&gt;DEMO02 THE CURRENT RECORD IS "NU-REC" (CODE
17)</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]WF | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.12 [<n>]WF</H5>

<P>Index WF Format Item Edits &lt;n&gt; words (default=&lt;1&gt;)
from the WRITE list into the WRITE BUFFER. The words are assumed to
contain FIELDATA characters. Those bytes that were not FIELDATA space
(05) or FIELDATA @ (00) will be inserted into the buffer - " " and
"@" will be ignored.</P>

<P>Like WA, an excellent use of this format item is the insertion of
strings in a variable length form. Observe the following macro which
prints the name of the current area along with its area code:</P>

<P>*:&gt;MACRO DEMO3 MAC:&gt;WRITE ANAME &lt;ART:4,5&gt;,ART[0]:H2
MAC:&gt;ANAME: FORMAT 'THE CURRENT AREA IS "',&lt;2&gt;WF,'" (CODE
',D,')',* MAC:&gt;@EOF *:&gt;DEMO3 THE CURRENT AREA IS "UTP-PROBLEMS"
(CODE 593) *:&gt;AREA 594 AREA FILE: TIP/DMS FILE: 594 *:&gt;DEMO3
THE CURRENT AREA IS "UTP-TROUBLES" (CODE 594)</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT and | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | WRITE = | Xn | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.13 Xn</H5>

<P>This item skips the column pointer forward or backward the number
of columns specified by "n". If "n" is positive the pointer moves
forward. If "n" is negative, the pointer moves backward.</P>

<P>The following prints out 'HELLO' (the hard way):</P>

<P>*:&gt;MACRO DEMO04 MAC:&gt;WRITE =
C5,'O',X-2,'L',X-2,'L',X-2,'E',X-2,'H',* MAC:&gt;@EOF *:&gt;DEMO04
HELLO</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | FORMAT only | WRITE/FORMAT Items | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | [<n>]Zw | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H5>9.2.4.1.14 [<n>]Zw</H5>

<P>This format item operates like "D" except that the field is
zero-filled. No variable-length fields are possible with this since
"w" is required.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | TERMINAL and | TREAD | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | PRINTER | | </B></CENTER></P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<H3>9.2.5 TREAD</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( 'character-string' ) ( subset ) TREAD[,C] - subset -,- scalar -
----- ( * ) ( array-element )</P>

<P>This statement allows an input message to be read from the
terminal (demand mode), card-reader (batch mode) or operators console
(either mode - by specifying C option).</P>

<P>The first field specifies an output message to be printed first.
In demand mode the message will be printed in Type-and-Read format
(i.e. the message is printed and the cursor/SOE remain on the same
line as the message).</P>

<P>The output message may be specified either as a character string,
as a subset, or as the asterisk character. If no output message is
wanted, use an output message of quote-quote (''). Use of the
asterisk in field one will cause the output message to come from the
standard write-buffer. This allows the output text to be created
dynamically.</P>

<P>The second field indicates what is to be done with the input
message. If a subset is specified, the message is saved as a FIELDATA
character string (left-justified, space-filled) in the subset. In
addition, the system variable NWORDS will be set to the number of
words read. If the user just depressed XMIT, with no text, NWORDS
will be equal to zero.</P>

<P>If a scalar or array element are used for the receiving field, the
input text will be treated as an expression and will be evaluated.
The 36-bit result will be stored in the scalar/array elelement. When
using scalars for receiving fields, they will be dynamically created
if necessary.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | Introduction | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*//</P>

<H2>9.3. DISC/TAPE I/O</H2>

<H3>9.3.1 Introduction</H3>

<P>The statements in the following sections are intended for use with
user files rather than database areas. User files are supported in
for basic forms: SDF DISC FILES, SECTOR-ADDRESSABLE DISC FILES,
NON-DMS TIP files and BLOCK-ORIENTED TAPE FILES.</P>

<H4>9.3.1.1 SDF Disc Files</H4>

<P>DBE may access SDF sequential data files or SDF program file
source elements as 'user files'. Such files may be available for
input or output operations, but both are not allowed simultaneously
for the same file. DBE will not distinguish between data files or
elements - a fact that distinguishes it from most every programming
language available on the 1100 series.</P>

<P>If a symbiont print file is being used as an sdf file, data images
and print-control (prtcn$) images will be passed to the user when the
file is read - consult the description of the system variable PRTCN
for more information. When an SDF file/element id read, deleted
images will be ignored. No element cycle capabilities are supported -
the current cycle will be read and cycle zero will be written.</P>

<P>SDF files may be written in FIELDATA or in ASCII. If ASCII is to
be used, the images being written will NOT be automatically converted
to ASCII - that is the user's responsibility. Declaring a file as
"ASCII" merely sets the header SDF image to reflect ASCII - necessary
to access the file from ACOB. When reading from a file, the images
will be delivered to DBE in native mode.</P>

<P>Two DBE system variables are defined that will assist the user in
processing an SDF file opened for input. The first, CHRSET, gives the
user a code denoting the data type of the most-recently read image. A
value of zero (0) means FIELDATA while a value of one denotes ASCII.
The second variable is FITYPE, which is the standard file type code
from the SDF header record of the file. Using this, the user may
determine if a print or data file is being read, for example.</P>

<H4>9.3.1.2 Sector-Addressable Disc Files</H4>

<P>The DBE user may access an Exec or TIP/DMS file on a
sector-addressable basis. When accessing TIP/DMS files, the user need
not TPFREE them first. While sector-addressable files may be read or
written, the ability to write to them is controlled through the
'update' security privilege to avoid providing a method of altering a
database via a "back-door" that is not protected by the dbe security
system.</P>

<P>When accessing these files, anywhere from 1 to 65k words may be
read/written at a time starting at a user-supplied sector address.
The sector address is actually supplied as two values: a block number
(0-n) and a block-size (1-n). The block-size will be rounded up to
the next sector and will then be used to interpret the "block"
number. For example, specifying a block-size of 100 words would be
interpreted as a block-size of 4 sectors (112 words). So a "block" of
0 starts at sector 0 while a "block" of 1 starts at sector 4. To
avoid confusion the user should use a block-size which is a multiple
of 28 words. A block of 28 words, or 1 sector, is the default), in
which case the block-number will be the actual sector number. A
block-size of 1792 would cause the block number to be interpreted as
a track number. Other values are, of course, avaliable if you
understand their implications.</P>

<P>Regardless of the block/block-size specifications, once the
starting sector for the I/O operation has been determined, the actual
I/O word count may be anywhere from one to 65,535.</P>

<P>Files which are catalogued as WORD-ADDRESSABLE can also be
accessed using the SECTOR-ADDRESSABLE syntax with the exception that
block-size will be computed as:</P>

<P><CENTER>(block-size+27)/28</CENTER></P>

<P>giving number of WORDS to be accessed instead of SECTORS.</P>

<H4>9.3.1.3 Non-Dms Tip Files</H4>

<P>The DBE user may access Non-DMS TIP files on a full record basis.
Note that Update Capabilties are not controlled as with
Sector-Adressable Disc Files - all DBE users have NON-DMS TIP file
update access.</P>

<P>I/O to these files is performed in the same manner as FCSS TIP
I/O. Records MUST be read/written on a full record boundary. Any
number of records can be accessed within DBE and File storage limits.
</P>

<P>The record number and number of records to be accessed are
determined by the parameters on the GET and PUT statements. Note that
unlike the Sector-Adressable Disc Files which require a block-size,
Non-DMS TIP I/O does not as it obtains the record size directly from
the TIP complex.</P>

<H4>9.3.1.4 Tape Files</H4>

<P>Tape files are available on an I-O basis - that is, they may be
read and written. The user is cautioned to remember this fact when
using tapes with DBE. Tapes are processed on a block-by-block basis.
Any blocking (multiple logical records within a single block) is
totally the responsibility of the DBE macro reading/writing the tape.
One probable application of tape I/O is the manipulation of DMS/1100
audit trail tapes.</P>

<P>Two DBE functions are defined that will assist the user in
processing tape files - FILE and BLOCK. consult the chapter on
Functions for more information.</P>

<H4>9.3.1.5 Access Concepts</H4>

<P>As with COBOL, DBE user files must be opened before use (via the
OPEN statement) and closed upon completion (via the CLOSE statement).
Files may remain open between macro executions, that is, a macro need
not close a file when it terminates (nor will the file be closed
automatically by DBE when the currently executing macro terminates).
This is useful in the construction of macros that depend on a file
remaining open during a DBE session (see the DPATCH macro). When the
BYE command is performed (or if a control card is read) all files
will be automatically closed. If DBE terminates abnormally (system
error or @@X T) the user files open at the time will not be properly
closed, thus data may be lost.</P>

<P>When a file is opened, it will be assigned a user-specified FILEID
by which the file will be refered by all file I/O statements until it
is closed. No two files may be open simultaneously with the same
FILEID and the same file may not be open simultaneously with
different FILEIDs. A FILEID is a name from 1- to 6-characters long
that is legal for use as an 1100-series @USE name (for it will become
a @USE name attached to the file if it is an Exec file or tape.</P>

<P>Some additional type-independent system variables exist for use by
the DBE user. The first is IOFILE, which always contains the FIELDATA
FILEID (left-justified, space-filled) of the most-recently referenced
file. The second, NWORDS, contains the number of words last read from
any file (note however that this variable is also used by the TREAD
command to return the input word count).</P>

<P>A function exists, STATUS, whereby the status of any user file
(input, output, tape, etc.) may be retrieved. Consult the chapter on
Functions for more information.</P>

<P>A special table called IOBUF exists for use as a general-purpose
buffer into which records (or blocks) may be read or from which
records (or blocks) may be written. Thus, the user need not specify
arrays in which to build or receive records (although it is certainly
possible, if conditions warrant). The size of IOBUF is a DBE
configuration parameter.</P>

<P>A limited number of user files are allowed to be open at any time.
This limit is also a DBE configuration parameter.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC, TIP | CLOSE | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | and TAPE | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */CLOSE</P>

<H3>9.3.2 CLOSE</H3>

<P>&nbsp;</P>

<P>CLOSE[,options] [[fileid],[fileid]...] -----</P>

<P>Options (Ignored for all but TAPE files):</P>

<P>&nbsp;</P>

<P>None: Opposite of the MRF options</P>

<P>&nbsp;</P>

<P>F: @FREE each tape file being CLOSEd</P>

<P>&nbsp;</P>

<P>M: @MARK each tape file being CLOSEd. The tapes will be
repositioned between the two EOF marks.</P>

<P>&nbsp;</P>

<P>R: Rewind each tape being CLOSEd.</P>

<P>&nbsp;</P>

<P>The specified user files will be closed and therefore will be
inaccessible for further operations without being OPENed again.</P>

<P>If no fileid's are given, then all open user files are closed. DBE
terminating normally (BYE, reading a control card, etc.) will have
the same effect as a CLOSE with no fileid. User files left open by a
macro remain open until they are explicitly closed (via the CLOSE
statement) or until DBE terminates normally (an abnormal termination
such as @@X T or a contingency error may cause loss of data in the
file). If a contingency error (resulting in a dump) is taken, no
guarantee is made that any open files will be closed.</P>

<P>See the GET, OPEN and PUT statements for more information on user
files.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | GET | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */GET</P>

<H3>9.3.3 GET</H3>

<P>&nbsp;</P>

<P>GET fileid[(EOF=label,ERR=label,BLOCK=block-#,REC=rec-#, --- ---
--- ----- ---</P>

<P>SIZE=block-size,NWORDS=#-wds-to-read,NRECS=#-recs-to-read)]</P>

<P>---- ------ -----</P>

<P>( array-element )</P>

<P>[- scalar -[:fill-value]],...</P>

<P>( subset )</P>

<P>The "fileid" is a file-identification of a user file opened for
use as an SDF input file (SDFI), sector-addressable file (DISC) or
tape (TAPE).</P>

<P>The scalars, array-elements and subsets that may optionally follow
the (...) signify the areas into which records/blocks are read.</P>

<P>Absence of an item after the (...) implies a reference to the
table IOBUF. When this table is used in this manner, the data will be
read into IOBUF and, following the GET, the size of IOBUF will be
adjusted to the number of words read. Only a single record may be
read per GET using this technique. There is an upper-limit to the
size of IOBUF specified at DBE-generation time.</P>

<P>The items within () after the fileid need not supplied in the
order shown. Their presence or absence (or even legality) is shown by
the following table:</P>

<P>&nbsp;</P>

<P>------- file type ------- Clause SDFI DISC TAPE TIP Argument-type
========== ======== ========= ======== ========= ============= ERR=
optional optional optional optional label EOF= optional optional
optional illegal label BLOCK= illegal mandatory illegal illegal
expression REC= illegal illegal illegal mandatory expression SIZE=
illegal optional illegal illegal expression NWORDS= illegal optional
optional illegal expression NRECS= illegal illegal illegal optional
expression</P>

<P>The meanings of the various (...) items are covered in detail in
the next three sections.</P>

<H4>9.3.3.1 SDF Reads</H4>

<P>(array-element)</P>

<P>GET fileid(EOF=label,ERR=label) [- scalar -[fill-value]]....</P>

<P>--- *** *** (subset )</P>

<P>--- = mandatory , *** = optional</P>

<P>For each item on the GET statement after the (...), an SDF record
will be read from the user file and it's contents placed in the item
according to the following rules:</P>

<P>&nbsp;</P>

<P>1. If the item is a subset, the record will be copied into it
left-justified. If the record is too large to completely fit, it will
be truncated. If it is smaller than the receiving item, the remainder
of the array subset will be filled with the "fill-value" specified
after the item (:fill-value) or, in the event that no fill was
specified, the remainder of the subset remains unaltered.</P>

<P>&nbsp;</P>

<P>2. If the item is a scalar or is a subscripted array element, the
first word of the record will be stored in the item and the remainder
of the record will be lost.</P>

<P>&nbsp;</P>

<P>3. If the item is absent (for example, GET ID &lt;A&gt;,,&lt;B&gt;
the SDF record will be read into the table IOBUF and the size of
IOBUF will be set to the number of words read.</P>

<P>After processing each item (and, therefore, each record) the
number of words stored will be available under the system variable
NWORDS. on a GET with more than one item, only the word count for the
last item will be available.</P>

<P>At the successful completion of a GET the system variable CHRSET
will contain a flag indicating the character set of the last record
returned by the GET. In the case of a GET with multiple items, only
the character set flag for the last item will be available for
inspection - if it is important to you to know the character set of
each record read in, limit each GET to a single item. The value of
this flag will be zero (0) to denote the record was represented in
FIELDATA while a value of one (1) will denote ASCII.</P>

<P>SDF end-of-file conditions or I/O errors will cause control to
transfer to the EOF= and ERR= labels, respectively. If no such
processing points are defined, DBE errors will occur (which may be
detected through the use of the ERROR statement). with the EOF=
specification and error code 35.</P>

<H4>9.3.3.2 Sector-addressable Reads</H4>

<P>GET
fileid[(EOF=label,ERR=label,BLOCK=block-#,SIZE=block-size,NWORDS=#-wds-to-read]
--- *** *** ----- **** ******</P>

<P>( array-element )</P>

<P>[- scalar -[:fill-value]],...</P>

<P>( subset )</P>

<P>--- = mandatory , *** = optional</P>

<P>Only one receiving field may follow the (...).</P>

<P>The actual sector address where the I/O begins will be determined
using the BLOCK= and SIZE= specifications. Remember that the default
SIZE is 28 words. The NWORDS= specification will be used to indicate
the number of words to read. In the absence of an NWORDS=
specification the number of words will be the size of the receiving
field. In the case of the receiving field being IOBUF when no NWORDS=
is specified, the number of words will be the maximum size of IOBUF.
The treatment of ERR= (and the resulting behavior if it is absent)
will be similar to that of the SDF GET.</P>

<H4>9.3.3.3 Non-DMS TIP Reads</H4>

<P>GET fileid[(ERR=label,REC=block-#,NRECS=#-recs-to-read] --- ***
--- *****</P>

<P>( array-element )</P>

<P>[- scalar -[:fill-value]],...</P>

<P>( subset )</P>

<P>--- = mandatory , *** = optional</P>

<P>Only one receiving field may follow the (...).</P>

<P>NRECS, if omitted, defaults to 1.</P>

<P>&nbsp;</P>

<P>The treatment of ERR= (and the resulting behavior if it is absent)
will be similar to that of the SDF GET.</P>

<H4>9.3.3.4 Tape Reads</H4>

<P>GET fileid[(EOF=label,ERR=label,NWORDS=#-wds-to-read] --- *** ***
******</P>

<P>( array-element )</P>

<P>[- scalar -[:fill-value]],...</P>

<P>( subset )</P>

<P>--- = mandatory , *** = optional</P>

<P>The ERR= and NWORDS= clauses are used in a similar fashion as for
the sector-addressable GET. The EOF= clause may be used to detect the
special case of I/O error 1 (tape end-of-file). The user must
position to the desired tape block (via the POSITION statement prior
to issuing the GET. Multiple receiving fields can be read with this
format the POSITION command determines the location of the first
block with successive blocks following sequentially.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | MARK | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | (TAPE only) | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */MARK</P>

<H3>9.3.4 MARK</H3>

<P>&nbsp;</P>

<P>MARK [fileid][,fileid]... ----</P>

<P>Two EOF marks will be written to each tape whose fileid is present
on the statement. Following this, the tape(s) will be repositioned
between the two EOF marks with the file/block number(s) adjusted
accordingly.</P>

<P>If no fileid is specified, the most-recently referenced tape will
be used.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | OPEN | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */OPEN</P>

<H3>9.3.5 OPEN</H3>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( ( SDFI ) )</P>

<P>( - ---- - fileid = [qual*file.][elt/vers] )</P>

<P>( ( SDFO[,ASCII] ) )</P>

<P>( ---- - )</P>

<P>( ( TIP/DMS-File-Number ) ) OPEN[,opts] - DISC[,TIP] fileid = - -
- ---- ( DMS - ( qual*file. ) )</P>

<P>( ---- )</P>

<P>( )</P>

<P>( TIP ( TIP-File-Number) )</P>

<P>( --- )</P>

<P>( )</P>

<P>( TAPE fileid = ...as per @asg... )</P>

<P>----</P>

<P>&nbsp;</P>

<P>OPEN DBEFDT ---- ------</P>

<P>Options: For OPEN TAPE, options "AFJT" will be used in the tape
@ASG image.</P>

<P>For OPEN SDFO, the "M" option will cause the created element to
have an element subtype of "MAC" instaed of the default "SYM".</P>

<P>&nbsp;</P>

<P>The word DISK may be substituted for DISC.</P>

<P>&nbsp;</P>

<P>The word DMS may be substituted for DISC,TIP.</P>

<P>The specialized format 'OPEN DBEFDT' causes DBE to use a DBE
SYSGEN specified file name which allows update capabilities without
the security update privilege set for a user. The open statement is
internally changed to an 'OPEN DISC' statement and processed normally
after that.</P>

<P>Note that when an Exec file is being referred to as an SDFI, SDFO
or DISC file that it is expected to exist. If it does not, DBE will
create a temporary file by that name.</P>

<P>Note that a file referred to as DISC,TIP / DMS or TIP is expected
to exist. If it does not, an error will be returned.</P>

<H4>9.3.5.1 SDF Files</H4>

<P>&nbsp;</P>

<P>OPEN SDFI fileid = [qual*file.][elt/vers]</P>

<P>---- ----</P>

<P>&nbsp;</P>

<P>OPEN SDFO fileid = [qual*file.][elt/vers]</P>

<P>---- ----</P>

<P>The exec file name is specified in standard q*f/rkey/wkey.
notation with or without an elt/version. If an element is supplied,
the file will be a symbolic program file element. If no element name
is supplied, the file will be an SDF data file or symbiont file. In
addition, he file specification may be supplied as an explicit name
coded on the OPEN, for example:</P>

<P>&nbsp;</P>

<P>OPEN SDFI MYFILE=EXEC-8*GARY/RDKEY/WRKEY.</P>

<P>or may be supplied as an array subset, for example:</P>

<P>&nbsp;</P>

<P>OPEN SDFI MYFILE=&lt;ARRAY&gt;</P>

<P>or may be mixed freely between the two, for example:</P>

<P>&nbsp;</P>

<P>OPEN SDFI MYFILE=QUAL*FILE.&lt;ELEMENT&gt;/&lt;VERSION&gt;</P>

<P>If the ASCII option (which may be abbreviated as simply "A") is
provided when the open mode is SDFO, the character-set type of the
file will be set to ASCII. The default if no ASCII option is provided
will be FIELDATA.</P>

<P>The "fileid" is a one- to six-character name comprised from the
characters 'A'-'Z', '0'-'9', '$' and '-' which will be used as the
file identification within DBE as well as for a @use name on the
file.</P>

<P>The specified SDF data file or program file symbolic element will
be made available to the user for input (SDFI) or output (SDFO)
purposes under the specified fileid.</P>

<P>These files will be available for use by the GET and PUT
statements until the file is CLOSEd (explicitly or implicitly). A
macro may continue writing to a file left open by a previous macro
simply by PUTting to it with no OPEN.</P>

<P>A file may not simultaneously be open both for SDFI and SDFO.</P>

<P>The file will be read/written in standard data format (SDF). this
means that the text editor (@ED) or programs written in ASCII COBOL
(ACOB) or ASCII FORTRAN (FTN) may be used to process them.</P>

<H4>9.3.5.2 Sector-addressable Files</H4>

<P>&nbsp;</P>

<P>OPEN DISC fileid = qual*file.</P>

<P>---- ----</P>

<P>&nbsp;</P>

<P>OPEN DISC,TIP fileid = TIP/DMS-File-Number</P>

<P>---- ---- -</P>

<P>&nbsp;</P>

<P>OPEN DMS fileid = TIP/DMS-File-Number</P>

<P>---- ---</P>

<P>The meaning of "fileid" is the same as for SDF files.</P>

<P>Most rules for the filename specification are the same as for SDF
files except the ability to include element/version names. A DBE
sector-addressable file cannot be opened as a program-file element
(although the program-file itself could be). An additional format for
the file specification available to sector-addressable files is an
arithmetic expression, evaluating to a TIP/DMS file number. This
format (legal only when the TIP option is specified after the mode of
DISC on the OPEN or a mode of DMS is specified ) specifies that the
file is a TIP/DMS file rather than an Exec file and that the file
specification must be a TIP/DMS file number. The TIP/DMS file must be
assigned to TIP in order to be accessed in this manner (or an I/O 21
error will result when the file is referenced on a GET or a PUT).
</P>

<P>The word TIP may be abbreviated to simply "T".</P>

<H4>9.3.5.3 Non-DMS TIP Files</H4>

<P>&nbsp;</P>

<P>OPEN TIP fileid = TIP-File-NUmber</P>

<P>---- ---</P>

<P>The TIP-File-Number is an arithmetic expression evaluating to a
TIP file number. The TIP file must be assigned to TIP in order to be
accessed in this manner (or an I/O 21 error will result when the file
is referenced on a GET or a PUT).</P>

<H4>9.3.5.4 Tape Files</H4>

<P>The meaning of "fileid" is the same as for SDF and
Sector-Addressable files.</P>

<P>The specifications after the "fileid=" are exactly as per
spec1-specn on an @asg of a tape file. The options on the OPEN may be
the AFJT options which have the same meaning as for a tape @ASG
(these options, in fact, will be used on the dynamic @ASG DBE uses to
get the tape). All options are indeed optional. If no device
specification is given for the tape (U9V, U9S, etc), a specification
of "T" will be used.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | PUT | </B></CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */PUT</P>

<H3>9.3.6 PUT</H3>

<P>&nbsp;</P>

<P>PUT fileid[(ERR=label,BLOCK=block-#,REC=rec-#,SIZE=block-size, ---
NWORDS=rec-size,NRECS=#-of-recs)]</P>

<P>&nbsp;</P>

<P>( subset ) ( subset )</P>

<P>( 'character-string' ) ( 'character-string' )</P>

<P>[ - - [, - - ]...]</P>

<P>( expression ) ( expression )</P>

<P>( * ) ( * )</P>

<P>The meanings, uses and allowable file modes for the various
clauses within the (...) are the same as for the GET command. Note
that the EOF= clause is not legal on a PUT.</P>

<P>The "fileid" is the file identification of a user file that is
currently opened for SDFO, TIP, TAPE or DISC.</P>

<P>The * in the format indicates that the current write buffer
contents are to be written (the buffer will not be cleared following
the PUT) to the given file. By using this technique formatted file
output may be prepared via the WRITE/FORMAT facilities.</P>

<P>Each item specified in the PUT list will be written to the
specified file as an SDF record (SDFO), tape block (TAPE) disc block
(DISC) or tip record (TIP).</P>

<P>The size of an SDF record cannot exceed 2047 words. The size of a
tape or disc block cannot exceed 65,535 words.</P>

<P>Note that the items are written out in exact binary (the fastest
possible method of writing them). Thus, if the following sequence of
code occurs:</P>

<P>&nbsp;</P>

<P>OPEN SDFO FILE=TEMP-FILE.ELT</P>

<P>LET A=7</P>

<P>PUT FILE A</P>

<P>there will be six FIELDATA characters written out to TEMP-FILE.ELT
- '@@@@@B' (whose binary value is 7).</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 9 | DISC and TAPE | REWIND | </B>
</CENTER></P>

<P><CENTER><B>| I/O STATEMENTS | (TAPE only) | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */REWIND</P>

<H3>9.3.7 REWIND</H3>

<P>&nbsp;</P>

<P>REWIND [fileid] ------</P>

<P>This command may be used only on TAPE files.</P>

<P>The tape specfied on the &lt;fileid&gt; will be rewound. If no
&lt;fileid&gt; is specified, the last tape referenced will be
rewound. SETCTR 1,10 TOCLVL 5</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STATEMENTS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>10. HIGH-LEVEL STATEMENTS</H1>

<P>The statements in this chapter perform very high-level functions
for the DBE user. While they will operate in either MACRO or
CONVERSATIONAL mode, they are intended for use within macros.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | COUNT | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */COUNT</P>

<H2>10.1. COUNT</H2>

<P>&nbsp;</P>

<P>COUNT subset[:start,stop] -----</P>

<P>This statement will perform gross record-counts for the current
area.</P>

<P>This command has been replaced by the SCAN command, and is in fact
the same command. See the discussion on SCAN for more information.
</P>

<P>The area will be scanned (see the discussion on the "start,stop"
option), page-by-page, and all records in that area will be counted.
The results of the count will be stored in the subset. The subset
should be AT LEAST AS LARGE as the NUMBER OF RECORD TYPES in the
currently loaded schema. The first word of the subset will be used as
a counter for the number of occurrences of the first record type. The
second word of the subset will be used as a counter for the number of
occurrences of the second record type, and so forth.</P>

<P>No attempt will be made by DBE to verify that a record type
encountered is actually allowed to be stored in that area. However,
the following checks for physical integrity will be made:</P>

<P>&nbsp;</P>

<P>1. Is the area uninitialized?</P>

<P>&nbsp;</P>

<P>2. Does the area code on the Page Header match that of the ART?
</P>

<P>&nbsp;</P>

<P>3. Does the Page Number on the Page Header match that which was
expected?</P>

<P>&nbsp;</P>

<P>4. Does the Vacant Entry Word contain the correct value?</P>

<P>&nbsp;</P>

<P>5. Does the Vacant Space Count in the Page Header contain the
correct value?</P>

<P>&nbsp;</P>

<P>6. Is the Record Header Word for each record on the page
consistent with the Record Slot word that points to it?</P>

<P>The subset will be cleared to zeros before the counts are
generated.</P>

<P>The optional "start" and "stop" expressions allow the area scan to
be restricted to that range of pages (start through stop, inclusive).
Absence of these expressions will cause the entire area to be
scanned.</P>

<P>The COUNT statement may not be used on an INDEX area.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | HISTOGRAM | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */HISTOGRAM</P>

<H2>10.2. HISTOGRAM</H2>

<P>&nbsp;</P>

<P>HISTOGRAM data-subset USING scale-subset --------- -----</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>C Provide Cumulative percentage total as well as individual
percentage.</P>

<P>The data-subset contains the data points to be histogramed while
scale-subset contains the labels for the vertical axis. Both must
have the same number of elements.</P>

<P>The contents of "data-subset" will be the data to be plotted. The
histogramming will be done as follows:</P>

<P>&nbsp;</P>

<P>1. First, the maximum number of data points will be computed. If
"data-subset" has the values 201, 150, 17 and 100 then the maximum
number of data points will be 201.</P>

<P>&nbsp;</P>

<P>2. Using the maximum value, a scaling factor will be computed. A
total of 50 '*' characters will be displayed per line when in DEMAND
mode (100 in BATCH mode - it may therefore be necessary to have a
single '*' denote more than one data point. For the example above,
the scaling factor would be (201+49)/50 or 5. This means that one '*'
on the histogram will denote 5 data points.</P>

<P>&nbsp;</P>

<P>3. For each element of "data-subset", there will be i/scale '*'
characters displayed where 'i' is the largest element of the subset
and 'scale' is the scaling factor. thus for the example given above,
the histogram would look like this:</P>

<P>&nbsp;</P>

<P>****************************************</P>

<P>******************************</P>

<P>***</P>

<P>********************</P>

<P>&nbsp;</P>

<P>4. Since this is only an approximate visual representation of the
data, the user must be given a more accurate idea of what the data
really is. The actual data count and percentage of the total data
count will be printed for each line. For the current example
(201+150+17+100=468 total data points) the result would be:</P>

<P>&nbsp;</P>

<P>**************************************** 201 43%</P>

<P>****************************** 150 32%</P>

<P>*** 17 4%</P>

<P>******************** 100 21%</P>

<P>&nbsp;</P>

<P>5. there will be axis and an annotated scale produced so that the
histogram looks like this:</P>

<P>&nbsp;</P>

<P>i---------i---------i---------i---------i---------i</P>

<P>i**************************************** 201 43%</P>

<P>i****************************** 150 32%</P>

<P>i*** 17 4%</P>

<P>i******************** 100 21%</P>

<P>i---------i---------i---------i---------i---------i</P>

<P>0 50 100 150 200 250</P>

<P>remain 15</P>

<P>6. Finally, the contents of "scale-subset" will be used as the
annotations for the vertical axis. Thus, if for this example
"scale-subset" had the value 'RNG1 RNG2 RNG3 RNG4 ' then the final
version of the histogram (the version actually printed) would be:
</P>

<P>remain 10</P>

<P>i---------i---------i---------i---------i---------i</P>

<P>RNG1 i**************************************** 201 43%</P>

<P>RNG2 i****************************** 150 32%</P>

<P>RNG3 i*** 17 4%</P>

<P>RNG4 i******************** 100 21%</P>

<P>i---------i---------i---------i---------i---------i</P>

<P>0 50 100 150 200 250</P>

<P>Any other information that should be printed out (titles,
comments, etc.) must be done via the WRITE command and can appear
above or below, but not alongside of the histogram.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | PFSSCH | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */PFSSCH</P>

<H2>10.3. PFSSCH</H2>

<P>&nbsp;</P>

<P>PFSSCH[,W] subset ----------</P>

<P>This statement performs a Program File Search and returns the
Element Table Entry for the current schema. The subset passed must be
at least 10 words in length.</P>

<P>If the "W" option is specified, the contents of the subset will
replace the Element Table entry information for the current schema.
No validation will take place on the data passed in the subset. pace
Note that the user must have UPDATE or SCHEMA REWRITE privileges to
use the "W" option to rewrite the entry.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | PFSSUB | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */PFSSUB</P>

<H2>10.4. PFSSUB</H2>

<P>&nbsp;</P>

<P>PFSSUB[,W] subset ----------</P>

<P>This statement performs a Program File Search and returns the
Element Table Entry for the current subschema. The subset passed must
be at least 10 words in length.</P>

<P>If the "W" option is specified, the contents of the subset will
replace the Element Table entry information for the current
subschema. No validation will take place on the data passed in the
subset.</P>

<P>Note that the user must have UPDATE or SCHEMA REWRITE privileges
to use the "W" option to rewrite the entry.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | RSCAN | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */RSCAN</P>

<H2>10.5. RSCAN</H2>

<P>&nbsp;</P>

<P>RSCAN[&lt;,options&gt;] subset [subset,subset] -----</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>V Validate Checksum for each page processed</P>

<P>This statement will perform gross record-counts and obtain
page-usage information for the current RDMS area.</P>

<P>The area will be scanned (see the discussion on the "start,stop"
option), page-by-page, and all records in that area will be counted.
The results of the count will be stored in the second subset which is
OPTIONAL. The subset must be AT LEAST 128 words. The first word of
the subset will be used as a counter for the number of occurrences of
the first record type. The second word of the subset will be used as
a counter for the number of occurrences of the second record type,
and so forth.</P>

<P>Min/Max record sizes are also obtained and stored in the
record-count subset word + 64. If the second subset is at least 256
words in size, Index record counts will be provided in the same
format as data records offset by 128 words. Min/Max Index record
sizes will be provided in a similar manner.</P>

<P>If subset 3 is present, it will be filled with page-usage
information as follows:</P>

<P>&nbsp;</P>

<P>word 1 = # of data pages with 0-9% available space</P>

<P>word 2 = # of data pages with 10-19% available space</P>

<P>.</P>

<P>.</P>

<P>word 12 = # of unallocated pages</P>

<P>&nbsp;</P>

<P>word 13 = # of index pages with 0-9% available space</P>

<P>word 14 = # of index pages with 10-19% available space</P>

<P>.</P>

<P>.</P>

<P>This subset, if supplied, must be at least 24 words long.</P>

<P>No attempt will be made by DBE to verify that a record type
encountered is actually allowed to be stored in that area. However,
the following checks for physical integrity will be made:</P>

<P>&nbsp;</P>

<P>1. Is the area uninitialized?</P>

<P>&nbsp;</P>

<P>2. Does the Vacant Space Count in the Page Header contain the
correct value?</P>

<P>&nbsp;</P>

<P>3. Is the Record Header Word for each record on the page
consistent with the Record Slot word that points to it?</P>

<P>If the RSCAN function determines that an error condition exists,
the System Variable ERRSTS (word 0) will be set as follows:</P>

<P>&nbsp;</P>

<P>Bit 0 = Page Header Format Error</P>

<P>Bit 1 = Vacant Space Error</P>

<P>Bit 2 = Active Slot Points To Deleted Record</P>

<P>Bit 3 = Bad Checksum</P>

<P>Note that these 4 bits will be initially zeroed each time the
RSCAN function is executed.</P>

<P>In addition to setting the error bits, the word in question will
be displayed along with the page offset in octal.</P>

<P>Subsets 2 and 3, if supplied, will be cleared to zeros before the
counts are generated.</P>

<P>Subset 1 is used to control which pages are to be scanned. It is
always required but may contain zeros indicating that the entire area
is to be scanned.</P>

<P>The optional "start" and "stop" expressions (passed as words 1
&amp; 2 of subset 1) allow the area scan to be restricted to that
range of pages (start through stop, inclusive).</P>

<P>Words 3 &amp; 4 of subset 1 will be returned with the actual start
and stop pages used by the RSCAN function.</P>

<P>Note that if the "start" expression is NOT supplied, the scan will
be performed via double-buffered, multi-track I/O. For this reason it
is recommended that the RSCAN function be used whenever possible to
gather gross RDMS area statistics.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | SCAN | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */SCAN</P>

<H2>10.6. SCAN</H2>

<P>&nbsp;</P>

<P>SCAN[&lt;,options&gt;] subset-1[:start,stop]
[subset-2,subset-3,subset-4] ----</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>I Ignore errors encounterd.</P>

<P>L Populate subset-4 with half word entries instead of full word
entries.</P>

<P>Q Return subset-4 as half word entries containing page
number/number of overflow pages attached. This option significantly
reduces the CPU utilization of the SCAN-ONE macro by performing the
CPU page chaining calculations as part of the function call instead
of in the macro.</P>

<P>V Validate page checksums for each database page scanned.</P>

<P>This statement will perform gross record-counts and obtain
page-usage and overflow chaining information for the current area.
</P>

<P>The area will be scanned (see the discussion on the "start,stop"
option), page-by-page, and all records in that area will be counted.
The results of the count will be stored in the first subset which is
REQUIRED. The subset must be AT LEAST AS LARGE as the NUMBER OF
RECORD TYPES in the currently loaded schema. The first word of the
subset will be used as a counter for the number of occurrences of the
first record type. The second word of the subset will be used as a
counter for the number of occurrences of the second record type, and
so forth.</P>

<P>If subset-2 is present, it will be filled with page-usage
information as follows:</P>

<P>&nbsp;</P>

<P>word 1 = # of prime pages with 0-9% available space</P>

<P>word 2 = # of prime pages with 10-19% available space</P>

<P>.</P>

<P>.</P>

<P>word 11 = # of prime pages with 100% available space</P>

<P>&nbsp;</P>

<P>word 13 = # of overflow pages with 0-9% available space</P>

<P>word 14 = # of overflow pages with 10-19% available space</P>

<P>.</P>

<P>.</P>

<P>word 23 = # of overflow pages with 100% available space</P>

<P>word 24 = # of unallocated overflow pages</P>

<P>This subset, if supplied, must be at least 24 words long.</P>

<P>If subset-3 is present, it will contain the number of pages that
have attached overflow using the same ranges as subset 2.</P>

<P>This subset, if supplied, must be at least 24 words long.</P>

<P>If subset-4 is present, it will contain overflow chaining
information. Each word of the subset represents the prime page to
which an overflow is attached. The first word of the subset will
contain the prime page for the first allocated overflow page, the
second word is the prime for the second overflow page, etc.</P>

<P>This subset, if supplied, must be dimensioned to at least the
number of allocated overflow pages in the area.</P>

<P>If the 'L' option is specified on the SCAN function call, subset-4
will be filled with half-word entries instead of full words. This
allows the subset to be sized as only half the number of allocated
overflow pages, allowing very large areas to be scanned.</P>

<P>if the 'Q" option is specified on the SCAN function call, subset-4
will contain 1 words entries in the format of H1=prime page number,
h2=number of attached overflow chains.</P>

<P>Note that this subset only has meaning for DARP areas.</P>

<P>No attempt will be made by DBE to verify that a record type
encountered is actually allowed to be stored in that area. However,
the following checks for physical integrity will be made:</P>

<P>&nbsp;</P>

<P>1. Is the area uninitialized?</P>

<P>&nbsp;</P>

<P>2. Does the area code on the Page Header match that of the ART?
</P>

<P>&nbsp;</P>

<P>3. Does the Page Number on the Page Header match that which was
expected?</P>

<P>&nbsp;</P>

<P>4. Does the Vacant Entry Word contain the correct value?</P>

<P>&nbsp;</P>

<P>5. Does the Vacant Space Count in the Page Header contain the
correct value?</P>

<P>&nbsp;</P>

<P>6. Is the Record Header Word for each record on the page
consistent with the Record Slot word that points to it?</P>

<P>&nbsp;</P>

<P>7. Is the Manual Flag Control Word valid?</P>

<P>&nbsp;</P>

<P>8. For each Set Pointer:</P>

<P>A. Is the Area Code valid?</P>

<P>B. Is the Page number a valid page within the area?</P>

<P>C. Is the record number non-zero?</P>

<P>If the SCAN function determines that an error condition exists,
the System Variable ERRSTS (word 0) will be set as follows:</P>

<P>&nbsp;</P>

<P>Bit 0 = Page Header Format Error</P>

<P>Bit 1 = Vacant Space Error</P>

<P>Bit 2 = Active Slot Points To Deleted Record</P>

<P>Bit 3 = Bad Page Checksum</P>

<P>Bit 4 = Bad Record Slot/Header</P>

<P>Bit 5 = Record Bit-out Detected (Record#=0)</P>

<P>Bit 6 = Bad Set Pointer</P>

<P>Note that these 7 bits will be initially zeroed each time the SCAN
function is executed.</P>

<P>The area being scanned is displayed when the first error is
encountered and after the scan is completed if an error was
encountered.</P>

<P>All errors encountered will be displayed unless the 'I' option is
used on the SCAN function call. If the 'I' option is specified, the
area name will still be displayed at the first error/after scanning.
</P>

<P>All supplied subsets will be cleared to zeros before the counts
are generated.</P>

<P>The optional "start" and "stop" expressions allow the area scan to
be restricted to that range of pages (start through stop, inclusive).
Absence of these expressions will cause the entire area to be
scanned.</P>

<P>Note that if the "start" and "stop" expressions are NOT supplied,
the SCAN will be performed via double-buffered, multi-track I/O. For
this reason it is recommended that the SCAN function be used whenever
possible to gather gross area statistics.</P>

<P>The SCAN statement may not be used on an INDEX area.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 10 | MACRO/ | SORT | </B></CENTER></P>

<P><CENTER><B>| HIGH-LEVEL STMNTS | CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */SORT</P>

<H2>10.7. SORT</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( UP ) SORT subset[:j-designator] - -- - ---- ( DOWN )</P>

<P>----</P>

<P>This statement will re-order the words of a subset into Ascending
or Descending order, depending on the specification of UP or DOWN
(UP=Ascending while DOWN=Descending).</P>

<P>The entire 36-bit contents of each word will be used to determine
that words order in the final sequence. Each word is treated as a
36-bit SIGNED quantity (leading 1-bits are treated as negative
values).</P>

<P>The optional :j-designator specification will use a partial-word
as the key for the sort.</P>

<P>Here are some examples:</P>

<P>*:&gt;DIM A(3) *:&gt;LET A(1)='AAAAAA' *:&gt;LET A(2)='BBBBBB'
*:&gt;P! A A(1) 060606060606 070707070707 000000000000 EOF: 3
A(1):&gt;SORT &lt;A&gt; UP A(1):&gt;P! A A(1) 000000000000
060606060606 070707070707 EOF: 3 A(1):&gt;LET A(1)='AAAAAA'
A(1):&gt;LET A(2)='111111' A(1):&gt;LET A(3)=0 A(1):&gt;P! A(1)
060606060606 616161616161 000000000000 EOF: 3 A(1):&gt;SORT &lt;A&gt;
UP A(1):&gt;P! A(1) 616161616161 000000000000 060606060606</P>

<P>Consult the next chapter for information on more complex sorting
techniques and for use with high-volume sorts. SETCTR 1,11 TOCLVL 5
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>11. SORT/MERGE INTERFACE</H1>

<P>This chapter describes the DBE interface to the 1100-series
SORT/MERGE package - only SORT modules are accessible.</P>

<P>Familiarity with the SORT/MERGE package as described in the
"SORT/MERGE Programmer Reference - UP-7621 (Current Version)" will be
assumed.</P>

<P>The concept of sorting within DBE is similar to using the COBOL
SORT statement with INPUT and OUTPUT procedures. The following
Nassi-Schneiderman chart illustrates the general logic used to sort
via DBE:</P>

<P>&nbsp;</P>

<P>:-------------------------------------------------:</P>

<P>| Define a SORT packet via R$FILE |</P>

<P>:-------------------------------------------------|</P>

<P>| Open the sort via R$OPN |</P>

<P>:-------------------------------------------------:</P>

<P>| While there are records to be released to SORT |</P>

<P>| :--------------------------------------------:</P>

<P>| | Release a record (subset) via R$REL |</P>

<P>:----:--------------------------------------------:</P>

<P>| Perform the actual sort via R$SORT |</P>

<P>:----:--------------------------------------------:</P>

<P>| | Retrieve a sorted record via R$RET |</P>

<P>| :--------------------------------------------:</P>

<P>| Until no-more-sorted-recs (EOF=label on R$RET) |</P>

<P>:-------------------------------------------------:</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO/ | R$FILE | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$FILE</P>

<H2>11.1. R$FILE</H2>

<P>&nbsp;</P>

<P>R$FILE[,opts]
packet,CORE=array-name,RSZ=record-size,key-spec[,key-spec]... ------
---- ---</P>

<P>where key-spec is: KEY=start/size/type/order</P>

<P>---</P>

<P>&nbsp;</P>

<P>options are: none: opposite of CL</P>

<P>&nbsp;</P>

<P>C: Do NOT suppress CONSOLE SORT messages</P>

<P>&nbsp;</P>

<P>L: Do NOT suppress run log SORT messages</P>

<P>&nbsp;</P>

<P>This is actually a macro, not a DBE statement. Its purpose is to
build a SORT/MERGE control packet for use by the R$OPN statement.
</P>

<P>The first parameter is a subset in which the SORT/MERGE control
packet will be built. The size of this packet never need exceed 23
words, but it may be optimally sized as follows:</P>

<P>&nbsp;</P>

<P>size = 13 + 1 (if C-option absent) + 1 (if L-option absent)</P>

<P>+ 2 * number of KEY specifications</P>

<P>Thus, if the C and L options were both absent and there was one
KEY specification, the packet subset must be 13 + 1 + 1 + 2*1 = 17
words long.</P>

<P>The remaining parameters may be in any order. There must be a
single RSZ and CORE parameter and from one to four KEY parameters.
</P>

<P>The CORE parameter specifies an array to be used as a SORT/MERGE
scratch memory area. This is the CORE specification described in the
SORT/MERGE documentation. The size of this array must be AT LEAST
1152 words, but should be calculated according to the sort
requirements (as documented in the SORT/MERGE PRM). The array name
should NOT be specified as a subset - use just its name.</P>

<P>The RSZ specification indicated the size of the record, in
characters. The type of characters (ASCII/FIELDATA) will be
determined by the specification of the first KEY field. The RSZ
specification should be given as an integer value (octal or decimal),
not as an expression.</P>

<P>Each KEY specification describes a key of the sort. The
significance of the key is determined by its order of appearance on
the R$FILE call - the first is the most significant, etc. There may
be no more than 4 KEY specifications supplied. The KEY specification
is supplied as follows:</P>

<P>remain 26</P>

<P>KEY=start/size/type/order</P>

<P>| | | |</P>

<P>Record byte position of first character -----: | | |</P>

<P>of the key (bytes are numbered 1-n) | | |</P>

<P>| | |</P>

<P>Size of the key item, in bytes -------------------: | |</P>

<P>| |</P>

<P>A single FIELDATA character indicating the field -------: |</P>

<P>type as follows: |</P>

<P>|</P>

<P>B Signed binary |</P>

<P>U Un-signed binary |</P>

<P>M IBM Fixed-point binary |</P>

<P>A FIELDATA Alphanumeric S same, but ASCII |</P>

<P>D FIELDATA leading signed decimal R same, but ASCII |</P>

<P>G FIELDATA trailing signed decimal T same, but ASCII |</P>

<P>L FIELDATA leading overpunched decimal V same, but ASCII |</P>

<P>P FIELDATA trailing overpunched decimal Q same, but ASCII |</P>

<P>|</P>

<P>Single FIELDATA character indicating KEY order --------------:
</P>

<P>&nbsp;</P>

<P>A Ascending order</P>

<P>D Descending order</P>

<P>For "type" indicators of "B", "U" and "M" a byte-size of 6 will be
assumed so that the RSZ parameter may be converted to words.</P>

<P>The packet will be defined so that a disc sort may be performed
using the files XA, XB and XC. While the entries for these files are
defined in the packet, it is the user's responsibility to @ASG them
in order for the mass-storage sort to be done.</P>

<P>Note that during the actual sort, no P-option parameter cards may
be specified - that module is excluded from the DBE collection.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO/ | R$OPN | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$OPN</P>

<H2>11.2. R$OPN</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>R$OPN packet</P>

<P>-----</P>

<P>Once a packet has been built using R$FILE, it must be supplied to
the R$OPN statement to open the SORT. The packet is supplied as a
subset.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO/ | R$REL | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$REL</P>

<H2>11.3. R$REL</H2>

<P>&nbsp;</P>

<P>R$REL subset -----</P>

<P>&nbsp;</P>

<P>Each record to be sorted must be released to the SORT/MERGE
package via the R$REL statement. The record is supplied as a subset.
A record size was specified by the R$FILE macro - this record size
MUST correspond to the size of all subsets released.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO/ | R$SORT | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$SORT</P>

<H2>11.4. R$SORT</H2>

<P>&nbsp;</P>

<P>R$SORT ------</P>

<P>This statement is executed after the last record (subset) has been
released to the SORT/MERGE package (via R$REL). This is what signals
the actual beginning of the sort operation itself.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO Mode | R$RET | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| | | </B></CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$RET</P>

<H2>11.5. R$RET</H2>

<P>&nbsp;</P>

<P>R$RET subset (EOF=label) -----</P>

<P>This statement retrieves a sorted record from the sort once the
sort has been completed. If there are no more records to retrieve,
control will transfer to the DBE statement with the supplied "label".
</P>

<P>The subset must be the size of the records that were sorted.</P>

<P><CENTER><B>:---------------------:----------------:-------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 11 | MACRO/ | R$QEND | </B></CENTER></P>

<P><CENTER><B>| SORT/MERGE INTERFACE| CONVERSATIONAL | | </B>
</CENTER></P>

<P><CENTER><B>|---------------------:----------------:-------------------------:
</B></CENTER></P>

<P>*// */R$QEND</P>

<H2>11.6. R$QEND</H2>

<P>&nbsp;</P>

<P>R$QEND ------</P>

<P>This statement is used to prematurely terminate the output phase
of a sort prior to retrieving the last sorted record (via R$RET).
After executing a R$QEND, another R$OPN may be performed. SETCTR 1,12
TOCLVL 5</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>12. UTILITY MACROS</H1>

<P>This chapter describes the various system macros that have been
constructed SPECIFICALLY to be used as "subroutines" or "functions"
by other macros.</P>

<P>While any of these macros may be executed in CONVERSATIONAL mode,
they are intended for use primarily in MACRO mode.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | ACCESS$CNTL | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ACCESS$CNTL</P>

<H2>12.1. ACCESS$CNTL</H2>

<P>ACCESS$CNTL base-address-within-SCRT -----------</P>

<P>The ACCESS$CNTL macro is called from the ART and SCRT macros to
produce the formatted Acess Control Entry listing.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | AREA-RECORDS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */AREA-RECORDS</P>

<H2>12.2. AREA-RECORDS</H2>

<P>LET subset = AREA-RECORDS --- ------------</P>

<P>The AREA-RECORDS macro will return an array indicating which
records can be stored in the currently based area. The array will be
filled with the record code corresponding to the relative record
number if the record (based on the within clauses) can be stored in
the area.</P>

<P>The subset specified must be dimensioned at least as big as the
number of records in the schema (SCRT[011]:H1).</P>

<P>Example:</P>

<P>If a schema has records 10,20,30,40,50 and records 10 &amp; 30 can
be stored in the current area, the array would look like:</P>

<P>&nbsp;</P>

<P>Array(1)=10</P>

<P>Array(2)=0</P>

<P>Array(3)=30</P>

<P>Array(4)=0</P>

<P>Array(5)=0</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | AREA-SETS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */AREA-SETS</P>

<H2>12.3. AREA-SETS</H2>

<P>LET subset = AREA-SETS --- ---------</P>

<P>The AREA-SETS macro will return an array indicating which sets
have owner and/or member records which can be stored in the currently
based area. The array will be filled with the set code corresponding
to the relative set number if the set (based on the within clauses)
can exist in the area.</P>

<P>The subset specified must be dimensioned at least as big as the
number of sets in the schema (SCRT[012]:H1).</P>

<P>Example:</P>

<P>If a schema has sets 10,20,30,40,50 and sets 10 &amp; 30 can exist
in the current area, the array would look like:</P>

<P>&nbsp;</P>

<P>Array(1)=10</P>

<P>Array(2)=0</P>

<P>Array(3)=30</P>

<P>Array(4)=0</P>

<P>Array(5)=0</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | AREASORT | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */AREASORT</P>

<H2>12.4. AREASORT</H2>

<P>AREASORT[,options] subset --------</P>

<P>The AREASORT macro is used to return a list of one word entries
containing Area Codes to a calling macro. If the "S" option is
supplied, the Area Codes will be returned in Area Name order rather
than the default of Area Code order.</P>

<P>The subset passed MUST be at least SCRT[010]:H1 words long (# of
areas in the currently based schema).</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | ART$PRE8R2 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ART$PRE8R2</P>

<H2>12.5. ART$PRE8R2</H2>

<P>ART$PRE8R2 ----------</P>

<P>The ART$PRE8R2 macro is called from the ART macro to produce the
formatted ART table listing for schemas with a DDL level less than
8R2.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | BREAK | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */BREAK</P>

<H2>12.6. BREAK</H2>

<P>&nbsp;</P>

<P>( 'string' ) LET subset = BREAK -
-,'delimiters',size,parse-ctl-tbl --- ----- ( subset )</P>

<P>&nbsp;</P>

<P>This macro will extract substrings from the 'string' or subset
supplied as the first parameter and returns them to the receiving
subset. The number of words returned are controlled by "size" - an
expression evaluating to the MAXIMUM number of characters to be
returned (smaller strings will be space-filled).</P>

<P>The 'delimiters' string specifies one to six characters used as
delimiters in much the same way as delimiters are used on the COBOL
UNSTRING verb.</P>

<P>The "parse-ctl-tbl" is a three-word subset serving as a Parse
Control Table with the following format:</P>

<P>&nbsp;</P>

<P>:----------------------------------------------------------: wd 0
| starting character posn in parm #1 to begin parsing from |</P>

<P>:----------------------------------------------------------: wd 1
| delimiter character (returned) |</P>

<P>:----------------------------------------------------------: wd 2
| actual number of characters transferred (returned) |</P>

<P>:----------------------------------------------------------:</P>

<P>The operation is best illustrated by an example.</P>

<P>Assume the following COBOL code:</P>

<P>&nbsp;</P>

<P>01 PARSE-CTL.</P>

<P>02 STARTING-BYTE PIC S9(10) COMP.</P>

<P>02 ACTUAL-DELIMITER PIC X.</P>

<P>02 FILLER PIC XXX.</P>

<P>02 SUBSTRING-SIZE PIC S9(10) COMP.</P>

<P>01 PARSE-CTL-TBL REDEFINES PARSE-CTL.</P>

<P>02 PCT OCCURS 3 TIMES PIC S9(10) COMP.</P>

<P>01 THE-STRING PIC X(48).</P>

<P>01 SUBSTRING PIC X(12).</P>

<P>.</P>

<P>.</P>

<P>.</P>

<P>MOVE 1 TO PCT (1).</P>

<P>UNSTRING THE-STRING</P>

<P>DELIMITED BY '.' OR ' ' OR '/'</P>

<P>INTO SUBSTRING</P>

<P>DELIMITER IN ACTUAL-DELIMITER COUNT IN PCT (3)</P>

<P>WITH POINTER PCT (1).</P>

<P>The following DBE code performs the same function:</P>

<P>&nbsp;</P>

<P>DIMENSION THE$STRING(8) @ 48-FIELDATA CHARACTERS DIMENSION
SUBSTRING(2) @ 12-FIELDATA CHARACTERS DIMENSION PCT(3) @ PARSE
CONTROL TABLE LET PCT(1)=1 @ START WITH BYTE #1 LET &lt;SUBSTRING&gt;
= BREAK &lt;THE$STRING&gt;,', /',12,&lt;PCT&gt;</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DD-CALL | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DD-CALL</P>

<H2>12.7. DD-CALL</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>LET subset = DD-CALL[,options] --- -------</P>

<P>This macro returns the DD processor file in FIELDATA for the
current UDS Application Group in the subset specified.</P>

<P>The subset should be at least 5 words long to prevent truncation.
</P>

<P>Any options specified are appended to the processor call.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DD-CALL-F | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DD-CALL-F</P>

<H2>12.8. DD-CALL-F</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>DD-CALL-F[,options] ---------</P>

<P>This macro creates a processor call to the corect DD/UREP
processor for the current UDS Application Group and writes it to an
SDF file.</P>

<P>The file created will be "DD-CALL$." with an @USE name of
"DDCALL.".</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DDL-SUB | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DDL-SUB</P>

<H2>12.9. DDL-SUB</H2>

<P>&nbsp;</P>

<P>DDL-SUB,&lt;options&gt; [entity-code] -----</P>

<P>This macro puts into the "write-buffer" the name of a
schema/subschema entity given its schema/subschema code. If no
entity-code is specified, the current of that entity-type is used.
</P>

<H4>12.9.0.1 Options</H4>

<P>A Prints the name of the current or selected area given its schema
code.</P>

<P>&nbsp;</P>

<P>D Prints the name of a Data Base Procedure given its schema code.
</P>

<P>&nbsp;</P>

<P>I Prints the name of a subschema item in the current record given
its subschema code.</P>

<P>&nbsp;</P>

<P>N Prints the name of a Data Base Data Name (DBDN) given its
subschema code.</P>

<P>&nbsp;</P>

<P>R Prints the name of the current or selected record given its
schema code.</P>

<P>&nbsp;</P>

<P>S Prints the name of the current or selected set given its schema
code.</P>

<H3>12.9.1 Results</H3>

<P>If available, the entity name will be written to the write-buffer,
and the value of the system-variable "RESULT" will be set to 1.</P>

<P>&nbsp;</P>

<P>Example: WRITE = 'THE NAME OF ITEM 123 IS '</P>

<P>DDL-SUB,I 123</P>

<P>WRITE = '.',*</P>

<P>&nbsp;</P>

<P>will print</P>

<P>&nbsp;</P>

<P>THE NAME OF ITEM 123 IS MA-PROGRAMMER-NAME.</P>

<P>&nbsp;</P>

<P>when MA-PROGRAMMER-NAME is included in the current subschema.</P>

<P>If unavailable, the type of entity and the code number will be
written to the write-buffer, and the value of the system-variable
"RESULT" will be set to zero. Entities will be unavailable if they
are not defined in the schema or subschema, e.g., item selection will
fail if either the record needed, or the item within that record is
not included in the currently loaded subschema. Note that item names
are not included anywhere in a schema absolute, but are included in a
subschema that has those items included.</P>

<P>&nbsp;</P>

<P>Example: WRITE = 'THE NAME OF ITEM 123 IS '</P>

<P>DDL-SUB,I 123</P>

<P>WRITE = '.',*</P>

<P>&nbsp;</P>

<P>will print</P>

<P>&nbsp;</P>

<P>THE NAME OF ITEM 123 IS ITEM-123.</P>

<P>&nbsp;</P>

<P>when MA-PROGRAMMER-NAME is not included in the current subschema.
</P>

<P>---</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DIVIDE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DIVIDE</P>

<H2>12.10. DIVIDE</H2>

<P>&nbsp;</P>

<P>DIVIDE dividend-first-half,dividend-second-half,divisor -----</P>

<P>The DIVIDE macro divides a two word number by a one word number,
returning a three word array consisting of a two word result and one
word remainder.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DMUFIND | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DMUFIND</P>

<H2>12.11. DMUFIND</H2>

<P>&nbsp;</P>

<P>DMUFIND dmu-name,invoke-key,impart-key,dmu-key -------</P>

<P>The DMUFIND searches the current Schema File and returns the name
of the DMU subschema (two words fieldata) for the currently based
schema, along with the various keys (three words ascii each) needed
to invoke the DMU subschema via the DMU processor.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DOWN-UP | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DOWN-UP</P>

<H2>12.12. DOWN-UP</H2>

<P>&nbsp;</P>

<P>DOWN-UP[,OPTIONS] &lt;mask&gt;,&lt;default-app&gt; -------</P>

<P>The DOWN-UP MACRO is called by the DOWN-AREAS and UP-AREAS macros
to generate the actual DMU/IRU down/up area syntax.</P>

<P>See the DBE Users Guide for information on the DOWN-AREAS and
UP-AREAS macros.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DSL | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DSL</P>

<H2>12.13. DSL</H2>

<P>&nbsp;</P>

<P>DSL 1st-wd-to-shift,2ns-wd-to-shift,#-of-bits-to-shift ---</P>

<P>DSL shifts two words a variable number of bits to the right.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | DUMP-LM-KEY | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DUMP-LM-KEY</P>

<H2>12.14. DUMP-LM-KEY</H2>

<P>&nbsp;</P>

<P>DUMP-LM-KEY -----------</P>

<P>The DUMP-LM-KEY macro will dump the Location Mode Key for the
current record on the current page if it is CALC or INDEX-SEQUENTIAL.
</P>

<P>See the DUMPREC macro for sample output.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | EJECT | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */EJECT</P>

<H2>12.15. EJECT</H2>

<P>&nbsp;</P>

<P>EJECT -----</P>

<P>This macro writes a page-eject to the print file and hardcopy file
(if any).</P>

<P>This merely provides a more readable alternative to "WRITE =
R,*(-1)".</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | ELT-TYPE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */ELT-TYPE</P>

<H2>12.16. ELT-TYPE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar ) LET - - = ELT-TYPE element-type[,element-subtype] --- (
array-element ) --------</P>

<P>This macro has, as parameters one or two expressions. The first is
a numeric element type code while the second is an element subtype
code. The output of this macro is a six-character FIELDATA string
(left-justified, space-filled) which represents the standard acronym
associated with that element type/subtype combination (COBP, COB,
ASM, ABS, etc.).</P>

<P>Consult the "1100 Series Executive System (Volume 3) PRM -
UP-4144.3" for a discussion of the various types and subtypes of
program-file elements.</P>

<P>The DBE TOC macro is an excellent example of this macro at work.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | EXPAND$REC | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */EXPAND$REC</P>

<H2>12.17. EXPAND$REC</H2>

<P>&nbsp;</P>

<P>EXPAND$REC &lt;compressed-array&gt;,&lt;expanded-array&gt;
----------</P>

<P>This macro expands a variable-length record-occurrence of the
current record type. The &lt;compressed-array&gt; is an array
containing the record data as read from the database. The macro
evaluates each occurs-depending-on item and creates an output array
which is expanded to the maximum occurs count for each item. This
duplicates the function that the DMR (or UDS) does when a
variable-length record is read into core. Note that IDT entries show
the starting word for an item as computed after the record has been
expanded in core.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | EXTRACTITEM | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */EXTRACTITEM</P>

<H2>12.18. EXTRACTITEM</H2>

<P>&nbsp;</P>

<P>EXTRACTITEM,&lt;options&gt;
&lt;expanded-data&gt;,&lt;Key-Item-Entry&gt;[,&lt;column-limit&gt;]
-----------</P>

<P>This macro puts into the "write-buffer" the value of an item as
found in the input array. Items are decoded based on the item-type:
numeric (PIC 9) items are displayed in decimal, alphanumeric (PIC X)
items are shown within quotes, signed items (PIC S) are shown with a
leading sign, etc. The &lt;expanded-data&gt; array is an array
containing the data of a specific record occurrence from the
database. It must first be expanded if necessary by using the
EXPAND$REC macro. The &lt;Key-Item-Entry&gt; is an array containing
(only) the standard KIE entry defining an item, as taken from the
RDT. The &lt;column-limit&gt; is used to limit the print width on the
page, i.e., if a decoded value will not fit in the write-buffer
before the column-limit, it will put on the next line.</P>

<P>Binary items longer than 36 bits, and all floating point items are
not supported, and will write the value '&lt;CANNOT BE DECODED&gt;'
into the write-buffer.</P>

<H4>12.18.0.1 Options</H4>

<P>C COBOL format. Set &lt;column-limit&gt; to 72, and if a value
will not fit on a line, continue the value on the next line by
putting an asterisk in column 7.</P>

<P>&nbsp;</P>

<P>P Print the write-buffer when the macro is complete. If the "P"
option is not used, the value will be written into the write-buffer,
but no printing will take place.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | EXTRACTKEY | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */EXTRACTKEY</P>

<H2>12.19. EXTRACTKEY</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>EXTRACTKEY[,M] page-locn-of-rec-hdr-wd,RDT-SME-offset</P>

<P>----------</P>

<P>&nbsp;</P>

<P>This macro will extract one or more key values from the record
whose</P>

<P>record header word address on the currently-loaded page is
supplied as the</P>

<P>first argument. The second argument is the Set Member Entry offset
within the</P>

<P>current RDT for the key whose contents are to be extracted.</P>

<P>&nbsp;</P>

<P>The data characters corrsponding to the key field will be inserted
into</P>

<P>the WRITE buffer.</P>

<P>&nbsp;</P>

<P>In the event that the record has been defined with multiple keys,
the</P>

<P>M option may be specified to extract multiple keys (and
concatenate the</P>

<P>values in the WRITE buffer). The SME entry pointed to by the
second parameter</P>

<P>should be the first one desired - ALL remaining keys will be
extracted from</P>

<P>that point on.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | FIND | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */FIND</P>

<H2>12.20. FIND</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar )</P>

<P>LET - - = FIND[,options] data-base-key/ptr</P>

<P>--- ( array-element ) ----</P>

<P>&nbsp;</P>

<P>Where the legal options are:</P>

<P>None: Treat the parameter as a Database Pointer</P>

<P>&nbsp;</P>

<P>K: Treat the parameter as a Database Key</P>

<P>&nbsp;</P>

<P>N: Do not print ANY messages (even errors)</P>

<P>&nbsp;</P>

<P>This macro locates the record whose database key or database
pointer</P>

<P>is supplied as an argument. Following a successful "find", the
current table</P>

<P>will be PAGE and $ (the current word of the current table) will be
the Record</P>

<P>Header Word of the record you were seeking.</P>

<P>&nbsp;</P>

<P>Values returned are:</P>

<P>&nbsp;</P>

<P>1. A DATABASE KEY - this will be returned if you called the macro
with a database pointer as an argument and the record was
successfully found. The database key will be that of the record.</P>

<P>&nbsp;</P>

<P>2. A DATABASE POINTER - this is returned if you called FIND with a
database key as an argument and the record was successfully found.
The database pointer will be that of the record.</P>

<P>&nbsp;</P>

<P>3. Zero (0) - the record could not be located.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | FINDMAC | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */FINDMAC</P>

<H2>12.21. FINDMAC</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar ) LET - - = FINDMAC macro-name --- ( array-element )
-------</P>

<P>This macro returns the element offset within the MA array for the
specified macro.</P>

<P>If the macro can not be found, a value of -1 is returned.</P>

<P>The SAVE macro uses this macro to determine the start of the macro
to be saved.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | GET-INDEX | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */GET-INDEX</P>

<H2>12.22. GET-INDEX</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar ) LET - - = GET-INDEX --- ( array-element ) ---------
</P>

<P>This macro returns the Index Area code and Index Sequential record
code (if any) for the current area.</P>

<P>The Area Code for the assopciated Index Area will be returned in
H1 and the Record code in H2 if the current area can have Index
Sequential records stored in it. If no Index Sequential records can
be stored, a value of 0 will be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | GETTOC | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */GETTOC</P>

<H2>12.23. GETTOC</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>(,T TIP/DMS-file-number ) LET subset = GETTOC - - --- ------ (
qual*file. )</P>

<P>This macro retrieves the ENTIRE table-of-contents of a program
file.</P>

<P>The receiving subset must be AT LEAST as large as the files toc to
avoid truncation (see the TOCSIZE macro).</P>

<P>The file may be a TIP/DMS file or an exec file.</P>

<P>This macro must be used to retrieve the toc of a file before that
toc may be searched via the PFS macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | IODUMP | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */IODUMP</P>

<H2>12.24. IODUMP</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>IODUMP[,options] &lt;start-word&gt;,&lt;end-word&gt; ------</P>

<P>This macro provides a quick method of dumping the IOBUF system
table via the WDDUMP macro.</P>

<P>If &lt;start-word&gt; is omitted, dumping will start at word 0 of
IOBUF.</P>

<P>If &lt;end-word&gt; is omitted, dumping will end at the last word
defined in the IOBUF.</P>

<H3>12.24.1 Options</H3>

<P>A Dump in ASCII.</P>

<P>F Dump in FIELDATA.</P>

<P>O Dump in Octal.</P>

<P>&nbsp;</P>

<P>None Dump in ASCII and Octal.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | IRU-CALL | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */IRU-CALL</P>

<H2>12.25. IRU-CALL</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>LET subset = IRU-CALL --- --------</P>

<P>This macro returns the IRU processor file in FIELDATA for the
current UDS Application Group in the subset specified.</P>

<P>The subset should be at least 5 words long to prevent truncation.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | LDSL | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */LDSL</P>

<H2>12.26. LDSL</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>LDSL 1st-wd-to-shift,2nd-wd-to-shift,#-of-bits-to-shift ----</P>

<P>LDSL shifts two words a variable number of bits to the left.</P>

<P>The result is returned as a three word array.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | MASKA | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MASKA</P>

<H2>12.27. MASKA</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar[:j] ) LET - - = MASKA mask,string --- ( array-element[:j]
) -----</P>

<P>Note that the [:j] denotes an optional j-designator.</P>

<P>This macro is used to perform masking operations against an ASCII
string.</P>

<P>Consult the MACROS chapter of the "DBE User's Guide" for a
discussion of the actual usage of masking. The following macros make
use of this one (or its partner - MASKF) to perform the masking
described in the User's Guide:</P>

<P>&nbsp;</P>

<P>AREAS</P>

<P>OVERFLOW-ALL</P>

<P>REC-COUNT-ALL</P>

<P>RECORDS</P>

<P>SETS</P>

<P>SIZE-REPORT</P>

<P>The "string" parameter MUST be a subset containing an ASCII string
against which a mask (the first parameter) will be compared.</P>

<P>The "mask" parameter may be a FIELDATA character string or a
subset containing FIELDATA characters (the mask will be converted to
ASCII internally).</P>

<P>If the mask matches the string (according to the rules documented
in the descriptions of the above macros), a value of 1 will be
returned. If the mask does not match the string, a value of zero will
be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | MASKF | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MASKF</P>

<H2>12.28. MASKF</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar[:j] ) LET - - = MASKF mask,string --- ( array-element[:j]
) -----</P>

<P>Note that the [:j] denotes an optional j-designator.</P>

<P>This macro is used to perform masking operations against a
FIELDATA string.</P>

<P>Consult the MACROS chapter of the "DBE User's Guide" for a
discussion of the actual usage of masking. The following macros make
use of this one (or its partner - MASKA) to perform the masking
described in the User's Guide:</P>

<P>&nbsp;</P>

<P>AREAS</P>

<P>OVERFLOW-ALL</P>

<P>REC-COUNT-ALL</P>

<P>RECORDS</P>

<P>SETS</P>

<P>SIZE-REPORT</P>

<P>The "string" parameter may be a subset containing a FIELDATA
string or may be an actual FIELDATA string. The mask will be compared
against this sequence of FIELDATA characters.</P>

<P>The "mask" parameter may be a FIELDATA character string or a
subset containing FIELDATA characters.</P>

<P>If the mask matches the string (according to the rules documented
in the descriptions of the above macros), a value of 1 will be
returned. If the mask does not match the string, a value of zero will
be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | MATCH-ARRAY | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MATCH-ARRAY</P>

<H2>12.29. MATCH-ARRAY</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar[:j] ) LET - - = MATCH-ARRAY string1,string2 --- (
array-element[:j] ) -----------</P>

<P>Note that the [:j] denotes an optional j-designator.</P>

<P>The MATCH-ARRAY macro functions in a manner similar to the MASKA
&amp; MASKF macros with the exception that it searches for an exact
binary match on the two strings This allows arrays with spaces and
asterisks to be compared. The number of words to be matched will be
equal to the size of the smaller array.</P>

<P>If the strings match exactly, a value of 1 will be returned. If
the strings do not match, a value of zero will be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | MSG-OUT | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MSG-OUT</P>

<H2>12.30. MSG-OUT</H2>

<P>&nbsp;</P>

<P>MSG-OUT[,options] message-text -------</P>

<P>The MSG-OUT macro provides a quick method of displaying text
messages with the current time. This can prove useful for debugging
purposes.</P>

<P>The message-text can be passed either as a string or an array.
</P>

<P>If the "S" option is specified, the SUPS macro will be called
after the message-text is displayed.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | NUMSLOTSATEND | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */NUMSLOTSATEND</P>

<H2>12.31. NUMSLOTSATEND</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) LET - - = NUMSLOTSATEND --- (
scalar[:j-designator] ) ------------</P>

<P>This macro returns the number of end-of-page slots (record + calc)
allocated on the currently-loaded page.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | OPTBIT2ALPHA | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */OPTBIT2ALPHA</P>

<H2>12.32. OPTBIT2ALPHA</H2>

<P>&nbsp;</P>

<P>OPTBIT2ALPHA[,options] bit-mask ------------</P>

<P>Legal options area:</P>

<P>L: Place a comma before the options C: Copy to console buffer W:
Copy to write buffer</P>

<P>This macro is used to take a one word bit mask and convert it to
its alphabetic option characters. The output can be written to the
write buffer or the console buffer.</P>

<P>Note that the word passed should NOT be the reserved word OPTS as
this variable is changed by the recieving macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | PAUSE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */PAUSE</P>

<H2>12.33. PAUSE</H2>

<P>&nbsp;</P>

<P>PAUSE -----</P>

<P>This macro will print the message "&lt;XMIT&gt; TO CONTINUE:" on
the terminal and wait for a reply from the terminal operator.</P>

<P>If the reply is null (no message, just XMIT), control will RETURN
to the macro calling this one. If text was given as input, that text
will be stored in the latent command buffer (CMDBUF) and the STOP
statement will be used to return to CONVERSATIONAL MODE (where the
saved command will be executed). This is the mechanism used by macros
such as LINK, ART, SCRT and so forth to suspend printout. These
macros, you will remember, allow a DBE command to be executed in
place of the XMIT - an event that causes those macros to terminate
and the command to be done.</P>

<P>If the "P" processor option is set, or DBE is running in batch
mode, the macro will have no effect.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | PFS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */PFS</P>

<H2>12.34. PFS</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j] ) LET - - = --- ( scalar[:j] )</P>

<P>&nbsp;</P>

<P>PFS[,options] toc,[elt],[vers],[start],[options],[subtype]</P>

<P>---</P>

<P>This macro searches a table-of-contents for an element entry,
returning the word offset of occurrence of that elements entry in the
toc.</P>

<P>The "toc" parameter is a subset containing the table-of-contents
entries from a program file as returned by the GETTOC macro.</P>

<P>The "elt" and "vers" parameters are strings or subsets containing
the element names and/or version names to be searched for - both may
be actually specified as masks (as per MASKF). An absent parameter in
either field assumes "*" (which would match any name or version). A
version of spaces must be specifically supplied as spaces.</P>

<P>The "start" parameter indicates where in the "toc" the search will
begin. Specfifying zero causes searching to begin at the start of the
"toc". By allowing this parameter to be specified, the "toc" may be
searched sequentially for elements matching a mask.</P>

<P>The options (which may be supplied as option letters after the PFS
call or as an OPTS-format bit mask as a parameter) may be any or all
of "AORSD". The "AORS" parameters specify the type of element being
searched for (absolute, omnibus, relocatable or source). The "D"
option allows matches against element entries that are marked for
deletion. Absence of any options implies "AORS" (matches any element
with the given elt/vers, regardless of type).</P>

<P>If desired, searches for source elements may be furthur refined by
element subtype via the "subtype" field. The subtype should be
specified by mnemonic (ELT, COB, etc.).</P>

<P>A value of -1 returned by PFS means the element could not be
located in the toc.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$ANAME | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$ANAME</P>

<H2>12.35. R$$ANAME</H2>

<P>&nbsp;</P>

<P>R$$ANAME[,options] --------</P>

<P>This macro writes the current RDMS area name to the write buffer.
If the current RDMS area is tip, the tip code will be followed by the
FCSS file name (from the RTREG table) in parentheses.</P>

<P>The "W" option will cause the contents of the write buffer to be
printed after the area name is moved in.</P>

<P>The "T" option will cause the area type (Data,Index,Data/Index) to
be printed along with the area name.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$AREAS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$AREAS</P>

<H2>12.36. R$$AREAS</H2>

<P>&nbsp;</P>

<P>R$$AREAS
&lt;RDMS-group-name&gt;,[&lt;file-mask&gt;],[&lt;qual-mask&gt;]
--------</P>

<P>This macro access the DBE FDT$ file to return all RDMS areas for
the specified RDMS Schema/Group name, optionally masked by file name
and qualifier.</P>

<P>Area names are written to SDF file 'RAFILE'.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$ATYPE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$ATYPE</P>

<H2>12.37. R$$ATYPE</H2>

<P>&nbsp;</P>

<P>LET subset = R$$ATYPE --- --------</P>

<P>This macro will return the current RDMS area type
(DATA,DATA/INDEX,INDEX) in the specified subset. The subset passed
should be at least 2 words long to avoid truncation.</P>

<P>No check is made to ensure that an RDMS area is current. This
should be done by the macro calling this macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$FIRSTPAGE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$FIRSTPAGE</P>

<H2>12.38. R$$FIRSTPAGE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar[:j] ) LET - - = R$$FIRSTPAGE[,options]
&lt;BTREE-number&gt; --- (aray-element[:j] ) ------------</P>

<P>This macro returns the first Index or Data page for the current
RDMS area.</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>none Return the first Data page</P>

<P>&nbsp;</P>

<P>I Return the first Index page</P>

<P>If BTREE-number is ommited, the first BTREE in the area will be
used.</P>

<P>The RDMS area type must be Data or Data/Index. If not, the
returned value will be -1.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$STATUS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$STATUS</P>

<H2>12.39. R$$STATUS</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( scalar[:j] ) LET - - = R$$STATUS[,options]
&lt;page-address&gt;,&lt;calling-macro-name&gt; --- (aray-element[:j]
) ---------</P>

<P>This macro determines if an RDMS area, page, and record is
current. Depending on options, an error message can be printed.</P>

<P>Options:</P>

<P>&nbsp;</P>

<P>A: Display message if RDMS area is not current</P>

<P>&nbsp;</P>

<P>P: Display message if RDMS page is not current</P>

<P>&nbsp;</P>

<P>R: Display message if RDMS record is not current</P>

<P>The value returned is determined as follows:</P>

<P>&nbsp;</P>

<P>1 No RDMS area is current</P>

<P>&nbsp;</P>

<P>2 No RDMS page is current</P>

<P>&nbsp;</P>

<P>3 No RDMS record is current</P>

<P>&nbsp;</P>

<P>4 RDMS area , record, and page are all current</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$TABLE-LD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$TABLE-LD</P>

<H2>12.40. R$$TABLE-LD</H2>

<P>&nbsp;</P>

<P>MACSUB R$$TABLE-LD ------ -----------</P>

<P>This macsub macro loads the two dimensional table DITEMS with byte
offsets and field sizes for the current RDMS record.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$$VALIDAREA | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$$VALIDAREA</P>

<H2>12.41. R$$VALIDAREA</H2>

<P>&nbsp;</P>

<P>LET scalar = R$VALIDAREA[,options] --- -----------</P>

<P>This macro determines if the current RDMS area type matches the
allowed area types specified by the macro call options. If the area
type is one of the allowed types, a value of 0 will be returned. If
the area type does not match, an error message will be printed an a
value of -1 will be returned.</P>

<H3>12.41.1 Options</H3>

<P>Any combination of valid options is allowed, but at least one
option must be specified.</P>

<P>&nbsp;</P>

<P>C Area Type may be DATA/INDEX.</P>

<P>D Area Type may be DATA.</P>

<P>I Area Type may be INDEX.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | R$UPH | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */R$UPH</P>

<H2>12.42. R$UPH</H2>

<P>&nbsp;</P>

<P>R$UPH -----</P>

<P>This macro will treat the contents of the USRBUF system table as
the RDMS RPH table and produce a formmated listing similar to the RPH
macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | RECLOCTOSLOT | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RECLOCTOSLOT</P>

<H2>12.43. RECLOCTOSLOT</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) LET - - = RECLOCTOSLOT
[rec-hdr-wd-adr] --- ( scalar[:j-designator] ) ------------</P>

<P>This macro returns the end-of-page slot number for the record on
the currently-loaded page whose record header word address (on the
current page) is supplied as an argument. If no argument is supplied,
the assumption will be made that the word PAGE[$] is the record
header word.</P>

<P>Remember that slots are numbered from zero with slot 0 being the
page header calc chain word.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | RECNUMTOSLOT | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RECNUMTOSLOT</P>

<H2>12.44. RECNUMTOSLOT</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) LET - - = RECNUMTOSLOT rec-number
--- ( scalar[:j-designator] ) ------------</P>

<P>This returns the end-of-page slot number on the currently-loaded
page which points to the record whose record number is supplied as an
argument. The term "record number" refers to the record-number
component of a database key.</P>

<P>If the record number is not defined on the current page, a value
of -1 will be returned.</P>

<P>Remember that slots are numbered starting at zero - slot 0 is the
page header calc chain word.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | RECSLOTTONUM | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RECSLOTTONUM</P>

<H2>12.45. RECSLOTTONUM</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) LET - - = RECSLOTTONUM
slot-number --- ( scalar[:j-designator] ) ------------</P>

<P>This returns the record number of the record on the
currently-loaded page which is pointed to by the slot whose slot
number is supplied as an argument. The term "record number" refers to
the record-number component of a database key.</P>

<P>No check is made to verify that the slot you have referenced is
actually a record slot - the record number portion of that word will
simply be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | SCHEMA-LOAD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SCHEMA-LOAD</P>

<H2>12.46. SCHEMA-LOAD</H2>

<P>&nbsp;</P>

<P>SCHEMA-LOAD[,&lt;options&gt;]
&lt;param-1&gt;,[&lt;param-2&gt;,....,&lt;param-7&gt;] -----------
</P>

<P>This macro is used to load a schema given the schema specification
in param-1 via CSF @ADD statements. This allows a user written macro
to be written with the macro name being a schema name for easy schema
loading.</P>

<P>Additional parameters can also be passed to execute any valid DBE
command. This can be used to set the QUAL value,etc.</P>

<H3>12.46.1 Options</H3>

<P>A Execute an AREA command after basing the schema.</P>

<P>S Execute an SS command after basing the schema/subschema.</P>

<P>None Execute a SCHEMA command after basing the schema.</P>

<P>Example:</P>

<P>&nbsp;</P>

<P>*:&gt;LIST DBE-SCH</P>

<P>&nbsp;</P>

<P>1: IF OPTS:A = 1 THEN</P>

<P>2: SCHEMA-LOAD 'SCH DA0*ABS-DBE.DBE-SCH'</P>

<P>3: ELSE</P>

<P>4: SCHEMA-LOAD 'SCH,T 2340 DBE-SCH'</P>

<P>5: END IF</P>

<P>&nbsp;</P>

<P>*:&gt;DBE-SCH</P>

<P>&nbsp;</P>

<P>SCH,T 2340 DBE-SCH</P>

<P>SCHEMA: DBE-SCH FILE: TIP/DMS FILE 2340</P>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>*:&gt;DBE-SCH,A</P>

<P>&nbsp;</P>

<P>SCH DA0*ABS-DBE.DBE-SCH</P>

<P>SCHEMA: DBE-SCH FILE: DA0*ABS-DBE.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | SDF-DUMP | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SDF-DUMP</P>

<H2>12.47. SDF-DUMP</H2>

<P>SDF-DUMP[,options]
&lt;file-name&gt;,[&lt;#-of-records&gt;,&lt;start-word&gt;,&lt;end-word&gt;
--------</P>

<P>This macro will read records from the SDF file supplied in
parameter #1 into the IOBUF system table, and call the WDDUMP macro
to dump the records read. The SDF file must have been previously
opened or an error will result.</P>

<P>If &lt;#-of-records&gt; is omitted, all records in the file will
be dumped.</P>

<P>If &lt;start-word&gt; and/or &lt;end-word&gt; are omitted, the
entire record read will be dumped.</P>

<P>All options specified are passed to the WDDUMP macro.</P>

<P>To position the SDF file, use the SDF-POS macro.</P>

<P>The file may be a TIP/DMS file or an exec file.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | SDF-POS | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SDF-POS</P>

<H2>12.48. SDF-POS</H2>

<P>SDF-POS &lt;file-name&gt;,&lt;number-of-records&gt; -------</P>

<P>This macro will skip the &lt;number-of-records&gt; specified on
the macro call for the &lt;file-name&gt; specified. The
&lt;file-name&gt; must have been previously opened or an error will
result.</P>

<P>At the end of the macro, the system variable IOBUF will contain
the last record read/skipped.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | SEARCH-SME | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SEARCH-SME</P>

<H2>12.49. SEARCH-SME</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>&lt;link-number&gt; SEARCH-SME,&lt;options&gt; or ----------
&lt;set-code&gt;</P>

<P>This macro searches the Set Member Entries (SME's) for a record
and returns a pointer to one selected by either link number or set
code.</P>

<H4>12.49.0.1 Options</H4>

<P>One and only one of the following primary options must be
specified:</P>

<P>&nbsp;</P>

<P>C Select the SME for the set code requested.</P>

<P>&nbsp;</P>

<P>P Select the SME for the set that includes the link number
requested.</P>

<P>At least one of the following secondary options must be specified:
</P>

<P>&nbsp;</P>

<P>O Search SME's for sets that the current record owns.</P>

<P>&nbsp;</P>

<P>A Search SME's for sets in which the current record may
participate as an automatic member.</P>

<P>&nbsp;</P>

<P>M Search SME's for sets in which the current record may
participate as a manual member.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | SETS-L | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */SETS-L</P>

<H2>12.50. SETS-L</H2>

<P>SETS-L &lt;mask&gt; ------</P>

<P>This macro is called by the SETS macro to produce a Long set
listing. The &lt;mask&gt; passed will mask set names to report only
on set names matching the mask.</P>

<P>If the "A" option is specified, only sets with an owner/member
which can reside in the current area are reported.</P>

<P>For more information, see the SETS macro in the DBE Users Guide.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE</P>

<H2>12.51. TDATE</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE DMS-DATE/TIME-stamp --- -----</P>

<P>This macro assumes that the expression being passed as its
argument is a legal DMS/1100 Date/Time stamp. The Date/Time stamp
will be broken apart, and its six components passed to the receiving
subset as six 36-bit values in the order Month, Day, Year (of
century), Hours, Minutes and Seconds. All values are binary (not
FIELDATA or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE1 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE1</P>

<H2>12.52. TDATE1</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE1 DMS-DATE/TIME-stamp --- ------</P>

<P>This macro assumes that the expression being passed as its
argument is a legal DMS/1100 Date/Time stamp. The Date/Time stamp
will be broken apart, and its six components passed to the receiving
subset as six 36-bit values in the order Year (of century), Month,
Day, Hours, Minutes and Seconds. All values are binary (not FIELDATA
or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE2 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE2</P>

<H2>12.53. TDATE2</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE2 IRU DATE/TIME-stamp --- ------</P>

<P>This macro assumes that the expression being passed as its
argument is a legal IRU Audit Trail Date/Time stamp. The Date/Time
stamp will be broken apart, and its six components passed to the
receiving subset as six 36-bit values in the order Year (of century),
Month, Day, Hours, Minutes and Seconds. All values are binary (not
FIELDATA or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE3 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE3</P>

<H2>12.54. TDATE3</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE3 DTIME$ DATE/TIME-stamp --- ------</P>

<P>This macro assumes that the expression being passed as its
argument is a legal "ER DTIME$" Date/Time stamp. The Date/Time stamp
will be broken apart, and its six components passed to the receiving
subset as six 36-bit values in the order Year (of century), Month,
Day, Hours, Minutes and Seconds. All values are binary (not FIELDATA
or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P>The DTIME$ passed must be a two word array / array subset.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE4 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE4</P>

<H2>12.55. TDATE4</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE4 DATE/TIME-stamp in TDATE$ Format --- ------
</P>

<P>This macro assumes that the expression being passed as its
argument is a legal "ER TDATE$" Date/Time stamp. The Date/Time stamp
will be broken apart, and its six components passed to the receiving
subset as six 36-bit values in the order Year (of century), Month,
Day, Hours, Minutes and Seconds. All values are binary (not FIELDATA
or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P>The Date/Time stamp input must be a one word scalar in the format:
</P>

<P>S1: Month S2: Day S3: Year Modulo 1964 H2: Seconds Past Midnight
</P>

<P>If the "R" option is specified, the current date/time will be
returned in TDATE$ format.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TDATE5 | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TDATE5</P>

<H2>12.56. TDATE5</H2>

<P>&nbsp;</P>

<P>LET subset = TDATE5 DATE/TIME-stamp in "Reverse" TDATE$ Format ---
------</P>

<P>This macro assumes that the expression being passed as its
argument is a legal "Reverse TDATE$" Date/Time stamp. The Date/Time
stamp will be broken apart, and its six components passed to the
receiving subset as six 36-bit values in the order Year (of century),
Month, Day, Hours, Minutes and Seconds. All values are binary (not
FIELDATA or ASCII strings).</P>

<P>To avoid truncation, the receiving subset should be at least six
words long.</P>

<P>The Date/Time stamp input must be a one word scalar in the format:
</P>

<P>H1: Seconds Past Midnight S4: Month S5: Day S6: Year Modulo 1964
</P>

<P>If the "R" option is specified, the current date/time will be
returned in Reverse TDATE$ format.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | TOCSIZE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TOCSIZE</P>

<H2>12.57. TOCSIZE</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element[:j-designator] ) (,T TIP/DMS-File-# ) LET - - =
TOCSIZE- - --- ( scalar[:j-designator] ) -------( qual*file. )</P>

<P>This macro is used to determine the size of the table-of-contents
of a program file so that an array may be DIMENSIONed to that size
and used as the receiving field of a call to GETTOC.</P>

<P>The file specifications are the same as for GETTOC.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | U$APP-LOAD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */U$APP-LOAD</P>

<H2>12.58. U$APP-LOAD</H2>

<P>&nbsp;</P>

<P>U$APP-LOAD[,options] ----------</P>

<P>This macro is used save and load the UDS system tables UDSVAR and
DCSIDX. The "S" option saves the variables to temp file ADT$INFO and
is intended for use by the U$APP macro only.</P>

<P>Without the "S" option, the ADT$INFO file is read and the arrays
loaded. Many of the System UDS macros use this technique to attempt
to base an application if one is not already current.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Site Library Macros | 'U$FDT-FILES' Macro | </B>
</CENTER></P>

<P><CENTER><B>| | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */U$FDT-FILES</P>

<H2>12.59. U$FDT-FILES</H2>

<P>MACSUB U$FDT-FILES ------ -----------</P>

<P>&nbsp;</P>

<P>The U$FDT-FILES macsub is a utility macro called by several System
Macros to open the DBE FDT$ File and return record start blocks. The
U$APP macro must have been run previously to base a UDS application.
</P>

<P>This macro performs an 'OPEN DBEFDT' to open the DBE FDT copy file
for inquiry or update. It also returns variables defining the
starting block number for each section of the file as follows:</P>

<P>&nbsp;</P>

<P>MAX$FDTS - Maximum number of FDT entries that can fit in file</P>

<P>&nbsp;</P>

<P>MAX$SCH - Maximum number of Schema entries that can fit in file
</P>

<P>&nbsp;</P>

<P>FDTE$BLKSZ - Size of FDT entry in words</P>

<P>&nbsp;</P>

<P>FDTL$SIZE - Size of Date/Time stamp table in words</P>

<P>&nbsp;</P>

<P>FDTG$START - Starting block for schema entry records</P>

<P>&nbsp;</P>

<P>FDTE$START - Block BEFORE start of FDT entries</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | U$LOAD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */U$LOAD</P>

<H2>12.60. U$LOAD</H2>

<P>&nbsp;</P>

<P>MACSUB U$LOAD table-name</P>

<P>------</P>

<P>The U$LOAD macro is used to dynamically dimension and load arrays
with data from the various UDS common banks.</P>

<P>The tables currently supported are:</P>

<P>&nbsp;</P>

<P>ACT Application Characteristic Table.</P>

<P>ACW Access Control Word List</P>

<P>BST Bank Summary Table</P>

<P>DFT Dedicated File Table</P>

<P>DMPERR Error Dump Table</P>

<P>DMRIDX DMR Index</P>

<P>GNL Group Name List Header</P>

<P>LCT LDM Characteristic Table</P>

<P>QAD Queuing and Deadlock Table</P>

<P>RFL Retention File List</P>

<P>TCS Table Control System Table</P>

<P>TMP Thread Environment Table Template</P>

<P>TRC Trace Table</P>

<P>TRL Table Reference List</P>

<P>TST Thread Summary Table</P>

<P>Note that the "ACT" table is returned as array "UACT" to prevent
duplication of the subschema ACT table.</P>

<P>This macro MUST be called as a macsub to properly return the
requested array.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | U$$THREAD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */U$$THREAD</P>

<H2>12.61. U$$THREAD</H2>

<P>&nbsp;</P>

<P>MACSUB U$$THREAD</P>

<P>---------</P>

<P>The U$$THREAD macro is used to dynamically dimension and load the
TSTE and TET arrays for the current thread. If no thread is current
or the current thread is not active, a message will be displayed and
a RESULT of -1 will be returned.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | U-ART | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */U-ART</P>

<H2>12.62. U-ART</H2>

<P>&nbsp;</P>

<P>U-ART -----</P>

<P>This macro will treat the contents of the USRBUF system table as
the ART table and produce a formatted dump similar to the ART system
macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | UPH | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */UPH</P>

<H2>12.63. UPH</H2>

<P>&nbsp;</P>

<P>UPH ---</P>

<P>This macro will treat the contents of the USRBUF system table as a
DMS database page and produce a formatted page header dump similar to
the PH system macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | WDDUMP | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */WDDUMP</P>

<H2>12.64. WDDUMP</H2>

<P>&nbsp;</P>

<P>WDDUMP[,options] subset[,starting-word-number] ------</P>

<P>legal options are (at least one must be specified):</P>

<P>&nbsp;</P>

<P>A: Dump in ASCII Format</P>

<P>B: Dump in BINARY Format</P>

<P>F: Dump in FIELDATA Format</P>

<P>O: Dump in OCTAL Format</P>

<P>The contents of the subset will be dumped in the format(s)
specified by the option(s). Note that multiple formats may be printed
at a time.</P>

<P>The optional "starting-word-number" merely specifies the value
used to label the first word of the dump. Absence of the starting
word number will imply reference to the system variable $ as the
label for the first word.</P>

<P>The entire subset will be dumped.</P>

<P>This is the macro used by the DATA and PGDUMP macros to dump data.
</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | WRITE-DECODE | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */WRITE-DECODE</P>

<H2>12.65. WRITE-DECODE</H2>

<P>&nbsp;</P>

<P>WRITE-DECODE ------------</P>

<P>This macro decodes the Database Key for the current record on the
current page and displays the octal Datbase Key along with the Area
code, Page Number, and Slot Number in both decimal and octal.</P>

<P>This macro is called by the DUMPREC macro.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 12 | YYMMDD | </B></CENTER></P>

<P><CENTER><B>| UTILITY MACROS | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */YYMMDD</P>

<H2>12.66. YYMMDD</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( array-element ) LET - - = YYMMDD --- ( scalar ) ------</P>

<P>This returns the current date in FIELDATA in a YYMMDD format
rather than the MMDDYY format as specified for the system variable
DATE. SETCTR 1,13 TOCLVL 5</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<H1>13. DEBUGGING FACILITIES</H1>

<P>This chapter describes the DBE debugging facilities. These
facilities make use of MACRO SUSPEND MODE. This mode of operation is
very similar to CONVERSATIONAL MODE, but is entered following the
suspension of a running macro. Macros may be suspended by certain
commands described in this chapter, or may be suspended by virtue of
having "errored off".</P>

<P>Through the facilities described in this chapter, the user may
trace macro execution, set/clear line number "breakpoints", set/clear
variable modification "traps" or monitor variables. In addition, the
values of variables may be examined or changed via the EVALUATE,
PRINT and LET statements.</P>

<P>There is a limitation on such activity however. No more than six
(6) macros may be involved in DEBUG activities at any one time. No
more than thirty-six (36) variables may be MONITORed or TRAPed at any
one time.</P>

<P>The remaining sections describe the various debugging commands.
None of these commands are intended for use within a macro. The DEBUG
command is presented first (rather than in normal alphabetic
sequence) since it controls the activities of the remaining commands
in this chapter.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | DEBUG | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */DEBUG</P>

<H2>13.1. DEBUG</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( OFF ) DEBUG [ - --- - ] ----- ( ON )</P>

<P>--</P>

<P>This command activates/deactivates the commands (except RETURN)
described in this chapter.</P>

<P>When the argument is ON, debugging mode will be activated. When
this occurs, the normal DBE terminal input prompt of</P>

<P>&nbsp;</P>

<P>*: or table[locn]:</P>

<P>will be changed to:</P>

<P>&nbsp;</P>

<P>DEBUG:*: or DEBUG:table[locn]:</P>

<P>&nbsp;</P>

<P>or</P>

<P>&nbsp;</P>

<P>DEBUG:NEXT=#/macroname:*:</P>

<P>&nbsp;</P>

<P>or</P>

<P>&nbsp;</P>

<P>DEBUG:NEXT=#/macroname:table[locn]:</P>

<P>The last two cases show the behavior when DEBUG ON is executed in
MACRO SUSPEND MODE - this is the ONLY way you can tell if a macro is
suspended. The prompt will tell you the NEXT statement number within
the macro that would have been executed had the macro not been
suspended. After the line number comes the name of the macro that is
suspended.</P>

<P>You do not have to be in DEBUG mode prior to running a macro in
order to begin to debug it after it errors off. For example:</P>

<P>*:&gt;MACRO DEMO1 MAC:&gt;LET I=1 MAC:&gt;BAD-MACRO-CALL
MAC:&gt;EVALUATE,D I MAC:&gt;@EOF *:&gt;DEMO1 &lt;27&gt; SYNTAX ERROR
ABOVE ERROR OCCURRED AT STATEMENT 2 OF MACRO DEMO1 *:&gt;DEBUG ON
DEBUG:NEXT=3/DEMO1:*:&gt;LIST DEMO1 2 2: BAD-MACRO-CALL
DEBUG:NEXT=3/DEMO1:*:&gt;EVALUATE,D I 1 DEBUG:NEXT=3/DEMO1:*:&gt;LET
I=12 DEBUG:NEXT=3/DEMO1:*:&gt;GO @ RESTART MACRO AT LINE 3 12
DEBUG:*:&gt;</P>

<P>Some points to note from the above example:</P>

<P>&nbsp;</P>

<P>1. Note how the macro could be LISTed and variables could be
examined and even changed.</P>

<P>&nbsp;</P>

<P>2. Note how the macro could be restarted via "GO". The next-line-#
in the DBE prompt line is the first statement to be executed after a
GO command.</P>

<P>&nbsp;</P>

<P>3. Note how MACRO SUSPEND MODE was no longer in effect once the
macro ran to normal completion.</P>

<P>It is important to remember that MACRO SUSPEND MODE is very
delicate - if a change is made to the macro area, MACRO SUSPEND MODE
will be lost and you will lose the ability to restart the current
macro. Events that change the macro area are:</P>

<P>&nbsp;</P>

<P>1. Loading another macro from a file</P>

<P>&nbsp;</P>

<P>2. LISTing a macro that is not presently loaded (in the macro
area) - note that this would cause the macro to be loaded</P>

<P>&nbsp;</P>

<P>3. DELETEing any macro from the macro area</P>

<P>&nbsp;</P>

<P>4. Running ANY macro</P>

<P>When DEBUG mode is turned OFF, all breakpoint, trap, monitor and
trace information is lost - MACRO SUSPEND MODE is still in effect
however, and it would be possible to re-enter DEBUG mode to continue
debugging the macro (the breakpoint, trap, monitor and trace info
would need to be reestablished).</P>

<P>For more information about the breakpoint, trace, trap and monitor
settings referred to here, consult the documentation for those
commands in this chapter.</P>

<P>When DEBUG is entered with no ON/OFF, the current breakpoint,
trace, trap and monitor information will be printed.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | BRKPT | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | B | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */BRKPT</P>

<H2>13.2. BRKPT</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>( macroname ) BRKPT[,C] [- - line#[,line#]...] ----- ( * ) B -
</P>

<P>Note that the command may be abbreviated to "B".</P>

<P>This command sets a BREAKPOINT at the given line(s) of the given
macro. A macroname specification of "*" sets the BREAKPOINT(S) at
those lines for ALL macros. A common "BRKPT *" specification is
"BRKPT * 1".</P>

<P>A BREAKPOINT is a special flag set at a line number of a macro so
that if that line is ever encountered during execution of that macro,
the macro will be suspended BEFORE that statement is executed. At
that time, the user may perform whatever operation is desired. For
example:</P>

<P>*:&gt;MACRO DEMO2 MAC:&gt;LET I = 1 MAC:&gt;REPEAT J=1,1
MAC:&gt;LET I=I*2 MAC:&gt;UNTIL J=10 MAC:&gt;LET I=-1
MAC:&gt;EVALUATE,D I MAC:&gt;@EOF *:&gt;DEBUG ON DEBUG:*:&gt;BRKPT
DEMO2 2,5 DEBUG:*:&gt;DEMO2 BREAKPOINT ENCOUNTERED AT LINE 2 OF MACRO
"DEMO2" DEBUG:NEXT=2/DEMO2:*:&gt;LIST DEMO2 2</P>

<P>2: REPEAT J=1,1 DEBUG:NEXT=2/DEMO2:*:&gt;EVALUATE,D I 1
DEBUG:NEXT=2/DEMO2:*:&gt;GO BREAKPOINT ENCOUNTERED AT LINE 5 OF MACRO
"DEMO2" DEBUG:NEXT=5/DEMO2:*:&gt;LIST DEMO2 5</P>

<P>5: LET I=-1 DEBUG:NEXT=5/DEMO2:*:&gt;EVALUATE,D I 1024
DEBUG:NEXT=5/DEMO2:*:&gt;GO -1 DEBUG:*:&gt;BRKPT BREAKPOINT(S) SET IN
MACRO "DEMO2"</P>

<P>2 5</P>

<P>This provides an excellent opportunity to interactively follow a
macro through the execution process, stoping at certain points to
check out variables before continuing.</P>

<P>Specifying the "C" option on the BRKPT command will clear the
given set of breakpoints. Note that when clearing breakpoints for
macro "*" that this will clear the breakpoints for the "*" entry in
the macro table - it will NOT clear breakpoints for
specifically-named macros.</P>

<P>Specifying no parameters to the BRKPT command will print the
current set of breakpoints.</P>

<P>No more than six (6) macros can be DEBUGed at any one time and no
more than sixteen (16) breakpoints may be set for any one of those
macros.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | GO | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */GO</P>

<H2>13.3. GO</H2>

<P>&nbsp;</P>

<P>GO --</P>

<P>This statement causes MACRO SUSPEND MODE to be terminated, and
execution of the currently suspended macro to continue. Execution
continues at the statement presently shown following the NEXT= on the
DBE input prompt.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | MONITOR | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | M | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */MONITOR</P>

<H2>13.4. MONITOR</H2>

<P>&nbsp;</P>

<P>( macroname ) ( variable ) ( variable ) MONITOR[,option] [- - -
-[,- -]...] ------- ( * ) ( * ) ( * ) M -</P>

<P>This command allows you to "monitor" certain variables during the
execution of macros. Monitoring a variable will cause its value to be
printed each time it is changed.</P>

<H3>13.4.1 Options</H3>

<P>None Implies "O" option, specifying that data is to be displayed
in octal.</P>

<P>&nbsp;</P>

<P>C Clear monitor.</P>

<P>&nbsp;</P>

<P>Other Any valid "PRINT" format option, designating the format in
which data will be displayed.</P>

<P>The options specified are standard PRINT command options
(ABDFHOQS) or the option C. Options in the PRINT group will specify
how the variables are to be printed. Caution should be exercised when
MONITORing arrays since the ENTIRE array will be printed EACH time it
is changed (see the TRAP command).</P>

<P>The C option will erase (clear) the MONITOR specification of a
variable.</P>

<H3>13.4.2 Usage</H3>

<P>The "*" selection for a macro name will cause an entry to be built
in the macro debug table for the name of "*". As with the BRKPT
command, this implies an action to be taken for ALL macros.
Specification of "*" for a variable is taken to mean "all unMONITORed
variables in that macro". Default ("*") macro/variable specifications
will apply only of there is no specific entry defined for a
macro/variable combination. For example:</P>

<P>*:&gt;MACRO DEMO3 MAC:&gt;LET I=1 MAC:&gt;REPEAT J=1,1 MAC:&gt;LET
I=I*2 MAC:&gt;UNTIL J=3 MAC:&gt;LET I=-1 MAC:&gt;E,D I MAC:&gt;@EOF
*:&gt;DEBUG ON DEBUG:*:&gt;MONITOR,D DEMO3 J DEBUG:*:&gt;MONITOR * *
DEBUG:*:&gt;MONITOR VARIABLES TO BE MONITORED IN MACRO DEMO3:</P>

<P>J: DECIMAL VARIABLES TO BE MONITORED IN MACRO *:</P>

<P>*: OCTAL DEBUG:*:&gt;DEMO3 *MONITOR* OF: I AT LINE: 1 OF MACRO:
DEMO3 *MONITOR* I: 000000000001 *MONITOR* OF: J AT LINE: 2 OF MACRO:
DEMO3 *MONITOR* J: 1 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO3
*MONITOR* I: 000000000002 *MONITOR* OF: J AT LINE: 2 OF MACRO: DEMO3
*MONITOR* J: 2 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO3 *MONITOR*
I: 000000000004 *MONITOR* OF: J AT LINE: 2 OF MACRO: DEMO3 *MONITOR*
J: 3 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO3 *MONITOR* I:
000000000010 *MONITOR* OF: I AT LINE: 5 OF MACRO: DEMO3 *MONITOR* I:
777777777776 -1</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | RETURN | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */RETURN</P>

<H2>13.5. RETURN</H2>

<P>&nbsp;</P>

<P>RETURN ------</P>

<P>Note that this is the SAME statement as the RETURN documented in
chapter 8, except for the lack of parameters.</P>

<P>When executed in MACRO SUSPEND MODE, this statement will cause a
macro return condition to occur. In a macro called from
conversational mode this will restore the environment to
CONVERSATIONAL MODE status. In a macro called from another macro,
this will cause the environment to return to that of the calling
macro - the NEXT= will indicate the statement following the macro
call.</P>

<P>This is useful when it is desired to, while debugging a macro
sequence, prematurely terminate the current macro and return control
to its caller. While you cannot specify the value to RETURN to the
caller directly on the RETURN statement itself, you may always modify
the desired variable/subset after the RETURN is done.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | STEP | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | S | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */STEP</P>

<H2>13.6. STEP</H2>

<P>&nbsp;</P>

<P>&nbsp;</P>

<P>[STEP [statement-count] ]</P>

<P>----</P>

<P>S</P>

<P>-</P>

<P>This command will cause the next "statement-count" statements to
be executed, after which the macro in execution at the moment will be
suspended. While the statement(s) is/are being executed, TRACE mode
will be assumed active. During a STEP operation, MONITOR mode will be
assumed active as well. Those macro/variable combinations not
explicitly defined will be dumped in OCTAL. Note that arrays will be
dumped in their entirety.</P>

<P>The statement-count must be greater than zero.</P>

<P>Note the [] around the entire command format (this implies a null
imput of just XMIT) - this will be taken to mean "STEP 1".</P>

<P>If a TRAP or BRKPT is encountered while the STEP operation is
taking place, the TRAP/BRKPT will be honored and the remaining step
count (if any) ignored.</P>

<P>&nbsp;</P>

<P>This provides a handy mechanism for "stepping" through a macro
while it is executing. For example:</P>

<P>*:&gt;MACRO DEMO4 MAC:&gt;LET I=1 MAC:&gt;REPEAT J=1,1 MAC:&gt;LET
I=I*2 MAC:&gt;UNTIL J=3 MAC:&gt;LET I=-1 MAC:&gt;EVALUATE,D I
MAC:&gt;@EOF *:&gt;DEBUG ON DEBUG:*:&gt;BRKPT DEMO4 1
DEBUG:*:&gt;DEMO4 BREAKPOINT ENCOUNTERED AT LINE 1 OF "DEMO4"
DEBUG:NEXT=1/DEMO4:*:&gt; (xmit) (BEGIN MACRO 'DEMO4')</P>

<P>1: LET I=1 *MONITOR* OF: I AT LINE: 1 OF MACRO: DEMO4 *MONITOR* I:
000000000001 DEBUG:NEXT=2/DEMO4:*:&gt;STEP 1</P>

<P>2: REPEAT J=1,1 *MONITOR* OF: J AT LINE: 2 OF MACRO: DEMO2
*MONITOR* J: 000000000001 DEBUG:NEXT=3/DEMO2:*:&gt;MONITOR,D * *
DEBUG:NEXT=3/DEMO2:*:&gt; (xmit)</P>

<P>3: LET I=I*2 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO2 *MONITOR*
I: 2 DEBUG:NEXT=4/DEMO2:*:&gt;STEP 1</P>

<P>4: UNTIL J=3 *MONITOR* OF: J AT LINE: 2 OF MACRO: DEMO2 *MONITOR*
J: 2 DEBUG:NEXT=3/DEMO2:*:&gt;STEP 999</P>

<P>3: LET I=I*2 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO2 *MONITOR*
I: 4</P>

<P>4: UNTIL J=3 *MONITOR* OF: J AT LINE: 2 OF MACRO: DEMO2 *MONITOR*
J: 3</P>

<P>3: LET I=I*2 *MONITOR* OF: I AT LINE: 3 OF MACRO: DEMO2 *MONITOR*
I: 8</P>

<P>4: UNTIL J=3</P>

<P>5: LET I=-1 *MONITOR* OF: I AT LINE: 5 OF MACRO: DEMO2 *MONITOR*
I: -1</P>

<P>6: E,D I ------------------------------------ -1
------------------------------------</P>

<P>*: RETURN DEBUG:*:&gt;</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | TRACE | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TRACE</P>

<H2>13.7. TRACE</H2>

<P>&nbsp;</P>

<P>( macroname ) TRACE[,C] [ - - ] ----- - ( * )</P>

<P>&nbsp;</P>

<P>This command activates or deactivates (by specifying the C option)
for the macro specified (or for ALL macros if the "*" is used). Each
statement executed from that point forward will be printed as it is
executed. Included in the listing will be its statement number and
label (if any). Note that if the macro is specified as "*" that
commands entered in CONVERSATIONAL mode will be traced also.</P>

<P>Specified without parameters, this command will print the names of
all macros being traced.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | TRAP | </B></CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | T | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*// */TRAP</P>

<H2>13.8. TRAP</H2>

<P>&nbsp;</P>

<P>( macroname ) ( variable ) ( variable ) TRAP[,C] [ - - - -[,- -
]...] ---- - ( * ) ( * ) ( * ) T -</P>

<P>This command is used in a manner similar to the MONITOR statement
but, rather than printing the variable contents when changed, this
command causes the current macro to be suspended when a TRAPped
variable is altered.</P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P><CENTER><B>| Chapter 13 | Implications of the Use of "*" | </B>
</CENTER></P>

<P><CENTER><B>| DEBUGGING FACILITIES | | </B></CENTER></P>

<P><CENTER><B>:-------------------------------:--------------------------------:
</B></CENTER></P>

<P>*//</P>

<H2>13.9. Implications of the Use of "*"</H2>

<P>As you have seen, the "*" can play a special role in many of the
commands described in this chapter. While it may greatly help you in
your debugging you should be aware of the potential pitfalls involved
in the use of this.</P>

<P>When MONITORing and TRAPing you should be aware that a MONITOR of
a specific variable/macro will override a "TRAP * *" when that
particular variable/macro pair from the MONITOR are encountered. A
specific variable/macro pair specified on a TRAP and a MONITOR will
cause BOTH the TRAP and the MONITOR to occur however.</P>
</BODY>
</HTML>
